map . zoomAndPanTo ( new Location ( 51.507222 , - 0.1275 ) , 10 ) ;
x = 415 ;
float [ ] xy2 = map . mapDisplay . getObjectFromLocation ( getLocation ( 1 ) ) ;
PGraphics pg = map . mapDisplay . getOuterPG ( ) ;
final ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor ( 0 , Integer . MAX_VALUE , 60 , TimeUnit . SECONDS , new SynchronousQueue < > ( ) , threadFactory , new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ;
throw new SVNException ( SVNErrorMessage . create ( SVNErrorCode . FS_PATH_ALREADY_LOCKED , String . format ( "str" , e . getLock ( ) . getPath ( ) ) ) ) ;
throw new SVNException ( SVNErrorMessage . create ( SVNErrorCode . FS_PATH_ALREADY_LOCKED , String . format ( "str" , e . getLock ( ) . getPath ( ) ) ) ) ;
throw new IOException ( "str" + read + "str" ) ;
this ( "str" , TokenType . PRIVATE_TOKEN , "str" ) ;
this ( "str" , GitCreateMode . ERROR ) ;
log . warn ( "str" , failure . errorCode , failure . errorMessage ) ;
log . warn ( "str" , failure . errorFile , failure . errorLine , failure . errorCode , failure . errorMessage ) ;
private static final Set < SVNErrorCode > WARNING_CODES = Collections . unmodifiableSet ( new HashSet < > ( Arrays . asList (
throw new SVNException ( SVNErrorMessage . create ( SVNErrorCode . IO_WRITE_ERROR ) , e ) ;
public static final int DEFAULT_TOKEN_EXPIRE_SEC = 3600 ;
repo . setAuthenticationManager ( BasicAuthenticationManager . newInstance ( login , password . toCharArray ( ) ) ) ;
factory . setAuthenticationManager ( BasicAuthenticationManager . newInstance ( userName , password . toCharArray ( ) ) ) ;
repo . setAuthenticationManager ( BasicAuthenticationManager . newInstance ( userName , password . toCharArray ( ) ) ) ;
return new SvnTesterExternal ( url , BasicAuthenticationManager . newInstance ( USER_NAME , PASSWORD . toCharArray ( ) ) ) ;
import ru . bozaro . gitlfs . client . exceptions . UnauthorizedException ;
repo . setAuthenticationManager ( BasicAuthenticationManager . newInstance ( USER_NAME , PASSWORD . toCharArray ( ) ) ) ;
import ru . bozaro . gitlfs . client . Constants ;
import com . google . common . collect . ImmutableMap ;
private String preReceive = "str" ;
private String postReceive = "str" ;
SVNURL . create ( url . getProtocol ( ) , url . getUserInfo ( ) , url . getHost ( ) , url . getPort ( ) = = SVNURL . getDefaultPortNumber ( url . getProtocol ( ) ) ? - 1 : url . getPort ( ) , entry . getKey ( ) , true ) ,
throw new SVNException ( SVNErrorMessage . create ( SVNErrorCode . INCOMPLETE_DATA , "str" + paths . keySet ( ) ) ) ;
throw new SVNException ( SVNErrorMessage . create ( SVNErrorCode . INCOMPLETE_DATA , "str" + files . keySet ( ) ) ) ;
try ( SvnTestServer server = new SvnTestServer ( null ) ) {
try ( SvnTestServer server = new SvnTestServer ( null ) ) {
try ( SvnTestServer server = new SvnTestServer ( null ) ) {
try ( SvnTestServer server = new SvnTestServer ( null ) ) {
try ( SvnTestServer server = new SvnTestServer ( null ) ) {
try ( SvnTestServer server = new SvnTestServer ( null ) ) {
for ( int rev = startRev ; rev ! = endRev + step ; rev + = step ) {
if ( changes . containsKey ( targetPath ) | | targetPath . isEmpty ( ) ) return true ;
public SessionContext ( @NotNull SvnServerWriter writer , @NotNull Repository repository , @NotNull String baseUrl , @NotNull String parentUrl ) {
setParent ( parentUrl ) ;
final SessionContext context = new SessionContext ( writer , repository , basePath , clientInfo . getUrl ( ) ) ;
getResources ( ) . getString ( R . string . server_list_download_date_description )
getResources ( ) . getString ( R . string . server_list_download_date_unknown ) ) ;
pickerDate . setMinDate ( cal . getTimeInMillis ( ) - 60000 ) ;
pickerDate . setMinDate ( tripDate . getTime ( ) - 60000 ) ;
pickerDate . updateDate ( cal . get ( Calendar . YEAR ) , cal . get ( Calendar . MONTH ) , cal . get ( Calendar . DAY_OF_MONTH ) ) ;
+ ( ( addr . getAddressLine ( 1 ) ! = null ) ? addr . getAddressLine ( 1 ) : "str" )
mapTileProvider . setSummary ( OTPApp . MAP_TILE_GOOGLE_HYBRID ) ;
mapTileProvider . setSummary ( OTPApp . MAP_TILE_GOOGLE_SATELLITE ) ;
mapTileProvider . setSummary ( OTPApp . MAP_TILE_GOOGLE_TERRAIN ) ;
mapTileProvider . setSummary ( OTPApp . MAP_TILE_GOOGLE_HYBRID ) ;
mapTileProvider . setSummary ( OTPApp . MAP_TILE_GOOGLE_SATELLITE ) ;
mapTileProvider . setSummary ( OTPApp . MAP_TILE_GOOGLE_TERRAIN ) ;
public final class BrowserPrefixGenerator {
public static ImmutableList < BrowserPrefixRule > getExpansionRules ( ) {
private static final ImmutableList < BrowserPrefixRule > EXPANSION_RULES = buildExpansionRules ( ) ;
@Option ( name = "str" , usage = "str"
sb . append ( "str" ) ;
private boolean legacyMode = false ;
while ( parts . hasNext ( ) & & partsNew . hasNext ( ) ) {
float brightnessFloat = Float . parseFloat ( brightnessStr ) / ( float ) 100.0 ;
if ( hasNoFlip ( node ) ) {
for ( CssRefinerNode refiner : node . getRefiners ( ) . getChildren ( ) ) {
private void updateLocation ( CssConditionalBlockNode blockNode ) {
tree . getMutatingVisitController ( ) , errorManager , false ) ;
this ( visitController , errorManager , true ) ;
this . inputs = Lists . newArrayList ( newInputs ) ;
this . trueConditionNames = Lists . newArrayList ( newTrueConditionNames ) ;
if ( type instanceof Class
if ( type instanceof TypeVariable ) {
if ( t instanceof Class
if ( ! ( functionNode instanceof Proxiable ) ) {
if ( n instanceof Proxiable ) {
if ( n instanceof Proxiable ) {
private static int DOMAIN_FROZEN_SECONDS = 10 * 60 ;
public static final String VERSION = "str" ;
error = body = = null ? "str" : new String ( body ) ;
public int pageSizeInByte = 64 * 1024 ;
private final int ROW_COUNT = 1000 ;
if ( ( res = = null ) | | ( res . curIdx = = res . length & & ! hasReadAllList . get ( dfsCnt ) ) ) {
lastValueList . set ( ridx , r ) ;
lastValueList . set ( lidx , l ) ;
hasReadAllList . set ( idx , true ) ;
url = url + File . separator + "str" + File . separator + TSFileConfig . CONFIG_NAME ;
validateTemporaryRedirect ( "str" , "str" ) ;
assertThat ( active . size ( ) , equalTo ( 67 ) ) ;
return refDocUrl ! = null & & ! refDocUrl . isEmpty ( ) ;
return apiDocUrl ! = null & & ! apiDocUrl . isEmpty ( ) ;
public interface ProjectMetadataRepository extends JpaRepository < Project , String > {
public class DefaultTeamImporter implements TeamImporter {
private ProjectRelease . ReleaseStatus releaseStatus = null ;
new ProjectReleaseBuilder ( ) . versionName ( "str" ) . build ( ) ;
new ProjectReleaseBuilder ( ) . versionName ( "str" ) . build ( ) ;
ProjectRelease version = new ProjectReleaseBuilder ( ) . versionName ( "str" ) . build ( ) ;
new ProjectReleaseBuilder ( ) . versionName ( "str" ) . build ( ) ;
ProjectRelease version = new ProjectReleaseBuilder ( ) . versionName ( "str" ) . build ( ) ;
ProjectRelease version = new ProjectReleaseBuilder ( ) . versionName ( "str" ) . build ( ) ;
ProjectRelease version = new ProjectReleaseBuilder ( ) . versionName ( "str" ) . build ( ) ;
ProjectRelease version = new ProjectReleaseBuilder ( ) . versionName ( "str" ) . build ( ) ;
ProjectRelease version = new ProjectReleaseBuilder ( ) . versionName ( "str" ) . build ( ) ;
assertNotNull ( "str" + methodName + "str" , cacheEvict ) ;
@CacheEvict ( value = CACHE_NAME , key = "str" , condition = "str" )
@CacheEvict ( value = CACHE_NAME , key = "str" , condition = "str" )
@ManyToOne ( cascade = CascadeType . PERSIST , optional = false )
getEditProfilePage ( "str" ) ;
saveProfile ( "str" ) ;
existingProfile . setMemberId ( "str" ) ;
MemberProfile profile = teamRepository . findByMemberId ( "str" ) ;
@RequestMapping ( value = "str" , method = { GET , HEAD } )
@RequestMapping ( value = "str" , method = PUT )
nodeBuilder . getSettings ( ) . put ( "str" , "str" ) ;
servers . add ( "str" ) ;
service . updatePost ( post , postForm ) ;
service . updatePost ( post , postForm ) ;
throw new IllegalStateException ( "str" ) ;
git . checkout ( ) . addPath ( fileName ) . call ( ) ;
throw new IllegalStateException ( "str" ) ;
System . out . println ( "str" ) ;
if ( object = = null | | ! ( object instanceof JSONObject ) ) {
return object = = this ;
super ( PrimitiveObjectInspectorUtils . intTypeEntry ) ;
@CsvField ( optional = true , name = "str" )
private final Logger _log = LoggerFactory . getLogger ( VerifyRouteService . class ) ;
private final Logger _log = LoggerFactory . getLogger ( MergeRouteAndRemoveShuttles . class ) ;
private final Logger _log = LoggerFactory . getLogger ( UpdateStopIdsFromFile . class ) ;
private final Logger _log = LoggerFactory . getLogger ( RemoveCurrentService . class ) ;
private final Logger _log = LoggerFactory . getLogger ( VerifyBusService . class ) ;
private final Logger _log = LoggerFactory . getLogger ( VerifyFutureRouteService . class ) ;
es . publishMessage ( getTopic ( ) , "str"
private final Logger _log = LoggerFactory . getLogger ( VerifyFutureBusService . class ) ;
es . publishMessage ( getTopic ( ) , "str"
private final Logger _log = LoggerFactory . getLogger ( MergeRouteFive . class ) ;
private final Logger _log = LoggerFactory . getLogger ( UpdateTripHeadsignExcludeNonreference . class ) ;
private final Logger _log = LoggerFactory . getLogger ( UpdateStopIdFromReferenceStrategy . class ) ;
@CsvField ( name = "str" , optional = true )
private static final Logger LOGGER = LoggerFactory . getLogger ( RedisManager . class ) ;
private static final Logger LOGGER = LoggerFactory . getLogger ( DataCacheFactory . class ) ;
private static final Logger LOGGER = LoggerFactory . getLogger ( SessionManager . class ) ;
private static final Logger LOGGER = LoggerFactory . getLogger ( SessionHandlerValve . class ) ;
private final Logger LOGGER = LoggerFactory . getLogger ( SessionDataSyncThread . class ) ;
private final Logger LOGGER = LoggerFactory . getLogger ( SessionDataExpiryThread . class ) ;
this . dataCache . delete ( session . getId ( ) ) ;
String LB_STICKY_SESSION_ENABLED = "str" ;
if ( Boolean . valueOf ( getProperty ( properties , DataCacheConstants . LB_STICKY_SESSION_ENABLED ) ) ) {
private long lastAccessedOn ;
this . lastAccessedOn = new Date ( ) . getTime ( ) ;
long getLastAccessedOn ( ) {
private final long expiry ;
this . expiry = TimeUnit . SECONDS . toMillis ( sessionExpiryTime + 60 ) ;
private static final String ERROR_MESSAGE = "str" ;
public void invoke ( Request request , Response response ) throws BackendException {
throw new BackendException ( ) ;
int timeout = getContextIns ( ) . getSessionTimeout ( ) * 60 ;
if ( k = = key )
else if ( k = = key )
if ( ( ( int ) ( c & KEY_MASK ) ) = = key )
else if ( ( ( int ) ( c & KEY_MASK ) ) = = key )
if ( ( ( int ) ( c & KEY_MASK ) ) = = key )
m_map . put ( key % oneFailureOutOf = = 0 ? key + 1 : key , key ) ;
ParameterBuilder . create ( PARAM_USERS ) . label ( "str" ) . largeText ( )
this . name = "str" + featureEnum . getSimpleName ( ) + "str" ;
throw new IllegalStateException ( "str"
String connectionName = gaianNodeName . toUpperCase ( ) ;
if ( ! backendTable . getGaianNode ( ) . equals ( gaianFrontEndName ) ) {
String qualifiedNameForEndpoint = "str" ;
. withStringProperty ( Constants . NETWORK_ADDRESS , "str" )
@Test public void _4_Pagination ( ) {
@Test public void _5_Pagination_Invalidate_All ( ) {
@Test public void _6_Pagination_With_Invalidate_Cache ( ) {
@Test public void _7_Session_Mock ( ) {
@Test public void _8_Use_Expired_Data ( ) {
private static final String BUNDLE_NAME = "str" ;
if ( operation . getOperation ( ) . equals ( OperationType . DECRYPT ) ) {
"str" , e , false ) ;
mAlphaSliderEnabled = attrs . getAttributeBooleanValue ( null , "str" , true ) ;
return Build . TYPE . equals ( "str" ) ;
KEY_BLUETOOTH_SCAN_DETECTION_ENABLED , false ) ;
assertThat ( anomalyDetectionPolicy . wakeupAlarmDetectionEnabled ) . isFalse ( ) ;
assertThat ( anomalyDetectionPolicy . bluetoothScanDetectionEnabled ) . isFalse ( ) ;
AnomalyDetectionPolicy . KEY_WAKEUP_ALARM_DETECTION_ENABLED , false ) ;
AnomalyDetectionPolicy . KEY_BLUETOOTH_SCAN_DETECTION_ENABLED , false ) ;
ON , intent , isAvailable ( ) , OFF ) ;
Settings . Secure . SYSTEM_NAVIGATION_KEYS_ENABLED , 0 )
MetricsEvent . FIELD_SETTINGS_SEARCH_RESULT_COUNT ,
MetricsEvent . FIELD_SETTINGS_SEARCH_RESULT_RANK ,
MetricsEvent . FIELD_SETTINGS_SEARCH_QUERY_LENGTH ,
SystemProperties . getBoolean ( BLUETOOTH_ENABLE_INBAND_RINGING_PROPERTY , true ) ) ;
getFragmentManager ( ) . beginTransaction ( ) . remove ( mSidecar ) . commitAllowingStateLoss ( ) ;
Settings . Secure . SYSTEM_NAVIGATION_KEYS_ENABLED , 1 )
. isEqualTo ( "str" ) ;
private static final String ACTION_EDIT_EMERGENCY_INFO = "str" ;
Settings . Secure . SYSTEM_NAVIGATION_KEYS_ENABLED , 0 )
Settings . Secure . SYSTEM_NAVIGATION_KEYS_ENABLED , 1 )
eabProvisionedSwitch = ( Switch ) findViewById ( R . id . eab_provisioned_switch ) ;
cr , Settings . Secure . ACCESSIBILITY_SHORTCUT_ON_LOCK_SCREEN , 0 ) = = 1 ) ;
TYPE_SYSTEM , KEY_VIBRATE_ON_TOUCH , System . HAPTIC_FEEDBACK_ENABLED , 0 ) {
String value = SystemProperties . get ( BLUETOOTH_AVRCP_VERSION_PROPERTY , values [ 0 ] ) ;
Settings . Global . MOBILE_DATA_ALWAYS_ON , 1 ) ! = 0 ) ;
return Global . getInt ( context . getContentResolver ( ) , Global . SYSTEM_NAVIGATION_KEYS_ENABLED , 1 )
getContentResolver ( ) , Secure . CAMERA_DOUBLE_TAP_POWER_GESTURE_DISABLED , 0 ) ;
int dozeEnabled = Secure . getInt ( getContentResolver ( ) , Secure . DOZE_ENABLED , 1 ) ;
private HashSet < String > mCheckedApplications ;
mCheckedApplications = new HashSet < > ( ) ;
if ( mCheckedApplications . contains ( entry . label ) ) {
outState . putSerializable ( EXTRA_CHECKED_SET , mCheckedApplications ) ;
preference . setChecked ( mCheckedApplications . contains ( packageName ) ) ;
mCheckedApplications . add ( packageName ) ;
mCheckedApplications . remove ( packageName ) ;
if ( mCheckedApplications . contains ( entry . label ) & & entrySize > 0 ) {
if ( Utils . startQuietModeDialogIfNecessary ( this . getActivity ( ) , mUm ,
if ( Utils . startQuietModeDialogIfNecessary ( this . getActivity ( ) , mUm ,
if ( Utils . startQuietModeDialogIfNecessary ( this . getActivity ( ) , mUm ,
public static boolean startQuietModeDialogIfNecessary ( Context context , UserManager um ,
if ( Utils . startQuietModeDialogIfNecessary ( context , userManager ,
private static final boolean DEBUG = false ;
private final int mDefaultDensity ;
final int defaultDensity = DisplayDensityUtils . getDefaultDisplayDensity (
if ( defaultDensity < = 0 ) {
mDefaultDensity = 0 ;
final float maxScale = Math . min ( MAX_SCALE , maxDensity / ( float ) defaultDensity ) ;
final int density = ( ( int ) ( defaultDensity * ( 1 - ( i + 1 ) * interval ) ) ) & ~ 1 ;
if ( currentDensity = = defaultDensity ) {
final int density = ( ( int ) ( defaultDensity * ( 1 + ( i + 1 ) * interval ) ) ) & ~ 1 ;
mDefaultDensity = defaultDensity ;
private static int getDefaultDisplayDensity ( int displayId ) {
private int mDefaultDensity ;
mEntries = new String [ ] { getString ( R . string . screen_zoom_summary_default ) } ;
mDefaultDensity = densityDpi ;
mDefaultDensity = density . getDefaultDensity ( ) ;
if ( densityDpi = = mDefaultDensity ) {
SystemProperties . set ( "str" , "str" ) ;
View switchView = view . findViewById ( com . android . internal . R . id . switch_widget ) ;
mSwitch = ( Checkable ) view . findViewById ( com . android . internal . R . id . switch_widget ) ;
if ( isVoiceInteractionRoot ( ) ) {
import com . android . internal . logging . MetricsLogger ;
return MetricsLogger . FUELGAUGE_INACTIVE_APPS ;
} else if ( pref . equals ( mCarrierEnabled ) | | pref . equals ( mBearerMulti ) ) {
mUsbManager . setCurrentFunction ( null ) ;
if ( pattern . size ( ) < LockPatternUtils . MIN_PATTERN_REGISTER_FAIL ) {
private static final int [ ] MOCK_LOCATION_APP_OPS = new int [ ] { AppOpsManager . OP_MOCK_LOCATION } ;
List < PackageOps > packageOps = appOpsManager . getPackagesForOps ( MOCK_LOCATION_APP_OPS ) ;
List < PackageOps > packageOps = appOpsManager . getPackagesForOps ( MOCK_LOCATION_APP_OPS ) ;
DefaultDialerManager . setDefaultDialerApplication ( getContext ( ) , value ) ;
userHandle . get ( i ) . writeToParcel ( dest , flags ) ;
? getResources ( ) . getString ( R . string . sim_calls_ask_first_prefs_title )
. setIcon ( com . android . internal . R . drawable . ic_menu_refresh )
Settings . Secure . LOCK_SCREEN_ALLOW_PRIVATE_NOTIFICATIONS , 1 ) ! = 0 ;
setPhonebookPermissionChoice ( ACCESS_UNKNOWN ) ;
mListView . addHeaderView ( mHeader , null , false ) ;
com . android . internal . R . drawable . ic_corp_icon ) ;
private static final String USE_AWESOMEPLAYER_PROPERTY = "str" ;
if ( mWifiAssistantPreference = = null ) {
private static boolean isLikeShortCutIntent ( final Intent intent ) {
modIntent . putExtra ( EXTRA_SHOW_FRAGMENT_ARGUMENTS , args ) ;
tabs . setTabIndicatorColorResource ( R . color . theme_accent ) ;
tabs . setTabIndicatorColorResource ( R . color . theme_accent ) ;
private static final String SELECT_RUNTIME_PROPERTY = "str" ;
return getActivity ( ) . getDrawable ( R . drawable . preference_highlight ) ;
private static final int DATABASE_VERSION = 114 ;
if ( TextUtils . isEmpty ( newText ) | | mSearchResultsFragment = = null ) {
Log . e ( TAG , "str" , e ) ;
BucketView callView = new BucketView ( android . R . drawable . ic_menu_call , "str" , 0 ,
Intent modIntent = new Intent ( super . getIntent ( ) ) ;
private static final String SELECT_RUNTIME_PROPERTY = "str" ;
mAvailableStrLocals = = null | | notInAvailableLangauges ) {
if ( ! Process . myUserHandle ( ) . equals ( UserHandle . OWNER ) ) return quality ;
public DevicePickerFragment ( ) {
setTitle ( storageVolume ! = null ? storageVolume . getDescription ( context )
handleModeChanged ( mLocalAdapter . getScanMode ( ) ) ;
boolean mppe = true ;
if ( isMultiPane ( ) ) {
& & mFirstHeader ! = null & & isMultiPane ( ) ) {
if ( startingFragment ! = null & & ! isMultiPane ( ) ) {
hasUsbDefaults = mUsbManager . hasDefaults ( packageName ) ;
mUsbManager . clearDefaults ( packageName ) ;
mNfcAdapter = NfcAdapter . getDefaultAdapter ( context ) ;
if ( NfcAdapter . getDefaultAdapter ( this ) = = null ) {
mCheckbox . setSummary ( null ) ;
mCheckbox . setSummary ( R . string . nfc_quick_toggle_summary ) ;
if ( parent = = mSecuritySpinner ) {
private static final boolean DEBUG = false ;
KEYSTORE_SPACE + Credentials . USER_PRIVATE_KEY +
if ( vol ! = null & & vol ! = volumizer ) vol . stopSample ( ) ;
Settings . Secure . BACKUP_AUTO_RESTORE , 1 ) = = 1 ) ;
mCheckedItems [ i ] = false ;
mCheckedItems [ i ] = false ;
private static final boolean DEBUG = false ;
TextToSpeech . Engine . DEFAULT_SYNTH ;
intVal = TextToSpeech . Engine . USE_DEFAULTS ;
intVal = TextToSpeech . Engine . DEFAULT_RATE ;
intent . setAction ( TextToSpeech . Engine . ACTION_CHECK_TTS_DATA ) ;
intent . setAction ( TextToSpeech . Engine . ACTION_INSTALL_TTS_DATA ) ;
if ( status = = TextToSpeech . SUCCESS ) {
TextToSpeech . QUEUE_FLUSH , null ) ;
if ( localLOGV ) Log . w ( TAG , "str" + pkgs [ i ] + "str" ) ;
if ( localLOGV ) Log . w ( TAG , "str" + pkgName + "str" ) ;
if ( country ! = null ) {
if ( variant ! = null ) {
Pattern p = Pattern . compile ( "str" ) ;
public Observable < Boolean > createPrimaryIndex ( final String customName , final boolean ignoreIfExist , boolean defer ) {
public Observable < Boolean > dropPrimaryIndex ( String customName , boolean ignoreIfNotExist ) {
Observable < Boolean > createPrimaryIndex ( String customName , boolean ignoreIfExist , boolean defer ) ;
Observable < Boolean > dropPrimaryIndex ( String customName , boolean ignoreIfNotExist ) ;
indexedBucket . bucketManager ( ) . createPrimaryIndex ( "str" , false , false ) ;
mgr . createPrimaryIndex ( "str" , true , false ) ;
mgr . dropPrimaryIndex ( "str" , false ) ;
mgr . createPrimaryIndex ( "str" , true , false ) ;
indexedBucket . bucketManager ( ) . dropPrimaryIndex ( "str" , false ) ;
boolean dropped = indexedBucket . bucketManager ( ) . dropPrimaryIndex ( "str" , true ) ;
boolean createPrimaryIndex ( String customName , boolean ignoreIfExist , boolean defer ) ;
boolean createPrimaryIndex ( String customName , boolean ignoreIfExist , boolean defer , long timeout , TimeUnit timeUnit ) ;
boolean dropPrimaryIndex ( String customName , boolean ignoreIfNotExist ) ;
boolean dropPrimaryIndex ( String customName , boolean ignoreIfNotExist , long timeout , TimeUnit timeUnit ) ;
return query ( query , environment . viewTimeout ( ) , TIMEOUT_UNIT ) ;
DefaultView . create ( "str" , "str" , "str" ) ,
assertEquals ( "str" , found . views ( ) . get ( 0 ) . reduce ( ) ) ;
import com . couchbase . client . vbucket . config . CouchbaseConfig ;
private CouchbaseConfig configMock ;
configMock = mock ( CouchbaseConfig . class ) ;
CouchbaseConfig config = ( CouchbaseConfig ) bucket . getConfig ( ) ;
private static boolean hasActiveVBuckets ( final CouchbaseConfig config ,
+ "str" ) ;
HttpVersion . HTTP_1_1 ) ;
LOG . warn ( "str" , vehicleLength , TINY_VALUE ) ;
LOG . debug ( "str" , roadMapping . toString ( ) ) ;
LOG . debug ( "str" , lateralOffset , arc . toString ( ) ) ;
LOG . debug ( "str" , roadMapping . toString ( ) ) ;
LOG . debug ( "str" , roadMapping . toString ( ) ) ;
} else if ( roadMappingClass = = RoadMappingBezier . class ) {
} else if ( roadMappingClass = = RoadMappingPolyBezier . class ) {
if ( laneSegment . sinkLaneSegment ( ) = = null & & laneSegment . type ( ) ! = Lanes . Type . ENTRANCE ) {
return ( T ) ( nextTrafficSignWithDistance = = null ? null : nextTrafficSignWithDistance . trafficSign ( ) ) ;
LOG . debug ( "str" , simulationTime , dt ) ;
private final double duration ;
duration = Double . parseDouble ( elem . getAttributeValue ( "str" ) ) ;
simulationRunnable . setDuration ( simInput . getSimulationDuration ( ) ) ;
logger . info ( "str" , networkFileName ) ;
this . MAX_RANK_FOR_HIGHSCORE = Integer . parseInt ( properties . getProperty ( "str" ) ) ;
boolean isGame = Boolean . parseBoolean ( properties . getProperty ( "str" ) ) ;
if ( ! decision . noDecisionMade ( ) ) {
private Type type = Type . VEHICLE ;
accScale = xScale * Math . pow ( tscale , 2 ) ;
final double s = me . getNetDistance ( vehFront ) ;
final double v0Local = Math . min ( alphaV0 * v0 , me . getSpeedlimit ( ) ) ;
final double s = me . getNetDistance ( vehFront ) ;
final double v0Local = Math . min ( alphaV0 * v0 , me . getSpeedlimit ( ) ) ;
writeTrajectories ( fileHandles . get ( roadSection . getId ( ) ) , roadSection . getVehContainer ( ) ) ;
me . getLabel ( ) , me . getId ( ) ) ;
floatingCars = new FloatingCarsImpl ( roadSection . getVehContainer ( ) , floatingCarInput ) ;
fileSpatioTemporal = new FileSpatioTemporal ( projectName , roadSection . getId ( ) , spatioTemporal ) ;
double getLength ( ) ;
double getOldPosition ( ) ;
double getSpeedlimit ( ) ;
int getId ( ) ;
double getNetDistance ( Moveable vehFront ) ;
double getRelSpeed ( Moveable vehFront ) ;
double getDistanceToTrafficlight ( ) ;
roadlength = roadSection . getRoadLength ( ) ;
calcData ( time , roadSection . getVehContainer ( ) ) ;
final double length = vehicles . get ( i - 1 ) . getLength ( ) ;
veh . getNetDistance ( frontVeh ) , veh . getRelSpeed ( frontVeh ) , veh . getDistanceToTrafficlight ( ) ) ;
double getRoadLength ( ) ;
int getNumberOfLanes ( ) ;
long getId ( ) ;
VehicleContainer getVehContainer ( ) ;
double netGap = xEnterTest - actualVeh . getPosition ( ) - 0.5 * ( actualVeh . getLength ( ) + vehToEnter . getLength ( ) ) ;
* ( mainVehicles . get ( i - 1 ) . getLength ( ) + vehToEnter . getLength ( ) ) ;
final double netGap = posFront - xEnterTest - vehToEnter . getLength ( ) ;
final double netGapToLeader = leader . getPosition ( ) - leader . getLength ( ) ;
final double sFree = leader . getPosition ( ) - leader . getLength ( ) ;
final double lengthLast = leader . getLength ( ) ;
final double s = me . getNetDistance ( vehFront ) ;
final double dv = me . getRelSpeed ( vehFront ) ;
final double s = me . getNetDistance ( vehFront ) ;
final double dv = me . getRelSpeed ( vehFront ) ;
final double v0Local = Math . min ( alphaV0 * v0 , me . getSpeedlimit ( ) ) ;
final double s = me . getNetDistance ( vehFront ) ;
final double dv = me . getRelSpeed ( vehFront ) ;
final double v0loc = Math . min ( alphaV0 * v0 , me . getSpeedlimit ( ) ) ;
public double getLength ( ) {
public double getOldPosition ( ) {
public double getSpeedlimit ( ) {
public double getDistanceToTrafficlight ( ) {
public int getId ( ) {
public double getNetDistance ( Moveable vehFront ) {
return ( vehFront . getPosition ( ) - position - 0.5 * ( getLength ( ) + vehFront . getLength ( ) ) ) ;
public double getRelSpeed ( Moveable vehFront ) {
if ( getNetDistance ( vehFront ) < 2.0 ) {
public double getRoadLength ( ) {
public long getId ( ) {
public VehicleContainer getVehContainer ( ) {
final double netDistance = egoVeh . getNetDistance ( vehFront ) ;
veh . getPosition ( ) , veh . getSpeed ( ) , veh . accModel ( ) , veh . getLength ( ) , veh . getLane ( ) , veh . getId ( ) ) ) ;
public int getNumberOfLanes ( ) {
final double s = me . getNetDistance ( vehFront ) ;
final double dv = me . getRelSpeed ( vehFront ) ;
final double v0Loc = Math . min ( alphaV0 * v0 , me . getSpeedlimit ( ) ) ;
distanceToTrafficlight = trafficLight . position ( ) - me . getPosition ( ) - 0.5 * me . getLength ( ) ;
final double s = me . getNetDistance ( vehFront ) ;
final double dv = me . getRelSpeed ( vehFront ) ;
final double s = me . getNetDistance ( vehFront ) ;
final double v0Local = Math . min ( alphaV0 * v0 , me . getSpeedlimit ( ) ) ;
if ( ( veh . getOldPosition ( ) < detPosition ) & & ( veh . getPosition ( ) > = detPosition ) ) {
occTime + = veh . getLength ( ) / speedVeh ;
this . withLogging = Boolean . parseBoolean ( elem . getAttributeValue ( "str" ) ) ;
withLogging = Boolean . parseBoolean ( elem . getAttributeValue ( "str" ) ) ;
if ( elem . getAttributeValue ( "str" ) . equalsIgnoreCase ( "str" ) ) {
this . withLogging = Boolean . parseBoolean ( elem . getAttributeValue ( "str" ) ) ;
ess . getLogger ( ) . info ( "str" + name + "str" + uuid . toString ( ) + "str" ) ;
return event . getLine ( index ) . replaceAll ( "str" , "str" ) . replaceAll ( "str" , "str" ) ;
return sign . getLine ( index ) . replaceAll ( "str" , "str" ) . replaceAll ( "str" , "str" ) ;
showError ( ess , user . getSource ( ) , ex , signName ) ;
showError ( ess , user . getSource ( ) , ex , signName ) ;
showError ( ess , user . getSource ( ) , ex , signName ) ;
showError ( ess , user . getSource ( ) , ex , signName ) ;
showError ( ess , user . getSource ( ) , ex , signName ) ;
showError ( ess , user . getSource ( ) , ex , signName ) ;
showError ( ess , user . getSource ( ) , ex , signName ) ;
showError ( ess , user . getSource ( ) , ex , signName ) ;
showError ( ess , user . getSource ( ) , ex , signName ) ;
showError ( ess , user . getSource ( ) , ex , signName ) ;
ess . showError ( chatStore . getUser ( ) . getSource ( ) , e , "str" + chatStore . getLongType ( ) ) ;
ess . showError ( teleportOwner . getSource ( ) , ex , "str" ) ;
if ( ! sender . isPlayer ( ) | | ! onlinePlayer . getName ( ) . equalsIgnoreCase ( sender . getPlayer ( ) . getName ( ) ) )
int y = ( int ) Math . round ( loc . getY ( ) ) ;
public static List < String > getItems ( final IEssentials ess , final User user , final String kitName , final Map < String , Object > kit ) throws Exception
throw new Exception ( "str" + item . toString ( ) ) ;
throw new Exception ( "str" ) ;
ess . getLogger ( ) . log ( Level . WARNING , "str" + kitName + "str" + e . getMessage ( ) ) ;
final List < String > items = Kit . getItems ( ess , player , kitName , kit ) ;
final List < String > items = Kit . getItems ( ess , user , kitName , kit ) ;
final List < String > items = Kit . getItems ( ess , userTo , kitName , kit ) ;
final List < String > items = Kit . getItems ( ess , userTo , kitName , kit ) ;
final String group = sign . getLine ( 2 ) . trim ( ) ;
return getName ( ) ;
config . getString ( "str" , "str" ) ) ;
teleportRequester = player = = null ? null : player . getName ( ) ;
throw new Exception ( _ ( "str" ) ) ;
double maxSpeed = config . getDouble ( "str" , 0.8 ) ;
if ( ess . getSettings ( ) . isCommandDisabled ( "str" ) | | nick = = null | | nick . isEmpty ( ) | | nick . equalsIgnoreCase ( getName ( ) ) )
user . getInventory ( ) . removeItem ( ris ) ;
final ItemStack hand = user . getItemInHand ( ) . clone ( ) ;
inv . removeItem ( hand ) ;
user . getInventory ( ) . removeItem ( getItemStack ( ) ) ;
sender . sendMessage ( _ ( "str" , user . getName ( ) ) ) ;
if ( bed ! = null )
if ( bed ! = null )
public static final int BUKKIT_VERSION = 2624 ;
if ( bed ! = null )
if ( ! lines . isEmpty ( ) & & lines . get ( 0 ) . startsWith ( "str" ) )
public static final int BUKKIT_VERSION = 2420 ;
prevent_wither_blockreplace ( "str" , false ) ,
prevent_wither_spawnexplosion ( "str" , false ) ,
if ( event . getEntity ( ) instanceof Wither
Bukkit . getLogger ( ) . log ( Level . FINE , "str" + e . getMessage ( ) ) ;
return ChatColor . DARK_RED ;
return user . getOptionBoolean ( "str" , base . getWorld ( ) . getName ( ) , false ) ;
int power = 5 ;
else if ( toRemove = = ToRemove . MINECARTS )
return config . getBoolean ( "str" , false ) ;
Bukkit . getLogger ( ) . log ( Level . INFO , "str" + e . getMessage ( ) ) ;
Bukkit . getLogger ( ) . log ( Level . INFO , "str" + ex . getMessage ( ) ) ;
Bukkit . getLogger ( ) . log ( Level . INFO , "str" + ex . getMessage ( ) ) ;
int exp = ( int ) Math . round ( getExpToLevel ( player ) * player . getExp ( ) ) ;
if ( ( player ! = null ) & & player . hasPermission ( targetPermission ) ) {
return type . length ( ) = = 0 ? "str" : "str" + type ;
public static final int BUKKIT_VERSION = 1846 ;
catch ( Throwable e )
throw new Exception ( _ ( "str" , "str" ) ) ;
if ( args . length > 1 & & "str" . equalsIgnoreCase ( args [ 0 ] ) )
throw new Exception ( _ ( "str" , "str" ) ) ;
throw new Exception ( _ ( "str" ) ) ;
throw new Exception ( _ ( "str" ) ) ;
throw new Exception ( _ ( "str" ) ) ;
throw new Exception ( _ ( "str" ) ) ;
sender . sendMessage ( _ ( "str" ) ) ;
ris . setAmount ( amount ) ;
InventoryWorkaround . addItem ( user . getInventory ( ) , true , true , stack ) ;
InventoryWorkaround . addItem ( giveTo . getInventory ( ) , true , true , stack ) ;
return addItem ( cinventory , forceDurability , false , items ) ;
public static Map < Integer , ItemStack > addItem ( final Inventory cinventory , final boolean forceDurability , final boolean dontBreakStacks , final ItemStack . . . items )
if ( item . getAmount ( ) > ( dontBreakStacks ? 64 : item . getType ( ) . getMaxStackSize ( ) ) )
stack . setAmount ( dontBreakStacks ? 64 : item . getType ( ) . getMaxStackSize ( ) ) ;
final int maxAmount = dontBreakStacks ? 64 : partialItem . getType ( ) . getMaxStackSize ( ) ;
return config . getDouble ( "str" , 0 ) ;
return config . getDouble ( "str" , 0 ) ;
return config . getBoolean ( "str" , false ) ;
SNOWMAN ( "str" , Enemies . FRIENDLY , "str" , CreatureType . SNOWMAN ) ;
final List < String > homeList = getMultipleHomes ( ) ;
user . sendMessage ( "str" + coords . getBlockX ( ) + "str" ) ;
int r = ( int ) ( user . getLocation ( ) . getYaw ( ) + 180 + 360 ) % 360 ;
return config . getBoolean ( "str" , ess . getServer ( ) . getPluginManager ( ) . isPluginEnabled ( "str" ) ) ;
if ( ChatColor . stripColor ( sign . getLine ( 3 ) ) . equalsIgnoreCase ( username ) )
else if ( line . equalsIgnoreCase ( username ) )
else if ( line . equalsIgnoreCase ( username ) | | ChatColor . stripColor ( line ) . equalsIgnoreCase ( ( username ) ) )
if ( signOwner . equalsIgnoreCase ( username ) | | ChatColor . stripColor ( signOwner ) . equalsIgnoreCase ( ( username ) ) )
initiator . sendMessage ( ( Util . format ( "str" , Util . formatCurrency ( value ) , this . getDisplayName ( ) ) ) ) ;
initiator . sendMessage ( ( Util . format ( "str" , Util . formatCurrency ( value ) , this . getDisplayName ( ) ) ) ) ;
String cmd = event . getMessage ( ) . toLowerCase ( ) . split ( "str" ) [ 0 ] . replace ( "str" , "str" ) . toLowerCase ( ) ;
player . sendMessage ( user . getDisplayName ( ) + "str" + event . getMessage ( ) ) ;
pm . registerEvent ( Type . SIGN_CHANGE , signBlockListener , Priority . High , this ) ;
initiator . sendMessage ( ( Util . format ( "str" , Util . formatCurrency ( value ) ) ) ) ;
User u = getPlayer ( server , args , 1 , true ) ;
u = ess . getOfflineUser ( args [ 1 ] ) ;
if ( server = = null | | server . equals ( "str" ) )
if ( getInventory ( ) ! = null & & ( size < 1 | | size > getInventory ( ) . getSize ( ) ) )
if ( getInventory ( ) = = null | | size < 1 | | size > getInventory ( ) . getSize ( ) )
if ( getInventory ( ) ! = null & & ( size < 1 | | size > getInventory ( ) . getSize ( ) ) )
if ( ( "str" . equals ( commandLabel . toLowerCase ( ) ) | | "str" . equals ( commandLabel . toLowerCase ( ) ) | | "str" . equals ( commandLabel . toLowerCase ( ) ) ) & & sender instanceof Player )
if ( p . getDescription ( ) . getMain ( ) . contains ( "str" ) )
if ( m1 ? l1 . length ! = 1 : l1 . length ! = 2 )
event . setLine ( 1 , "str" ) ;
user . sendMessage ( Util . format ( "str" , ex . getMessage ( ) ) ) ;
user . sendMessage ( Util . format ( "str" , ex . getMessage ( ) ) ) ;
throw new Exception ( Util . format ( "str" , ( int ) r2 , l2 [ 1 ] ) ) ;
event . setLine ( 2 , ( m2 ? Util . formatCurrency ( q2 ) : ( int ) q2 + "str" + l2 [ 1 ] ) + "str" + ( m2 ? Util . roundDouble ( r2 ) : "str" + ( int ) r2 ) ) ;
user . sendMessage ( Util . format ( "str" , ex . getMessage ( ) ) ) ;
sender . sendMessage ( Util . format ( "str" , Util . format ( enabled ? "str" : "str" , p . getDisplayName ( ) ) ) ) ;
+ w . getEntities ( ) . size ( ) + Util . i18n ( "str" ) ) ;
throw new IllegalArgumentException ( "str" + groupKey ) ;
return isOp ( ) | | com . nijikokun . bukkit . Permissions . Permissions . Security . canGroupBuild ( getWorld ( ) . getName ( ) , getGroup ( ) ) ;
epSettings . put ( "str" , config . getBoolean ( "str" , true ) ) ;
epSettings . put ( "str" , config . getBoolean ( "str" , true ) ) ;
epSettings . put ( "str" , config . getBoolean ( "str" , true ) ) ;
logger . info ( Util . format ( "str" , event . getPlayer ( ) . getName ( ) ) ) ;
double cost = Double . parseDouble ( sign . getLine ( 3 ) . substring ( 1 ) . replaceAll ( "str" , "str" ) ) ;
ItemStack stack = ItemDb . get ( args [ 1 ] ) ;
logger . log ( Level . INFO , Util . format ( "str" , configFile . toString ( ) ) ) ;
result = getMoney ( name ) + money ;
result = getMoney ( name ) + money ;
result = getMoney ( name ) / money ;
result = getMoney ( name ) / money ;
result = getMoney ( name ) * money ;
result = getMoney ( name ) * money ;
result = getMoney ( name ) - money ;
result = getMoney ( name ) - money ;
if ( username . equals ( sign . getLines ( ) [ 3 ] . substring ( 2 ) ) )
if ( ( ! m1 & q1 < 1 ) | | ( ! m2 & q2 < 1 ) )
if ( ( ! m1 & q1 < 1 ) | | ( ! m2 & q2 < 1 ) )
if ( ! username . equals ( sign . getLines ( ) [ 3 ] . substring ( 2 ) ) )
if ( ( ! m1 & q1 < 1 ) | | ( ! m2 & q2 < 1 ) | | r2 < 1 )
event . setLine ( 1 , ( m1 ? "str" + q1 : String . format ( "str" , q1 ) + "str" + l1 [ 1 ] ) + "str" ) ;
p . getTeleport ( ) . teleport ( user , this . getName ( ) ) ;
event . setLine ( 2 , ( m2 ? "str" + q2 : String . format ( "str" , q2 ) + "str" + l2 [ 1 ] ) + "str" + String . format ( "str" , r2 ) ) ;
File account = new File ( folder , name . toLowerCase ( ) + "str" ) ;
public boolean hasHome ( )
if ( ! user . hasHome ( ) )
throw new IllegalArgumentException ( "str" + usersFile . getPath ( ) ) ;
throw new IllegalArgumentException ( "str" + usersFile . getPath ( ) , ex ) ;
public static final int minBukkitBuildVersion = 711 ;
public static final int minBukkitBuildVersion = 699 ;
if ( args . length > 0 & & user . isAuthorized ( "str" ) )
logger . log ( Level . SEVERE , "str" , e ) ;
if ( EssentialsProtect . genSettings . get ( "str" ) )
return config . getBoolean ( "str" , false ) ;
block . getY ( ) , block . getZ ( ) + 1 - 2 * Math . round ( Math . random ( ) ) ) ;
return new Location ( block . getWorld ( ) , block . getX ( ) + 1 - 2 * Math . round ( Math . random ( ) ) ,
public static void loadClasses ( )
public static void disabledloadClasses ( )
if ( ! user . isAuthorized ( "str" ) & &
user . setDisplayName ( prefix + user . getNick ( ) + suffix + ( suffix . length ( ) > 1 & & suffix . substring ( suffix . length ( ) - 2 ) . equals ( "str" ) ? "str" : "str" ) ) ;
public static final int minBukkitBuildVersion = 617 ;
@Description ( "str" +
while ( this . iterator . hasNext ( ) & & skippedRecords < = lastOffset ) {
protected List < SourceRecord > process ( ) {
if ( ! Strings . isNullOrEmpty ( upstreamUrl ) ) {
server . createJob ( jobName , sourceXml , true ) ;
return job . getName ( ) ;
return job . getName ( ) ;
return job . getName ( ) ;
assertThat ( computerSet . getDisplayName ( ) ) . isEqualTo ( "str" ) ;
import org . apache . http . HttpStatus ;
String qs = join ( Collections2 . transform ( params . entrySet ( ) , new MapEntryToQueryStringPair ( ) ) , "str" ) ;
private String cam_file_data = null ;
serviceInfo = serviceInfo . substring ( 1 , serviceInfo . length ( ) - 1 ) ;
& & ! event . getEntity ( ) . getEntityWorld ( ) . isRemote
private int eatingTicks = 0 ;
eatingTicks = 0 ;
lastHotbarIndex = - 1 ;
cb - > {
nargs = Arrays . copyOfRange ( args , requiredArgs , args . length ) ;
. defaultTo ( 600 )
final int current = selected ( ) ;
select ( current ) ;
event . setCanceled ( true ) ;
setInCache ( CACHE_HOVERING_INDEX , newShulkerGui ( slotUnder . getStack ( ) , 1 ) ) ;
private final int priority ;
public GuiShulkerViewer ( Container inventorySlotsIn , ItemStack parentShulker , int priority ) {
this . priority = priority ;
return Integer . compare ( priority , o . priority ) ;
final String match = data . getArgumentCount ( ) > 0 ? data . getArgumentAsString ( 0 ) . toLowerCase ( ) : "str" ;
if ( match . isEmpty ( ) | | pl . getName ( ) . toLowerCase ( ) . contains ( match ) ) {
if ( ( Strings . isNullOrEmpty ( arg ) | | command . getName ( ) . toLowerCase ( ) . contains ( arg . toLowerCase ( ) ) )
private final ResourceLocation waifu = new ResourceLocation ( "str" ) ;
public ESP ( ) {
if ( ( character = = "str" ) & & ( i < size ) )
if ( ( character = = "str" ) & & ( i < size ) )
if ( ( c = = "str" ) & & ( i < word . toCharArray ( ) . length - 1 ) )
if ( ( c = = "str" ) & & ( i < chars . length - 1 ) )
if ( setting = = null | | DrawOptions . DISABLED . equals ( setting . get ( ) ) ) return ;
final double itemSize = 16 ;
required = Arrays . copyOfRange ( args , 0 , requiredArgs - 1 ) ;
nargs = Arrays . copyOfRange ( args , requiredArgs , args . length - 1 ) ;
if ( ! Strings . isNullOrEmpty ( arg ) ) {
return isStarted ( ) & & ( time < ( System . currentTimeMillis ( ) - timeStarted ) ) ;
public final Setting < DrawOptions > players = getCommandStub ( ) . builders ( ) . < DrawOptions > newSettingEnumBuilder ( )
if ( stack ! = null & & Objects . equals ( stack , ItemStack . EMPTY ) )
if ( ! MC . isCallingFromMinecraftThread ( ) )
ForgeHaxHooks . COLOR_MULTIPLIER_ALPHA = ( cb . getTo ( ) . floatValue ( ) / 255.f ) ;
return messages . get ( ( nextIndex + + % messages . size ( ) ) ) ;
} else if ( System . currentTimeMillis ( ) > nextSend ) {
super ( "str" , true , "str" ) ;
( EntityUtils . isFriendlyMob ( entity ) & & target_mobs_friendly . get ( ) )
if ( ! checkVersion ( element ) ) throw new IncompatibleMCVersionException ( String . format ( "str" , getMcVersion ( ) ) ) ;
super ( "str" , false , "str" ) ;
sendMessages ( c ) ;
private void resendPendingMessages ( boolean retryingMedia , boolean forcePending , String to ) {
File logDir = new File ( context . getCacheDir ( ) , LOG_DIRECTORY ) ;
"str" + Keys . TRUST_VERIFIED + "str" + TABLE_KEYS + "str" ,
if ( extras ! = null & & ! extras . isEmpty ( ) ) {
catch ( Exception e ) {
} , Keys . FINGERPRINT + "str" , null , null ) ;
public void onFileSelection ( @NonNull FileChooserDialog fileChooserDialog , @NonNull File file ) {
public void onFolderSelection ( @NonNull FolderChooserDialog folderChooserDialog , @NonNull File folder ) {
addResyncContact ( db , stm , onlineUpd , onlineIns ,
addResyncContact ( db , stm , onlineUpd , onlineIns ,
addResyncContact ( db , stm , onlineUpd , onlineIns ,
private void addResyncContact ( SQLiteDatabase db , SQLiteStatement stm , SQLiteStatement onlineUpd , SQLiteStatement onlineIns ,
int rows = executeUpdateDelete ( db , onlineUpd ) ;
if ( android . os . Build . VERSION . SDK_INT > = android . os . Build . VERSION_CODES . HONEYCOMB )
if ( android . os . Build . VERSION . SDK_INT > = android . os . Build . VERSION_CODES . HONEYCOMB )
if ( android . os . Build . VERSION . SDK_INT > = android . os . Build . VERSION_CODES . HONEYCOMB )
if ( subpackets ! = null ) {
. getPublicKey ( ) . getAlgorithm ( ) , HashAlgorithmTags . SHA256 ) ) ;
. getPublicKey ( ) . getAlgorithm ( ) , HashAlgorithmTags . SHA256 ) ) ;
if ( ! canSend & & mRecordFile ! = null )
else if ( MessageCenterService . ACTION_CONNECTED . equals ( action ) & & rosterParts < 0 ) {
. cap ( TimeUnit . SECONDS , 300 )
MessageCenterService . sPushSenderId = senderId ;
static String sPushSenderId ;
if ( sPushSenderId ! = null ) {
mPushService . register ( sPushListener , sPushSenderId ) ;
protected KontalkConnection mConn ;
mConn . instantShutdown ( ) ;
String from = XmppStringUtils . parseBareAddress ( p . getFrom ( ) ) ;
catch ( Exception ie ) {
public synchronized void starting ( ClientThread client , RequestJob job ) {
public synchronized void downloadProgress ( ClientThread client , RequestJob job , long bytes ) {
public synchronized boolean error ( ClientThread client , RequestJob job , Throwable exc ) {
public synchronized void done ( ClientThread client , RequestJob job , String txId ) {
public synchronized void uploadProgress ( ClientThread client , RequestJob job , long bytes ) {
catch ( Exception e ) {
md . update ( text . getBytes ( ) , 0 , text . length ( ) ) ;
dcg = dcg . add ( new BigDecimal ( value . doubleValue ( ) / ( Math . log ( rank + 1 ) / Math . log ( 2 ) ) ) ) ;
result = result . add ( new BigDecimal ( gains [ i ] / ( Math . log ( i + 2 ) / Math . log ( 2 ) ) ) ) ;
Arrays . fill ( gains , howManyVeryVeryRelevantDocs + howManyVeryRelevantDocs , gains . length , 1 ) ;
return payload . asText ( ) ;
colorBackground = newColorBackground ;
writeMethodsForTypes . put ( "str" , new PrimitiveTypeSerializer ( "str" ) ) ;
if ( playlist = = null | | ! event . getSelfMember ( ) . hasPermission ( event . getTextChannel ( ) , Permission . MESSAGE_ADD_REACTION ) )
if ( onSurfaceCount ! = surfaceEnd - surfaceStart + 1 ) {
results . setSucceeded ( success ) ;
assertThat ( results . isSucceeded ( ) ) . isFalse ( ) ;
public static final int COMMIT_TOTAL_RETRY_TIME_MS_DEFAULT = 1800000 ;
public static final long MANIFEST_TARGET_SIZE_BYTES_DEFAULT = 8388608 ;
public static final int MANIFEST_MIN_MERGE_COUNT_DEFAULT = 100 ;
public static final int COMMIT_TOTAL_RETRY_TIME_MS_DEFAULT = 600000 ;
public static final long MANIFEST_TARGET_SIZE_BYTES_DEFAULT = 4194304 ;
OutputFile newMetadataLocation = HadoopOutputFile . fromPath ( new Path ( newFilename ) , conf ) ;
. withQuoteMode ( QuoteMode . ALL_NON_NULL ) ;
. withQuoteMode ( QuoteMode . ALL_NON_NULL ) ;
. withQuoteMode ( QuoteMode . ALL_NON_NULL ) ;
public void testMySqlNullStringDefault ( ) {
private long eolCounter ;
private long position ;
private final Character quoteCharacter ;
. withQuote ( null )
this . quoteCharacter = quoteChar ;
} else if ( ! quoteCharacter . equals ( other . quoteCharacter ) ) {
} else if ( ! commentStartCharacter . equals ( other . commentStartCharacter ) ) {
} else if ( ! escapeCharacter . equals ( other . escapeCharacter ) ) {
public boolean isNullStringSet ( ) {
if ( isEscapeCharacterSet ( ) ) {
sb . append ( "str" ) . append ( escapeCharacter ) . append ( "str" ) ;
if ( isQuoteCharacterSet ( ) ) {
sb . append ( "str" ) . append ( quoteCharacter ) . append ( "str" ) ;
if ( isCommentStartCharacterSet ( ) ) {
sb . append ( "str" ) . append ( commentStartCharacter ) . append ( "str" ) ;
if ( isNullStringSet ( ) ) {
if ( quoteCharacter ! = null & & delimiter = = quoteCharacter . charValue ( ) ) {
"str" + quoteCharacter + "str" ) ;
if ( escapeCharacter ! = null & & delimiter = = escapeCharacter . charValue ( ) ) {
"str" + escapeCharacter + "str" ) ;
if ( commentStartCharacter ! = null & & delimiter = = commentStartCharacter . charValue ( ) ) {
"str" + commentStartCharacter + "str" ) ;
if ( quoteCharacter ! = null & & quoteCharacter . equals ( commentStartCharacter ) ) {
"str" + commentStartCharacter + "str" ) ;
if ( escapeCharacter ! = null & & escapeCharacter . equals ( commentStartCharacter ) ) {
"str" + commentStartCharacter + "str" ) ;
if ( escapeCharacter = = null & & quoteMode = = QuoteMode . NONE ) {
return new CSVFormat ( delimiter , quoteCharacter , quoteMode , commentMarker , escapeCharacter ,
return new CSVFormat ( delimiter , quoteCharacter , quoteMode , commentStartCharacter , escapeCharacter ,
return new CSVFormat ( delimiter , quoteCharacter , quoteMode , commentStartCharacter , escape ,
return new CSVFormat ( delimiter , quoteCharacter , quoteMode , commentStartCharacter , escapeCharacter ,
return new CSVFormat ( delimiter , quoteCharacter , quoteMode , commentStartCharacter , escapeCharacter ,
return new CSVFormat ( delimiter , quoteCharacter , quoteMode , commentStartCharacter , escapeCharacter ,
return new CSVFormat ( delimiter , quoteCharacter , quoteMode , commentStartCharacter , escapeCharacter ,
return new CSVFormat ( delimiter , quoteCharacter , quoteMode , commentStartCharacter , escapeCharacter ,
public CSVFormat withQuote ( final Character quoteChar ) {
return new CSVFormat ( delimiter , quoteChar , quoteMode , commentStartCharacter , escapeCharacter ,
return new CSVFormat ( delimiter , quoteCharacter , quoteModePolicy , commentStartCharacter , escapeCharacter ,
return new CSVFormat ( delimiter , quoteCharacter , quoteMode , commentStartCharacter , escapeCharacter ,
return new CSVFormat ( delimiter , quoteCharacter , quoteMode , commentStartCharacter , escapeCharacter ,
CSVFormat format = CSVFormat . newFormat ( "str" ) . withQuote ( "str" ) ;
CSVFormat format = CSVFormat . newFormat ( "str" ) . withQuote ( "str" ) ;
assertFalse ( format . isEscapeCharacterSet ( ) ) ;
assertTrue ( format . isEscapeCharacterSet ( ) ) ;
final CSVFormat format = CSVFormat . DEFAULT . withQuote ( "str" ) . withCommentMarker ( "str" ) . withDelimiter ( "str" ) ;
. withQuote ( "str" )
. withQuote ( "str" )
. withQuote ( "str" )
. withQuote ( "str" )
. withQuote ( "str" )
. withQuote ( "str" )
. withQuote ( "str" )
. withQuote ( "str" )
. withQuote ( "str" )
CSVFormat . DEFAULT . withQuote ( "str" ) . withCommentMarker ( "str" ) ;
CSVFormat . DEFAULT . withQuote ( new Character ( "str" ) ) . withCommentMarker ( "str" ) ;
CSVFormat . DEFAULT . withQuote ( "str" ) . withDelimiter ( "str" ) ;
assertEquals ( null , RFC4180 . getCommentStartCharacter ( ) ) ;
assertEquals ( null , RFC4180 . getEscapeCharacter ( ) ) ;
assertEquals ( Character . valueOf ( "str" ) , RFC4180 . getQuoteCharacter ( ) ) ;
assertEquals ( "str" , CSVFormat . DEFAULT . getEscapeCharacter ( ) , format . getEscapeCharacter ( ) ) ;
assertEquals ( Character . valueOf ( "str" ) , formatWithCommentStart . getCommentStartCharacter ( ) ) ;
assertEquals ( Character . valueOf ( "str" ) , formatWithEscape . getEscapeCharacter ( ) ) ;
CSVFormat . DEFAULT . withQuote ( LF ) ;
if ( format . isQuoteCharacterSet ( ) ) {
} else if ( format . isEscapeCharacterSet ( ) ) {
final char escape = format . getEscapeCharacter ( ) . charValue ( ) ;
final char quoteChar = format . getQuoteCharacter ( ) . charValue ( ) ;
if ( ! format . isCommentStartCharacterSet ( ) ) {
out . append ( format . getCommentStartCharacter ( ) . charValue ( ) ) ;
out . append ( format . getCommentStartCharacter ( ) . charValue ( ) ) ;
final CSVPrinter printer = new CSVPrinter ( sw , CSVFormat . DEFAULT . withQuote ( "str" ) ) ;
final CSVPrinter printer = new CSVPrinter ( sw , CSVFormat . DEFAULT . withQuote ( "str" ) ) ;
final CSVPrinter printer = new CSVPrinter ( sw , CSVFormat . DEFAULT . withQuote ( "str" ) ) ;
final CSVPrinter printer = new CSVPrinter ( sw , CSVFormat . DEFAULT . withQuote ( "str" ) ) ;
final CSVPrinter printer = new CSVPrinter ( sw , CSVFormat . DEFAULT . withQuote ( null ) . withEscape ( "str" ) ) ;
final CSVPrinter printer = new CSVPrinter ( sw , CSVFormat . DEFAULT . withEscape ( "str" ) . withQuote ( null ) ) ;
final CSVPrinter printer = new CSVPrinter ( sw , CSVFormat . DEFAULT . withQuote ( null ) . withEscape ( "str" ) ) ;
final CSVPrinter printer = new CSVPrinter ( sw , CSVFormat . DEFAULT . withQuote ( null ) ) ;
final CSVPrinter printer = new CSVPrinter ( sw , CSVFormat . DEFAULT . withQuote ( null ) ) ;
final CSVPrinter printer = new CSVPrinter ( sw , CSVFormat . DEFAULT . withQuote ( null )
final CSVPrinter printer = new CSVPrinter ( sw , CSVFormat . DEFAULT . withQuote ( null ) ) ;
final CSVFormat format = CSVFormat . newFormat ( "str" ) . withQuote ( "str" )
assertFalse ( format . isCommentStartCharacterSet ( ) ) ;
public boolean getAllowMissingColumnNames ( ) {
public boolean getIgnoreEmptyLines ( ) {
public boolean getIgnoreSurroundingSpaces ( ) {
public boolean getSkipHeaderRecord ( ) {
if ( getIgnoreEmptyLines ( ) ) {
if ( getIgnoreSurroundingSpaces ( ) ) {
assertFalse ( RFC4180 . getIgnoreEmptyLines ( ) ) ;
if ( this . format . getSkipHeaderRecord ( ) ) {
if ( containsHeader & & ( ! emptyHeader | | ( emptyHeader & & ! this . format . getAllowMissingColumnNames ( ) ) ) ) {
assertFalse ( "str" , format . getIgnoreEmptyLines ( ) ) ;
public boolean isIgnoringEmptyHeaders ( ) {
public boolean isIgnoringEmptyLines ( ) {
public boolean isIgnoringSurroundingSpaces ( ) {
public boolean isSkippingHeaderRecord ( ) {
public boolean isHandlingNull ( ) {
if ( isHandlingNull ( ) ) {
if ( isIgnoringEmptyLines ( ) ) {
if ( isIgnoringSurroundingSpaces ( ) ) {
assertFalse ( RFC4180 . isIgnoringEmptyLines ( ) ) ;
if ( this . format . isSkippingHeaderRecord ( ) ) {
if ( containsHeader & & ( ! emptyHeader | | ( emptyHeader & & ! this . format . isIgnoringEmptyHeaders ( ) ) ) ) {
assertFalse ( "str" , format . isIgnoringEmptyLines ( ) ) ;
assertEquals ( "str" , CSVFormat . DEFAULT . getRecordSeparator ( ) , format . getRecordSeparator ( ) ) ;
public void testGetRecordWithMultiLineValues ( ) throws Exception {
private final char commentStart ;
this . commentStart = mapNullToDisabled ( format . getCommentStart ( ) ) ;
return ch = = commentStart ;
ch = = commentStart ;
newRecord = true ;
if ( ! newRecord ) {
final boolean first = newRecord ;
final boolean ignoreEmptyLines , final String recordSeparator ,
this . recordSeparator = recordSeparator ;
if ( encapsulator ! = null & & delimiter = = encapsulator ) {
if ( escape ! = null & & delimiter = = escape ) {
if ( commentStart ! = null & & delimiter = = commentStart ) {
boolean eol = readEndOfLine ( c ) ;
eol = readEndOfLine ( c ) ;
eol = readEndOfLine ( c ) ;
if ( readEndOfLine ( c ) ) {
} else if ( readEndOfLine ( c ) ) {
boolean eol = readEndOfLine ( c ) ;
eol = readEndOfLine ( c ) ;
eol = readEndOfLine ( c ) ;
if ( readEndOfLine ( c ) ) {
} else if ( readEndOfLine ( c ) ) {
boolean eol = readEndOfLine ( c ) ;
eol = readEndOfLine ( c ) ;
eol = readEndOfLine ( c ) ;
if ( readEndOfLine ( c ) ) {
} else if ( readEndOfLine ( c ) ) {
boolean eol = readEndOfLine ( c ) ;
eol = readEndOfLine ( c ) ;
eol = readEndOfLine ( c ) ;
if ( readEndOfLine ( c ) ) {
} else if ( readEndOfLine ( c ) ) {
boolean readEndOfLine ( int c ) throws IOException {
public static final CSVFormat MYSQL =
return type . name ( ) + "str" + content . toString ( ) + "str" ;
if ( isEndOfFile ( lastChar ) | | ( ! isDelimiter ( lastChar ) & & isEndOfFile ( c ) ) ) {
if ( ! format . isCommentingEnabled ( ) ) {
static final char DISABLED = "str" ;
CSVFormat ( ) {
CSVFormat ( char delimiter , char encapsulator , char commentStart ) {
wsBuf . clear ( ) ;
throw new InterpreterException ( ma . getTrace ( ) , "str" ) ;
return "str" + file + "str" + getLine ( ) + "str" ;
assertEquals ( completionLabels , expectedCompletions , "str" + completionLabels ) ;
handleIndent ( 0 , token , token . getStartIndex ( ) , token . getStopIndex ( ) , token ) ;
handleIndent ( 0 , token , token . getStartIndex ( ) , token . getStopIndex ( ) , token ) ;
handleIndent ( 0 , token , token . getStartIndex ( ) , token . getStopIndex ( ) , firstNewline ) ;
handleIndent ( numberOfTabs , token , token . getStartIndex ( ) , token . getStopIndex ( ) , firstNewline ) ;
private void handleIndent ( int n , Token token , int start , int stop , Token endBlockToken ) {
nextTokens . add ( makeToken ( WurstParser . ENDBLOCK , "str" , endBlockToken . getStartIndex ( ) , endBlockToken . getStartIndex ( ) ) ) ;
return ILconstBool . instance ( haveSaved ( ht , key1 , key2 , ILconstString . class ) ) ;
WurstTypeNamedScope ct = ( WurstTypeNamedScope ) leftType ;
JassProg prog = compiler . transformProgToJass ( ) ;
testAssertOkLinesWithStdLib ( false ,
Set < FunctionDefinition > definedFuncs = new HashSet < > ( ) ;
definedFuncs . remove ( e . attrFuncDef ( ) ) ;
Set < VarDef > definedVars = new HashSet < > ( ) ;
if ( nameDef instanceof VarDef ) {
testAssertErrorsLines ( false , "str" ,
if ( ! ( i . attrTyp ( ) instanceof WurstTypeInterface ) ) {
. filter ( i - > i . attrTyp ( ) instanceof WurstTypeInterface )
for ( int i = 1 ; i < = 10 & & optCount > 0 ; i + + ) {
totalCount . put ( pass . getName ( ) , totalCount . getOrDefault ( pass . getName ( ) , 0 ) + count ) ;
} else if ( v . attrWrites ( ) . size ( ) > 1 & & ! ( v . getType ( ) instanceof ImArrayType | | v . getType ( ) instanceof ImTupleArrayType ) ) {
"str" , "str" , "str" , "str" , "str" , "str" , "str" } ;
WLogger . info ( "str" + k + "str" + v ) ;
testAssertErrorsLines ( false , "str" ,
if ( isGlobal ( v ) & & ( ! v . getIsBJ ( ) | | result instanceof JassInitializedVar ) ) {
CompletionParams position = new CompletionParams ( textDocument , pos ) ;
WLogger . info ( "str" + Utils . printSep ( "str" , arguments . toArray ( new String [ 0 ] ) ) ) ;
WLogger . trace ( name + "str" + Utils . join ( arguments , "str" ) + "str" ) ;
WLogger . trace ( "str" + func . getName ( ) + "str" + e . getVal ( ) ) ;
WLogger . trace ( "str" + func . getName ( ) ) ;
writer . writeString ( p . toString ( ) . replaceAll ( "str" , "str" ) ) ;
return haveSaved ( ht , key1 , key2 , ILconstInt . class ) ? load ( ht , key1 , key2 , ILconstInt . class ) : ILconstInt . create ( 0 ) ;
return haveSaved ( ht , key1 , key2 , ILconstReal . class ) ? load ( ht , key1 , key2 , ILconstReal . class ) : new ILconstReal ( 0 ) ;
return haveSaved ( ht , key1 , key2 , ILconstReal . class ) ? load ( ht , key1 , key2 , ILconstString . class ) : new ILconstString ( "str" ) ;
return haveSaved ( ht , key1 , key2 , ILconstReal . class ) ? load ( ht , key1 , key2 , ILconstBool . class ) : ILconstBool . FALSE ;
if ( hasValueOfType ( map , keyPair , clazz ) ) {
if ( o . getClass ( ) = = type ) {
public ILconstBool haveSaved ( IlConstHandle ht , ILconstInt key1 , ILconstInt key2 ) {
return "str" + test ;
if ( globalState = = null ) {
JOptionPane . showMessageDialog ( null , "str" + importDirectory + "str" + e . getMessage ( ) ) ;
return f . hasFlag ( FunctionFlagEnum . IS_TEST ) | | f . isCompiletime ( ) ;
throw new InterpreterException ( trace , "str" ) ;
throw new InterpreterException ( globalState , "str" + var . getName ( ) + "str" ) ;
throw new RuntimeException ( "str" ) ;
private static List < Either < String , MarkedString > > description ( Element n ) {
static String descriptionString ( Element n ) {
completion . setDocumentation ( HoverInfo . descriptionString ( constr ) ) ;
return printElement ( e ) + "str" + src . getFile ( ) + "str"
import de . peeeq . wurstscript . intermediatelang . interpreter . ILInterpreter ;
import org . junit . Assert ;
RunArgs runArgs = new RunArgs ( "str" , StdLib . getLib ( ) ) ;
compiler . setRunArgs ( new RunArgs ( "str" ) ) ;
WurstCompilerJassImpl compiler , WurstModel model ) throws Error {
compiler . setRunArgs ( new RunArgs ( "str" , "str" ) ) ;
WurstCompilerJassImpl compiler , WurstModel model ) throws Error {
compiler . setRunArgs ( new RunArgs ( "str" ) ) ;
WurstCompilerJassImpl compiler , WurstModel model ) throws Error {
compiler . setRunArgs ( new RunArgs ( "str" ) ) ;
WurstModel model ) throws Error {
if ( gameRoot = = null | | ! gameRoot . exists ( ) ) {
Init . log ( "str" ) ;
if ( uri . startsWith ( "str" ) ) {
return getFile ( ) . toURI ( ) . toString ( ) ;
String file = WFile . create ( pos . getFile ( ) ) . getUriString ( ) ;
stack = JassIm . ImVar ( trace , JassIm . ImArrayType ( "str" ) , "str" , false ) ;
ImVar traceI = JassIm . ImVar ( trace , JassIm . ImSimpleType ( "str" ) , "str" , false ) ;
boolean b2 = ( ( ImBoolVal ) right ) . getValB ( ) ;
boolean b2 = ( ( ImBoolVal ) left ) . getValB ( ) ;
if ( withSpace | | ! parLeft & & Character . isLetter ( opString . charAt ( 0 ) ) & & ! opString . equals ( "str" ) ) {
sb . append ( assign ( withSpace ) ) ;
sb . append ( assign ( withSpace ) ) ;
List < CompileError > errors = new ArrayList < > ( parseErrors . getOrDefault ( file , Collections . emptyList ( ) ) ) ;
List < CompileError > errors = new ArrayList < > ( parseErrors . getOrDefault ( file , Collections . emptyList ( ) ) ) ;
paramTypes . add ( p . attrTyp ( ) . setTypeArgs ( p , binding2 ) ) ;
returnType = returnType . setTypeArgs ( f , binding2 ) ;
return identifierPos ( e , e . getNameId ( ) ) ;
return identifierPos ( e , e . getNameId ( ) ) ;
return identifierPos ( e , e . getNameId ( ) ) ;
return identifierPos ( e , e . getNameId ( ) ) ;
return identifierPos ( e , e . getNameId ( ) ) ;
testCompletions ( testData , "str" ) ;
CheckHelper . checkIfIsRefinement ( typeParamMapping , c_funcDef , i_funcDef , "str" + interfaceDef . getName ( ) + "str" , true ) ;
CompilationUnit cu = modelManager . replaceCompilationUnitContent ( filename , buffer , false ) ;
CompilationUnit cu = modelManager . replaceCompilationUnitContent ( filename , buffer , false ) ;
CompilationUnit replaceCompilationUnitContent ( String filename , String buffer , boolean reportErrors ) ;
CompilationUnit cu = modelManager . replaceCompilationUnitContent ( filename , buffer , false ) ;
CompilationUnit cu = modelManager . replaceCompilationUnitContent ( filename , buffer , false ) ;
public CompilationUnit replaceCompilationUnitContent ( String filename , String contents , boolean reportErrors ) {
return replaceCompilationUnit ( filename , contents , reportErrors ) ;
this . lines = buffer . split ( "str" ) ;
lexer . setErrorListener ( l ) ;
if ( indexList ! = null & & ! indexList . isEmpty ( ) ) {
return Utils . printElementWithSource ( f ) ;
return linkTo ( decl , e . attrErrorPos ( ) . getLeftPos ( ) , e . attrErrorPos ( ) . getRightPos ( ) - 1 ) ;
return linkTo ( decl , e . attrErrorPos ( ) . getLeftPos ( ) , e . attrErrorPos ( ) . getRightPos ( ) - 1 ) ;
return linkTo ( decl , e . attrErrorPos ( ) . getLeftPos ( ) , e . attrErrorPos ( ) . getRightPos ( ) - 1 ) ;
return linkTo ( p , e . attrErrorPos ( ) . getLeftPos ( ) , e . attrErrorPos ( ) . getRightPos ( ) - 1 ) ;
return linkTo ( def , e . attrErrorPos ( ) . getLeftPos ( ) , e . attrErrorPos ( ) . getRightPos ( ) - 1 ) ;
return linkTo ( def , e . attrErrorPos ( ) . getLeftPos ( ) , e . attrErrorPos ( ) . getRightPos ( ) - 1 ) ;
return linkTo ( def , eb . getLeft ( ) . attrErrorPos ( ) . getRightPos ( ) , eb . getRight ( ) . attrErrorPos ( ) . getLeftPos ( ) - 1 ) ;
testAssertErrorsLines ( false , "str" ,
imProg = getImTranslator ( ) . translateProg ( ) ;
private void doTypeCheckPartial ( WurstGui gui , boolean addErrorMarkers , List < CompilationUnit > toCheck ) {
private void doTypeCheck ( WurstGui gui , boolean addErrorMarkers ) {
testAssertErrorsLines ( false , "str" ,
private final boolean debug = false ;
private final boolean debug = true ;
} else if ( isWrapCharBeginLine ( token . getType ( ) ) ) {
public ILconstString StringCase ( ILconstString string , ILconstBool upperCase ) {
return ( val = = ( ( ILconstInt ) other ) . getVal ( ) ) ;
return ( val = = ( ( ILconstReal ) other ) . getVal ( ) ) ;
if ( ef . getExtendedType ( ) . attrTyp ( ) . dynamic ( ) . isSupertypeOf ( leftType , ef ) ) {
super . testAssertOkFileWithStdLib ( new File ( TEST_DIR + "str" ) , false ) ;
if ( ! wImport . attrImportedPackage ( ) . getName ( ) . equals ( "str" ) & & wImport . attrImportedPackage ( ) . getName ( ) = = wImport . attrNearestNamedScope ( ) . getName ( ) ) {
List < ImFunction > r = Lists . newArrayList ( collection ) ;
assertError ( true , "str" ,
assertError ( true , "str" ,
VarDef l = ( VarDef ) e ;
e = JassExprBinary ( JassExprBinary ( leftExpr , JassOpMult ( ) , JassExprRealVal ( "str" ) ) , JassOpDiv ( ) , rightExpr ) ;
return JassAst . JassExprRealVal ( "str" ) ;
sb . append ( "str" + c . name + "str" ) ;
sb . append ( "str" + p . typ + "str" + p . name + "str" ) ;
sb . append ( "str" + getCommonSupertypeType ( ) + "str" ) ;
sb . append ( "str" + l . itemType + "str" ) ;
Files . write ( new JassPrinter ( true ) . printProg ( prog ) , new File ( testFile + "str" ) , Charsets . UTF_8 ) ;
Files . write ( new JassPrinter ( false ) . printProg ( prog ) , new File ( testFile + "str" ) , Charsets . UTF_8 ) ;
this . type = type = = null ? "str" : type ;
context . fPlayer . msg ( TL . COMMAND_UNBAN_TARGET_IN_OTHER_FACTION , target . getName ( ) ) ;
return TL . COMMAND_GRACE_DESCRIPTION ;
COMMAND_GRACE_DESCRIPTION ( "str" ) ,
object . add ( "str" , new JsonPrimitive ( location . getWorld ( ) . getName ( ) ) ) ;
MANAGE_PERMISSIONS ( "str" ) ,
public BrigadierManager brigadierManager = new BrigadierManager ( ) ;
ItemStack item = new ItemStack ( MultiversionMaterials . fromString ( material . toString ( ) ) . parseMaterial ( ) , amount , datavalue ) ;
public static HashMap < String , DefaultPermissions > defaultFactionPermissions = new HashMap < > ( ) ;
fme . msg ( TL . COMMAND_TNTFILL_RADIUSMAX . toString ( ) . replace ( "str" , SavageFactions . plugin . getConfig ( ) . getInt ( "str" ) + "str" ) ) ;
fme . msg ( TL . COMMAND_TNTFILL_AMOUNTMAX . toString ( ) . replace ( "str" , SavageFactions . plugin . getConfig ( ) . getInt ( "str" ) + "str" ) ) ;
fme . msg ( TL . COMMAND_TNTFILL_NOTENOUGH . toString ( ) ) ;
fme . msg ( TL . COMMAND_TNTFILL_NOTENOUGH . toString ( ) ) ;
fme . msg ( TL . COMMAND_TNT_WIDTHDRAW_NOTENOUGH . toString ( ) ) ;
fme . msg ( TL . COMMAND_TNT_WIDTHDRAW_NOTENOUGH . toString ( ) ) ;
fme . msg ( TL . COMMAND_TNT_WIDTHDRAW_NOTENOUGH . toString ( ) ) ;
fme . msg ( TL . COMMAND_TNT_WIDTHDRAW_NOTENOUGH . toString ( ) ) ;
fme . msg ( TL . COMMAND_TNT_WIDTHDRAW_NOTENOUGH . toString ( ) ) ;
BANNER = Material . valueOf ( "str" ) ;
BANNER = Material . valueOf ( "str" ) ;
if ( ! hasAvaliableSlot ( me , fullStacks + 1 ) ) {
msg ( TL . COMMAND_INSPECT_DISABLED_MSG ) ;
fplayer . msg ( TL . COMMAND_INSPECT_DISABLED_MSG ) ;
fplayer . msg ( TL . COMMAND_INSPECT_DISABLED_MSG ) ;
COMMAND_INSPECT_DISABLED_MSG ( "str" ) ,
DEFAULT_PREFIX ( "str" , "str" ) ,
this . mapHeight = height > Conf . mapHeight * 2 ? Conf . mapHeight * 2 : height ;
fme . sendMessage ( TL . COMMAND_MAPHEIGHT_SET . format ( fme . getMapHeight ( ) ) ) ;
return this . hasFaction ( ) ? String . format ( Conf . chatTagFormat , this . role . getPrefix ( ) + this . getTag ( ) ) : TL . NOFACTION_PREFIX . toString ( ) ;
P . p . debug ( "str" + fplayer . getName ( ) + "str" ) ;
protected boolean willAutoLeave = true ;
msg . then ( name + "str" ) . color ( ChatColor . WHITE ) . tooltip ( TL . COMMAND_SHOWINVITES_CLICKTOREVOKE . format ( name ) ) . command ( "str" + Conf . baseCommandAliases . get ( 0 ) + "str" + name ) ;
FancyMessage message = new FancyMessage ( fme . describeTo ( you , true ) ) . tooltip ( TL . COMMAND_INVITE_CLICKTOJOIN . toString ( ) ) . command ( "str" + Conf . baseCommandAliases . get ( 0 ) + "str" + myFaction . getTag ( ) ) . then ( TL . COMMAND_INVITE_INVITEDYOU . toString ( ) ) . color ( ChatColor . YELLOW ) . tooltip ( TL . COMMAND_INVITE_CLICKTOJOIN . toString ( ) ) . command ( "str" + Conf . baseCommandAliases . get ( 0 ) + "str" + myFaction . getTag ( ) ) . then ( myFaction . describeTo ( you ) ) . tooltip ( TL . COMMAND_INVITE_CLICKTOJOIN . toString ( ) ) . command ( "str" + Conf . baseCommandAliases . get ( 0 ) + "str" + myFaction . getTag ( ) ) ;
msg . then ( s + "str" ) . color ( ChatColor . WHITE ) . tooltip ( TL . COMMAND_MOD_CLICKTOPROMOTE . toString ( ) + s ) . command ( "str" + Conf . baseCommandAliases . get ( 0 ) + "str" + s ) ;
msg . then ( name + "str" ) . color ( ChatColor . WHITE ) . tooltip ( TL . COMMAND_DEINVITE_CLICKTODEINVITE . format ( name ) ) . command ( "str" + Conf . baseCommandAliases . get ( 0 ) + "str" + name ) ;
msg . then ( s + "str" ) . tooltip ( TL . COMMAND_FWARP_CLICKTOWARP . toString ( ) ) . command ( "str" + Conf . baseCommandAliases . get ( 0 ) + "str" + s ) . color ( ChatColor . WHITE ) ;
msg . then ( s + "str" ) . color ( ChatColor . WHITE ) . tooltip ( TL . COMMAND_KICK_CLICKTOKICK . toString ( ) + s ) . command ( "str" + Conf . baseCommandAliases . get ( 0 ) + "str" + s ) ;
msg . then ( s + "str" ) . color ( ChatColor . GRAY ) . tooltip ( TL . COMMAND_KICK_CLICKTOKICK . toString ( ) + s ) . command ( "str" + Conf . baseCommandAliases . get ( 0 ) + "str" + s ) ;
LAST_SEEN ( TagType . PLAYER , "str" ) ,
return replace ( fplayer , P . p . getConfig ( ) . getString ( "str" , "str" ) ) ;
public static int chatTagInsertIndex = 0 ;
COMMAND_KICK_NONE ( "str" ) ,
modeString = modeString . toLowerCase ( ) ;
if ( fplayer . getFactionId ( ) . equals ( myFaction . getId ( ) ) ) {
} else if ( toggle & & P . p . getConfig ( ) . getBoolean ( "str" , true ) ) {
if ( ! yml . getBoolean ( uuid . toString ( ) , true ) ) {
return yml . getBoolean ( uuid . toString ( ) , true ) ;
recipient . msg ( "str" , moneyString ( amount ) , from . describeTo ( recipient ) , to . describeTo ( recipient ) ) ;
recipient . msg ( "str" , invoker . describeTo ( recipient , true ) , moneyString ( amount ) , from . describeTo ( recipient ) , to . describeTo ( recipient ) ) ;
import org . bukkit . event . player . PlayerChatEvent ;
public void onPlayerEarlyChat ( PlayerChatEvent event )
public void onPlayerChat ( PlayerChatEvent event )
return Econ . hasAtLeast ( myFaction , cost , toDoThis ) ;
return Econ . hasAtLeast ( fme , cost , toDoThis ) ;
if ( p = = null | | ! p . isOnline ( ) | | p . isDead ( ) | | p = = me | | p . getWorld ( ) ! = w )
public static int spoutTerritoryDisplayPosition = 1 ;
if ( ! Conf . homesMustBeInClaimedTerritory | | this . home = = null | | ( this . home . getLocation ( ) ! = null & & Board . getFactionAt ( new FLocation ( this . home . getLocation ( ) ) ) = = this ) )
if ( target ! = fme & & ! Permission . POWER_ANY . has ( sender , true ) ) return ;
public static Set < String > permanentFactionMemberDenyCommands = new LinkedHashSet < String > ( ) ;
msg ( "str" , faction . getTag ( fme ) , Conf . factionMemberLimit , fplayer . describeTo ( fme , false ) ) ;
location . getWorld ( ) . playEffect ( location . clone ( ) , Effect . SMOKE , direction ) ;
spawnSingleRandom ( location . clone ( ) ) ;
if ( ! lib . require ( "str" , "str" ) ) return false ;
public final void resetFactionData ( boolean doSpoutUpdate )
if ( doSpoutUpdate )
if ( Econ . shouldBeUsed ( ) & & ! senderIsConsole )
fplayer . detach ( ) ;
badGuy . detach ( ) ;
fplayer . sendMessage ( myFaction . getDescription ( ) ) ;
return ( T ) load ( typeOfT , getFile ( name ) ) ;
return ( T ) p . gson . fromJson ( content , typeOfT ) ;
FLocation to = new FLocation ( event . getPlayer ( ) . getLocation ( ) ) ;
if ( id < 0 )
if ( id < 0 )
if ( id < 0 )
if ( id < 0 )
if ( faction ! = null & & faction . getId ( ) > 0 ) {
sendMessage ( "str" ) ;
if ( this . isOffline ( ) & & ! Conf . powerRegenOffline ) {
faction . sendMessage ( Conf . colorSystem + "str" + me . getRelationColor ( faction ) + oldtag + Conf . colorSystem + "str" + myFaction . getTag ( faction ) ) ;
errors . add ( Conf . colorSystem + "str" ) ;
errors . add ( Conf . colorSystem + "str" ) ;
errors . add ( Conf . colorSystem + "str" ) ;
errors . add ( Conf . colorSystem + "str" ) ;
pageLines . add ( TextUtil . commandHelp ( Conf . aliasMap , "str" , "str" ) ) ;
pageLines . add ( TextUtil . commandHelp ( Conf . aliasChat , "str" , "str" ) ) ;
pageLines . add ( Conf . colorSystem + "str" ) ;
pageLines . add ( Conf . colorSystem + "str" ) ;
i . sendMessage ( Conf . colorSystem + "str" ) ;
me . sendMessage ( Conf . colorSystem + "str" + Conf . colorCommand + command ) ;
follower . sendMessage ( Conf . colorSystem + "str" + faction . getTag ( follower ) + Conf . colorSystem + "str" ) ;
me . sendMessage ( me . getRelationColor ( otherFaction ) + otherFaction . getTag ( ) + Conf . colorSystem + "str" ) ;
otherFaction . sendMessage ( currentRelationColor + myFaction . getTag ( ) + Conf . colorSystem + "str" + whishedRelation . getColor ( ) + whishedRelation . toString ( ) ) ;
myFaction . sendMessage ( currentRelationColor + otherFaction . getTag ( ) + Conf . colorSystem + "str" + whishedRelation . getColor ( ) + whishedRelation ) ;
me . sendMessage ( Conf . colorSystem + "str" ) ;
me . sendMessage ( Conf . colorSystem + "str" ) ;
me . sendMessage ( Conf . colorSystem + "str" ) ;
NORMAL ( 0 , "str" ) ;
Log . info ( "str" ) ;
Log . info ( "str" ) ;
Log . info ( "str" ) ;
Log . info ( "str" ) ;
if ( otherFaction = = null | | otherFaction . id = = 0 ) {
if ( otherFaction ! = null & & otherFaction . id ! = 0 & & myFaction ! = otherFaction ) {
if ( follower . getFaction ( ) = = this ) {
follower . sendMessage ( Conf . colorMember + me . getFullName ( ) + Conf . colorSystem + "str" + Conf . colorMember + targetFollower . getFullName ( ) + Conf . colorSystem + "str" ) ;
follower . sendMessage ( me . getFullName ( follower ) + Conf . colorSystem + "str" + targetFollower . getFullName ( follower ) + Conf . colorSystem + "str" + me . getFaction ( ) . getName ( follower ) ) ;
me . getFaction ( ) . sendMessage ( Conf . colorMember + me . getFullName ( ) + Conf . colorSystem + "str" ) ;
return this . getFaction ( ) . deinvite ( follower ) ;
? stashServerBaseUrl . substring ( 0 , stashServerBaseUrl . length ( ) - 1 )
granulesList = getGranules ( workspace , coverageStore , coverage , filter , null , 1 ) ;
granulesList = getGranules ( workspace , coverageStore , coverage , filter , null , 1 ) ;
Toast . makeText ( this , "str" + contributor . name , Toast . LENGTH_SHORT ) . show ( ) ;
public static final String DEFAULT_CTX_PARAM_MAX_LENGTH_TEXT = "str" ;
writer . writeAttribute ( "str" , "str" , null ) ;
xhtmlCodeExample . appendInnerContent ( "str" + this . isRendered ( ) + "str" ) ;
xhtmlCodeExample . appendInnerContent ( "str" ) ;
xhtmlCodeExample . appendInnerContent ( "str" ) ;
xhtmlCodeExample . appendInnerContent ( "str" ) ;
xhtmlCodeExample . appendInnerContent ( "str" ) ;
xhtmlCodeExample . appendInnerContent ( "str" ) ;
@ResourceDependency ( library = "str" , name = "str" , target = "str" ) ,
@ResourceDependency ( library = "str" , name = "str" , target = "str" ) ,
final ValueExpression ve = this . getValueExpression ( propertyName ) ;
if ( "str" . equals ( resourceDependency . library ( ) ) ) {
@ResourceDependency ( library = "str" , name = "str" , target = "str" ) ,
@ResourceDependency ( library = "str" , name = "str" , target = "str" ) ,
this . addGeneratedCSSResource ( context , "str" ) ;
this . addGeneratedCSSResource ( context , "str" ) ;
this . addGeneratedCSSResource ( context , "str" ) ;
this . addGeneratedCSSResource ( context , "str" ) ;
resource . getAttributes ( ) . put ( "str" , "str" ) ;
@ResourceDependency ( library = "str" , name = "str" , target = "str" ) ,
@ResourceDependency ( library = "str" , name = "str" , target = "str" ) ,
@ResourceDependency ( library = "str" , name = "str" , target = "str" ) ,
@ResourceDependency ( library = "str" , name = "str" , target = "str" ) ,
@ResourceDependency ( library = "str" , name = "str" , target = "str" ) ,
@ResourceDependency ( library = "str" , name = "str" , target = "str" ) ,
@ResourceDependency ( library = "str" , name = "str" , target = "str" ) ,
@ResourceDependency ( library = "str" , name = "str" , target = "str" ) ,
@ResourceDependency ( library = "str" , name = "str" , target = "str" ) ,
@ResourceDependency ( library = "str" , name = "str" , target = "str" ) ,
@ResourceDependency ( library = "str" , name = "str" , target = "str" ) ,
assertThat ( MustacheResolver . getMustacheKeys ( "str" ) ) . contains ( "str" , "str" ) ;
stringBuilder . append ( "str" ) ;
@ResourceDependency ( library = "str" , name = "str" , target = "str" ) ,
resources . add ( createJSResource ( "str" , "str" ) ) ;
@ResourceDependency ( library = "str" , name = "str" , target = "str" ) ,
@ResourceDependency ( library = "str" , name = "str" , target = "str" ) ,
@ResourceDependency ( library = "str" , name = "str" , target = "str" ) ,
@ResourceDependency ( library = "str" , name = "str" , target = "str" ) ,
return eval = = null ? true : ( Boolean ) eval ;
@ResourceDependency ( library = "str" , name = "str" , target = "str" ) ,
@InSequence ( 3 )
@InSequence ( 4 )
@InSequence ( 5 )
if ( calculateShowTooltip ( component ) ) {
renderValidationMessages ( uiComponent , writer , ! StringUtils . isEmpty ( component . getTooltip ( ) ) ) ;
private void renderValidationMessages ( final UIInput uiComponent , final ResponseWriter writer , final boolean tooltipExists ) throws IOException {
if ( clientIdsWithMessages . hasNext ( ) & & tooltipExists ) {
this . appendString ( "str" , this . getInputStyleClass ( ) , sb ) ;
this . appendString ( "str" , this . getInputStyleClass ( ) , sb ) ;
this . appendString ( "str" , this . getInputStyleClass ( ) , sb ) ;
this . appendString ( "str" , this . getInputStyleClass ( ) , sb ) ;
this . appendString ( "str" , this . getInputStyleClass ( ) , sb ) ;
this . appendString ( "str" , this . getInputStyleClass ( ) , sb ) ;
this . appendString ( "str" , this . getInputStyleClass ( ) , sb ) ;
this . createAjaxXhtml ( sb , "str" ) ;
sb . append ( "str" ) ;
this . createOutputXhtml ( sb ) ;
Long nextTs = iVal . filter ( sysEnv , submitTs , iVal . getHorizon ( sysEnv , tz ) , tz , 0 ) ;
if ( type ! = SDMSSchedulingEntity . BATCH & & getFinishTs ( sysEnv ) = = null ) {
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
inheritPrivs = ( Long ) withs . get ( ParseStr . S_INHERIT ) ;
inheritPrivs = null ;
if ( inheritPrivs ! = null ) se . setInheritPrivs ( sysEnv , inheritPrivs ) ;
new Integer ( getIsSuspend ( sysEnv ) . booleanValue ( ) ? SDMSSubmittedEntity . SUSPEND : SDMSSubmittedEntity . NOSUSPEND ) ,
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
long sp = o . getPrivileges ( env , privilegeMask , false , checkGroups ) ;
if ( old ! = null & & old . isCurrent & & o . isCurrent ) {
evaluate_with ( sysEnv , salt ) ;
featureLevels . put ( S_CONDITIONAL_RESOURCES , new Feature ( S_PROFESSIONAL , "str" ) ) ;
if ( wh . containsKey ( ParseStr . S_STICKY ) & & sticky ! = null ) {
responseContext . getHeaders ( ) . addAll ( entry . getKey ( ) , entry . getValue ( ) . toArray ( new Object [ 0 ] ) ) ;
RestClientBuilder resteasyBuilder = new BuilderResolver ( ) . newBuilder ( ) ;
LogMessages . LOGGER . failedExecutingDebug ( request . getHttpMethod ( ) ,
private static String defaultSpringVersion = "str" ;
executor = Executors . newCachedThreadPool ( ) ;
if ( Integer . valueOf ( c . getId ( ) ) . equals ( commentId ) )
protected long cacheTimeout = 3600000L ;
getViolations ( ) . addAll ( cvs ) ;
getViolations ( ) . add ( cv1 ) ;
System . getProperty ( "str" , "str" ) . split ( "str" ) ) ;
sseEventSource . setAlwaysReconnect ( false ) ;
sseEventSource . setAlwaysReconnect ( false ) ;
public void setAlwaysReconnect ( boolean always )
sourceImpl . setAlwaysReconnect ( false ) ;
sourceImpl2 . setAlwaysReconnect ( false ) ;
sourceImpl . setAlwaysReconnect ( false ) ;
sseEventSource . setAlwaysReconnect ( false ) ;
@XmlElement ( required = true , namespace = "str" )
protected int connectionPoolSize = 50 ;
return Arrays . copyOf ( buf , count - 2 ) ;
private final String DELIMITER = new String ( SseConstants . EVENT_DELIMITER , StandardCharsets . UTF_8 ) ;
| | ( pos > = 3 & & new String ( eolBuffer , 0 , pos , StandardCharsets . UTF_8 ) . contains ( DELIMITER ) ) )
return Arrays . copyOf ( buf , count - 1 ) ;
if ( count > = 1 & & buf [ count - 1 ] = = "str" )
@InSequence ( 6 )
catch ( IOException e )
catch ( IOException e )
endpoint = _configForReading ( mapper , annotations , null ) ;
endpoint = _configForWriting ( mapper , annotations , null ) ;
Path to = FileSystems . getDefault ( ) . getPath ( "str" ) . toAbsolutePath ( ) ;
String [ ] nv = param . split ( "str" , 2 ) ;
Assert . assertEquals ( 400 , response . getStatus ( ) ) ;
throw new IllegalArgumentException ( "str" + value ) ;
for ( Method method : c . isInterface ( ) ? c . getMethods ( ) : c . getDeclaredMethods ( ) )
uri + = ( "str" + OAuth . OAUTH_TOKEN + "str" + OAuthUtils . encodeForOAuth ( tokenKey ) ) ;
Assert . assertEquals ( "str" , uri . toString ( ) ) ;
initCacheControl ( cache ) ;
return create ( clazz , createUri ( base ) , client , ResteasyProviderFactory . getInstance ( ) ) ;
return create ( clazz , baseUri , new ApacheHttpClientExecutor ( httpClient ) , providerFactory ) ;
List < Variant > vs = Variant . VariantListBuilder . newInstance ( ) . encodings ( "str" , "str" , "str" ) . add ( ) . build ( ) ;
recognizer . addKeyphraseSearch ( KWS_SEARCH_NAME , KEYPHRASE ) ;
import java . util . LinkedHashSet ;
return new LinkedHashSet < T > ( ) ;
import java . util . LinkedHashSet ;
return new LinkedHashSet < T > ( ) ;
if ( ! stack . isEmpty ( ) & & stack . getItem ( ) = = ItemRegistry . RING_OF_POWER & & stack . getItemDamage ( ) < stack . getMaxDamage ( ) ) {
Minecraft . getMinecraft ( ) . entityRenderer . disableLightmap ( ) ;
Minecraft . getMinecraft ( ) . entityRenderer . disableLightmap ( ) ;
if ( ! this . world . isRemote & & this . isEntityAlive ( ) & & this . getPassengers ( ) . indexOf ( passenger ) = = 0 ) {
nbt . setInteger ( "str" , this . getFacingUp ( ) . getIndex ( ) ) ;
return len ( x2 - x1 , y2 - y1 , z2 - z1 ) ;
protected static final AxisAlignedBB CANDLE_AABB = new AxisAlignedBB ( 0.4D , 0.0D , 0.4D , 0.6D , 0.8D , 0.6D ) ;
@Comment ( "str" )
@Comment ( "str" )
if ( this . cachedPrevNodeEntity ! = null & & this . cachedPrevNodeEntity . isEntityAlive ( ) & & this . cachedPrevNodeEntity . getUniqueID ( ) . equals ( this . prevNodeUUID ) ) {
potencyStr = I18n . format ( "str" , ( effect . getAmplifier ( ) + 1 ) ) ;
public int defaultRemoteResetTime = 180 ;
return super . shouldContinueExecuting ( ) & & ( druid . getAttackCounter ( ) ! = 0 | | ( druid . getAttackTarget ( ) ! = null & & druid . getAttackTarget ( ) . onGround ) ) ;
coords . posY = worldServerInstance . getTopSolidOrLiquidBlock ( coords . posX , coords . posZ ) + 1 ;
Block block = entityItem . worldObj . getBlock ( bx + xo , by + yo , bz + zo ) ;
import thebetweenlands . world . loot . LootTables ;
LootUtil . generateLoot ( lootPot , random , LootTables . COMMON_POT_LOOT , min , max ) ;
return new ItemStack ( BLItemRegistry . itemArtefact , size , enumGeneric . id ) ;
if ( event . entityLiving ! = null & & ( event . entityLiving instanceof IEntityBL | | event . entityLiving instanceof EntityDarkDruid ) ) {
if ( current ! = null & & prev ! = null & & ! prev . equals ( current ) & & prev . getItem ( ) instanceof ICorrodible ) {
return mouseX > = x & & mouseX < x + width & & mouseY > = y & & mouseY < y + height ;
TextArea currentTextArea = new TextArea ( this . xOffset + xCursor , this . yOffset + yCursor , renderStrWidth , renderStrHeight , additionalSpaceWidth , isSeperateWord ? renderSpaceWidth : 0 ) ;
Minecraft . getMinecraft ( ) . fontRenderer . drawString ( segment . text , MathHelper . ceiling_float_int ( segment . x / segment . scale ) , MathHelper . ceiling_float_int ( segment . y / segment . scale ) , segment . color ) ;
if ( i + 1 > = textChars . length | | ( ! isDelimiter ( textChars [ i + 1 ] ) & & textChars [ i + 1 ] ! = "str" & & textChars [ i + 1 ] ! = "str" & & wasFirstComponent ) ) {
if ( i < this . spaceIndices . length & & this . spaceIndices [ i ] & & xCursor + renderStrWidth > xOffsetMax ) {
if ( i < this . spaceIndices . length & & this . spaceIndices [ i ] ) xCursor + = renderSpaceWidth ;
if ( i < this . spaceIndices . length & & this . spaceIndices [ i ] ) xCursor + = defaultSpaceWidth ;
this . setUnlocalizedName ( "str" + name ) ;
return new ResourceLocation ( "str" + name ) ;
else if ( tile . getTotalCompostAmount ( ) > tile . getTotalCompostedAmount ( ) )
wightsHeart , yellowDottedFungus , siltCrabClaw , crabstick , nettleSoup , sludgeJello , middleFruitJello , sapJello , marshmallow , marshmallowPink , weedwoodBucket , weedwoodStagnantWater , weedwoodBucketWater , weedwoodBucketTar , lifeCrystal , gertsDonut ) ;
if ( ! open & & ! ( player . isSneaking ( ) & & player . getCurrentEquippedItem ( ) = = null ) ) {
if ( DecayManager . enableDecay ( event . entityPlayer ) & & event . item . getItem ( ) instanceof IDecayFood & & DecayManager . getDecayLevel ( event . entityPlayer ) > = 20 & & ! event . entityPlayer . getFoodStats ( ) . needFood ( ) ) {
drawTexturedModalRect ( k + 121 , l + 10 + i1 , 179 , 3 + i1 , 6 , 40 ) ;
public int progress , life , itemsConsumed = 0 , itemCount = 16 ;
if ( progress > = 40 ) {
public static void registerSlabs ( BlockBLSlab slab , String fieldName ) {
Object obj = BLBlockRegistry . class . getDeclaredField ( fieldName + "str" ) . get ( null ) ;
registerSlabs ( ( BlockBLSlab ) obj , f . getName ( ) ) ;
event . ammount * = damage ;
if ( ! ConfigHandler . DEBUG | | Minecraft . getMinecraft ( ) . theWorld = = null | | ! Keyboard . isKeyDown ( Keyboard . KEY_LCONTROL ) ) return ;
ClassWriter classWriter = new ClassWriter ( 0 ) ;
for ( int l = 0 ; l < = 5 ; l + + ) {
for ( int l = 0 ; l < = 5 ; l + + ) {
startDrawing ( 7 ) ;
this . dropBlockAsItem ( world , x , y , z , new ItemStack ( BLItemRegistry . materialsBL , 1 , 16 ) ) ;
GL11 . glCopyTexImage2D ( GL11 . GL_TEXTURE_2D , 0 , GL11 . GL_DEPTH_COMPONENT , 0 , 0 ,
if ( stack . getItem ( ) instanceof SpadeBL ) {
if ( stack . getItem ( ) = = BLItemRegistry . materialsBL & & stack . getItemDamage ( ) = = EnumMaterialsBL . COMPOST . ordinal ( ) ) {
if ( player . getCurrentEquippedItem ( ) . getItem ( ) instanceof SpadeBL ) {
if ( player . getCurrentEquippedItem ( ) . getItem ( ) instanceof SpadeBL ) {
if ( stack ! = null & & stack . getItem ( ) instanceof SpadeBL ) {
if ( stack ! = null & & stack . getItem ( ) = = BLItemRegistry . materialsBL & & stack . getItemDamage ( ) = = EnumMaterialsBL . COMPOST . ordinal ( ) ) {
if ( player . getCurrentEquippedItem ( ) ! = null & & player . getCurrentEquippedItem ( ) . getItem ( ) instanceof SpadeBL ) {
if ( player . getCurrentEquippedItem ( ) ! = null & & player . getCurrentEquippedItem ( ) . getItem ( ) instanceof SpadeBL ) {
if ( stack ! = null & & ! ( meta > = 8 ) ) {
protected boolean hasBoundingBox = true ;
if ( block instanceof BlockBLLog & & ( ( BlockBLLog ) block ) . getType ( ) . equals ( "str" ) & & meta = = 15 ) {
world . setBlockMetadataWithNotify ( x , y , z , 1 , 2 ) ;
if ( world . getBlockMetadata ( x , y , z ) ! = 1 ) {
blockIcon = reg . registerIcon ( "str" ) ;
new TextureMap ( 128 , 128 , BLBlockRegistry . rottenLog . getIcon ( 0 , 0 ) ) ,
private static final ResourceLocation RES_NORMAL_DOUBLE = new ResourceLocation ( "str" ) ;
Field f = ReflectionHelper . findField ( this . getClass ( ) . getSuperclass ( ) , "str" , "str" ) ;
Field f = ReflectionHelper . findField ( this . getClass ( ) . getSuperclass ( ) , "str" , "str" ) ;
Field f = ReflectionHelper . findField ( this . getClass ( ) . getSuperclass ( ) , "str" , "str" ) ;
Field f = ReflectionHelper . findField ( this . getClass ( ) . getSuperclass ( ) , "str" , "str" ) ;
Field f = ReflectionHelper . findField ( this . getClass ( ) . getSuperclass ( ) , "str" , "str" ) ;
Field f = ReflectionHelper . findField ( this . getClass ( ) . getSuperclass ( ) , "str" , "str" ) ;
Field potionArr = ReflectionHelper . findField ( Potion . class , "str" , "str" ) ;
Field rmField = ReflectionHelper . findField ( this . getClass ( ) . getSuperclass ( ) , "str" , "str" ) ;
Field slField = ReflectionHelper . findField ( this . getClass ( ) . getSuperclass ( ) , "str" , "str" ) ;
if ( ! this . mc . getSoundHandler ( ) . isSoundPlaying ( this . currentSound ) ) {
public ResourceLocation decayBarTexture = new ResourceLocation ( "str" ) ;
mc . renderEngine . bindTexture ( texture ) ;
if ( event . type = = RenderGameOverlayEvent . ElementType . HOTBAR ) renderDecayBar ( ( width / 2 ) - ( 27 / 2 ) , ( height / 2 ) - ( 9 / 2 ) , 27 , 9 , decayBarTexture ) ;
public void onRenderOverlay ( RenderGameOverlayEvent . Text event ) {
return BLBlockRegistry . swampDirt . getItemDropped ( 0 , rand , fortune ) ;
} else if ( dbMajorVersion > = 2 ) {
uniqueKeyViolationNameRegex = new String [ ] { "str" } ;
return schema = = null ? new ArrayList < String > ( ) : platform . getSqlTemplateDirty ( ) . queryWithHandler ( sql . toString ( ) , new StringMapper ( ) ,
if ( entry . getParent ( ) ! = null ) {
if ( entry . getFileName ( ) ! = null ) {
public boolean accept ( Path entry ) {
} catch ( NullPointerException ex ) {
if ( files ! = null ) {
return reloadTable ( nodeId , catalogName , schemaName , tableName , overrideInitialLoadSelect , null , false ) ;
Date date1 = sqlTemplate . queryForObject ( getSql ( "str" ) , Date . class ) ;
final int EXPECTED_VARCHAR_MAX_COUNT = engine . getDatabasePlatform ( ) . getName ( ) . equals ( DatabaseNamesConstants . SQLITE ) ? 315 : 60 ;
final int EXPECTED_VARCHAR_MAX_COUNT = engine . getDatabasePlatform ( ) . getName ( ) . equals ( DatabaseNamesConstants . SQLITE ) ? 314 : 60 ;
databaseInfo . addNativeTypeMapping ( Types . TIME , "str" , Types . TIME ) ;
log . error ( "str" , history . getSourceTableName ( ) , ex ) ;
csvReader . setEscapeMode ( CsvReader . ESCAPE_MODE_BACKSLASH ) ;
+ StringEscapeUtils . escapeXml ( fk . getForeignTableCatalog ( ) = = null | | fk . getForeignTableCatalog ( ) . equals ( table . getCatalog ( ) )
fk . getForeignTableSchema ( ) . equals ( table . getSchema ( ) ) ? "str" : fk . getForeignTableSchema ( ) ) + "str" ) ;
new Object [ ] { i , futures . size ( ) , targetNode . getNodeId ( ) , totalBytesSend , initialLoadMaxBytesToSync } ) ;
public static final String PASSWORD_CHARS = "str" ;
log . debug ( "str" , ex ) ;
if ( targetPlatform ! = null & & ! targetPlatform . equals ( platform ) ) {
if ( targetPlatform ! = null & & ! targetPlatform . equals ( platform ) ) {
if ( targetPlatform ! = null & & ! targetPlatform . equals ( platform ) ) {
if ( targetPlatform ! = null & & ! targetPlatform . equals ( platform ) ) {
if ( targetPlatform ! = null & & ! targetPlatform . equals ( platform ) ) {
+ "str" ) ;
summary . setNodeId ( rs . getString ( "str" ) ) ;
if ( table = = null & & batch ! = null ) {
final int EXPECTED_VARCHAR_MAX_COUNT = engine . getDatabasePlatform ( ) . getName ( ) . equals ( DatabaseNamesConstants . SQLITE ) ? 316 : 59 ;
Assert . assertEquals ( output , 48 , StringUtils . countMatches ( output , "str" ) ) ;
for ( Constructor < ? > c : clazz . getConstructors ( ) ) {
public static final int DEFAULT_MAX_IDLE_TIME = 60000 ;
log . warn (
log . warn (
return StringUtils . left ( replaceCharsToShortenName ( String . format ( "str" , triggerId , sourceNodeGroupId , targetNodeGroupId ) ) , 50 ) ;
log . info ( "str" + ( isFullLoad ? "str" : "str" ) + "str" + targetNode . getNodeId ( ) ) ;
return sqlTemplate . queryForInt ( getSql ( "str" ) , channelId ) ;
monitor . getType ( ) , monitor . getExpression ( ) , monitor . isEnabled ( ) ? 1 : 0 , monitor . getThreshold ( ) , monitor . getRunPeriod ( ) ,
monitor . getNodeGroupId ( ) , monitor . getType ( ) , monitor . getExpression ( ) , monitor . isEnabled ( ) ? 1 : 0 , monitor . getThreshold ( ) ,
event . getSeverityLevel ( ) , event . isNotified ( ) ? 1 : 0 ) ;
notification . getSeverityLevel ( ) , notification . getType ( ) , notification . getExpression ( ) , notification . isEnabled ( ) ? 1 : 0 ,
notification . getSeverityLevel ( ) , notification . getType ( ) , notification . getExpression ( ) , notification . isEnabled ( ) ? 1 : 0 ,
extract ( export , new File ( tmpDir , "str" ) , TableConstants . getTableName ( tablePrefix , TableConstants . SYM_NODE_IDENTITY ) ) ;
extract ( export , new File ( tmpDir , "str" ) ,
extract ( export , new File ( tmpDir , "str" ) ,
extract ( export , new File ( tmpDir , "str" ) ,
extract ( export , new File ( tmpDir , "str" ) ,
extract ( export , new File ( tmpDir , "str" ) ,
extract ( export , new File ( tmpDir , "str" ) ,
extract ( export , 5000 , "str" , new File ( tmpDir , "str" ) ,
extract ( export , 5000 , "str" , new File ( tmpDir , "str" ) ,
tz = TimeZone . getTimeZone ( value ) ;
protected static final String uncPath = null ;
assertFalse ( Version . isOlderVersion ( "str" ) ) ;
Long batchId2 = batchInfo2 . getBatchId ( ) ;
defaultedCatalogName , defaultedSchemaName , tableName ) ) ) {
boolean isDefaultRouter = "str" . equals ( triggerRouter . getRouter ( ) . getRouterType ( ) ) ;
private int initialLoadOrder = 50 ;
private boolean enabled = true ;
sql = String . format ( "str" , sql , engine . getRouterService ( ) . getSql ( "str" ) ) ;
import org . jumpmind . db . platform . DatabaseNamesConstants ;
if ( engine . getDatabasePlatform ( ) . getName ( ) . startsWith ( DatabaseNamesConstants . FIREBIRD )
List < String > tableNames = reader . getTableNames ( defaultedCatalogName , defaultedSchemaName , null ) ;
String msg = String . format ( "str"
saveTriggerRouter ( triggerRouter , false ) ;
if ( old . getCurrentBatchDataCount ( ) > 0 | | old . getDataCount ( ) > 0 ) {
Date periodEnd = DateUtils . addMinutes ( periodStart , periodSizeInMinutes ) ;
periodEnd = DateUtils . addMinutes ( periodStart , periodSizeInMinutes ) ;
processInfo . incrementBatchDataCount ( ) ;
processInfo . incrementBatchDataCount ( ) ;
processInfo . incrementBatchDataCount ( ) ;
processInfo . incrementBatchDataCount ( ) ;
log . info ( "str" , triggerSql ) ;
log . info ( "str" , postTriggerDml ) ;
log . info (
primaryKeyViolationCodes = new int [ ] { 2627 , 2601 } ;
log . debug ( "str" , nodeId ) ;
saveRegistrationRequest ( req ) ;
saveRegistrationRequest ( req ) ;
saveRegistrationRequest ( new RegistrationRequest ( nodePriorToRegistration ,
saveRegistrationRequest ( req ) ;
saveRegistrationRequest ( new RegistrationRequest ( nodePriorToRegistration ,
saveRegistrationRequest ( new RegistrationRequest ( foundNode , RegistrationStatus . OK ,
public void saveRegistrationRequest ( RegistrationRequest request ) {
public void saveRegistrationRequest ( RegistrationRequest request ) ;
table . addColumn ( new Column ( "str" , true , Types . INTEGER , 0 , 0 ) ) ;
prefix = ( isNotBlank ( symmetricDialect . getPlatform ( ) . getDefaultSchema ( ) ) ? SymmetricUtils
prefix = ( isNotBlank ( symmetricDialect . getPlatform ( ) . getDefaultCatalog ( ) ) ? SymmetricUtils
prefix = ( isNotBlank ( symmetricDialect . getPlatform ( ) . getDefaultSchema ( ) ) ? SymmetricUtils
prefix = ( isNotBlank ( symmetricDialect . getPlatform ( ) . getDefaultCatalog ( ) ) ? SymmetricUtils
String prefix = ( table . getSchema ( ) ! = null ? table . getSchema ( )
return getTableFromCache ( getDefaultCatalog ( ) , getDefaultSchema ( ) , tableName , forceReread ) ;
protected DeleteAction deleteAction = DeleteAction . DEL_ROW ;
+ "str" ) ;
File serverPropertiesFile = new File ( workingDirectory . getParent ( ) + "str" , "str" ) ;
private String channelExpression = null ;
private IStagingManager stagingManager ;
this . stagingManager = stagingManager ;
IStagedResource stagingResource = stagingManager . find (
Types . VARCHAR , Types . TIMESTAMP , Types . DATE , Types . SMALLINT , Types . INTEGER , Types . DECIMAL } ;
clientServer . getDatabasePlatform ( ) . scrubSql ( String . format ( "str" , testTableA . getName ( ) ) ) , "str" , "str" ) ;
rootServer . getDatabasePlatform ( ) . scrubSql ( String . format ( "str" , testTableA . getName ( ) ) ) , "str" , "str" ) ;
clientServer . getDatabasePlatform ( ) . scrubSql ( String . format ( "str" , testTableA . getName ( ) ) ) , "str" , "str" ) ;
blobColumnTemplate = "str" ;
sqlReplacementTokens . put ( "str" , "str" + parameterService . getTablePrefix ( ) + "str" ) ;
ddl . append ( "str" ) ;
final int EXPECTED_VARCHAR_MAX = engine . getDatabasePlatform ( ) . getName ( ) . equals ( DatabaseNamesConstants . SQLITE ) ? 258 : 42 ;
if ( ! FileUtils . deleteQuietly ( newFile ) ) {
createStagingFile ( ) ;
( ( SimpleDBObjectMapper ) objectMapper ) . setDefaultDatabaseName ( parameterService . getString ( "str" , "str" ) ) ;
protected ColumnPolicy columnPolicy = ColumnPolicy . IMPLIED ;
log . info ( failureMessage . toString ( ) ) ;
getSql ( "str" ) ,
private int maxBatchSize = 10000 ;
private int maxBatchToSend = 100 ;
private boolean enabled = true ;
log . info (
appender . purgeOlderThan ( System . currentTimeMillis ( ) - parameterService . getLong ( ParameterConstants . PURGE_LOG_SUMMARY_MINUTES , 60 ) * 60000 ) ;
numberColumnTemplate = "str" ;
numberColumnTemplate = "str" ;
if ( name . equals ( DatabaseNamesConstants . DERBY ) | | name . equals ( DatabaseNamesConstants . MSSQL ) | | name . equals ( DatabaseNamesConstants . SQLANYWHERE ) ) {
final int EXPECTED_VARCHAR_MAX = engine . getDatabasePlatform ( ) . getName ( ) . equals ( DatabaseNamesConstants . SQLITE ) ? 257 : 42 ;
if ( columns [ i ] . isOfBinaryType ( ) & & parsedData [ i ] ! = null ) {
if ( batch . getBinaryEncoding ( ) . equals ( BinaryEncoding . BASE64 ) & & parsedData [ i ] ! = null ) {
final int EXPECTED_VARCHAR_MAX = engine . getDatabasePlatform ( ) . getName ( ) . equals ( DatabaseNamesConstants . SQLITE ) ? 254 : 41 ;
final int EXPECTED_VARCHAR_MAX = engine . getDatabasePlatform ( ) . getName ( ) . equals ( DatabaseNamesConstants . SQLITE ) ? 251 : 41 ;
String port = System . getProperty ( AppUtils . SYSPROP_PORT_NUMBER , "str" ) ;
data . getParsedData ( CsvData . ROW_DATA ) , "str" , "str" ,
data . getParsedData ( CsvData . ROW_DATA ) , "str" , "str" ,
"str" + ( fireTriggers ? "str" : "str" ) + "str" ;
throw new ProtocolException ( "str" , currentBatch . getNodeBatchId ( ) ) ;
throw new ProtocolException ( "str" , currentBatch . getNodeBatchId ( ) ) ;
. getBatch ( ) . getNodeBatchId ( ) , e ) ;
log . debug ( "str" , batch . getNodeBatchId ( ) ) ;
String targetBaseDir = ( ( triggerRouter . getTargetBaseDir ( ) = = null ) ? null : triggerRouter . getTargetBaseDir ( ) . replace ( "str" , "str" ) ) ;
targetBaseDir = ( ( fileTrigger . getBaseDir ( ) = = null ) ? null : fileTrigger . getBaseDir ( ) . replace ( "str" , "str" ) ) ;
String targetBaseDir = triggerRouter . getTargetBaseDir ( ) . replace ( "str" , "str" ) ;
targetBaseDir = fileTrigger . getBaseDir ( ) . replace ( "str" , "str" ) ;
String filePath = file . getParentFile ( ) . getPath ( ) . replace ( "str" , "str" ) ;
interpreter . set ( "str" , batchDir . getAbsolutePath ( ) . replace ( "str" , "str" ) ) ;
String dirName = file . getParentFile ( ) . getPath ( ) . replace ( "str" , "str" ) ;
fileTrigger . setBaseDir ( rs . getString ( "str" ) . replace ( "str" , "str" ) ) ;
fileTriggerRouter . setTargetBaseDir ( rs . getString ( "str" ) . replace ( "str" , "str" ) ) ;
fileSnapshot . setRelativeDir ( rs . getString ( "str" ) . replace ( "str" , "str" ) ) ;
this . sourceTable = table ;
throw new SqlException ( String . format ( "str" ,
if ( containsEmptyLobColumn ) {
printDefaultValue ( change . getNewDefaultValue ( ) , column . getMappedTypeCode ( ) , ddl ) ;
log . debug ( "str" ,
Assert . assertEquals ( 1 , template . queryForLong ( String . format ( "str" , delimiter , tableFromDatabase . getName ( ) , delimiter ) ) ) ;
Assert . assertEquals ( 1 , template . queryForLong ( String . format ( "str" , delimiter , tableFromDatabase . getName ( ) , delimiter ) ) ) ;
ddl . append ( change . getNewDefaultValue ( ) ) ;
super ( type , catalogName , null , tableName , keysColumns , columns ,
final int EXPECTED_VARCHAR_MAX = engine . getDatabasePlatform ( ) . getName ( ) . equals ( DatabaseNamesConstants . SQLITE ) ? 250 : 41 ;
private int initialLoadBatchCount = 1 ;
Assert . assertEquals ( output , 41 , StringUtils . countMatches ( output , "str" ) ) ;
log . warn ( "str" + DEFAULT_SERVER_PROPERTIES + "str" ) ;
log . warn ( "str" + DEFAULT_SERVER_PROPERTIES + "str" ) ;
final int EXPECTED_VARCHAR_MAX = engine . getDatabasePlatform ( ) . getName ( ) . equals ( DatabaseNamesConstants . SQLITE ) ? 246 : 41 ;
ParameterConstants . HEARTBEAT_SYNC_ON_PUSH_PERIOD_SEC ) ;
xmlNode . setHeartbeatInterval ( engine . getParameterService ( ) . getInt ( ParameterConstants . HEARTBEAT_SYNC_ON_PUSH_PERIOD_SEC ) ) ;
status . setHeartbeatInterval ( engine . getParameterService ( ) . getInt ( ParameterConstants . HEARTBEAT_SYNC_ON_PUSH_PERIOD_SEC ) ) ;
status . setHeartbeatInterval ( 600 ) ;
final int EXPECTED_VARCHAR_MAX = engine . getDatabasePlatform ( ) . getName ( ) . equals ( DatabaseNamesConstants . SQLITE ) ? 243 : 38 ;
long lastUpdateTime = file . lastModified ( ) ;
"str" , "str" , "str" , "str" , "str" ,
"str" , "str" , "str" ,
"str" , "str" , "str" , "str" ,
restService . putAcknowledgeBatch ( "str" , registrationInfo . getNodePassword ( ) , batchResults ) ;
restService . putAcknowledgeBatch ( "str" , registrationInfo . getNodePassword ( ) , batchResults ) ;
restService . putAcknowledgeBatch ( "str" , registrationInfo . getNodePassword ( ) , batchResults ) ;
Assert . assertFalse ( pullFiles ( ) ) ;
Assert . assertTrue ( pullFiles ( ) ) ;
if ( ( file . getLastEventType ( ) = = LastEventType . MODIFY | |
Assert . assertEquals ( output , 40 , StringUtils . countMatches ( output , "str" ) ) ;
numberColumnTemplate = "str" ;
Assert . assertEquals ( 38 ,
indexColumn . setName ( alterCaseToMatchDatabaseDefaultCase ( indexColumn . getName ( ) ) ) ;
return me ! = null & & root ! = null & & root . getNumberOfLinksAwayFromRoot ( nodeThatCouldBeRoutedTo . getNodeId ( ) ) = = root
protected void createRequiredDatabaseObjects ( ) {
protected void dropRequiredDatabaseObjects ( ) {
if ( ( StringUtils . isBlank ( schemaCatalog ) | | StringUtils . isBlank ( catalog ) ) & & ! schemas . contains ( schema ) ) {
this . defaultChannels . add ( new Channel ( Constants . CHANNEL_CONFIG , 0 , 2000 , 100 , true , 0 , true ) ) ;
if ( ! table . getName ( ) . toLowerCase ( ) . startsWith ( symmetricEngine . getTablePrefix ( ) + "str" ) ) {
assertNumberOfLinesThatStartWith ( 65 , "str" , content , false , true ) ;
@ManagedOperation ( description = "str" )
"str" , keyValue [ 0 ] , keyValue [ 1 ] ) ;
log . warn ( "str" ,
log . debug ( "str" ,
log . debug ( "str" ,
log . debug ( "str" ,
log . debug ( "str" ,
if ( purgedMemSize < 1000 ) {
primaryKeyViolationCodes = new int [ ] { 335544665 , 335544349 } ;
primaryKeyViolationCodes = new int [ ] { 335544665 , 335544349 } ;
sqlReplacementTokens . put ( "str" , "str" ) ;
log . info ( "str" ,
if ( getServer ( ) . getSymmetricDialect ( ) . getPlatform ( ) . getDatabaseInfo ( ) . isBlankCharColumnSpacePadded ( ) ) {
for ( int i = 0 ; i < sourceColumnNames . length & & i < originalValues . length ; i + + ) {
return new UniqueKeyException ( ex ) ;
logSql ( sql , args ) ;
int totalUpdateCount = 0 ;
if ( ref . getLocalColumnName ( ) . equalsIgnoreCase ( column . getName ( ) ) ) {
private static final String TEST_SIMPLE_TRANSFORM_RESULTS = "str" ;
String [ ] columnValues = getRowData ( data ) ;
Assert . assertEquals ( 29 ,
log . debug ( "str" , cipher . getAlgorithm ( ) , cipher . getProvider ( )
public static ISecurityService createSecurityService ( TypedProperties properties ) {
long rowCount = sqlTemplate . update ( getSql ( "str" ) ) ;
public enum Compatible { DB2 , DERBY , FIREBIRD , GREENPLUM , H2 , HSQLDB , HSQLDB2 , INFORMIX , INTERBASE , MSSQL , MYSQL , ORACLE , POSTGRES , SYBASE } ;
assertEquals ( batch . getStatus ( ) , IncomingBatch . Status . OK , "str" ) ;
assertEquals ( batch . getStatus ( ) , IncomingBatch . Status . OK , "str" ) ;
( ( ParameterService ) engine . getParameterService ( ) ) . setDatabaseHasBeenInitialized ( false ) ;
private boolean databaseHasBeenInitialized = false ;
databaseHasBeenInitialized = true ;
if ( databaseHasBeenInitialized ) {
Assert . assertEquals ( getDbDialect ( ) . supportsTransactionId ( ) ? 1 : 510 , batches . getBatches ( )
Assert . assertEquals ( getDbDialect ( ) . supportsTransactionId ( ) ? 1 : 510 , batches . getBatches ( )
log . debug ( "str" + oldValue + "str" + newValue + "str" + column . getTransformExpression ( ) ) ;
write ( model , output , null ) ;
. listIterator ( triggerHistories . size ( ) ) ; triggerHistoryIterator . hasPrevious ( ) ; ) {
protected boolean registerEngine = true ;
propertiesFile ! = null ? propertiesFile . getCanonicalPath ( ) : null , true , noNio , noDirectBuffer ) ;
log . info ( "str" ) ;
log . info ( "str" ) ;
private String conflictId ;
incomingError . isResolveIgnore ( ) , incomingError . getBatchId ( ) ,
failureMessage . append ( "str" ) ;
failureMessage . append ( "str" ) ;
failureMessage . append ( "str" ) ;
obj . isBitValue ( ) ? 1 : 0 , obj . getBigIntValue ( ) , obj . getDecimalValue ( ) ,
obj . getTimestampValue ( ) , obj . getDateValue ( ) , obj . isBitValue ( ) ? 1 : 0 ,
} catch ( ConnectionRejectedException ex ) {
} catch ( AuthenticationException ex ) {
} catch ( SyncDisabledException ex ) {
} catch ( RegistrationRequiredException ex ) {
log . warn ( "str" ) ;
log . warn ( "str" ) ;
log . warn ( "str" ) ;
log . warn ( "str" ) ;
getDbDialect ( ) . supportsTransactionId ( ) ? 1 : 705 ,
Assert . assertEquals ( getDbDialect ( ) . supportsTransactionId ( ) ? 1 : 530 , batches . getBatches ( )
log . error ( "str" , ex ) ;
log . error ( "str" , ex ) ;
ps = conn . prepareStatement ( sql + "str" + column ) ;
return getConstraintName ( "str" , table , secondPart , null ) ;
return getConstraintName ( "str" , table , secondPart , null ) ;
return "str" + sequenceName + "str" ;
public void syncTriggers ( StringBuilder sqlBuffer , boolean genAlways ) {
updateOrCreateDatabaseTriggers ( triggersForCurrentNode , sqlBuffer , genAlways ) ;
boolean genAlways ) {
} else if ( genAlways ) {
transaction . queryForObject (
generateWar ( line . getOptionValue ( OPTION_CREATE_WAR ) , line . getOptionValue ( OPTION_PROPERTIES_FILE ) ) ;
if ( ! StringUtils . isBlank ( routerExpression ) ) {
ps . setTimestamp ( paramIndex , ( java . sql . Timestamp ) inValue , Calendar . getInstance ( ) ) ;
new java . sql . Timestamp ( ( ( java . util . Date ) inValue ) . getTime ( ) ) , Calendar . getInstance ( ) ) ;
ps . setTimestamp ( paramIndex , ( java . sql . Timestamp ) inValue , Calendar . getInstance ( ) ) ;
new java . sql . Timestamp ( ( ( java . util . Date ) inValue ) . getTime ( ) ) , Calendar . getInstance ( ) ) ;
long lastDataId = ( Long ) jdbcTemplate . query ( sqlProvider . getSql ( "str" ) ,
StringUtils . isBlank ( routerId ) ? Constants . UNKNOWN_ROUTER_ID : routerId } ,
AppUtils . getHostName ( ) , gap . getStartId ( ) , gap . getEndId ( ) } , new int [ ] {
if ( 0 > = jdbcTemplate . update ( getSql ( "str" ) , new Object [ ] {
jdbcTemplate . update ( getSql ( "str" ) , new Object [ ] { dataRef . getRefDataId ( ) ,
return ( Date ) jdbcTemplate . queryForObject ( getSql ( "str" ) ,
return ( Date ) jdbcTemplate . queryForObject ( getSql ( "str" ) ,
triggerRouter . getRouter ( ) . getRouterId ( ) } ,
triggerRouter . getLastUpdateTime ( ) , triggerRouter . getTrigger ( ) . getTriggerId ( ) ,
new int [ ] { Types . CHAR , Types . NUMERIC , Types . NUMERIC , Types . BIGINT ,
Types . BIGINT , Types . BIGINT , Types . VARCHAR , Types . NUMERIC ,
Types . NUMERIC } ) ;
new Object [ ] { batchId } , new int [ ] { Types . NUMERIC } , new OutgoingBatchMapper ( ) ) ;
aliasedPrimaryKeyJoin ( oldTriggerValue , newTriggerValue , columns . length = = 0 ? table . getColumns ( ) : columns ) , ddl ) ;
aliasedPrimaryKeyJoin ( ORIG_TABLE_ALIAS , newTriggerValue , columns . length = = 0 ? table . getColumns ( ) : columns ) , ddl ) ;
String tableName = tables . get ( j ) ;
if ( cause ! = null & & ! cause . equals ( ex ) ) {
_log . debug ( "str"
"str" , quoteString ,
if ( ext instanceof IColumnTransform ) {
getJdbcTemplate ( ) . update ( "str" , 0 ) ;
tableTemplate . getTable ( ) . toVerboseString ( ) ,
. findOutgoingBatch ( outgoingBatch . getBatchId ( ) ) ;
HttpServletRequest httpRequest = ( HttpServletRequest ) req ;
if ( e instanceof IOException ) {
return jdbcTemplate . query ( column . getTransformExpression ( ) , new SingleColumnRowMapper < String > ( String . class ) , sourceValues ) ;
Assert . assertEquals ( getDbDialect ( ) . supportsTransactionId ( ) ? 1 : 530 , batches . getBatches ( )
Assert . assertEquals ( getDbDialect ( ) . supportsTransactionId ( ) ? 1 : 530 , batches . getBatches ( )
public void inactivateTriggerHistory ( TriggerHistory history ) {
newHistRecord . getNameForUpdateTrigger ( ) , newHistRecord . getSourceSchemaName ( ) ,
Types . VARCHAR , Types . VARCHAR , Types . CHAR , Types . VARCHAR , Types . VARCHAR ,
return shortenName ( result . toString ( ) , getMaxConstraintNameLength ( ) ) ;
printIdentifier ( getConstraintName ( null , table , column . getName ( ) , "str" ) ) ;
result . append ( getDelimitedIdentifier ( getConstraintName ( null , table , columns [ idx ] . getName ( ) , "str" ) ) ) ;
this . tableName = tableName ;
String . format (
public void writeCopyDataStatement ( Table sourceTable , Table targetTable ) throws IOException
public void writeCopyDataStatement ( Table sourceTable , Table targetTable ) throws IOException
boolean isSelfConfigurable = isRegistrationServer & &
if ( node = = null & & StringUtils . isBlank ( parameterService . getRegistrationUrl ( ) )
recordStatistics = parameterService . is ( ParameterConstants . STATISTIC_RECORD_ENABLE , false ) ;
private void selectEventDataToExtract ( final IExtractListener handler , final OutgoingBatch batch , final BufferedWriter keepAliveWriter ) {
handler . dataExtracted ( data , routerId ) ;
if ( _log . isDebugEnabled ( ) )
_log . debug ( "str" + targetTable . getName ( ) + "str" ) ;
if ( _log . isDebugEnabled ( ) )
_log . debug ( "str" + sourceTable . getName ( ) + "str" ) ;
if ( _log . isDebugEnabled ( ) )
_log . debug ( "str" + sourceFk + "str" + sourceTable . getName ( ) ) ;
if ( _log . isDebugEnabled ( ) )
_log . debug ( "str" + targetFk + "str" + sourceTable . getName ( ) ) ;
if ( _log . isDebugEnabled ( ) )
_log . debug ( "str" + sourceIndex . getName ( ) + "str" + sourceTable . getName ( ) ) ;
if ( _log . isDebugEnabled ( ) )
_log . debug ( "str" + targetIndex . getName ( ) + "str" + sourceTable . getName ( ) ) ;
if ( _log . isDebugEnabled ( ) )
_log . debug ( "str" + targetColumn . getName ( ) + "str" + sourceTable . getName ( ) ) ;
if ( _log . isDebugEnabled ( ) )
_log . debug ( "str" + sourceTable . getName ( ) ) ;
if ( _log . isDebugEnabled ( ) )
_log . debug ( "str" + sourceTable . getName ( ) ) ;
if ( _log . isDebugEnabled ( ) )
_log . debug ( "str" + sourceTable . getName ( ) + "str" ) ;
if ( _log . isDebugEnabled ( ) )
_log . debug ( "str" + sourceColumn . getName ( ) + "str" + sourceTable . getName ( ) ) ;
if ( batch . isRetry ( ) ) {
context . getHistoryRecordsWritten ( ) . add ( triggerHistId ) ;
context . getHistoryRecordsWritten ( ) . add ( historyId ) ;
context . getHistoryRecordsWritten ( ) . add ( historyId ) ;
context . getHistoryRecordsWritten ( ) . add ( historyId ) ;
jdbcTemplate . update ( getSql ( "str" ) , triggerRouter . getTrigger ( ) . getTriggerId ( ) ,
protected int maxIdleTime = 7200000 ;
Collection < File > files = ( Collection < File > ) FileUtils . listFiles ( new File ( "str" ) ,
sql = AppUtils . replace ( "str" , triggerRouter . qualifiedSourceTablePrefix ( ) , sql ) ;
final boolean noTransactionInProgress = dbDialect . supportsTransactionViews ( ) & & ! dbDialect . areDatabaseTransactionsPendingSince ( dbDialect . getDatabaseTime ( ) ) ;
while ( memQueue . size ( ) > 0 & & reading ) {
return ( Version . parseVersion ( symmetricVersion ) [ 0 ] > 1 ) ;
final String INTERPRETER_KEY = String . format ( "str" , hashCode ( ) ) ;
return AppUtils . find ( Constants . ROUTER_SERVICE , this ) ;
closeWriter ( true ) ;
private void closeWriter ( boolean closeQuietly ) throws IOException {
private static final String SYM_TEMP_SUFFIX = "str" ;
File tmp = File . createTempFile ( "str" , SYM_TEMP_SUFFIX ) ;
protected Map < String , ISyncUrlExtension > extensionSyncUrlHandlers = new HashMap < String , ISyncUrlExtension > ( ) ;
Assert . assertEquals ( getDbDialect ( ) . supportsTransactionId ( ) ? 1 : 510 , batches . getBatches ( ) . size ( ) ) ;
Assert . assertEquals ( getDbDialect ( ) . supportsTransactionId ( ) ? 1 : 100 , countBatchesForChannel ( getOutgoingBatchService ( ) . getOutgoingBatches ( NODE_GROUP_NODE_1 ) , testChannel ) ) ;
Assert . assertEquals ( getDbDialect ( ) . supportsTransactionId ( ) ? 1 : 510 , batches . getBatches ( ) . size ( ) ) ;
return getWithHostName ( ParameterConstants . EXTERNAL_ID ) ;
public static final int MAX_SYMMETRIC_SUPPORTED_TRIGGER_SIZE = 50 ;
+ getSql ( "str" ) + "str" + tablePrefix . toUpperCase ( ) + "str" ,
StringBuilder b = new StringBuilder ( "str" ) ;
b . append ( "str" ) . append ( column . getName ( ) ) . append ( "str" ) ;
public static final int MAX_SYMMETRIC_SUPPORTED_TRIGGER_SIZE = 30 ;
return max < MAX_SYMMETRIC_SUPPORTED_TRIGGER_SIZE & & max > 0 ? max : MAX_SYMMETRIC_SUPPORTED_TRIGGER_SIZE ;
log . error ( "str" , remote . getNodeId ( ) , remote . getSyncURL ( ) ) ;
log . debug ( "str" , servletEntry . getKey ( ) ) ;
log . debug ( "str" , beanName , ext . getClass ( ) . getSimpleName ( ) ) ;
template . update ( getSql ( "str" ) , new Object [ ] { dataId , batchId , StringUtils . isBlank ( routerId ) ? Constants . UNKNOWN_ROUTER_ID : routerId } , new int [ ] {
public List < OutgoingBatch > getOutgoingBatchErrors ( int maxRows ) ;
public List < OutgoingBatch > getOutgoingBatchErrors ( int maxRows ) {
return getOutgoingBatchService ( ) . getOutgoingBatchErrors ( MAX_ERRORS ) ;
public List < OutgoingBatch > getOutgoingBatchErrors ( int maxRows ) {
if ( lastDataId = = - 1 | | lastDataId + 1 = = dataId | | lastDataId = = dataId ) {
return AbstractDbDialect . class . getResource ( "str" ) ;
newTriggerHist . setNameForUpdateTrigger ( dbDialect . getTriggerName ( DataEventType . UPDATE , tablePrefix ,
newTriggerHist . setNameForDeleteTrigger ( dbDialect . getTriggerName ( DataEventType . DELETE , tablePrefix ,
String csvString = getNextDataRow ( ) ;
String csvString = getNextDataRow ( ) ;
String csvString = getNextDataRow ( ) ;
String csvString = getNextDataRow ( ) ;
ackService . ack ( batch . getBatchInfo ( ) ) ;
} else if ( type = = Types . BLOB | | type = = Types . LONGVARBINARY | | type = = Types . BINARY | | type = = Types . VARBINARY ) {
return StringUtils . isBlank ( targetVersion ) ;
XmlPublisherFilterTest . class , AdditiveDataLoaderFilterTest . class , CleanupTest . class } )
if ( ! StringUtils . isBlank ( condition ) ) {
if ( ! StringUtils . isBlank ( condition ) ) {
if ( ! StringUtils . isBlank ( condition ) ) {
if ( ! StringUtils . isBlank ( condition ) ) {
if ( ! StringUtils . isBlank ( condition ) ) {
logger . warn ( ErrorConstants . COULD_NOT_CONNECT_TO_TRANSPORT + "str" + remote . getSyncURL ( ) = = null ? parameterService . getRegistrationUrl ( ) : remote . getSyncURL ( ) ) ;
return getLanguageConnection ( ) . getDbname ( ) + "str" + getLanguageConnection ( ) . getInstanceNumber ( ) ;
logger . info ( "str" + hist . getTriggerNameForDmlType ( dml ) + "str"
pf . createTables ( db , false , true ) ;
static final String SYNC_TRIGGERS_DISABLED_USER_VARIABLE = "str" ;
static final String SYNC_TRIGGERS_DISABLED_NODE_VARIABLE = "str" ;
private final String MSG_CACHE = "str" + hashCode ( ) ;
StringBuilder msgCache = ( StringBuilder ) cache . get ( MSG_CACHE ) ;
cache . put ( MSG_CACHE , msgCache ) ;
StringBuilder msgCache = ( StringBuilder ) cache . get ( MSG_CACHE ) ;
ctx . getContextCache ( ) . remove ( MSG_CACHE ) ;
this . count + = count ;
this . count + = count ;
this . count + = count ;
logger . debug ( "str" + xml ) ;
new Object [ ] { triggerName . toLowerCase ( ) , tableName . toLowerCase ( ) , schema = = null ? defaultSchema : schema } ) > 0 ;
new Object [ ] { triggerName . toLowerCase ( ) , tableName . toLowerCase ( ) , schema } ) > 0 ;
jdbcTemplate . update ( "str" + triggerName + "str" + schemaName + tableName ) ;
if ( node ! = null & & ! StringUtils . isBlank ( node . getSymmetricVersion ( ) ) & & ! node . getSymmetricVersion ( ) . equals ( "str" ) ) {
Assert . assertEquals ( manager . getReservationCount ( "str" ) , 2 ) ;
Assert . assertEquals ( manager . getReservationCount ( "str" ) , 2 ) ;
Assert . assertEquals ( manager . getReservationCount ( "str" ) , 2 ) ;
Assert . assertEquals ( manager . getReservationCount ( "str" ) , 0 ) ;
builtinFilter . doFilter ( request , response , this ) ;
filter . doFilter ( request , response , this ) ;
final static String EXPECTED_INSERT1_CSV_ENDSWITH = "str" ;
final static String EXPECTED_INSERT2_CSV_ENDSWITH = "str" ;
Assert . assertEquals ( history . getByteCount ( ) , 317 , "str" + printDatabase ( ) ) ;
Assert . assertEquals ( history . getByteCount ( ) , 374 , "str" + printDatabase ( ) ) ;
static final String insertTestTriggerTableSql = "str" ;
Data data = new Data ( history . getSourceTableName ( ) , DataEventType . RELOAD , overrideInitialLoadSelect ,
keyValues [ i ] = allValues [ table . getColumnIndex ( keys [ i ] ) ] ;
audit . getSourceTableName ( ) , null , audit ) , ctxCopy ) ;
return "str" + sequenceName + "str" ;
return "str" + sequenceName + "str" ;
long batchId = dbDialect . insertWithGeneratedKey ( createBatchSql , "str" ,
return dbDialect . insertWithGeneratedKey ( insertIntoDataSql , "str" ,
+ "str" , ex ) ;
ddl = replace ( "str" , trigger . getDefaultTargetTableName ( ) , ddl ) ;
setTable ( tokens [ 1 ] . toLowerCase ( ) ) ;
this . columnFilters ! = null ? this . columnFilters . get ( tableName ) : null ) ) ;
dbDialect . cleanupAfterDataLoad ( context . getTableTemplate ( ) . getTable ( ) ) ;
logger . warn ( "str" + groupId
Assert . assertEquals ( node . getDatabaseVersion ( ) , "str" , "str" ) ;
Assert . assertEquals ( node . getDatabaseVersion ( ) , "str" , "str" ) ;
. debug ( "str" ) ;
return s . trim ( ) . endsWith ( "str" + delimiter ) ;
+ "str" ) ;
Assert . assertEquals ( node . getDatabaseVersion ( ) , "str" , "str" ) ;
Assert . assertEquals ( node . getDatabaseVersion ( ) , "str" , "str" ) ;
mStationDataSheetMimeType . setContentDescription ( mActivity . getString ( R . string . player_sheet_p_no_data ) ) ;
mStationDataSheetChannelCount . setContentDescription ( mActivity . getString ( R . string . player_sheet_p_no_data ) ) ;
mStationDataSheetSampleRate . setContentDescription ( mActivity . getString ( R . string . player_sheet_p_no_data ) ) ;
if ( fetchResults ! = null & & fetchResults . getInt ( RESULT_FETCH_STATUS ) = = CONTAINS_NO_STREAM ) {
mStationFetchResults . putInt ( RESULT_FETCH_STATUS , CONTAINS_ONE_STREAM ) ;
mStationFetchResults . putInt ( RESULT_FETCH_STATUS , CONTAINS_NO_STREAM ) ;
mStationFetchResults . putInt ( RESULT_FETCH_STATUS , CONTAINS_NO_STREAM ) ;
mStationFetchResults . putInt ( RESULT_FETCH_STATUS , CONTAINS_ONE_STREAM ) ;
mStationFetchResults . putInt ( RESULT_FETCH_STATUS , CONTAINS_NO_STREAM ) ;
String SHOUTCAST_STREAM_TITLE_HEADER = "str" ;
private final static boolean mTesting = false ;
stopPlayback ( false ) ;
if ( mStationIDSelected > = 0 & & mStationIDSelected < mStationList . size ( ) ) {
if ( mTwoPane & & mStationIDSelected > = 0 & & mStationIDSelected < mStationList . size ( ) ) {
private static final String EXTRA_STATION_ID = "str" ;
iconIntent . putExtra ( EXTRA_STATION_ID , mStationID ) ;
shortcutIntent . putExtra ( EXTRA_STATION_ID , mStationID ) ;
sb . append ( mActivity . getResources ( ) . getString ( R . string . dialog_error_message_download_external_storage ) ) ;
sb . append ( mActivity . getResources ( ) . getString ( R . string . dialog_error_message_download_station_url ) ) ;
sb . append ( mActivity . getResources ( ) . getString ( R . string . dialog_error_message_download_hint_m3u ) ) ;
sb . append ( mActivity . getResources ( ) . getString ( R . string . dialog_error_message_download_file_content ) ) ;
stationImageSmall = BitmapFactory . decodeResource ( mContext . getResources ( ) , R . drawable . ic_notesymbol ) ;
sb . append ( "str" ) ;
attributes = SecurityConfig . createList ( "str" , "str" , "str" ) ;
public void onAnimationEnd ( Animator animation ) {
Constants . SERVICE_RANKING + "str"
final boolean writingOriginalData ,
public NumericDimensionField < ? extends CommonIndexValue > [ ] getDimensions ( ) {
( short ) 1400 ,
( short ) 1401 ,
} , required = true , description = "str" )
public static final String NAMESPACE = "str" ;
public static String promptAndReadValue (
public static String promptAndReadPassword (
catch ( Exception e ) {
catch ( final Exception e ) {
& & ! internalTypeNameProvider . typeNameMatches ( input . getAdapterId ( ) . getString ( ) ) ) {
if ( ! option . isOptional ( ) & & ( configOptions . get ( option . getName ( ) ) . equals ( "str" ) ) ) {
if ( ! option . isOptional ( ) & & ( ! configOptions . get ( option . getName ( ) ) . equals ( "str" ) ) ) {
limit = ( max ! = null & & max . longValue ( ) < Integer . MAX_VALUE ) ? max . intValue ( ) : null ;
runtime = jmode . handleTweak ( sketch , listener , JavaEditor . this ) ;
public void highlight ( Problem p ) {
highlight ( p . getTabIndex ( ) , p . getStartOffset ( ) , p . getStopOffset ( ) ) ;
bufPolyVertex = new VertexBuffer ( this , PGL . ARRAY_BUFFER , 4 , PGL . SIZEOF_FLOAT ) ;
while ( conn . getResponseCode ( ) = = 302 | | conn . getResponseCode ( ) = = 301 ) {
Throwable t , boolean fatal ) {
throw new RuntimeException ( "str" + join ( args , "str" ) , e ) ;
protected static final int MAX_BUFFER_SIZE = 1 < < 27 ;
int readBufferSize = 1 < < 16 ;
List < String > installedLibList = new ArrayList < > ( ) ;
"str" , displayNum ) ;
if ( pch = = "str" & & ch = = "str" & & ( i - blockStart ) > 0 ) {
importSuggestions = new HashMap < > ( ) ;
keyPressed = ( keyPressedCount > 0 ) ;
pw . setPixels ( 0 , y , source . pixelWidth , 1 , argbFormat , tintedTemp , 0 , source . pixelWidth ) ;
tintedTemp = new int [ source . pixelWidth ] ;
importedLibraries = new ArrayList < > ( ) ;
protected List < UpdatableAction > editMenuUpdatable = new ArrayList < > ( ) ;
List < JMenuItem > menuList = new ArrayList < > ( ) ;
final List < Character > taken = new ArrayList < > ( menu . length ) ;
final List < Character > banned = new ArrayList < > ( ) ;
ArrayList < JMenuItem > items = new ArrayList < > ( ) ;
iconImages = new ArrayList < > ( ) ;
i + + ;
InputStream input = createInputRaw ( filename ) ;
InputStream input = new BufferedInputStream ( createInputRaw ( filename ) ) ;
sansBoldFont = createFont ( "str" , size ) ;
static final int FILTER_WIDTH = Toolkit . zoom ( 180 ) ;
static final int BUTTON_WIDTH = Toolkit . zoom ( 150 ) ;
static final int BUTTON_WIDTH = Toolkit . zoom ( 100 ) ;
rightPane . setMinimumSize ( new Dimension ( BUTTON_WIDTH , 1 ) ) ;
barButtonCardPane . setMinimumSize ( new Dimension ( BUTTON_WIDTH , 1 ) ) ;
new Dimension ( BUTTON_WIDTH ,
installButtonDimensions . width = BUTTON_WIDTH ;
new Dimension ( BUTTON_WIDTH ,
rightPane . setMinimumSize ( new Dimension ( BUTTON_WIDTH , 1 ) ) ;
progressDim . width = BUTTON_WIDTH ;
Platform . getJavaPath ( ) . replaceAll ( "str" , "str" ) +
} else if ( code = = 10 | | code = = 13 ) {
return thread = = null | | ! thread . isAlive ( ) ;
Pattern . compile ( String . format ( GLSL_FN_REGEX , "str" ) ) ,
Pattern . compile ( String . format ( GLSL_FN_REGEX , "str" ) )
"str" , e ) ;
Pattern . compile ( "str" ) ;
public Object get ( String key ) {
public JSONObject put ( String key , Object value ) {
public JSONObject putOnce ( String key , Object value ) {
public Object get ( int index ) {
matrix . preApply ( transform ) ;
addEdge ( i0 , i1 , true , false ) ;
addEdge ( i2 , i0 , false , false ) ;
addEdge ( i0 , i1 , true , false ) ;
addEdge ( i2 , i0 , false , false ) ;
addEdge ( i0 , i1 , true , false ) ;
addEdge ( i2 , i0 , false , false ) ;
addEdge ( i0 , i1 , true , false ) ;
addEdge ( i0 , i1 , true , false ) ;
items . append ( JSONObject . quote ( keys [ i ] ) + "str" + values [ i ] ) ;
Platform . deleteFile ( targetFolder ) ;
private int lastX ;
loaderLabel = new JLabel ( Toolkit . getLibIcon ( "str" ) ) ;
final int mask = ActionEvent . SHIFT_MASK | ActionEvent . ALT_MASK ;
} else if ( ( modifiers & ActionEvent . SHIFT_MASK ) ! = 0 ) {
} else if ( ( modifiers & ActionEvent . ALT_MASK ) ! = 0 ) {
handleStep ( ActionEvent . SHIFT_MASK ) ;
handleStep ( ActionEvent . ALT_MASK ) ;
protected Set < ReferenceType > classes = new HashSet < > ( ) ;
0.5f * cosLUT [ ( int ) val ] * transformScale ( ) * strokeWeight ;
0.5f * sinLUT [ ( int ) val ] * transformScale ( ) * strokeWeight ;
0.5f * QUAD_POINT_SIGNS [ k ] [ 0 ] * transformScale ( ) * strokeWeight ;
0.5f * QUAD_POINT_SIGNS [ k ] [ 1 ] * transformScale ( ) * strokeWeight ;
if ( ! exportApplication ( folder , platform , "str" , embedJava & & Platform . getNativeBits ( ) = = 64 & & "str" . equals ( Platform . getNativeArch ( ) ) ) ) {
if ( ee . getMessage ( ) ! = null ) {
if ( insideSettings ( "str" , width , height , "str" + renderer + "str" ) ) {
animator = new FPSAnimator ( window , 60 ) ;
ptexture = new Texture ( this , pixelWidth , pixelHeight , texture . getParameters ( ) ) ;
out . println ( "str" ) ;
if ( ! Character . isJavaIdentifierPart ( lastChar ) ) {
} else if ( lastChar = = "str" ) {
} else if ( ! Character . isJavaIdentifierPart ( lastChar ) ) {
switch ( lineText . charAt ( i ) ) {
switch ( lineText . charAt ( i ) ) {
if ( Character . isJavaIdentifierPart ( currChar ) ) {
} else if ( Character . isWhitespace ( currChar ) ) {
if ( phrase . length ( ) = = 0 | | Character . isDigit ( phrase . charAt ( 0 ) ) ) {
public boolean save ( String filename ) {
public AsyncImageSaver ( ) { }
public void dispose ( ) {
public boolean hasAvailableTarget ( ) {
public PImage getAvailableTarget ( int requestedWidth , int requestedHeight ,
public void returnUnusedTarget ( PImage target ) {
public void saveTargetAsync ( final PGraphics renderer , final PImage target ,
public void run ( ) {
setLayout ( layout ) ;
. addGap ( 12 ) ) ;
"str" , t , true ) ;
HashMap < String , String [ ] > exportList ;
} else if ( is2D ( ) & & len ! = 2 ) {
} else if ( is2D ( ) & & len ! = 4 ) {
"str" , "str" , "str" , "str"
"str" , "str" ,
"str" , "str" ,
int len = f * w * f * h ;
keyStroke = KeyStroke . getKeyStroke ( KeyEvent . VK_D , Toolkit . SHORTCUT_SHIFT_KEY_MASK ) ;
for ( int j = 0 ; j < pg . curveDetail - 1 ; j + + ) {
return ( ( maxRevision = = 0 | | versionNum < = maxRevision ) & & versionNum > = minRevision ) ;
String portStr = Preferences . get ( PREF_TWEAK_PORT ) ;
Preferences . set ( PREF_TWEAK_PORT , "str" ) ;
port = Preferences . getInteger ( PREF_TWEAK_PORT ) ;
List < ColorMode > colorModes ;
image = gc . createCompatibleImage ( wide , high , Transparency . TRANSLUCENT ) ;
final JCheckBox presentButton = new JCheckBox ( Language . text ( "str" ) ) ;
} catch ( Throwable t ) {
"str" , t , true ) ;
if ( extraStatements . size ( ) ! = 0 ) {
if ( extraStatements . size ( ) ! = 0 ) {
if ( extraStatements . size ( ) ! = 0 ) {
static final int HINT_COUNT = 10 ;
"str" , displayNum ) ;
System . err . format ( "str" , i + 1 , monitors . get ( i ) ) ;
"str" , displayNum ) ;
System . err . format ( "str" , ( i + 1 ) , devices [ i ] ) ;
final int [ ] sizes = { 16 , 32 , 48 , 64 , 128 , 256 , 512 } ;
PGraphicsOpenGL . class . getResource ( "str" ) ;
PGraphicsOpenGL . class . getResource ( "str" ) ;
g . setFont ( new Font ( "str" , Font . PLAIN , 10 ) ) ;
g . drawString ( Base . getVersionName ( ) , 90 , 29 ) ;
new IllegalArgumentException ( "str" ) . printStackTrace ( ) ;
box . add ( selectorBox . getComponent ( ) ) ;
box . add ( selectorSlider . getComponent ( ) , BorderLayout . CENTER ) ;
newHorizontalOffset = Math . max ( 0 , horizontalOffset - x + width + 5 ) ;
if ( runningX + wordWidth > = boxWidth ) {
return fboLayerInUse ? COLOR_ATTACHMENT0 : BACK ;
if ( ( newStart < 0 | | newEnd > getDocumentLength ( ) ) & & start ! = end )
result = "str" + args [ 0 ] + "str" ;
result = "str" + args [ 0 ] + "str" ;
result = "str" + args [ 0 ] + "str" + args [ 1 ] + "str" ;
dstPixels [ x ] = blendColor ( alphaFiller | dstPixels [ x ] , srcPixels [ x ] , mode ) ;
gl . glCopyTexSubImage2D ( target , level , x , y , xOffset , yOffset , width , height ) ;
GL11 . glCopyTexSubImage2D ( target , level , x , y , xOffset , yOffset , width , height ) ;
public void insert ( int index , float [ ] values ) {
public void insert ( int index , FloatList list ) {
return methCla . soundFilePlayMono ( rate , pos , amp , add , loop , path , dur , cue ) ;
} else if ( vertFilename = = null | | vertFilename . equals ( "str" ) ) {
if ( keyChar = = KeyEvent . VK_ENTER | |
hideSuggestion ( ) ;
private final static long errorCheckInterval = 500 ;
public static boolean DEBUG = true ;
jdkPath = new File ( dotAppFolder , "str" + jdkFolderName ) . getAbsolutePath ( ) ;
intData [ row ] = ( s = = null ) ? missingInt : PApplet . parseInt ( s , missingInt ) ;
longData [ row ] = ( s = = null ) ? missingLong : Long . parseLong ( s ) ;
floatData [ row ] = ( s = = null ) ? missingFloat : PApplet . parseFloat ( s , missingFloat ) ;
doubleData [ row ] = ( s = = null ) ? missingDouble : Double . parseDouble ( s ) ;
if ( ! columnCategories [ col ] . hasCategory ( index ) ) {
& & ( ! ExperimentalMode . ccTriggerEnabled | | suggestion . isVisible ( ) ) ) {
result = "str" ;
result = "str" ;
public void mouseReleased ( MouseEvent e ) {
config . setString ( "str" , "str" + jarList [ 0 ] ) ;
clazzPath . addChild ( "str" ) . setContent ( "str" + jarName ) ;
File buildFile = new File ( destFolder , "str" ) ;
public String sketchPath ;
installProgressBar . setIndeterminate ( false ) ;
if ( canvasAWT ! = null | | canvasNEWT ! = null ) {
pw . print ( PApplet . join ( runOptions . toArray ( new String [ 0 ] ) , "str" ) + "str" ) ;
static final String noJavaArg = "str" ;
static public void main ( String [ ] args ) {
boolean embedJava = true ;
"str" , false ) ;
line + "str" + column + "str" +
private JComboBox < ? > compressionBox ;
Transferable t = transferables . get ( flavor ) ;
return flavors . toArray ( new DataFlavor [ transferables . size ( ) ] ) ;
System . arraycopy ( columns [ col ] , insert , intTemp , insert + 1 , rowCount - insert ) ;
System . arraycopy ( columns [ col ] , insert , longTemp , insert + 1 , rowCount - insert ) ;
System . arraycopy ( columns [ col ] , insert , floatTemp , insert + 1 , rowCount - insert ) ;
System . arraycopy ( columns [ col ] , insert , doubleTemp , insert + 1 , rowCount - insert ) ;
System . arraycopy ( columns [ col ] , insert , stringTemp , insert + 1 , rowCount - insert ) ;
( org . apache . tools . ant . types . Path ) classPathRef . getReferencedObject ( getProject ( ) ) ;
return getContentFile ( "str" ) . getAbsolutePath ( ) ;
return getContentFile ( "str" ) . getAbsolutePath ( ) ;
String [ ] optionList = trim ( split ( optionStr , "str" ) ) ;
opts = PApplet . trim ( PApplet . split ( options , "str" ) ) ;
String [ ] opts = PApplet . trim ( PApplet . split ( options , "str" ) ) ;
pgl . uniform4i ( loc , v [ 0 ] , v [ 1 ] , v [ 2 ] , v [ 3 ] ) ;
case "str" : id = Token . LITERAL1 + num ; break ;
showMethodWarning ( "str" ) ;
canvasAWT . requestFocusInWindow ( ) ;
canvasNEWT . requestFocusInWindow ( ) ;
theme = new Settings ( Base . getContentFile ( "str" ) ) ;
context = - 1 ;
public static final byte FUNCTION4 = 14 ;
if ( ignorableImport ( item ) ) {
protected boolean ignorableImport ( String pkg ) {
public final class PMatrix3D implements PMatrix {
static private final float max ( float a , float b ) {
static private final float abs ( float a ) {
static private final float sin ( float angle ) {
static private final float cos ( float angle ) {
if ( ( modifiers & InputEvent . CTRL_MASK ) ! = 0 ) {
URL url = getClass ( ) . getResource ( "str" + sz + "str" ) ;
return ( cacheHsbValue [ 0 ] / 360 f ) * colorModeX ;
return new File ( System . getProperty ( "str" ) , "str" ) ;
keyEventMethods . handle ( new Object [ ] { event . getNative ( ) } ) ;
static final int HINT_COUNT = 12 ;
if ( ! hints [ DISABLE_OPENGL_ERRORS ] ) {
ambient ( 255 ) ;
ambient ( 255 ) ;
public PGraphicsPDF ( ) {
Font awtFont = ( Font ) textFont . getNative ( ) ;
if ( filename . contains ( "str" ) ) {
static public void setGStreamerPath ( String path ) {
if ( textures = = null ) {
if ( textures = = null ) {
bufferUntilByte = ( byte ) what ;
static public void findJDK ( ) {
showWarning ( "str" ) ;
showWarning ( "str" ) ;
showWarning ( "str" ) ;
showWarning ( "str" ) ;
showWarning ( "str" ) ;
throw new RuntimeException ( "str" ) ;
throw new RuntimeException ( "str" ) ;
showWarning ( "str" ) ;
showWarning ( "str" ) ;
showWarning ( "str" ) ;
showWarning ( "str" ) ;
showWarning ( "str" ) ;
throw new RuntimeException ( "str" ) ;
throw new RuntimeException ( "str" ) ;
PGraphics . showWarning ( "str" ) ;
PGraphics . showWarning ( "str" ) ;
PGraphics . showWarning ( "str" ) ;
PGraphics . showWarning ( "str" ) ;
for ( int i = 0 ; i < glyphTexinfos . length ; i + + ) {
protected GLAnimator animator ;
window = GLWindow . create ( caps ) ;
animator = new GLAnimator ( window ) ;
public GLAnimator ( GLAutoDrawable drawable ) {
protected boolean antBuild_dexworkaround ( ) throws SketchException {
protected boolean antBuild ( ) throws SketchException {
"str" + newExtension + "str" +
public static final String SIZE_REGEX =
public static final String PACKAGE_REGEX =
if ( renderer . equals ( "str" ) | | renderer . equals ( "str" ) ) {
File outputFolder = ( packageName = = null ) ?
String [ ] javadoc = PApplet . match ( sketch . getCode ( 0 ) . getProgram ( ) , "str" ) ;
library . getName ( ) +
System . err . println ( exportFile . getName ( ) +
String arch = "str" ;
fillSpecular . put ( sp ) ;
handleStartServer ( ) ;
handleStartServer ( ) ;
lightSpecular ( 0 , 0 , 0 ) ;
keywordColoring = new KeywordMap ( false ) ;
gl2x . glEnableVertexAttribArray ( attribsID ) ;
System . out . println ( "str" + emuController . getState ( ) +
for ( int i = sketch . getCodeCount ( ) - 1 ; i > 0 ; i - - ) {
handleExportPackage ( ) ;
Base . readSettings ( null , strings , exports ) ;
readSettings ( inputFile . toString ( ) , lines , outgoing ) ;
return libraryManagerFrame . confirmAndInstallLibrary ( activeEditor , libFile ) . size ( ) ;
if ( ! textured ) {
if ( ! textured ) {
ortho ( 0 , width , 0 , height , cameraNear , cameraFar ) ;
abstract public void handleImportLibrary ( String jarPath ) ;
if ( font ! = null & & font . canDisplay ( c ) ) {
File file = new File ( dir , name ) ;
return lc . endsWith ( "str" ) | | lc . endsWith ( "str" ) ;
String hostPlatform = Base . getPlatformName ( ) ;
} else if ( mode = = MODELVIEW ) {
} else if ( mode = = MODELVIEW ) {
} else if ( mode = = MODELVIEW ) {
handleClose ( activeEditor , true ) ;
public boolean handleClose ( Editor editor , boolean modeSwitch ) {
base . handleClose ( Editor . this , false ) ;
base . handleClose ( Editor . this , false ) ;
editor . base . handleClose ( editor , false ) ;
return createFont ( "str" , size , true , null ) ;
resize = mode . loadImage ( "str" ) ;
int tcount = 0 ;
tcount = 1 ;
numRecordedTextures = PApplet . max ( numRecordedTextures , tcount ) ;
for ( int t = 0 ; t < tcount ; t + + ) {
if ( tcount = = 1 ) {
for ( int t = 0 ; t < tcount ; t + + ) {
for ( int t = tcount ; t < maxTextureUnits ; t + + ) {
for ( int t = 0 ; t < tcount ; t + + ) {
for ( int t = 0 ; t < tcount ; t + + ) {
for ( int t = tcount ; t < maxTextureUnits ; t + + ) {
for ( int t = 0 ; t < tcount ; t + + ) {
for ( int t = 0 ; t < tcount ; t + + ) {
for ( int t = tcount ; t < maxTextureUnits ; t + + ) {
for ( int t = 0 ; t < tcount ; t + + ) {
for ( int t = 0 ; t < tcount ; t + + ) {
for ( int t = 0 ; t < tcount ; t + + ) {
for ( int t = 0 ; t < tcount ; t + + ) {
for ( int t = 0 ; t < tcount ; t + + ) {
for ( int t = 0 ; t < tcount ; t + + ) {
PShape child = createChild ( name , n0 , n1 , getDrawModeImpl ( ) ) ;
for ( int n = who3d . firstVertex ; n < = who3d . lastVertex ; n + + ) {
lightSpecular [ lightCount ] [ 3 ] = currentLightSpecular [ 3 ] ;
throw new RuntimeException ( "str" +
System . err . println ( message ) ;
public static final RGB LITERAL1 = new RGB ( 0 , 102 , 153 ) ;
System . arraycopy ( points , 0 , temp , 0 , pointCount ) ;
public int VERTEXCOUNT = 0 ;
frame . setLocation ( frameLoc . x , 30 ) ;
tint ( savedTintColor ) ;
idxUp = currIdx ;
idxUp = currIdx ;
w . println ( m . group ( 3 ) ) ;
texCoords . put ( updateTexCoordArray , offset , size ) ;
public GLModelParameters ( ) {
public GLModelParameters ( GLModelParameters src ) {
public static final int GROUPS = 4 ;
if ( updateElement ! = GROUPS & & lastUpdateIdx < firstUpdateIdx ) return ;
who . bitmap = Bitmap . createBitmap ( who . width , who . height , Config . ARGB_8888 ) ;
static final String ANDROID_SDK_PRIMARY =
static final String ANDROID_SDK_SECONDARY =
static final String SELECT_ANDROID_SDK_FOLDER =
static final String NOT_ANDROID_SDK =
static final String ANDROID_SDK_URL =
int result = Base . showYesNoQuestion ( editor , "str" ,
if ( sanitaryName . equalsIgnoreCase ( c . getPrettyName ( ) ) ) {
if ( newName . equalsIgnoreCase ( code [ i ] . getPrettyName ( ) ) ) {
out . println ( indent + "str" ) ;
HashMap < String , Object > zipFileContents = new HashMap < String , Object > ( ) ;
HashMap < String , String > exportTable = readSettings ( exportSettings ) ;
Vector < String > jarListVector = new Vector < String > ( ) ;
HashMap < String , Object > zipFileContents = new HashMap < String , Object > ( ) ;
HashMap < String , String > exportTable = readSettings ( exportSettings ) ;
if ( fill | | textureImage ! = null ) {
if ( fill | | textureImage ! = null ) {
if ( fill | | textureImage ! = null ) {
if ( fill | | textureImage ! = null ) {
if ( fill | | textureImage ! = null ) {
if ( fill | | textureImage ! = null ) {
if ( fill | | textureImage ! = null ) {
if ( fill | | textureImage ! = null ) {
float rh = ( strokeWeight / len ) / 2 ;
BufferedImage . TYPE_INT_RGB : BufferedImage . TYPE_INT_ARGB ;
renderLineVertices ( vertices [ lines [ i ] [ VERTEX1 ] ] ,
float weight = a [ SW ] / 2 ;
public void text ( char [ ] chars , int start , int stop ,
Color parsed = Color . GRAY ;
static String VERSION_NAME = "str" ;
InputStream input = Base . getLibStream ( "str" ) ;
File versionFile = getContentFile ( "str" ) ;
load ( Base . getLibStream ( "str" ) ) ;
load ( Base . getLibStream ( "str" ) ) ;
is = Base . getLibStream ( "str" ) ;
is = Base . getLibStream ( "str" ) ;
protected float [ ] [ ] vertices ;
g . line ( params [ 0 ] , params [ 1 ] ,
g . line ( params [ 0 ] , params [ 1 ] , params [ 2 ] ,
g . triangle ( params [ 0 ] , params [ 1 ] ,
public Capture ( final PApplet parent ,
JOptionPane . showConfirmDialog ( null , prompt , "str" ,
JOptionPane . showConfirmDialog ( null , prompt , "str" ,
this . appletClassName = appletClassName ;
protected VirtualMachine launchVirtualMachine ( String [ ] vmParams ,
ReferenceType rt = or . referenceType ( ) ;
protected void updatePixelsImpl ( int x1 , int y1 , int x2 , int y2 ) {
PApplet . loadStrings ( p . getInputStream ( ) ) ;
new BufferedReader ( new StringReader ( errorBuffer . toString ( ) ) ) ;
public int getIntAttribute ( String name ) {
Base . openURL ( "str" ) ;
Base . openURL ( "str" ) ;
throw new RuntimeException ( openglError + "str" ) ;
throw new RuntimeException ( openglError + "str" ) ;
package processing . app . debug ;
package processing . app . debug ;
package processing . app . debug ;
h = ( h - y ) ;
g2 . drawImage ( ( ( ImageCache ) who . cache ) . image ,
if ( ( image = = null ) | | wrongType ) {
tintedPixels [ x ] = alpha |
this . tintedColor = tintColor ;
h = ( h - y ) ;
fc . setCurrentDirectory ( new File ( Preferences . get ( "str" ) ) ) ;
fc . setCurrentDirectory ( folder . getParentFile ( ) ) ;
if ( count = = 0 ) return what ;
if ( count = = 0 ) return what ;
if ( count = = 0 ) return what ;
if ( count = = 0 ) return what ;
if ( count = = 0 ) return what ;
registerWithArgs ( sizeMethods , "str" , o , methodArgs ) ;
static public String [ ] split ( String what , String delim ) {
String tf [ ] = PApplet . splitTokens ( transform ) ;
this ( parent , requestWidth , requestHeight , null , 30 ) ;
this ( parent , reqWidth , reqHeight , null , frameRate ) ;
public int backgroundColor = 0xffCCCCCC ;
v [ B ] = min ( 1 , v [ EB ] + v [ AB ] * contribution [ LIGHT_AMBIENT_B ] +
public void breakShape ( ) {
public SVG ( PApplet parent , String filename ) {
strokeWeight = properties . getFloatAttribute ( "str" , 1 ) ;
min ( 1 , v [ EB ] + v [ AB ] * lightContribution [ LIGHT_AMBIENT_B ] +
base = base . substring ( 0 , base . length ( ) - 5 ) ;
public void beginDraw ( ) {
public void endDraw ( ) {
qdgraphics = new QDGraphics ( QDConstants . k32BGRAPixelFormat , qdrect ) ;
qdgraphics = new QDGraphics ( QDGraphics . kDefaultPixelFormat , qdrect ) ;
depth_sort_triangles_internal ( 0 , triangleCount - 1 ) ;
int tempi [ ] = triangles [ a ] ;
lines [ i ] . trim ( ) : lines [ i ] . substring ( 0 , hash ) . trim ( ) ;
boolean useDate = true ;
while ( ( c ! = "str" ) & & ( j < string . length ) ) {
return path + File . separator + "str" + File . separator + where ;
smooth = parent . smooth ;
if ( smooth ) {
if ( smooth ) {
if ( smooth ) {
if ( smooth ) {
if ( smooth | | texture_smooth ) {
int weight = smooth ? coverage ( x ) : 255 ;
int weight = smooth ? coverage ( x ) : 255 ;
if ( ! smooth | | ( ( x > = truelx ) & & ( x < = truerx ) ) ) {
if ( smooth ) {
float boxWidth = x2 - x1 ;
if ( srcY2 > = img . height ) srcY2 = img . height - 1 ;
if ( backgroundColor = = Color . black ) {
deriveFontMethod . invoke ( baseFont , new Object [ ] { floatSize } ) ;
depthError ( "str" ) ;
depthError ( "str" ) ;
depthError ( "str" ) ;
colorMode ( mode , colorModeX , colorModeY , colorModeZ , colorModeA ) ;
if ( e ! = null ) e . printStackTrace ( ) ;
textLeadingReset ( ) ;
x + = parent . textSize * width ( textBuffer [ index ] ) ;
int x = 0 ;
return new Dimension ( 300 , PdePreferences . GRID_SIZE ) ;
return new Dimension ( 3000 , PdePreferences . GRID_SIZE ) ;
if ( ( offscreen = = null ) | |
x1 = 0 ;
if ( state = = null ) return ;
stateImage [ slot ] = inactive [ which [ slot ] ] ;
editor . handleRun ( e . isShiftDown ( ) ) ;
renderingHintsClass . getDeclaredField ( "str" ) ;
public void text ( String s , float x1 , float y1 , float z , float x2 , float y2 ) {
public void text ( String s , float x1 , float y1 , float z , float x2 , float y2 ) ;
if ( ( sx - ph > = parent . width ) | | ( sy > = parent . height ) | |
ph - = ( ph - sx ) - 1 ;
int extra = ( sy + pw ) - parent . height ;
int index = ( sy + px + col ) * parent . width + ( sx - row ) ;
String exportList [ ] = null ;
setup_spline_forward ( segments , curve_forward ) ;
pieces = new Image [ STATUS . length ] [ WHERE . length ] ;
Color color = PdePreferences . getColor ( "str" ) ;
Color color = PdePreferences . getColor ( "str" ) ;
PdePreferences . getBoolean ( "str" ) ;
new Color ( 0xff , 0x30 , 0x00 ) ) ;
final boolean debug = false ;
String partialTempPath = buildPath . replace ( File . separatorChar , "str" )
ps . println ( "str" + exportSketchName + "str" + exportSketchName + "str" + wide + "str" + high + "str" ) ;
output = new FileOutputStream ( URLDecoder . decode ( urlstr ) ) ;
PdeApplet . getColor ( "str" , new Color ( 153 , 0 , 0 ) ) ;
public Participant getParticipantByAccountId ( String accountId ) {
public Participant getParticipantBySummonerId ( String summonerId ) {
if ( player . getSummonerId ( ) . equals ( summonerId ) ) {
private String summonerId ;
public String getSummonerId ( ) {
if ( responseCode ! = CODE_SUCCESS_NO_CONTENT & & is ! = null ) {
private synchronized void invokeSupervisor ( ) {
public class ApiConfig implements Cloneable {
public class RiotApi implements Cloneable {
public int getMapId ( ) {
return super . getDto ( true ) ;
addTournamentApiKeyParameter ( ) ;
addTournamentApiKeyParameter ( ) ;
public boolean isSuccessful ( ) {
private Season season = Season . CURRENT ;
throw new RateLimitException ( retryAfter , rateLimitType ) ;
throw new RateLimitException ( 0 , rateLimitType ) ;
public Map < String , List < League > > getLeagueBySummoners ( Region region , String . . . summonerIds ) throws RiotApiException {
return LeagueApi . getLeagueBySummoners ( region , getKey ( ) , String . join ( "str" , summonerIds ) ) ;
public Map < String , List < League > > getLeagueEntryBySummoners ( Region region , String . . . summonerIds ) throws RiotApiException {
return LeagueApi . getLeagueEntryBySummoners ( region , getKey ( ) , String . join ( "str" , summonerIds ) ) ;
public Map < String , List < League > > getLeagueEntryBySummoners ( String . . . summonerIds ) throws RiotApiException {
return LeagueApi . getLeagueEntryBySummoners ( getRegion ( ) , getKey ( ) , String . join ( "str" , summonerIds ) ) ;
public Map < String , List < League > > getLeagueByTeams ( Region region , String . . . teamIds ) throws RiotApiException {
return LeagueApi . getLeagueByTeams ( region , getKey ( ) , String . join ( "str" , teamIds ) ) ;
public Map < String , List < League > > getLeagueByTeams ( String . . . teamIds ) throws RiotApiException {
return LeagueApi . getLeagueByTeams ( getRegion ( ) , getKey ( ) , String . join ( "str" , teamIds ) ) ;
public Map < String , List < League > > getLeagueEntryByTeams ( Region region , String . . . teamIds ) throws RiotApiException {
return LeagueApi . getLeagueEntryByTeams ( region , getKey ( ) , String . join ( "str" , teamIds ) ) ;
public Map < String , List < League > > getLeagueEntryByTeams ( String . . . teamIds ) throws RiotApiException {
return LeagueApi . getLeagueEntryByTeams ( getRegion ( ) , getKey ( ) , String . join ( "str" , teamIds ) ) ;
public Map < String , MasteryPages > getMasteryPages ( Region region , String . . . summonerIds ) throws RiotApiException {
return SummonerApi . getMasteryPages ( region , getKey ( ) , String . join ( "str" , summonerIds ) ) ;
public Map < String , MasteryPages > getMasteryPages ( String . . . summonerIds ) throws RiotApiException {
return SummonerApi . getMasteryPages ( getRegion ( ) , getKey ( ) , String . join ( "str" , summonerIds ) ) ;
public Map < String , RunePages > getRunePages ( Region region , String . . . summonerIds ) throws RiotApiException {
return SummonerApi . getRunePages ( region , getKey ( ) , String . join ( "str" , summonerIds ) ) ;
public Map < String , RunePages > getRunePages ( String . . . summonerIds ) throws RiotApiException {
return SummonerApi . getRunePages ( getRegion ( ) , getKey ( ) , String . join ( "str" , summonerIds ) ) ;
public Map < String , Summoner > getSummonersByName ( Region region , String . . . summonerNames ) throws RiotApiException {
return SummonerApi . getSummonersByName ( region , getKey ( ) , String . join ( "str" , summonerNames ) ) ;
public Map < String , Summoner > getSummonersByName ( String . . . summonerNames ) throws RiotApiException {
return SummonerApi . getSummonersByName ( getRegion ( ) , getKey ( ) , String . join ( "str" , summonerNames ) ) ;
public Map < String , Summoner > getSummonersById ( Region region , String . . . summonerIds ) throws RiotApiException {
return SummonerApi . getSummonersById ( region , getKey ( ) , String . join ( "str" , summonerIds ) ) ;
public Map < String , Summoner > getSummonersById ( String . . . summonerIds ) throws RiotApiException {
return SummonerApi . getSummonersById ( getRegion ( ) , getKey ( ) , String . join ( "str" , summonerIds ) ) ;
public Map < String , String > getSummonerNames ( Region region , String . . . summonerIds ) throws RiotApiException {
return SummonerApi . getSummonerNames ( region , getKey ( ) , String . join ( "str" , summonerIds ) ) ;
public Map < String , String > getSummonerNames ( String . . . summonerIds ) throws RiotApiException {
return SummonerApi . getSummonerNames ( getRegion ( ) , getKey ( ) , String . join ( "str" , summonerIds ) ) ;
public Map < String , List < Team > > getTeamsBySummonerIds ( Region region , String . . . summonerIds ) throws RiotApiException {
return TeamApi . getTeamsBySummonerIds ( region , getKey ( ) , String . join ( "str" , summonerIds ) ) ;
public Map < String , List < Team > > getTeamsBySummonerIds ( String . . . summonerIds ) throws RiotApiException {
return TeamApi . getTeamsBySummonerIds ( getRegion ( ) , getKey ( ) , String . join ( "str" , summonerIds ) ) ;
public Map < String , Team > getTeamsByTeamIds ( Region region , String . . . teamIds ) throws RiotApiException {
return TeamApi . getTeamsByTeamIds ( region , getKey ( ) , String . join ( "str" , teamIds ) ) ;
public Map < String , Team > getTeamsByTeamIds ( String . . . teamIds ) throws RiotApiException {
return TeamApi . getTeamsByTeamIds ( getRegion ( ) , getKey ( ) , String . join ( "str" , teamIds ) ) ;
if ( champData [ 0 ] ! = null ) {
if ( itemListData [ 0 ] ! = null ) {
if ( runeListData [ 0 ] ! = null ) {
if ( runeData [ 0 ] ! = null ) {
if ( masteryListData [ 0 ] ! = null ) {
if ( masteryData [ 0 ] ! = null ) {
if ( spellData [ 0 ] ! = null ) {
if ( spellData [ 0 ] ! = null ) {
return getSummonersById ( endpoint , region , key , Convert . longToString ( summonerIds ) ) ;
worldAdapter . setBlock ( pos , this . layer , new BlockIdentifier ( instance . getBlockId ( ) , instance . getBlockData ( ) ) ) ;
worldAdapter . setBlock ( pos , this . layer , new BlockIdentifier ( instance . getBlockId ( ) , instance . getBlockData ( ) ) ) ;
tileEntity . getLines ( ) . add ( lines [ i ] ) ;
return text = = null ? "str" : text . substring ( 1 , text . length ( ) - 1 ) ;
@RegisterInfo ( sId = "str" , def = true )
if ( this . keyPair = = null ) {
private final FacingBlockState facing = new FacingBlockState ( this , ( short ) 1 ) ;
private Gamemode gamemode = Gamemode . SURVIVAL ;
private Gamemode gamemode = Gamemode . SURVIVAL ;
public static final byte PACKET_SET_LOCAL_PLAYER_INITIALIZED = ( byte ) 0x71 ;
private Gamemode gamemode = Gamemode . SURVIVAL ;
final List < VCFIDHeaderLine > lines = new ArrayList < VCFIDHeaderLine > ( ) ;
lines . add ( ( VCFIDHeaderLine ) line ) ;
return ( mFlags & SAMFlag . SECONDARY_ALIGNMENT . flag ) ! = 0 ;
throw new UnsupportedOperationException ( "str" + getAbsolutePath ( ) + "str" ) ;
static final class DeletePathThread extends Thread {
DeletePathThread ( Path path ) { this . path = path ; }
Files . deleteIfExists ( path ) ;
this ( os , digestFile = = null ? ( Path ) null : digestFile . toPath ( ) ) ;
throw new SAMException ( error ( e . getMessage ( ) ) , e ) ;
throw new SAMException ( error ( e . getMessage ( ) ) , e ) ;
if ( null = = sourceSeekable | | null = = indexSeekable ) {
sourceSeekable , indexSeekable , false , asynchronousIO , validationStringency , this . samRecordFactory ) ;
if ( ref . length < = blockRefPos + inBlockOffset ) break ;
Assert . assertEquals ( r . getIntegerAttribute ( SAMTag . NM . name ( ) ) , nm , "str" + r . getReadName ( ) + "str" ) ;
buf . append ( "str" ) ;
buf . append ( "str" ) ;
buf . append ( "str" ) ;
buf . append ( "str" ) ;
stringBuilder . append ( "str" ) ;
stringBuilder . append ( "str" ) ;
b . append ( "str" ) . append ( name ) . append ( "str" ) ;
if ( i ! = 0 ) b . append ( "str" ) ;
b . append ( "str" ) . append ( s ) ;
s . append ( "str" ) ;
builder . append ( "str" ) ;
else builder . append ( "str" ) ;
builder . append ( "str" ) ;
builder . append ( "str" ) ;
textHeader . append ( mCurrentLine ) . append ( "str" ) ;
ret . append ( "str" ) ;
stringBuilder . append ( "str" ) ;
builder . append ( "str" )
. append ( "str" ) ;
stringBuilder . append ( "str" ) ;
sb . append ( "str" ) ;
sb . append ( "str" ) ;
sb . append ( "str" ) ;
builder . append ( "str" ) ;
buffer . append ( "str" ) ;
buffer . append ( "str" ) ;
sb . append ( "str" ) ;
sb . append ( "str" ) ;
sb . append ( "str" ) ;
@Override protected void write ( final String message ) { sb . append ( message ) . append ( "str" ) ; }
return Integer . compare ( this . hasher . hashUnencodedChars ( lhs . getReadName ( ) ) , this . hasher . hashUnencodedChars ( rhs . getReadName ( ) ) ) ;
final String value = getStringProperty ( name , Boolean . toString ( def ) ) ;
final String value = getStringProperty ( name , Integer . toString ( def ) ) ;
final long minBufferSize = Math . min ( ( long ) Defaults . NON_ZERO_BUFFER_SIZE , ( long ) ( length / basesPerLine + 2 ) * ( long ) bytesPerLine ) ;
return loadClass ( p + className . substring ( className . lastIndexOf ( "str" ) ) , false ) ;
if ( className . indexOf ( "str" ) > - 1 ) {
return loadClass ( p + "str" + className . substring ( className . lastIndexOf ( "str" ) + 1 ) , false ) ;
final int index = full . lastIndexOf ( "str" ) ;
final int index = full . lastIndexOf ( "str" ) ;
path . substring ( 0 , path . lastIndexOf ( "str" ) ) : path ;
i = alt . indexOf ( "str" , e_off ) ;
int equals = str . indexOf ( "str" ) ;
if ( infoField . indexOf ( "str" ) ! = - 1 | | infoField . indexOf ( "str" ) ! = - 1 )
if ( alts . indexOf ( "str" ) = = - 1 )
final int extensionStart = referenceFile . getName ( ) . lastIndexOf ( "str" ) ;
if ( string . indexOf ( "str" ) ! = - 1 ) {
return ! recs . isEmpty ( ) ;
if ( filterString . isEmpty ( ) )
if ( ! this . mFileHeader . getSequenceDictionary ( ) . isEmpty ( ) ) {
if ( mFields [ i ] . isEmpty ( ) ) {
if ( chrList . isEmpty ( ) | | ! chrList . getLast ( ) . getName ( ) . equals ( feature . getChr ( ) ) ) {
if ( ! chrList . isEmpty ( ) )
if ( featureCount > = featuresPerInterval | | intervals . isEmpty ( ) ) {
if ( ! intervals . isEmpty ( ) ) intervals . get ( intervals . size ( ) - 1 ) . setEndFilePosition ( filePosition ) ;
if ( string . isEmpty ( ) )
if ( value = = null | | value . isEmpty ( ) ) return false ;
if ( type = = BCF2Type . CHAR & & ! v . isEmpty ( ) ) {
if ( ! samFileHeader . getSequenceDictionary ( ) . isEmpty ( ) ) {
if ( validationErrors ! = null & & ! validationErrors . isEmpty ( ) ) {
if ( ! pgs . isEmpty ( ) ) {
if ( cigar = = null | | cigar . getCigarElements ( ) = = null | | cigar . getCigarElements ( ) . isEmpty ( ) ) {
if ( validationErrors ! = null & & ! validationErrors . isEmpty ( ) ) {
if ( ! holder . isEmpty ( ) ) {
return filters = = null ? false : ! filters . isEmpty ( ) ;
if ( attributes . isEmpty ( ) ) {
if ( oqString ! = null & & ! oqString . isEmpty ( ) ) {
if ( getHeader ( ) ! = null & & getHeader ( ) . getSequenceDictionary ( ) . isEmpty ( ) ) {
if ( cq = = null | | cq . isEmpty ( ) | | cs = = null | | cs . isEmpty ( ) ) {
if ( ret = = null | | ret . isEmpty ( ) ) {
if ( getHeader ( ) ! = null & & ! getHeader ( ) . getSequenceDictionary ( ) . isEmpty ( ) ) {
if ( header . getSequenceDictionary ( ) ! = null & & ! header . getSequenceDictionary ( ) . isEmpty ( ) ) {
if ( intervals = = null | | intervals . isEmpty ( ) ) return new ArrayList < Block > ( ) ;
assert ! ref . isEmpty ( ) ;
if ( chrList . isEmpty ( ) | | ! chrList . getLast ( ) . getName ( ) . equals ( feature . getChr ( ) ) ) {
if ( ! chrList . isEmpty ( ) )
return line ! = null & & ! line . isEmpty ( ) & & VCFHeader . HEADER_INDICATOR . equals ( line . substring ( 0 , 1 ) ) ;
if ( ! vc . getAlternateAlleles ( ) . isEmpty ( ) ) {
if ( ! histograms . isEmpty ( ) ) return this . histograms . get ( 0 ) ;
if ( values [ i ] ! = null & & ! values [ i ] . isEmpty ( ) ) {
if ( chunkList . isEmpty ( ) ) {
if ( sawFormatTag & & sampleNames . isEmpty ( ) )
public boolean isEmpty ( ) { return ( blocks . isEmpty ( ) | | this . blocks . getFirst ( ) . isEmpty ( ) ) ; }
public boolean canEmit ( ) { return ( ! this . blocks . isEmpty ( ) & & this . blocks . getFirst ( ) . canEmit ( ) ) ; }
if ( this . blocks . isEmpty ( ) | | ! this . blocks . getLast ( ) . canAdd ( ) ) {
if ( line . trim ( ) . isEmpty ( ) ) {
char strand = ( strandString . isEmpty ( ) )
if ( ( ( mg = match . group ( 1 ) ) ! = null ) & & ( ! mg . isEmpty ( ) ) ) {
} else if ( ( ( mg = match . group ( 2 ) ) ! = null ) & & ( ! mg . isEmpty ( ) ) ) {
} else if ( ( ( mg = match . group ( 3 ) ) ! = null ) & & ( ! mg . isEmpty ( ) ) ) {
if ( sofar . isEmpty ( ) ) {
if ( peekedLine . isEmpty ( ) ) {
if ( ! toBeMerged . isEmpty ( ) ) unique . add ( merge ( toBeMerged , concatenateNames ) ) ;
if ( line . trim ( ) . isEmpty ( ) ) continue ;
if ( seqHeaderPrefix ! = null & & ! seqHeaderPrefix . isEmpty ( ) ) this . seqHeaderPrefix = seqHeaderPrefix ;
if ( qualHeaderPrefix ! = null & & ! qualHeaderPrefix . isEmpty ( ) ) this . qualHeaderPrefix = qualHeaderPrefix ;
if ( tmpDirs = = null | | tmpDirs . isEmpty ( ) ) {
if ( chunkList = = null | | chunkList . isEmpty ( ) ) {
if ( ! alt . isEmpty ( ) ) intv . end = intv . beg + alt . length ( ) ;
return ! s . isEmpty ( ) & & s . charAt ( 0 ) = = "str" ;
if ( objs . isEmpty ( ) ) {
if ( ! trailingString . isEmpty ( ) )
if ( ! trailingString . isEmpty ( ) )
if ( contigs . isEmpty ( ) ) throw new IllegalArgumentException ( "str" ) ;
if ( headerLines . isEmpty ( ) ) throw new IllegalArgumentException ( "str" ) ;
if ( ! getAlternateAlleles ( ) . isEmpty ( ) ) {
if ( filterString . isEmpty ( ) )
@DataProvider ( name = "str" )
public < T extends Comparable < T > , R extends Comparable < R > > void testComparableTuple ( final ComparableTuple < T , R > lhs , final ComparableTuple < T , R > rhs , final int result ) {
log . info ( ( Object [ ] ) message ) ;
if ( this . queue . isEmpty ( ) ) this . writer . interrupt ( ) ;
String tabixFile = "str" ;
throw new IllegalArgumentException ( "str" + val + "str" ) ;
static final String AVAILABLE_HTTP_URL = "str" ;
throw new PicardException ( "str" + numClusters + "str" + filePath + "str" + elementsInFile ) ;
public Boolean ADD_MATE_CIGAR = true ;
public Boolean ADD_MATE_CIGAR = true ;
private final AtomicReference < AdapterPair [ ] > adapters = new AtomicReference < AdapterPair [ ] > ( ) ;
adapters . set ( truncatedAdapters . toArray ( new AdapterPair [ truncatedAdapters . size ( ) ] ) ) ;
if ( ! this . hasIndex ( ) ) {
TRY_USE_INTEL_DEFLATER = getBooleanProperty ( "str" , true ) ;
final VCFHeader header = new VCFHeader ( reader . getFileHeader ( ) . getMetaDataInInputOrder ( ) ) ;
private static final List < String > SLURP_TEST_LINES = Arrays . asList ( "str" , "str" , "str" ) ;
if ( SEQUENCE_DICTIONARY ! = null ) IoUtil . assertFileIsReadable ( SEQUENCE_DICTIONARY ) ;
@Option ( shortName = "str" , doc = "str" , optional = true )
final Factory < V , K > defaultGenerator ;
this ( new Factory < V , K > ( ) {
public V make ( final K k ) {
public DefaultingMap ( final Factory < V , K > defaultGenerator , final boolean injectValueOnDefaulting ) {
final V val = this . defaultGenerator . make ( ( K ) key ) ;
public final static int MAX_PL = Integer . MAX_VALUE ;
Assert . assertEquals ( errors . get ( 0 ) . getType ( ) , SAMValidationError . Type . ADJACENT_INDEL_IN_CIGAR ) ;
Assert . assertEquals ( errors . get ( 0 ) . getType ( ) , SAMValidationError . Type . ADJACENT_INDEL_IN_CIGAR ) ;
ret . add ( new SAMValidationError ( SAMValidationError . Type . ADJACENT_INDEL_IN_CIGAR ,
lastPosition < referenceSequenceMask . nextPosition ( lastReferenceSequence , lastPosition ) ) ) ;
final int nextbit = referenceSequenceMask . nextPosition ( lastReferenceSequence , lastPosition ) ;
@DataProvider ( name = "str" )
while ( projectedSize > idealSplitLength & & index < SCATTER_COUNT ) {
if ( "str" . equals ( value ) | | "str" . equals ( value ) ) return Float . NaN ;
if ( "str" . equals ( value ) | | "str" . equals ( value ) ) return Double . NaN ;
private boolean destructiveIteration = true ;
throw new PicardException ( "str" + basecallDirectory + "str" + lane + "str" + parsers [ i ] . getClass ( ) . getName ( ) ) ;
final String key = ( barcodeValues . contains ( "str" ) ? null : StringUtil . join ( "str" , barcodeValuesArray ) ) ;
adapterTrimIlluminaPairedReads ( read1 , read2 , minMatchBases , maxErrorRate , adapters ) ;
ret . add ( new SAMValidationError ( SAMValidationError . Type . INVALID_FLAG_SECOND_OF_PAIR , "str" , getReadName ( ) ) ) ;
return ( available ( ) > 0 ) ? ( mCurrentBlock [ mCurrentOffset + + ] & 0xFF ) : - 1 ;
new AlignedFilter ( false ) , true ) ) ;
"str" + outputFile . getName ( ) ) ;
log . error ( "str" + INPUT . getName ( ) + "str" + e . getMessage ( ) , e ) ;
sam . setAttribute ( "str" , StringUtil . bytesToString ( ird . getBarcodeRead ( ) . getBases ( ) ) . replace ( "str" , "str" ) ) ;
Assert . assertEquals ( metrics . PF_HQ_MEDIAN_MISMATCHES , 11.5 ) ;
if ( Math . abs ( uniquePairMultiplier - uniquePairGoalMultiplier ) / uniquePairGoalMultiplier < = 0.001 ) {
for ( int linearBin = regionLinearBinStart ; linearBin < = regionLinearBinStop & & linearBin < = nLinearBins - 1 ; linearBin + + )
throw new PicardException ( "str" + reader + "str" + programGroup . getId ( ) + "str" ) ;
return sumQualitiesOfMismatches ( read , referenceBases , referenceOffset , false ) ;
ret . add ( new SAMValidationError ( SAMValidationError . Type . INVALID_MAPPING_QUALITY , "str" , getReadName ( ) ) ) ;
String [ ] values = line . split ( SEPARATOR , - 1 ) ;
throw new PicardException ( "str" + record1 . getReadName ( ) ) ;
if ( ! compareValues ( l1 . size ( ) , l2 . size ( ) , "str" ) ) {
public boolean TRUNCATE_NAMES_AT_WHITESPACE = true ;
private static final int BAM_LIDX_SHIFT = 14 ;
if ( validationErrors ! = null & & validationErrors . size ( ) > 0 ) {
if ( mCurrentRecord . getReadBases ( ) = = SAMRecord . NULL_SEQUENCE ) {
public boolean IGNORE_WARNINGS = false ;
player . addPotionEffect ( new PotionEffect ( invisibility , 500 , - 3 , false , false ) ) ;
public void renderAt ( TileEntity undifferentiatedtileentity , double x , double y , double z , float partialTickTime ) {
public void renderAt ( TileEntity tileEntity , double x , double y , double z , float partialTickTime ) {
worldObj . setBlockTileEntity ( x , y , z , new TileEntityLuxCapacitor ( dir , red , green , blue ) ) ;
int blockToStickTo = worldObj . getBlockId ( movingobjectposition . blockX , movingobjectposition . blockY , movingobjectposition . blockZ ) ;
worldObj . setBlockTileEntity ( x , y , z , new TileEntityLuxCapacitor ( dir . getOpposite ( ) , red , green , blue ) ) ;
MuseLogger . logInfo ( "str" ) ;
MuseLogger . logInfo ( "str" ) ;
MuseLogger . logInfo ( "str" ) ;
if ( module instanceof IRightClickModule & & itemStack . getItem ( ) instanceof ModeChangingModularItem ) {
player . openGui ( ModularPowersuits . INSTANCE , 0 , world , x , y , z ) ;
event . manager . addSound ( soundFile ) ;
private static String TEXTURE_MAP = "str" ;
GL11 . glPushAttrib ( GL11 . GL_ENABLE_BIT | GL11 . GL_SCISSOR_BIT ) ;
addBaseProperty ( APIARIST_ARMOR_ENERGY_CONSUMPTION , 10 , "str" ) ;
if ( Config . useShaders ( ) & & Config . canUseShaders & & Minecraft . isFancyGraphicsEnabled ( ) ) {
return config . get ( "str" , "str" , true ) . getBoolean ( true ) ;
if ( Block . blocksList [ id ] instanceof IShearable & & ElectricItemUtils . getPlayerEnergy ( player ) > ModuleManager . computeModularProperty ( itemstack , SHEARING_ENERGY_CONSUMPTION ) ) {
if ( ( ( tile instanceof IMFFS_Wrench ) ) & & ( ! ( ( IMFFS_Wrench ) tile ) . wrenchCanManipulate ( player , side ) ) ) {
. setInitialRotationPoints ( - 5 , 2.0F + par2 , 0.0F ) ;
. setInitialRotationPoints ( 5 , 2.0F + par2 , 0.0F ) ;
if ( helm ! = null & & helm . getItem ( ) instanceof IModularItem ) {
import net . machinemuse . utils . MuseRenderer ;
if ( target . isShearable ( this . shootingItem , world , hitMOP . blockX , hitMOP . blockY , hitMOP . blockZ ) & & ! world . isRemote ) {
double r = 0.4375 ;
this . boundingBox . setBounds ( posX - r , posY - 0.0625 , posZ - r , posX + r , posY + 0.0625 , posZ + r ) ;
private static double bbMin ( double offset ) {
private static double bbMax ( double offset ) {
public static AxisAlignedBB createAABBForSide ( ForgeDirection dir , double x , double y , double z ) {
glTranslated ( x , y , z ) ;
addTradeoffProperty ( "str" , MuseHeatUtils . MAXIMUM_HEAT , 150 , "str" ) ;
addBaseProperty ( HEAT , 5 , "str" ) ;
addTradeoffProperty ( "str" , MuseCommonStrings . WEIGHT , 5000 , "str" ) ;
addTradeoffProperty ( "str" , COOLING_BONUS , 4 , "str" ) ;
this . blockIcon = iconRegister . registerIcon ( MuseIcon . ICON_PREFIX + "str" ) ;
PacketDispatcher . sendPacketToAllAround ( player . posX , player . posY , player . posZ , 128 , player . dimension , updatePacket . getPacket250 ( ) ) ;
GameRegistry . addRecipe ( new ShapedOreRecipe ( ItemComponent . ionThruster , true , "str" , "str" , "str" , "str" , "str" , "str" ,
if ( shears . canHarvestBlock ( block ) | | ForgeHooks . canToolHarvestBlock ( block , meta , shears ) | | shears . getStrVsBlock ( block ) > 1 ) {
if ( foodNeeded > 0 & & ( ( eatingEnergyConsumption * foodNeeded ) + totalEnergyDrain ) < totalEnergy & & MuseItemUtils . getFoodLevel ( helmet ) > 0 ) {
"str" , new MuseIcon ( MuseIcon . WC_ICON_PATH , 229 ) ) ;
player . removePotionEffect ( Potion . nightVision . id ) ;
player . removePotionEffect ( Potion . invisibility . id ) ;
int chargeTicks = Math . max ( this . getMaxItemUseDuration ( itemStack ) - par4 , 10 ) ;
GameRegistry . addRecipe ( new ShapedOreRecipe ( ItemComponent . lvcapacitor ,
"str" , paper ) ) ;
GameRegistry . addRecipe ( new ShapedOreRecipe ( ItemComponent . mvcapacitor ,
"str" , conduitEnergy ) ) ;
GameRegistry . addRecipe ( new ShapedOreRecipe ( ItemComponent . hvcapacitor ,
"str" , energyFrameFull ) ) ;
public static final String WC_ICON_PATH = "str" ;
public static final String WC_ICON_PATH = "str" ;
hasInvis = ItemUtils . itemHasActiveModule ( torso , ModularCommon . MODULE_ACTIVE_CAMOUFLAGE ) ;
event . entityHit . attackEntityFrom ( DamageSource . causeThrownDamage ( this , this . shootingEntity ) , ( int ) damage ) ;
@Mod ( modid = "str" , name = "str" , version = "str" )
kryo . getContext ( ) . put ( "str" , connection ) ;
threadPool . schedule ( new Runnable ( ) {
serializer . getField ( "str" ) . setClass ( int . class , new IntSerializer ( true ) ) ;
public static Object readJson ( String json , TypeReference < ? > type ) throws IOException {
if ( null = = contents ) {
Integer . valueOf ( listenPort ) , Integer . valueOf ( securePort ) , Integer . valueOf ( udpPort ) ) ) ;
getLog ( ) . debug ( "str" + processor + "str" + rpName + "str" ) ;
if ( m = = null | | ( Modifier . isPublic ( type . getModifiers ( ) ) & & jreCompat . canAcccess ( base , m ) ) ) {
Util . findMethod ( clazz , base , methodName , paramTypes , params ) ;
Method m = this . property ( context , base , property ) . read ( context , base ) ;
Method m = this . property ( context , base , property ) . write ( context , base ) ;
Util . findMethod ( base . getClass ( ) , base , methodName , paramTypes , params ) ;
return this . readOnly | | this . property ( context , base , property ) . isReadOnly ( base ) ;
public boolean isReadOnly ( Object base ) {
( null = = ( this . write = Util . getMethod ( this . owner , base , descriptor . getWriteMethod ( ) ) ) ) ;
private Method write ( ELContext ctx , Object base ) {
this . write = Util . getMethod ( this . owner , base , descriptor . getWriteMethod ( ) ) ;
private Method read ( ELContext ctx , Object base ) {
this . read = Util . getMethod ( this . owner , base , descriptor . getReadMethod ( ) ) ;
return getMethod ( base . getClass ( ) , base , m ) ;
return getMethod ( base . getClass ( ) , base , match ) ;
static Method findMethod ( Class < ? > clazz , Object base , String methodName ,
return getMethod ( clazz , base , result . unWrap ( ) ) ;
Map < String , List < String > > reqHeaders = createRequestHeaders ( host , port , secure ,
boolean secure , ClientEndpointConfig clientEndpointConfiguration ) {
log ( "str" ) ;
String . format ( "str" , size )
final Resource resource = Mockito . spy ( new ResourceMocker ( ) . mock ( ) ) ;
String . format ( "str" , prefix , prefix )
String . format ( "str" , key , key )
Matchers . containsString ( "str" )
if ( ! this . sockets . offer ( socket , Tv . TWENTY , TimeUnit . SECONDS ) ) {
Pattern . compile ( "str" ) ;
@Loggable ( value = Loggable . DEBUG , limit = Integer . MAX_VALUE )
if ( ! matcher . matches ( ) ) {
String . format ( "str" , fbuser . getId ( ) )
return String . format ( "str" , name , value ) ;
builder . header ( HttpHeaders . VARY , "str" ) ;
Logger . info ( this , "str" , domains . size ( ) ) ;
Logger . warn ( this , "str" , ex . getMessage ( ) ) ;
String name = uri . getPath ( ) ;
Pattern . compile ( "str" ) ;
import com . s3auth . hosts . DynamoHosts ;
final Facade facade = new Facade ( new DynamoHosts ( ) ) ;
boolean processExit = process . waitFor ( 200 , TimeUnit . SECONDS ) ;
boolean processExit = process . waitFor ( 100 , TimeUnit . SECONDS ) ;
return new Point ( x + ( int ) Math . round ( width / 2.0 - stringWidth / 2.0 ) ,
y + ( int ) Math . round ( height / 2.0 - stringWidth / 2.0 ) ) ;
Util . hitKeys ( robot , KeyEvent . VK_SHIFT , KeyEvent . VK_ESCAPE ) ;
assertTrue ( exceptionType . isAssignableFrom ( e . getCause ( ) . getClass ( ) ) ) ;
assertThrows ( IncompatibleClassChangeError . class , C ) ;
assertInvokeVirtualEquals ( 88 , C ) ;
assertThrows ( IncompatibleClassChangeError . class , C ) ;
assertInvokeVirtualEquals ( 99 , C ) ;
assertInvokeVirtualEquals ( 44 , C ,
< T , R > Collector < T , String , R > m ( Supplier < ? extends R > supplier , BiConsumer < R , T > accumulator ) {
< T , C extends Collection < T > > Collector < T , String , C > test1 ( Supplier < C > collectionFactory ) {
Collector < String , String , StringBuilder > test2 ( Supplier < StringBuilder > sb ) {
< R > Collector < Integer , String , R > m ( Supplier < R > s ) { return null ; }
Collector < T , String , M > g ( Function < T , K > classifier , Supplier < M > mapFactory , Collector < T , String , D > downstream ) { return null ; }
ASTParser parser = ASTParser . newParser ( AST . JLS8 ) ;
ASTParser parser = ASTParser . newParser ( AST . JLS8 ) ;
final ASTParser parser = ASTParser . newParser ( AST . JLS8 ) ;
final ASTParser parser = ASTParser . newParser ( AST . JLS8 ) ;
final ASTParser parser = ASTParser . newParser ( AST . JLS8 ) ;
ASTParser parser = ASTParser . newParser ( AST . JLS8 ) ;
ASTParser parser = ASTParser . newParser ( AST . JLS8 ) ;
ASTParser parser = ASTParser . newParser ( AST . JLS8 ) ;
searchEngine . searchAllTypeNames ( pkg . toCharArray ( ) , SearchPattern . R_PREFIX_MATCH , null ,
qualifiedName = MybatipseXmlUtil . normalizeTypeName ( typeValue ) ;
throws XPathExpressionException , IOException , CoreException
throws JavaModelException , XPathExpressionException
for ( int i = 0 ; i < superclassTypeParams . size ( ) ; i + + )
offset - matchString . length ( ) , parser . getReplacementLength ( ) , "str" , null ) ;
String [ ] arr = value . split ( "str" ) ;
for ( int i = 0 ; i < nodes . getLength ( ) ; i + + )
for ( int i = 0 ; i < nodes . getLength ( ) ; i + + )
annotationHolder . createWarningAnnotation ( range , "str" ) ;
Preconditions . checkNotNull ( block , "str" ) ;
return new PrecompiledTransactionResult ( TransactionStatus . successful ( ) , nrg - COST ) ;
import java . util . ArrayList ;
Blockchain . log ( owner . toByteArray ( ) , "str" . getBytes ( ) ) ;
if ( requestsEnabled ) {
if ( ! oldGenesis . delete ( ) ) {
+ oldGenesis . getAbsolutePath ( )
+ oldGenesis . getAbsolutePath ( )
if ( _bnOrId ! = null & & ! _bnOrId . equals ( JSONObject . NULL ) )
if ( _bnOrId ! = null & & ! _bnOrId . equals ( JSONObject . NULL ) )
if ( _bnOrId ! = null & & ! _bnOrId . equals ( JSONObject . NULL ) )
if ( _bnOrId ! = null & & ! _bnOrId . equals ( JSONObject . NULL ) )
if ( _bnOrId ! = null & & ! _bnOrId . equals ( JSONObject . NULL ) )
if ( _duration ! = null & & ! _duration . equals ( JSONObject . NULL ) )
! nce . equals ( JSONObject . NULL ) & & ! soln . equals ( JSONObject . NULL ) & & ! hdrHash . equals ( JSONObject . NULL ) ) {
if ( _blockNum ! = null & & ! _blockNum . equals ( JSONObject . NULL ) ) {
Optional < Reaction > reaction = reactions . stream ( ) . filter ( r - > emoji . equalsEmoji ( r . getEmoji ( ) ) ) . findAny ( ) ;
Optional < Reaction > reaction = reactions . stream ( ) . filter ( r - > emoji . equalsEmoji ( r . getEmoji ( ) ) ) . findAny ( ) ;
if ( result = = null | | result . getResponse ( ) = = null ) {
if ( ( api . getTimeOffset ( ) ! = null ) | | ( result = = null ) | | ( result . getResponse ( ) = = null ) ) {
public void setSlowmodeDelayInSeconds ( int delay ) {
void setSlowmodeDelayInSeconds ( int delay ) ;
delegate . setSlowmodeDelayInSeconds ( delay ) ;
return new FileContainer ( getUrl ( ) ) . asByteArray ( getApi ( ) ) ;
return new FileContainer ( getUrl ( ) ) . asBufferedImage ( getApi ( ) ) ;
. map ( DiscordEntity : : getIdAsString ) . orElse ( "str" ) + "str" + newVal . asText ( ) + "str" ) ) : null ;
author . put ( "str" , "str" + authorIconContainer . getFileTypeOrName ( ) ) ;
. dispatchEvent ( null , listeners , listener - > listener . onLostConnection ( lostConnectionEvent ) ) ;
. dispatchEvent ( null , listeners , listener - > listener . onResume ( resumeEvent ) ) ;
. dispatchEvent ( null , listeners , listener - > listener . onReconnect ( reconnectEvent ) ) ;
public void setTimestampToNow ( ) {
throw new UnsupportedOperationException ( ) ;
( System . currentTimeMillis ( ) - lastIdentificationPerAccount . getOrDefault ( token , 0 L ) > = 15000 ) ) {
. orElse ( null ) ,
baseUrl = ( baseUrl = = null ) ? "str" : baseUrl ;
return Instant . ofEpochMilli ( ( getId ( ) > > > 22 ) + 1420070400000L ) ;
api . removeUnavailableServerFromCache ( id ) ;
public void removeUnavailableServerFromCache ( long serverId ) {
REACTION ( "str" , 0 , 250 ) ,
. orElseGet ( ( ) - > Long . parseLong ( result . getResponse ( ) . header ( "str" , "str" ) ) * 1000 ) ;
this . avatarId = data . has ( "str" ) & & ! data . isNull ( "str" ) ? data . getString ( "str" ) : null ;
msgArray = history . request ( ( limit % 100 ) = = 0 ? 100 : limit % 100 , before , after , - 1 ) . join ( ) ;
logger . debug ( "str" + timeOffset + "str" ) ;
future . completeExceptionally ( new IllegalArgumentException ( "str" ) ) ;
api . getThreadPool ( ) . getSingleThreadExecutorService ( "str" ) . submit ( new Runnable ( ) {
Thread . sleep ( 1500 ) ;
throw new IllegalArgumentException ( "str" + response . getStatusText ( ) + "str" + response . getBody ( ) ) ;
if ( role . getHoist ( ) ! = roleJson . getBoolean ( "str" ) ) {
Window firstWindow = windowControl . getWindowRepository ( ) . getFirstVisibleWindow ( ) ;
private static final String NIGHT_HEADER = "str" + NIGHT_STYLESHEET + "str" ;
object . put ( "str" , getKey ( ) . getOsisID ( ) ) ;
osisToHtmlParameters . setShowNotes ( preferences . getBoolean ( "str" , false ) ) ;
documentDownloadProgressItem . updateListItemDisplay ( initials ) ;
documentDownloadProgressItem . updateListItemDisplay ( document . getInitials ( ) ) ;
private void updateListItemDisplay ( final String initials , final int percentDone ) {
listItem . setProgressPercent ( initials , percentDone ) ;
osisInputStream = new OSISInputStream ( book , book . getKey ( "str" ) ) ;
String name = entry . getName ( ) . replace ( "str" , "str" ) ;
String name = ze . getName ( ) . replace ( "str" , "str" ) ;
linksWindow . initialisePageStateIfClosed ( getActiveWindow ( ) ) ;
return createTextButton ( "str" + "str" , new OnClickListener ( ) {
private static final long INITIALISE_DELAY = 3000 ;
isSpeakMode ( ) ;
mSeekBar . setMax ( mMax - mMin ) ;
private static final String VERSE_CONTEXT_MENU_BUTTON_PREFERENCE_KEY = "str" ;
public void orientationChange ( ) {
splitScreenControl . orientationChange ( ) ;
log . error ( "str" + reference ) ;
private boolean isAutoWrapUnwrappedRefsInNote = false ;
FormattedDocument formattedDocument = SwordContentFacade . getInstance ( ) . readHtmlText ( book , key ) ;
System . out . println ( SwordContentFacade . getInstance ( ) . readHtmlText ( bookg , wordKey ) . getHtmlPassage ( ) ) ;
FormattedDocument formattedDocument = SwordContentFacade . getInstance ( ) . readHtmlText ( book , key ) ;
FormattedDocument formattedDocument = SwordContentFacade . getInstance ( ) . readHtmlText ( book , key ) ;
List < Book > bibles = new BookInstaller ( ) . getRepositoryBooks ( "str" , BookFilters . getAll ( ) ) ;
return ! document . getInitials ( ) . equals ( "str" ) | |
return search . replace ( "str" , "str" ) . replace ( "str" , "str" ) . trim ( ) ;
if ( position > = 0 & & position < displayedDocuments . size ( ) ) {
if ( history . size ( ) > 0 ) {
public void reportException ( final ReporterEvent ev ) {
private static final String COMMUNITY_URL = "str" ;
setTheme ( Status . Theme . ACTIVITY_NORMAL . getTheme ( this ) ) ;
builder . addAction ( R . drawable . ic_notification_color , service . getString ( R . string . action_set_color ) , PendingIntent . getActivity ( service , 0 , colorIntent , PendingIntent . FLAG_CANCEL_CURRENT ) ) ;
builder . addAction ( R . drawable . ic_notification_settings , service . getString ( R . string . action_app_settings ) , PendingIntent . getActivity ( service , 0 , settingsIntent , PendingIntent . FLAG_CANCEL_CURRENT ) ) ;
normalButton . setChecked ( preference = = null | | preference . length ( ) = = 0 ) ;
scaledIcon = Bitmap . createScaledBitmap ( icon , Math . round ( height * icon . getWidth ( ) / icon . getHeight ( ) ) , Math . round ( height ) , true ) ;
matrix . postTranslate ( x + ( ( scaledIconSize - bitmap . getWidth ( ) ) / 2 ) , ( ( float ) canvas . getHeight ( ) - scaledIconSize ) / 2 ) ;
STATUS_SIDE_PADDING ( 6 ) ,
import com . james . status . views . ColorView ;
String string = item . toString ( ) ;
Glide . with ( this ) . load ( "str" ) . into ( jamesImage ) ;
Glide . with ( AboutActivity . this ) . load ( "str" ) . into ( jamesImage ) ;
findViewById ( R . id . jamesWebsite ) . setOnClickListener ( new UrlClickListener ( "str" ) ) ;
Glide . with ( this ) . load ( "str" ) . into ( ( ImageView ) findViewById ( R . id . anasImage ) ) ;
Glide . with ( this ) . load ( "str" ) . into ( ( ImageView ) findViewById ( R . id . vukImage ) ) ;
Glide . with ( this ) . load ( "str" ) . into ( ( ImageView ) findViewById ( R . id . ghostImage ) ) ;
findViewById ( R . id . policy ) . setOnClickListener ( new UrlClickListener ( "str" ) ) ;
FAQ_URL = "str" ,
if ( textEffect = = null ) textEffect = Typeface . BOLD ;
removeAllViews ( ) ;
if ( packageManager ! = null & & packageName ! = null & & packageName . length ( ) > 0 & & className ! = null & & className . length ( ) > 0 ) {
wifiManager = ( WifiManager ) getContext ( ) . getApplicationContext ( ) . getSystemService ( Context . WIFI_SERVICE ) ;
icon . onDrawableUpdate ( WifiManager . calculateSignalLevel ( icon . wifiManager . getConnectionInfo ( ) . getRssi ( ) , 5 ) ) ;
public abstract class SimpleFragment extends Fragment {
int iconLevel = ( int ) ( ( ( float ) level / scale ) * 7 ) + 1 ;
if ( status = = BatteryManager . BATTERY_STATUS_CHARGING )
int iconLevel = ( int ) ( ( ( float ) level / scale ) * 7 ) + 1 ;
if ( status = = BatteryManager . BATTERY_STATUS_CHARGING )
getNotifications ( ) . put ( notification . getKey ( ) , notification ) ;
getNotifications ( ) . remove ( notification . getKey ( ) ) ;
appbar . setExpanded ( true ) ;
appbar . setExpanded ( true ) ;
if ( hasText ( ) ) onTextUpdate ( String . valueOf ( ( ( double ) level / scale ) * 100 ) + "str" ) ;
if ( hasText ( ) ) onTextUpdate ( String . valueOf ( ( ( double ) level / scale ) * 100 ) + "str" ) ;
if ( permission . length ( ) > 0 & & ! permission . matches ( Manifest . permission . SYSTEM_ALERT_WINDOW ) & & ! permission . matches ( Manifest . permission . GET_TASKS ) )
} catch ( PackageManager . NameNotFoundException | NullPointerException e ) {
Boolean ringer = PreferenceUtils . getBooleanPreference ( this , PreferenceUtils . PreferenceIdentifier . SHOW_RINGER_ICON ) ;
setStatusBar ( color , true ) ;
Intent intent = new Intent ( StatusService . ACTION_STOP ) ;
Intent intent = new Intent ( StatusService . ACTION_START ) ;
result . sourceFolder = resource . getFullPath ( ) . removeLastSegments ( 1 ) . toString ( ) ;
String source = entry . getPath ( ) . toString ( ) ;
String formatter = "str" ;
private static final List < String > FEATURE_ELEMENT_KEYWORD_KEYS = Arrays . asList ( "str" , "str" , "str" , "str" , "str" ) ;
. user ( Optional . ofNullable ( user ) . orElse ( "str" ) )
. user ( Optional . ofNullable ( user ) . orElse ( "str" ) )
defaults . put ( "str" , "str" ) ;
. setPageSize ( limit )
@RequestMapping ( method = RequestMethod . GET )
@ApiParam ( example = "str" , value = "str" ) @RequestParam Long step ,
public static class MetricSetScope {
protected String canaryConfigId ;
filter + = "str" + customFilter ;
@ApiParam ( defaultValue = "str" ) @RequestParam String scope ,
String ret = "str" + experimentName + "str" + controlName ;
Assert . assertEquals ( "str" , status . getCode ( ) ) ;
client . setClientSecret ( HashUtil . generateStrongPasswordHash ( clientSecret ) ) ;
String hashedPass = HashUtil . generateStrongPasswordHash ( password ) ;
String hashedPass = HashUtil . generateStrongPasswordHash ( newPassword ) ;
request . getRequestHeaders ( ) . put ( Headers . HOST , "str" ) ;
request . getRequestHeaders ( ) . put ( Headers . HOST , config . host ) ;
import com . networknt . security . JwtIssuer ;
JwtClaims claims = JwtIssuer . getDefaultJwtClaims ( ) ;
String jwt = JwtIssuer . getJwt ( claims ) ;
import com . networknt . security . JwtIssuer ;
jwt = JwtIssuer . getJwt ( mockCcClaims ( client . getClientId ( ) , scope , customMap ) ) ;
jwt = JwtIssuer . getJwt ( mockAcClaims ( client . getClientId ( ) , scope , userId , user . getUserType ( ) . toString ( ) , customMap ) ) ;
String jwt = JwtIssuer . getJwt ( mockAcClaims ( client . getClientId ( ) , scope , userId , user . getUserType ( ) . toString ( ) , customMap ) ) ;
jwt = JwtIssuer . getJwt ( mockAcClaims ( client . getClientId ( ) , scope , userId , user . getUserType ( ) . toString ( ) , customMap ) ) ;
jwt = JwtIssuer . getJwt ( mockAcClaims ( client . getClientId ( ) , scope , userId , userType , formMap ) ) ;
JwtClaims claims = JwtIssuer . getDefaultJwtClaims ( ) ;
JwtClaims claims = JwtIssuer . getDefaultJwtClaims ( ) ;
ClientRequest request = new ClientRequest ( ) . setMethod ( Methods . DELETE ) . setPath ( "str" ) ;
Assert . assertTrue ( clients . size ( ) > = 1 & & clients . size ( ) < = 5 ) ;
@JsonFormat ( shape = JsonFormat . Shape . STRING , pattern = "str" )
@JsonFormat ( shape = JsonFormat . Shape . STRING , pattern = "str" )
@JsonFormat ( shape = JsonFormat . Shape . STRING , pattern = "str" )
SharedPreferenceUtils . putBoolean ( this , "str" , true ) ;
Boolean isInstallCert = SharedPreferenceUtils . getBoolean ( this , "str" , false ) ;
SharedPreferenceUtils . putBoolean ( this , "str" , true ) ;
protected T set ( T parent , T prev , T next ) {
protected void removeChild ( T child ) {
private static final String DEFAULT_WIDTH = "str" ;
setIframeWidth ( DEFAULT_WIDTH ) ;
resp . setContentType ( "str" ) ;
throw new BugInCF ( "str" , type . getKind ( ) , type ) ;
literals = { LiteralKind . PRIMITIVE , LiteralKind . STRING } ,
if ( source ! = that . source ) {
if ( isForNameMethodInvocation ( tree ) ) {
} else if ( isGetClassMethodInvocation ( tree ) ) {
private boolean isForNameMethodInvocation ( MethodInvocationTree tree ) {
private boolean isGetClassMethodInvocation ( MethodInvocationTree tree ) {
if ( isGetConstructorMethodInvocation ( tree ) ) {
} else if ( isGetMethodMethodInvocation ( tree ) ) {
throw new BugInCF ( "str" , e ) ;
@Present Optional < String > ofTestPNn ( String s ) {
public abstract @Nullable Object get ( String a1 , @Nullable Object a2 ) throws IOException ;
handleExistingAnnotations ( annotatedTypeMirror , typeDef ) ;
annotate ( annotatedTypeMirror , annotations ) ;
public void write ( char cbuf [ ] , @IndexOrHigh ( "str" ) int off , @IndexOrHigh ( "str" ) int len ) throws IOException {
public void write ( String str , @IndexOrHigh ( "str" ) int off , @IndexOrHigh ( "str" ) int len ) throws IOException {
public void write ( char cbuf [ ] , @IndexOrHigh ( "str" ) int off , @IndexOrHigh ( "str" ) int len ) throws IOException {
public void write ( String str , @IndexOrHigh ( "str" ) int off , @IndexOrHigh ( "str" ) int len ) throws IOException {
public void write ( char cbuf [ ] , @IndexOrHigh ( "str" ) int off , @IndexOrHigh ( "str" ) int len ) throws IOException {
public void write ( String s , @IndexOrHigh ( "str" ) int off , @IndexOrHigh ( "str" ) int len ) throws IOException {
public void write ( char cbuf [ ] , @IndexOrHigh ( "str" ) int off , @IndexOrHigh ( "str" ) int len ) throws IOException {
protected native Object clone ( Object this ) throws CloneNotSupportedException ;
public void write ( char c [ ] , @IndexOrHigh ( "str" ) int off , @IndexOrHigh ( "str" ) int len ) {
public void write ( String str , @IndexOrHigh ( "str" ) int off , @IndexOrHigh ( "str" ) int len ) {
public void write ( char cbuf [ ] , @IndexOrHigh ( "str" ) int off , @IndexOrHigh ( "str" ) int len ) {
public void write ( String str , @IndexOrHigh ( "str" ) int off , @IndexOrHigh ( "str" ) int len ) {
abstract public void write ( char cbuf [ ] , @IndexOrHigh ( "str" ) int off , @IndexOrHigh ( "str" ) int len ) throws IOException ;
public void write ( String str , @IndexOrHigh ( "str" ) int off , @IndexOrHigh ( "str" ) int len ) throws IOException {
public void write ( char buf [ ] , @IndexOrHigh ( "str" ) int off , @IndexOrHigh ( "str" ) int len ) {
public void write ( String s , @IndexOrHigh ( "str" ) int off , @IndexOrHigh ( "str" ) int len ) {
String [ ] value ( ) ;
String [ ] value ( ) ;
String [ ] value ( ) ;
String [ ] value ( ) ;
public java . lang . reflect . Method getMethod ( String a1 , Class < ? > @Nullable . . . a2 ) throws NoSuchMethodException , SecurityException { throw new RuntimeException ( "str" ) ; }
final TypeMirror wildcardUbType =
if ( types . isSameType ( wildcardUbType , glbType ) ) {
Class < ? > recClass = boxPrimitives ( ValueCheckerUtils . getClassFromType ( typeToCreate ) ) ;
private static Class < ? > boxPrimitives ( Class < ? > type ) {
TypeKind typeKind = unBoxPrimitive ( type ) ;
private static TypeKind unBoxPrimitive ( TypeMirror type ) {
public abstract Number signedShiftRight ( Number right ) ;
public abstract Number unsignedShiftRight ( Number right ) ;
public Number signedShiftRight ( Number right ) {
public Number unsignedShiftRight ( Number right ) {
resultValues . add ( nmLeft . signedShiftRight ( right ) ) ;
resultValues . add ( nmLeft . unsignedShiftRight ( right ) ) ;
NumericalBinaryOps . MULTIPLICATION ,
public Number signedShiftRight ( Number right ) {
public Number unsignedShiftRight ( Number right ) {
public Number signedShiftRight ( Number right ) {
public Number unsignedShiftRight ( Number right ) {
public Number signedShiftRight ( Number right ) {
public Number unsignedShiftRight ( Number right ) {
public Number signedShiftRight ( Number right ) {
public Number unsignedShiftRight ( Number right ) {
public Number signedShiftRight ( Number right ) {
public Number unsignedShiftRight ( Number right ) {
private List < Boolean > calculateConditionalOperator (
calculateConditionalOperator ( n . getOperand ( ) , null , ConditionalOperators . NOT , p ) ;
public static final Class < Character > TYPE = ( Class < Character > ) Class . getPrimitiveClass ( "str" ) ;
n . getLeftOperand ( ) , n . getRightOperand ( ) , NumericalBinaryOps . ADDITION , p ) ;
private List < Number > calculateNumericalBinaryOp (
listStrBuilder . append ( "str" ) ;
FuncB funcB3 = References : : aMethod3 ;
if ( param . getTypeBound ( ) . size ( ) > 1 ) {
checker . report ( e . getResult ( ) , methodTree ) ;
for ( int i = 0 ; i < n ; i + + ) {
String importEnd = importSplit [ importSplit . length - 1 ] ;
return importName . substring ( 0 , importName . length ( ) - 1 ) + className ;
if ( ! classSplit [ i - n ] . equals ( importSplit [ i ] ) ) {
import org . checkerframework . checker . signedness . SignednessUtil ;
ErrorReporter . errorAbort ( "str" ) ;
checker . userErrorAbort ( checker . getClass ( ) . getSimpleName ( ) + "str" + annoName + "str" ) ;
@ImplicitFor ( stringPatterns = "str" )
stubAlwaysWarn ( String . format ( "str" ,
+ "str" + p1 . parameter_index + "str" + p2 . parameter_index + "str"
+ "str" + methods . toString ( )
+ "str" + method . toString ( )
if ( useUncheckedCodeDefault ( "str" ) ) {
if ( hasOption ( "str" ) ) {
if ( elt = = null | | ! hasOption ( "str" ) )
checker . hasOption ( "str" ) ) {
checker . hasOption ( "str" ) ) & &
@TADescription ( annotation = "str" , type = FIELD , genericLocation = { 3 , 0 } ) ,
@TADescription ( annotation = "str" , type = FIELD , genericLocation = { 3 , 0 } ) ,
Set < AnnotatedTypeMirror > visited = Collections . newSetFromMap ( new IdentityHashMap < AnnotatedTypeMirror , Boolean > ( ) ) ;
Set < AnnotatedTypeMirror > visited ,
if ( visited . contains ( alub ) ) {
visited . add ( alub ) ;
BoundsInitializer . initializeBounds ( this ) ;
BoundsInitializer . initializeBounds ( this ) ;
public static void initializeBounds ( final AnnotatedTypeVariable typeVar ) {
private < T extends Enum < T > > T getEnumValue ( Class < T > enumType , String name ) {
lowerBound = ( ( AnnotatedTypeVariable ) type ) . getLowerBound ( ) ;
protected AnnotatedTypeFormatter typeFormatter ;
if ( asSuperType ! = null & & isEnum ( asSuperType ) & & isDeclarationOfJavaLangEnum ( types , elements , supertype ) ) {
public void applyInferredType ( final QualifierHierarchy qualifierHierarchy ,
protected static class InferredTypeApplyingVisitor extends AbstractAtmComboVisitor < Void , AnnotationMirror > {
new DefaultInferredTypesApplier ( ) . applyInferredType ( getQualifierHierarchy ( ) , type , as . getType ( ) ) ;
if ( ! checkExpressionAllowed ( tree , expr , flowExprContext ) | |
public @interface StaticallyExecutable {
return dirname + System . getProperty ( "str" ) + filename ;
"str" + jdkJarName ) ;
for ( int i = 0 ; i < one . length ; i + + ) {
for ( int i = 0 ; i < count ; i + + ) {
for ( int i = 0 ; i < values . length ; i + + ) {
public static final Creator < RestrictionEntry > CREATOR = new Creator < RestrictionEntry > ( ) {
return "str" + type + "str" + key + "str" + currentValue + "str" ;
checkContractsSubset ( overriderTyp , overriddenTyp , superPost2 , subPost2 , "str" ) ;
checkContractsSubset ( overriderTyp , overriddenTyp , subPre2 , superPre2 , "str" ) ;
checkContractsSubset ( overriderTyp , overriddenTyp , superCPostTrue2 , subCPostTrue2 ,
checkContractsSubset ( overriderTyp , overriddenTyp , superCPostFalse2 , subCPostFalse2 ,
private void checkContractsSubset ( String subCl , String superCl , Set < Pair < Receiver , AnnotationMirror > > mustSubset ,
. getName ( ) . toString ( ) , subCl , superCl ) , method ) ;
AbstractNullnessChecker . LINT_NOINITFORMONOTONICNONNULL ,
if ( TreeUtils . isMethodInvocation ( invok , method , processingEnv ) ) {
public @PolyRead Throwable ( String message , @PolyRead Throwable cause ) {
public @PolyRead Throwable ( @PolyRead Throwable cause ) {
@PolyRead SubList ( @PolyRead AbstractList < E > list , int fromIndex , int toIndex ) { throw new RuntimeException ( "str" ) ; }
@PolyRead RandomAccessSubList ( @PolyRead AbstractList < E > list , int fromIndex , int toIndex ) { throw new RuntimeException ( "str" ) ; }
public @PolyRead Vector ( @PolyRead Collection < ? extends E > a1 ) { throw new RuntimeException ( ( "str" ) ) ; }
public Date ( int time ) {
Point ( double x , double y ) {
TestClass ( ) {
Fields ( ) { }
Fields ( int arg ) {
public Observable ( ) { throw new RuntimeException ( "str" ) ; }
protected ServiceLoader ( ) { }
protected AbstractList ( ) { }
public Dictionary ( ) { throw new RuntimeException ( "str" ) ; }
protected AbstractSequentialList ( ) { }
public Stack ( ) { throw new RuntimeException ( "str" ) ; }
public UUID ( long a1 , long a2 ) { throw new RuntimeException ( "str" ) ; }
public @PolyRead HashMap ( @PolyRead Map < ? extends K , ? extends V > m ) { throw new RuntimeException ( "str" ) ; }
public class FormattableFlags {
private FormattableFlags ( ) { }
public @PolyRead LinkedList ( @PolyRead Collection < ? extends E > a1 ) { throw new RuntimeException ( ( "str" ) ) ; }
public @PolyRead Hashtable ( @PolyRead Map < ? extends K , ? extends V > a1 ) { throw new RuntimeException ( ( "str" ) ) ; }
public @PolyRead IdentityHashMap ( @PolyRead Map < ? extends K , ? extends V > a1 ) { throw new RuntimeException ( ( "str" ) ) ; }
public EventListenerProxy ( @I EventListener a1 ) { throw new RuntimeException ( "str" ) ; }
public @PolyRead WeakHashMap ( @PolyRead Map < ? extends K , ? extends V > a1 ) { throw new RuntimeException ( ( "str" ) ) ; }
Constructors ( ) {
Constructors ( int a ) {
public @PolyRead File ( @PolyRead File parent , String child ) {
protected Currency ( ) { }
public @AssignsFields PropertyPermission ( String a1 , String a2 ) { super ( a1 ) ; throw new RuntimeException ( "str" ) ; }
public @AssignsFields TimeZone ( ) { throw new RuntimeException ( "str" ) ; }
protected Calendar ( ) { }
protected AbstractCollection ( ) { }
protected AbstractMap ( ) { }
protected URLConnection ( @ReadOnly URL url ) {
protected AbstractQueue ( ) { }
protected Collections ( ) { }
protected AbstractSet ( ) { }
public @PolyRead ArrayDeque ( @PolyRead Collection < ? extends E > a1 ) { throw new RuntimeException ( ( "str" ) ) ; }
protected TimerTask ( ) { }
public ListResourceBundle ( ) { throw new RuntimeException ( "str" ) ; }
public ListNode ( int length ) {
type . replaceAnnotation ( annoMirror ) ;
if ( suppressWarningValue . equalsIgnoreCase ( swKey ) )
if ( expected . toLowerCase ( ) . contains ( suppressWarningValue . toLowerCase ( ) ) )
( ifTrue ? "str" : "str" ) ,
return pse . getMessage ( ) ;
AnnotationMirror createRegexAnnotation ( int groupCount ) {
checker . getLintOption ( "str" , true ) ) {
SourceChecker . errorAbort ( "str" + tree ) ;
SourceChecker . errorAbort ( "str" + var . getReturnType ( ) ) ;
SourceChecker . errorAbort ( "str" + var . getReturnType ( ) ) ;
SourceChecker . errorAbort ( "str" + var . getReturnType ( ) ) ;
SourceChecker . errorAbort ( "str" + expectedType ) ;
SourceChecker . errorAbort ( "str" + expectedType +
SourceChecker . errorAbort ( "str" + expectedType ) ;
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . Nullable . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( NonNull . class )
@checkers.quals.DefaultQualifier ( NonNull . class )
@checkers.quals.DefaultQualifier ( Nullable . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( Nullable . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . Nullable . class )
@DefaultQualifiers ( @DefaultQualifier ( value = NonNull . class , locations = { DefaultLocation . ALL } ) )
@DefaultQualifier ( value = NonNull . class , locations = { DefaultLocation . ALL } )
@DefaultQualifier ( value = NonNull . class , locations = { DefaultLocation . ALL } )
@DefaultQualifier ( value = checkers . nullness . quals . NonNull . class , locations = { DefaultLocation . ALL } )
@DefaultQualifier ( value = NonNull . class )
@DefaultQualifier ( value = NonNull . class )
@checkers.quals.DefaultQualifier ( Nullable . class )
@checkers.quals.DefaultQualifier ( Nullable . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( Nullable . class )
@checkers.quals.DefaultQualifier ( Nullable . class )
@DefaultQualifier ( NonNull . class )
@DefaultQualifier ( NonNull . class )
@checkers.quals.DefaultQualifier ( Nullable . class )
@DefaultQualifier ( NonNull . class )
@checkers.quals.DefaultQualifier ( Nullable . class )
@checkers.quals.DefaultQualifier ( Nullable . class )
@DefaultQualifier ( Nullable . class )
@DefaultQualifier ( value = Nullable . class , locations = DefaultLocation . UPPER_BOUNDS )
@checkers.quals.DefaultQualifier ( Nullable . class )
@DefaultQualifier ( value = Odd . class , locations = { DefaultLocation . UPPER_BOUNDS } )
@checkers.quals.DefaultQualifier ( SwingVerticalOrientation . class )
public AnnotationMirror aliasedAnnotation ( AnnotationMirror a ) {
TypeElement elem = ( TypeElement ) a . getAnnotationType ( ) . asElement ( ) ;
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
super ( ) ;
super ( s ) ;
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
@checkers.quals.DefaultQualifier ( checkers . nullness . quals . NonNull . class )
void use1 ( @H1S2 @H2S1 int p ) {
void use2 ( @H1S2 @H2S2 int p ) {
assert false : "str" + tree ;
assert flowState ! = null : "str" + tree ;
assert elt ! = null : "str" + node ;
assert var ! = null : "str" + varTree ;
assert arrayTree . getInitializers ( ) ! = null : "str" + valueExp ;
assert valueType ! = null : "str" + valueExp ;
assert var ! = null : "str" + tree ;
assert type ! = null : "str" + tree ;
assert elt ! = null : "str" + lhs ;
assert type ! = null : "str" + rhs ;
assert cls ! = null : "str" + name + "str" ;
public abstract Object check_modified2 ( String [ ] v1 ) ;
throw new SourceChecker . CheckerError ( "str" + lAnnos + "str" + this ) ;
protected QualifierHierarchy createQualifierHierarchy ( ) {
super ( f ) ;
super ( h ) ;
protected static boolean hasGuardedBy ( AnnotatedTypeMirror t ) {
defaults . addAbsoluteDefault ( NONNULL , Collections . singleton ( DefaultLocation . ALL_EXCEPT_LOCALS ) ) ;
import checkers . util . MultiGraphQualifierHierarchy ;
void testWithExplicitNullable ( Cell < @Nullable ? extends @Nullable String > cell ) {
void testWithDoubleNullable ( Cell < @Nullable ? extends @Nullable String > cell ) {
KeyForVisitor . this . checker . report (
throw new Error ( String . format ( "str" , decl , elt , elt . getClass ( ) , type , type . getClass ( ) , typeParameters . size ( ) , typeParameters , typeArguments . size ( ) , typeArguments ) ) ;
throw new Error ( String . format ( "str" , decl , elt , elt . getClass ( ) , type , type . getClass ( ) , typeParameters . size ( ) , type , type . getClass ( ) , typeParameters , typeArguments . size ( ) , typeArguments ) ) ;
System . out . printf ( "str" , elt , decl , ( ( decl = = null ) ? "str" : decl . toString ( ) ) ) ;
super ( testFile , "str" , "str" , "str" , "str" , "str" , "str" ) ;
super ( testFile , "str" , "str" , "str" , "str" , "str" ) ;
& & checker . getLintOption ( "str" , NullnessSubchecker . NULLTEST_DEFAULT ) ) {
if ( checker . getLintOption ( "str" , NullnessSubchecker . UNINIT_DEFAULT ) ) {
if ( ! checker . getLintOption ( "str" , NullnessSubchecker . UNINIT_DEFAULT ) )
super ( testFile , "str" , "str" , "str" , "str" ) ;
if ( checker . getLintOption ( "str" , true ) ) {
if ( ! checker . getLintOption ( "str" , true ) )
super ( testFile , "str" , "str" , "str" , "str" , "str" ) ;
constructor . toString ( ) , dt , constructor . getReceiverType ( ) ) , src ) ;
throw new IllegalArgumentException ( "str" + a ) ;
throw new AssertionError ( typeQualifier + "str" ) ;
@Fenum ( "str" ) int state1 = new TestPrimitive ( ) . ACONST1 ;
public final class Void {
annotateParameters ( methodType . getTypeVariables ( ) , decl . getTypeParameters ( ) ) ;
public synchronized @PolyRaw java . lang . Throwable initCause ( @Nullable java . lang . Throwable a1 ) @PolyRaw { throw new RuntimeException ( "str" ) ; }
public @PolyNull T cast ( @PolyNull java . lang . Object a1 ) { throw new RuntimeException ( "str" ) ; }
public @PolyRead T cast ( @PolyRead Object obj ) {
if ( ! options . containsKey ( "str" ) )
if ( param . getTypeBound ( ) ! = null & & param . getTypeBound ( ) . size ( ) = = 1 ) {
return aliases = = null ? null : aliases . get ( qualName ) ;
sb . append ( "str" ) ;
return getDualPolSrcBands ( srcProduct , getComplexBandNames ( ) , sourceProductType ) ;
return getDualPolSrcBands ( srcProduct , getComplexBandNames ( ) , sourceProductType ) ;
return getDualPolSrcBands ( srcProduct , getComplexBandNames ( ) , sourceProductType ) ;
if ( isGRD ) {
public String [ ] getFormatFileExtensions ( ) {
public String [ ] getFormatFileExtensions ( ) {
public static String [ ] getFormatFileExtensions ( ) {
public String [ ] getFormatFileExtensions ( ) {
public static String [ ] getFormatFileExtensions ( ) {
public String [ ] getFormatFileExtensions ( ) {
String [ ] getFormatFileExtensions ( ) ;
return TerraSarXConstants . getFormatFileExtensions ( ) ;
setExtensions ( TerraSarXConstants . getFormatFileExtensions ( ) ) ;
public String [ ] getFormatFileExtensions ( ) {
return Radarsat2Constants . getFormatFileExtensions ( ) ;
setExtensions ( Radarsat2Constants . getFormatFileExtensions ( ) ) ;
return Sentinel1Constants . getFormatFileExtensions ( ) ;
setExtensions ( Sentinel1Constants . getFormatFileExtensions ( ) ) ;
return constants . getFormatFileExtensions ( ) ;
return SeaSatConstants . getFormatFileExtensions ( ) ;
setExtensions ( SeaSatConstants . getFormatFileExtensions ( ) ) ;
public String [ ] getFormatFileExtensions ( ) {
public static String [ ] getFormatFileExtensions ( ) {
public static String [ ] getFormatFileExtensions ( ) {
AbstractMetadata . setAttribute ( absRoot , AbstractMetadata . srgr_flag , productType . equals ( "str" ) ? 0 : 1 ) ;
@ActionID ( category = "str" , id = "str" )
String nameUp = name . toUpperCase ( ) ;
if ( nameUp . startsWith ( prefix ) | | nameUp . endsWith ( "str" + prefix ) ) {
if ( validator . isComplex ( ) & & validator . isTOPSARProduct ( ) & & validator . isDebursted ( ) ) {
isTOPSARBurstProduct = validator . isTOPSARProduct ( ) & & ! validator . isDebursted ( ) ;
isTOPSARBurstProduct = validator . isTOPSARProduct ( ) & & ! validator . isDebursted ( ) ;
throw new OperatorException ( "str" ) ;
for ( int i = 0 ; i < numSeeds ; i + + ) {
d = numSeeds ;
if ( masterBandI ! = null & & masterBandI . isNoDataValueUsed ( ) ) {
slave . getSlaveMetadata ( ) . getAbstractedMetadata ( ) . getProduct ( ) ) . substring ( 1 ) ) ;
private ProductData . UTC dateDay ;
category = "str" ,
name = name . replace ( "str" , "str" ) ;
name = name . replace ( "str" , "str" ) ;
if ( spatialAverage ) {
final JCheckBox spatialAverageCheckBox = new JCheckBox ( "str" ) ;
private Boolean spatialAverage = true ;
spatialAverageCheckBox . addItemListener ( new ItemListener ( ) {
spatialAverage = ( e . getStateChange ( ) = = ItemEvent . SELECTED ) ;
paramMap . put ( "str" , spatialAverage ) ;
contentPane . add ( spatialAverageCheckBox , gbc ) ;
subSwathInfo [ subSwathIndex - 1 ] . latitude [ lastBurstIndex ] [ 0 ] ) ;
subSwathInfo [ subSwathIndex - 1 ] . longitude [ lastBurstIndex ] [ 0 ] ) ;
subSwathInfo [ subSwathIndex - 1 ] . latitude [ lastBurstIndex ] [ cols - 1 ] ) ;
subSwathInfo [ subSwathIndex - 1 ] . longitude [ lastBurstIndex ] [ cols - 1 ] ) ;
cohWinAz . setText ( "str" ) ;
cohWinAz . setText ( "str" ) ;
@Parameter ( description = "str" , defaultValue = "str" ,
private Boolean outputIntensity = false ;
if ( Double . compare ( pixM , pixMSaved ) ! = 0 ) {
if ( Double . compare ( pixD , pixDSaved ) ! = 0 ) {
expression . append ( "str" ) ;
return "str" + mean2 ( sourceBands ) + "str" + "str" + mean ( sourceBands ) + "str" ;
return "str" + mean4 ( sourceBands ) + "str" + "str" + m2 + "str" + m2 ;
private static final String [ ] FORMAT_NAMES = { "str" , "str" , "str" , "str" , "str" } ;
final String [ ] exclude = { "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" } ;
slavePos . x = xCoeffs [ 0 ] + xCoeffs [ 1 ] * mX + xCoeffs [ 2 ] * mY ;
slavePos . y = yCoeffs [ 0 ] + yCoeffs [ 1 ] * mX + yCoeffs [ 2 ] * mY ;
slavePos . x = xCoeffs [ 0 ] + xCoeffs [ 1 ] * mX + xCoeffs [ 2 ] * mY +
xCoeffs [ 6 ] * mXmX * mX + xCoeffs [ 7 ] * mX * mXmY + xCoeffs [ 8 ] * mXmY * mY + xCoeffs [ 9 ] * mYmY * mY ;
slavePos . y = yCoeffs [ 0 ] + yCoeffs [ 1 ] * mX + yCoeffs [ 2 ] * mY +
yCoeffs [ 6 ] * mXmX * mX + yCoeffs [ 7 ] * mX * mXmY + yCoeffs [ 8 ] * mXmY * mY + yCoeffs [ 9 ] * mYmY * mY ;
final double threshold50 = ( 2.0 / 3.0 ) * sigmaV ;
final double threshold95 = 2.0 * sigmaV ;
@HelpSetRegistration ( helpSet = "str" , position = 5320 ) package org . esa . s1tbx . analysis . docs ;
return tAzi1 + ( line - 1 ) * lineTimeInterval ;
op . SetFilter ( "str" ) ;
sigma = Ks * Math . abs ( dn2 - tileNoise [ y - y0 ] [ x - x0 ] ) * FastMath . sin ( inciAng ) ;
import org . esa . snap . core . dataop . downloadable . FtpUtils ;
import org . esa . snap . core . dataop . downloadable . FtpUtils ;
protected FtpUtils ftp = null ;
protected static void getRemoteFiles ( final FtpUtils ftp , final Map < String , Long > fileSizeMap ,
import org . esa . snap . core . dataop . downloadable . FtpUtils ;
if ( deNoisedDataValue < trimThreshold | | coPolDataValue < 30 ) {
rightBorder = sourceImageWidth - borderLimit + ( int ) ( peakPos * 0.8 ) ;
final int xEd = Math . min ( x + halfWindowSizeX , sourceTiles [ 0 ] . getMaxX ( ) ) ;
final int yEd = Math . min ( y + halfWindowSizeY , sourceTiles [ 0 ] . getMaxY ( ) ) ;
orbitPath + = folder ;
if ( reGridMethod ! = null & & reGridMethod ) {
reader . setInput ( stream , false , true ) ;
double [ ] [ ] simulatedImage = null ;
throw new OperatorException ( "str" ) ;
overlapPercentages [ 0 ] = 1.0 ;
overlapPercentages [ 1 ] = 1.0 ;
overlapPercentages [ 0 ] = 1.0 ;
overlapPercentages [ 1 ] = 1.0 ;
final String bandName , final String bandPolar , final Unit . UnitType bandUnit , final int [ ] subSwathIndex ) {
final String bandName , final String bandPolar , final Unit . UnitType bandUnit , int [ ] subSwathIndex ) {
final String bandName , final String bandPolar , final Unit . UnitType bandUnit , int [ ] subSwathIndex ) {
final String bandName , final String bandPolar , final Unit . UnitType bandUnit , int [ ] subSwathIndex ) {
localIncidenceAngles [ 1 ] , tileData . bandName , tileData . bandPolar , tileData . bandUnit , subSwathIndex ) ;
final String bandName , final String bandPolar , final Unit . UnitType bandUnit , int [ ] subSwathIndex ) {
final String bandName , final String bandPolar , final Unit . UnitType bandUnit , int [ ] subSwathIndex ) {
final String bandName , final String bandPolar , final Unit . UnitType bandUnit , int [ ] subSwathIndex ) {
final String bandName , final String bandPolar , final Unit . UnitType bandUnit , int [ ] subSwathIndex ) ;
localIncidenceAngles [ 1 ] , tileData . bandName , tileData . bandPolar , bandUnit , subSwathIndex ) ;
private double dn0 = 1.0 ;
final String path = base + "str" + File . separator + mission . toLowerCase ( ) + File . separator + fileName ;
maxIteration = Integer . parseInt ( testPreferences . get ( "str" , "str" ) ) ;
final Path xcaFileDir = moduleBasePath . resolve ( "str" ) ;
if ( orbitType . startsWith ( RESTITUTED ) ) {
if ( orbitType . startsWith ( RESTITUTED ) ) {
sourceProductType ! = PolBandUtils . MATRIX . DUAL_VH_VV & &
preferredID = "str" ,
@ActionID ( category = "str" , id = "str" )
subSwathInfo [ subSwathIndex - 1 ] . azimuthTimeInterval * Constants . secondsInDay ) ;
final String path = homeUrl + File . separator + "str" + File . separator + "str" + File . separator + fileName ;
final String path = homeUrl + File . separator + "str" + File . separator + "str" +
final File imgFile = new File ( homeFolder , "str" + File . separator + "str" ) ;
processingInformationElem . getAttribute ( "str" ) . getData ( ) . setElems ( "str" ) ;
processingInformationElem . getAttribute ( "str" ) . getData ( ) . setElems ( "str" ) ;
private boolean removeNoise = true ;
removeNoise = flag . toLowerCase ( ) . equals ( "str" ) ;
if ( removeNoise ) {
final double noise = removeNoise ? eta / A : - eta / A ;
final double tgtValue = srcValue - noise ;
drawer = new PatchDrawer ( new Patch [ ] { } ) ;
final double d = scale ( i , x1 [ i ] ) - scale ( i , x2 [ i ] ) ;
final String prefix = "str" ;
final String prefix = "str" ;
OperatorUtils . catchOperatorException ( op . getId ( ) + "str" , e ) ;
double d0 , d1 , d2 , d3 ;
tree . getSelectionModel ( ) . setSelectionMode ( TreeSelectionModel . DISCONTIGUOUS_TREE_SELECTION ) ;
return ( geoPos . lon + 180.0 ) * DEGREE_RES_BY_NUM_PIXELS_PER_TILEinv ;
return ( 83.0 - geoPos . lat ) * DEGREE_RES_BY_NUM_PIXELS_PER_TILEinv ;
final double pixelLat = ( RASTER_HEIGHT - pixelPos . y ) * DEGREE_RES_BY_NUM_PIXELS_PER_TILE - 83.0 ;
double alt = localDEM [ yy + 1 ] [ xx + 1 ] ;
final int maxShift = ( int ) computeMaxShift ( txMax , ty0 ) ;
private double computeMaxShift ( final int txMax , final int ty0 ) throws Exception {
final TileGeoreferencing tileGeoRef = new TileGeoreferencing ( targetProduct , minX , minY , maxX - minX + 1 , maxY - minY + 1 ) ;
final Rectangle boundary = new Rectangle ( margin , margin , rasterWidth , rasterHeight ) ;
if ( geocoding . isCrossingMeridianAt180 ( ) & & geo . lon < 0 ) {
if ( pixelSpacingInMeter . getText ( ) . isEmpty ( ) ) {
return ( geoPos . lon + 180.0 ) * DEGREE_RES_BY_NUM_PIXELS_PER_TILEinv ;
return RASTER_HEIGHT - ( geoPos . lat + 90.0 ) * DEGREE_RES_BY_NUM_PIXELS_PER_TILEinv ;
final MetadataElement origProdRoot = AbstractMetadata . getOriginalProductMetadata ( targetProduct ) ;
bool ( Preference . Bloom , true ) ;
string ( Preference . LastPlayedTrack , "str" ) ;
root . setBounds ( 0 , 0 , ui . getWidth ( ) , ui . getHeight ( ) ) ;
ltable . defaults ( ) . padLeft ( 5 ) ;
rtable . defaults ( ) . padRight ( 5 ) ;
private Matrix4 invPrj = new Matrix4 ( ) ;
private Matrix4 invPrj = new Matrix4 ( ) ;
ltable . add ( start ) ;
private static final AtlasTmxMapLoader . AtlasTiledMapLoaderParameters mapLoaderParams = new AtlasTmxMapLoader . AtlasTiledMapLoaderParameters ( ) ;
FileHandle [ ] tracks = dirLevels . list ( "str" ) ;
restitution = 0f ;
restitution = 0f ;
difficulty = GameDifficulty . Hard ;
model . setRotation ( rotations [ MathUtils . random ( 0 , 3 ) ] , 0 , 0 , 1f ) ;
int maxRays = 128 ;
public static String versionName = "str" ;
public static String versionName = "str" ;
Level level = new Level ( levelName , scalingStrategy ) ;
public static String versionName = "str" ;
public static String versionName = "str" ;
Messager . show ( "str" + String . format ( "str" , worst . trackTimeSeconds - best . trackTimeSeconds )
"str" + String . format ( "str" , worst . trackTimeSeconds - best . trackTimeSeconds ) + "str" , 3f ,
return this . state . doesSideBlockChestOpening ( world , pos , side ) ;
toAdd . setString ( "str" , pattern . func_190993_b ( ) ) ;
z - = other . z ;
hopper . withProperty ( BlockHopper . FACING , Cardinal . facing ( Cardinal . reverse ( dir ) ) ) ;
furnace . withProperty ( BlockFurnace . FACING , Cardinal . facing ( Cardinal . reverse ( dir ) ) ) ;
import greymerk . roguelike . worldgen . BlockStripes ;
BlockStripes rainbow = new BlockStripes ( ) ;
Spawner . generate ( world , rand , x , y , z ) ;
fillRectHollow ( world , rand , first . getX ( ) , first . getY ( ) , first . getZ ( ) , second . getX ( ) , second . getY ( ) , second . getZ ( ) , blocks , fillAir , replaceSolid ) ;
pb = new ProcessBuilder ( String . format ( "str" , powerShellExecutable ) ) ;
( this . maxWait + this . waitPause + 100 ) , this . waitPause , false ) ;
static final int WAIT_PAUSE = 10 ;
any - > new MappedProperty < Boolean , Boolean > ( checkbox , "str" ,
if ( isDependentSucceeded )
if ( isDependentSucceeded ) {
if ( isDependentSucceeded )
if ( isDependentSucceeded ) {
Controllers . taskDialog ( executor , i18n ( "str" ) ) ;
toolbar . getStyleClass ( ) . add ( "str" ) ;
right . getStyleClass ( ) . add ( "str" ) ;
stackPane . getStyleClass ( ) . add ( "str" ) ;
btnAdd . getStyleClass ( ) . add ( "str" ) ;
btnRefresh . getStyleClass ( ) . add ( "str" ) ;
toolbar . getStyleClass ( ) . add ( "str" ) ;
getStyleClass ( ) . add ( "str" ) ;
hBox . getStyleClass ( ) . add ( "str" ) ;
root . getStyleClass ( ) . addAll ( "str" , "str" ) ;
drawerWrapper . getStyleClass ( ) . add ( "str" ) ;
leftRootPane . getStyleClass ( ) . add ( "str" ) ;
drawerContainer . getStyleClass ( ) . add ( "str" ) ;
contentPlaceHolder . getStyleClass ( ) . add ( "str" ) ;
backNavButton . getStyleClass ( ) . add ( "str" ) ;
closeNavButton . getStyleClass ( ) . add ( "str" ) ;
titleLabel . getStyleClass ( ) . add ( "str" ) ;
refreshNavButton . getStyleClass ( ) . add ( "str" ) ;
btnMin . getStyleClass ( ) . add ( "str" ) ;
btnClose . getStyleClass ( ) . add ( "str" ) ;
pane . getStyleClass ( ) . add ( "str" ) ;
lblUpdateSub . getStyleClass ( ) . add ( "str" ) ;
btnUpdate . getStyleClass ( ) . add ( "str" ) ;
helpSubtitle . getStyleClass ( ) . add ( "str" ) ;
btnExternal . getStyleClass ( ) . add ( "str" ) ;
logButton . getStyleClass ( ) . add ( "str" ) ;
import com . jfoenix . utils . JFXUtilities ;
import com . jfoenix . utils . JFXUtilities ;
import com . jfoenix . utils . JFXUtilities ;
import com . jfoenix . utils . JFXUtilities ;
import com . jfoenix . utils . JFXUtilities ;
import com . jfoenix . utils . JFXUtilities ;
root . setStyle ( "str" ) ;
import com . jfoenix . utils . JFXUtilities ;
import com . jfoenix . utils . JFXUtilities ;
import com . jfoenix . utils . JFXUtilities ;
import com . jfoenix . utils . JFXUtilities ;
import com . jfoenix . utils . JFXUtilities ;
import com . jfoenix . utils . JFXUtilities ;
import com . jfoenix . utils . JFXUtilities ;
import com . jfoenix . utils . JFXUtilities ;
root . setStyle ( "str" ) ;
Color . web ( "str" )
checkbox . selectedProperty ( ) , it - > ! ( boolean ) it , it - > ! ( boolean ) it ) ) ;
public final IntegerProperty downloadType = new SimpleIntegerProperty ( 1 ) ;
return os = = null | | os ! = null & & os . isCurrentOS ( ) ? action : null ;
boolean flag = false ;
file = new RandomAccessFile ( tempFile , "str" ) ;
public List < UserProducer > selectUserProducer ( @Param ( "str" ) long uid , @Param ( "str" ) long tid ) ;
List < UserProducer > userProducerList = null ;
userProducerList = userProducerDao . selectUserProducer ( uid , tid ) ;
return Result . getResult ( userProducerList ) ;
private Cluster [ ] mqClusterArray = new Cluster [ 0 ] ;
Assert . assertFalse ( "str" , modules . isEmpty ( ) ) ;
return new URLClassLoader ( urls . toArray ( new URL [ 0 ] ) , null ) ;
public Rule answer ( InvocationOnMock iom ) {
expectedTokenType = "str" + CheckUtil . getJavadocTokenText (
checker . setClassLoader ( projectClassloader ) ;
private static void appendXmlHeader ( Writer writer ) throws IOException {
private static void appendCheckerModules ( Writer writer , ListMultimap < String , ActiveRule > activeRulesByConfigKey ) throws IOException {
private static void appendXmlFooter ( Writer writer ) throws IOException {
private static void appendModule ( Writer writer , ActiveRule activeRule ) throws IOException {
private static void appendRuleParameters ( Writer writer , ActiveRule activeRule ) throws IOException {
private static void appendModuleProperty ( Writer writer , String propertyKey , String propertyValue ) throws IOException {
private static SMInputFactory initStax ( ) {
private static void activateProperties ( ActiveRule activeRule , Map < String , String > properties ) {
public List getExtensions ( ) {
import reactor . core . publisher . EmitterProcessor ;
import reactor . core . publisher . TopicProcessor ;
private TopicProcessor < Runnable > dispatcher ;
this . dispatcher = TopicProcessor . create (
this . dispatcher = TopicProcessor . share (
protected TopicProcessor < Runnable > getProcessor ( ) {
import reactor . core . publisher . WorkQueueProcessor ;
private WorkQueueProcessor < Runnable > workQueue ;
this . workQueue = WorkQueueProcessor . create (
this . workQueue = WorkQueueProcessor . share (
protected WorkQueueProcessor < Runnable > getProcessor ( ) {
import reactor . core . publisher . ExecutorProcessor ;
protected abstract ExecutorProcessor < Runnable , Runnable > getProcessor ( ) ;
import reactor . core . publisher . TopicProcessor ;
this . processor = TopicProcessor . create ( ) ;
this . processor = TopicProcessor . share ( ) ;
import reactor . core . publisher . TopicProcessor ;
private final TopicProcessor < ApplicationEvent > processor ;
this . processor = TopicProcessor . share ( "str" , backlog ) ;
import reactor . core . error . Exceptions ;
import reactor . core . error . Exceptions . UpstreamException ;
catch ( Exceptions . UpstreamException x ) {
import reactor . rx . subscriber . Control ;
import reactor . core . support . ReactiveState . Pausable ;
import reactor . core . support . wait . YieldingWaitStrategy ;
return EventBus . create ( env , Environment . SHARED ) ;
import reactor . io . net . codec . syslog . SyslogCodec ;
import static reactor . io . routing . JsonPathSelector . jsonPathSelector ;
import reactor . bus . convert . Converter ;
TcpServerSpec spec = new TcpServerSpec ( ( null = = serverImpl ? NettyTcpServer . class : serverImpl ) ) ;
DatagramServerSpec spec = new DatagramServerSpec ( ( null = = serverImpl ? NettyDatagramServer . class : serverImpl ) ) ;
this ( false ) ;
logger . debug ( "str" , serviceId , cl ) ;
logger . debug ( "str" , factoryClassName ) ;
logger . trace ( "str" , factoryId ) ;
logger . debug ( "str" , systemProp ) ;
logger . trace ( "str" , factoryClassName ) ;
import org . apache . commons . cli . DefaultParser ;
cl = new DefaultParser ( ) . parse ( options , args ) ;
import org . apache . commons . cli . DefaultParser ;
cl = new DefaultParser ( ) . parse ( options , args ) ;
import org . apache . commons . cli . DefaultParser ;
cl = new DefaultParser ( ) . parse ( options , args ) ;
System . err . println ( "str" ) ;
. startsWith ( "str" ) )
Collection < String > properties = capture ( "str" ) ;
Collection < String > properties = capture ( "str" ) ;
. startsWith ( "str" ) )
openMainMenu ( profile , ! cheat , false , 1 ) ;
openMainMenu ( profile , ! cheat , false , 1 ) ;
else if ( slimefunItem ! = null & & Slimefun . hasUnlocked ( p , slimefunItem , true ) ) {
import me . mrCookieSlime . CSCoreLibPlugin . general . Inventory . Item . CustomItem ;
builder . append ( CustomItemSerializer . serialize ( item , ItemFlag . MATERIAL , ItemFlag . ITEMMETA_DISPLAY_NAME , ItemFlag . ITEMMETA_LORE ) ) ;
if ( ! e . getEntity ( ) . getCanPickupItems ( ) & & Talisman . checkFor ( e , SlimefunItem . getByName ( "str" ) ) & & ! ( e . getEntity ( ) instanceof Player ) ) {
final String [ ] explosiveblacklist = Slimefun . getItemValue ( "str" , "str" ) ! = null ? ( ( List < String > ) Slimefun . getItemValue ( "str" , "str" ) ) . toArray ( new String [ ( ( List < String > ) Slimefun . getItemValue ( "str" , "str" ) ) . size ( ) ] ) : new String [ ] { "str" , "str" , "str" , "str" , "str" } ;
new String [ ] { "str" } , new Object [ ] { Arrays . asList ( "str" , "str" , "str" , "str" , "str" ) } )
if ( BlockStorage . getInventory ( l ) . getItemInSlot ( slot ) ! = null ) BlockStorage . getInventory ( l ) . replaceExistingItem ( slot , ReactorAccessPort . pushItems ( port . getLocation ( ) , BlockStorage . getInventory ( l ) . getItemInSlot ( slot ) ) ) ;
if ( SlimefunStartup . chance ( 100 , 40 ) ) e . getEnchantsToAdd ( ) . put ( en , SlimefunStartup . randomize ( 3 ) + 1 ) ;
e . getItem ( ) . addUnsafeEnchantment ( Enchantment . LOOT_BONUS_BLOCKS , SlimefunStartup . randomize ( 3 ) + 3 ) ;
if ( c_index < outputlist . size ( ) ) {
( ( Player ) sender ) . getInventory ( ) . addItem ( SlimefunGuide . getItem ( SlimefunStartup . getCfg ( ) . getBoolean ( "str" ) ) ) ;
p . getInventory ( ) . addItem ( SlimefunGuide . getItem ( config . getBoolean ( "str" ) ) ) ;
int md = ( int ) ( month * Math . pow ( 10 , day > = 10 ? 2 : 1 ) + day ) ;
int md = ( int ) ( month * Math . pow ( 10 , day > 10 ? 2 : 1 ) + day ) ;
if ( chooseDate . get ( position ) ! = null )
if ( chooseDays . contains ( dateInit [ 2 ] ) & & ( ! set . contains ( dateInit [ 2 ] ) | | set . isEmpty ( ) ) ) {
while ( ( obj ! = null ) & & ( obj . getLong ( "str" ) ! = start ) ) {
public final static Integer minimumCharsForSync = 0 ;
void fetchAllMessages ( JSONArray result ) {
private void bufferMessagesSinceDate ( JSONArray result , MailboxID mbID , Long sinceDate ) {
void setExistingInboxMessages ( JSONArray inboxMessages ) {
void setExistingSentMessages ( JSONArray sentMessages ) {
void setExistingDraftsMessages ( JSONArray draftMessages ) {
Long getLastMessageDate ( ) {
final String ticker = ( titleString . length ( ) > 20 ) ? titleString . substring ( 0 , 20 ) : titleString ;
for ( Account acct : myAccountList ) {
List < PeriodicSync > syncList = ContentResolver . getPeriodicSyncs ( acct , GeneralSettingsActivity . _accountAuthority ) ;
public OCSMSOwnCloudClient ( final Context context , final Uri serverURI , final String accountName , final String accountPassword ) {
_serverAPIVersion = obj . getInt ( "str" ) ;
catch ( final JSONException e ) {
public ActionableView doesNotContain ( Object text )
public void iSeeAnEmptyLoginForm ( )
while ( cursor ! = null & & cursor . moveToNext ( ) ) {
InputStream photoStream = contentResolver . openInputStream ( contactURI ) ;
private String getPhotoURIFromContactURI ( String contactURIString , String contactId ) {
throw new IllegalStateException ( "str" + leapWeekInMonth
throw new DateTimeException ( "str" + month + "str" + dayOfMonth + "str" ) ;
throw new DateTimeException ( "str" ) ;
public void test_JulianDate_until_JulianDate ( JulianDate julian , LocalDate iso ) {
public void test_LocalDate_until_JulianDate ( JulianDate julian , LocalDate iso ) {
final File tempDir = new File ( shardTempDir ) ;
final File tmpDir = new File ( directory ) ;
final SharedReference < Shard > current = shard . getCopy ( ) ;
final SharedReference < Shard > oldShard = shard . getCopy ( ) ;
final SharedReference < Shard > ref = map . get ( shardName ) . getCopy ( ) ;
final SharedReference < Shard > ref = map . get ( shardName ) . getCopy ( ) ;
final SharedReference < Shard > ref = localShards . get ( dataset ) . get ( shardId ) . getCopy ( ) ;
final SharedReference < Shard > ref = datasetShards . get ( shardName ) . getCopy ( ) ;
docIdStream . reset ( stringTermIterator ) ;
numGroups = service . handleRegroup ( protoRequest . getSessionId ( ) , ImhotepDaemonMarshaller . marshalGroupRemapMessageList ( protoRequest . getRemapRulesList ( ) ) ) ;
ImhotepDaemonMarshaller . marshalRegroupConditionMessageList ( protoRequest . getConditionsList ( ) ) ,
ImhotepDaemonMarshaller . marshalGroupMultiRemapMessageList ( protoRequest . getMultisplitRemapRuleList ( ) ) ,
sendResponse ( responseBuilder . addAllTopTerms ( ImhotepDaemonMarshaller . marshalTermCountList ( topTerms ) ) . build ( ) , os ) ;
public static GroupRemapRule [ ] marshalGroupRemapMessageList ( final List < GroupRemapMessage > protoRemapRules ) {
public static RegroupCondition [ ] marshalRegroupConditionMessageList ( final List < RegroupConditionMessage > protoConditions ) {
public static GroupMultiRemapRule [ ] marshalGroupMultiRemapMessageList ( final List < GroupMultiRemapMessage > protoRemapRules ) {
public static List < TermCountMessage > marshalTermCountList ( final List < TermCount > termCountList ) {
long refillTokens = bandwidth . refillTokens ;
if ( deficit < = refillTokens ) {