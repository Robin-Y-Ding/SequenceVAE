updateViewport ( w , h ) ;
private void updateViewport ( float width , float height ) {
private RectF generateRandomRect ( RectF viewportRect , RectF drawableBounds ) {
Preconditions . checkState ( mAppDelegate instanceof App , "str" , mAppDelegate . getClass ( ) . getName ( ) , App . class . getName ( ) ) ;
private static String computeKey ( ) {
if ( mOnItemClickListener ! = null & & mInfos . size ( ) > 0 ) {
if ( body . contentType ( ) ! = null & & ! body . contentType ( ) . toString ( ) . contains ( "str" ) ) {
isNotAdd = getIntent ( ) . getBooleanExtra ( IS_NOT_ADD_ACTIVITY_LIST , false ) ;
RefWatcher watcher = WEApplication . getRefWatcher ( getActivity ( ) ) ;
gen . writeObjectField ( "str" , event . getFormattedMessage ( ) ) ;
public void should_delegate_setters_to_settings ( ) throws MalformedURLException {
private ElasticsearchProperties properties ;
private ElasticsearchPublisher publisher ;
this . publisher = new ElasticsearchPublisher ( getContext ( ) , sleepTime , maxRetries , index , type , new URL ( url ) , connectTimeout , readTimeout , debug , properties ) ;
public void setProperties ( ElasticsearchProperties properties ) {
assertTrue ( "str" + score , score > 40 ) ;
assertTrue ( "str" + score , score < 20 ) ;
private Item ( List < String > input ) {
fabView . setTranslationZ ( getResources ( ) . getDimensionPixelSize ( R . dimen . fab_elevation ) ) ;
handler . setHandler ( this . createResourceHandler ( true , context . getDirectory ( ) . getCanonicalPath ( ) , null ) ) ;
rootContextHandler . setHandler ( this . createResourceHandler ( false , this . configuration . getBasedir ( ) . getCanonicalPath ( ) , new String [ ] { this . getWelcomeFilePath ( ) } ) ) ;
ContextHandler srcDirContextHandler = contexts . addContext ( "str" + this . configuration . getSrcDirectoryName ( ) , "str" ) ;
"str" + debug + "str" ) ;
return ( Boolean ) driver . executeScript ( "str" ) ;
borderColor = a . getColor ( R . styleable . ColorPanelView_cpv_borderColor , DEFAULT_BORDER_COLOR ) ;
showDialog = a . getBoolean ( R . styleable . ColorPreference_cpv_showDialog , true ) ;
if ( ! HtmlUtils . htmlEscape ( name ) . equals ( name ) ) {
return ( User ) getOne ( "str" , name , "str" , PasswordUtil . encryptPassword ( password ) , "str" , "str" ) ;
if ( table ! = null ) table . close ( ) ;
if ( removed . incrementAndGet ( ) % 1000l = = 0 ) {
acceptedMimeTypes , TupleQueryResultFormat . CSV , exchange . getResponseHeaders ( ) ) ;
acceptedMimeTypes , RDFFormat . NTRIPLES , exchange . getResponseHeaders ( ) ) ;
acceptedMimeTypes , BooleanQueryResultFormat . JSON , exchange . getResponseHeaders ( ) ) ;
addOption ( "str" , "str" , "str" , "str" + HALYARD . STATS_GRAPH_CONTEXT . stringValue ( ) + "str" , false , true ) ;
addOption ( "str" , "str" , "str" , "str" , true , true ) ;
addOption ( "str" , "str" , "str" , "str" , true , true ) ;
new HalyardBulkExport ( ) . run ( new String [ ] { "str" } ) ;
assertEquals ( 0.000001 , sail . statistics . getCardinality ( q4 ) , 0.01 ) ;
assertEquals ( 0.000001 , sail . statistics . getCardinality ( q4 ) , 0.01 ) ;
return super . createStatement ( subject , predicate , object , defaultRdfContext ) ;
return super . createStatement ( subject , predicate , object , overrideRdfContext | | context = = null ? defaultRdfContext : context ) ;
long defaultCardinality = Math . round ( Math . sqrt ( triples ) ) ;
super . meet ( node ) ;
assertEquals ( 0 , ToolRunner . run ( conf , new HalyardBulkDelete ( ) , new String [ ] { "str" , TABLE , "str" , "str" , "str" , "str" , "str" , "str" , "str" , htableDir . toURI ( ) . toURL ( ) . toString ( ) } ) ) ;
addOption ( "str" , "str" , "str" , "str" , false , false ) ;
addOption ( "str" , "str" , "str" , "str" , false , true ) ;
addOption ( "str" , "str" , "str" , "str" , false , true ) ;
dos . writeInt ( 0 ) ;
dos . writeInt ( b . length ) ;
partitionId = new byte [ dis . readInt ( ) ] ;
new HelpFormatter ( ) . printHelp ( 100 , "str" , "str" , options , "str" + MRJobConfig . QUEUE_NAME + "str" + GRAPH_CONTEXT + "str" , true ) ;
options . addOption ( newOption ( "str" , "str" , "str" ) ) ;
try ( InputStream in = HalyardStats . class . getResourceAsStream ( "str" ) ) {
try ( InputStream in = HalyardUpdate . class . getResourceAsStream ( "str" ) ) {
try ( InputStream in = HalyardExport . class . getResourceAsStream ( "str" ) ) {
try ( InputStream in = HalyardExport . class . getResourceAsStream ( "str" ) ) {
public static final String DECIMATE_FUNCTION_NAME = "str" ;
new String [ ] { "str" , "str" , "str" , "str" , "str" , "str" , root . toURI ( ) . toURL ( ) . toString ( ) + "str" } ) ) ;
Thread . sleep ( 2 * sleepTime ) ;
Thread . sleep ( 2 * sleepTime ) ;
Thread . sleep ( 2 * sleepTime ) ;
Thread . sleep ( 2 * sleepTime ) ;
Thread . sleep ( 2 * sleepTime ) ;
Thread . sleep ( 2 * sleepTime ) ;
Thread . sleep ( 4 * sleepTime ) ;
Thread . sleep ( 4 * sleepTime ) ;
Thread . sleep ( 3 * sleepTime ) ;
private int sleepTime = 1 ;
Thread . sleep ( 4 * sleepTime ) ;
Thread . sleep ( 4 * sleepTime ) ;
return Collector . < T , Tuple1 < A1 > , Tuple1 < D1 > > of (
return Collector . < T , Tuple2 < A1 , A2 > , Tuple2 < D1 , D2 > > of (
return Collector . < T , Tuple3 < A1 , A2 , A3 > , Tuple3 < D1 , D2 , D3 > > of (
return Collector . < T , Tuple4 < A1 , A2 , A3 , A4 > , Tuple4 < D1 , D2 , D3 , D4 > > of (
return Collector . < T , Tuple5 < A1 , A2 , A3 , A4 , A5 > , Tuple5 < D1 , D2 , D3 , D4 , D5 > > of (
return Collector . < T , Tuple6 < A1 , A2 , A3 , A4 , A5 , A6 > , Tuple6 < D1 , D2 , D3 , D4 , D5 , D6 > > of (
return Collector . < T , Tuple7 < A1 , A2 , A3 , A4 , A5 , A6 , A7 > , Tuple7 < D1 , D2 , D3 , D4 , D5 , D6 , D7 > > of (
return Collector . < T , Tuple8 < A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 > , Tuple8 < D1 , D2 , D3 , D4 , D5 , D6 , D7 , D8 > > of (
public static final Consumer < Throwable > THROWABLE_TO_RUNTIME_EXCEPTION = t - > {
return biConsumer ( consumer , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return objIntConsumer ( consumer , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return objLongConsumer ( consumer , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return objDoubleConsumer ( consumer , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return biFunction ( function , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return toIntBiFunction ( function , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return toLongBiFunction ( function , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return toDoubleBiFunction ( function , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return biPredicate ( predicate , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return binaryOperator ( operator , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return intBinaryOperator ( operator , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return longBinaryOperator ( operator , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return doubleBinaryOperator ( operator , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return consumer ( consumer , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return intConsumer ( consumer , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return longConsumer ( consumer , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return doubleConsumer ( consumer , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return function ( function , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return toIntFunction ( function , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return toLongFunction ( function , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return toDoubleFunction ( function , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return intFunction ( function , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return intToLongFunction ( function , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return intToDoubleFunction ( function , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return longFunction ( function , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return longToIntFunction ( function , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return longToDoubleFunction ( function , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return doubleFunction ( function , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return doubleToIntFunction ( function , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return doubleToLongFunction ( function , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return predicate ( predicate , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return intPredicate ( predicate , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return longPredicate ( predicate , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return doublePredicate ( predicate , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return supplier ( supplier , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return intSupplier ( supplier , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return longSupplier ( supplier , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return doubleSupplier ( supplier , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return booleanSupplier ( supplier , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return unaryOperator ( operator , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return intUnaryOperator ( operator , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return longUnaryOperator ( operator , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
return doubleUnaryOperator ( operator , THROWABLE_TO_RUNTIME_EXCEPTION ) ;
if ( ! isLoading & & isAutoLoadMoreEnd ) {
} , 100 ) ;
} , 100 ) ;
} , 100 ) ;
for ( int i = 0 ; i < 20 ; i + + ) {
if ( mViewId . size ( ) > 0 & & mListener . size ( ) > 0 & & viewHolder . getSwipeView ( ) ! = null ) {
public int [ ] [ ] partialNeighbourCountFromObservations ( int startTimePoint ,
private int dynCorrExclTime = 0 ;
protected int [ ] condEmbedDims = new int [ ] { 1 } ;
protected int [ ] cond_taus = new int [ ] { 1 } ;
protected int [ ] condDelays = new int [ ] { 1 } ;
protected boolean addNoise = true ;
protected double noiseLevel = ( double ) 1e-8 ;
protected boolean addNoise = true ;
protected double noiseLevel = ( double ) 1e-8 ;
protected boolean addNoise = true ;
protected double noiseLevel = ( double ) 1e-8 ;
System . out . println ( "str" ) ;
import infodynamics . measures . discrete . TransferEntropyCalculatorDiscrete ;
import infodynamics . measures . discrete . TransferEntropyCalculatorDiscrete ;
import infodynamics . measures . discrete . TransferEntropyCalculatorDiscrete ;
import infodynamics . measures . discrete . TransferEntropyCalculatorDiscrete ;
ConditionalMutualInformationCalculatorDiscrete condMiCalc = new ConditionalMutualInformationCalculatorDiscrete ( 2 , 2 , 2 ) ;
ConditionalMutualInformationCalculatorDiscrete condMiCalc = new ConditionalMutualInformationCalculatorDiscrete ( 2 , 2 , 2 ) ;
ConditionalMutualInformationCalculatorDiscrete condMiCalc = new ConditionalMutualInformationCalculatorDiscrete ( 2 , 2 , 2 ) ;
PredictiveInformationCalculatorDiscrete piCalc = new PredictiveInformationCalculatorDiscrete ( 2 , 1 ) ;
PredictiveInformationCalculatorDiscrete piCalc = new PredictiveInformationCalculatorDiscrete ( 2 , 1 ) ;
PredictiveInformationCalculatorDiscrete piCalc = new PredictiveInformationCalculatorDiscrete ( 2 , 1 ) ;
PredictiveInformationCalculatorDiscrete piCalc = new PredictiveInformationCalculatorDiscrete ( 2 , 1 ) ;
PredictiveInformationCalculatorDiscrete piCalc = new PredictiveInformationCalculatorDiscrete ( 2 , 1 ) ;
ActiveInformationCalculatorDiscrete aiCalc = new ActiveInformationCalculatorDiscrete ( 2 , 1 ) ;
PredictiveInformationCalculatorDiscrete piCalc = new PredictiveInformationCalculatorDiscrete ( 2 , 1 ) ;
piCalc = new PredictiveInformationCalculatorDiscrete ( 2 , 2 ) ;
MutualInformationCalculatorDiscrete miCalc = new MutualInformationCalculatorDiscrete ( 2 , 0 ) ;
MutualInformationCalculatorDiscrete miCalc = new MutualInformationCalculatorDiscrete ( 2 , 0 ) ;
MutualInformationCalculatorDiscrete miCalc = new MutualInformationCalculatorDiscrete ( 2 , 0 ) ;
MutualInformationCalculatorDiscrete miCalcBase4 = new MutualInformationCalculatorDiscrete ( 4 , 0 ) ;
MutualInformationCalculatorDiscrete miCalc = new MutualInformationCalculatorDiscrete ( 2 , 0 ) ;
MutualInformationCalculatorDiscrete miCalcBase4 = new MutualInformationCalculatorDiscrete ( 4 , 0 ) ;
MutualInformationCalculatorDiscrete miCalcBase8 = new MutualInformationCalculatorDiscrete ( 8 , 0 ) ;
teCalc = new TransferEntropyCalculatorDiscrete ( 2 , 2 ) ;
teCalc = new TransferEntropyCalculatorDiscrete ( 2 , 1 , 2 ) ;
public class SeparableInfoCalculatorDiscreteByAddition extends SeparableInfoCalculatorDiscrete {
public SeparableInfoCalculatorDiscreteByAddition ( int base , int history ,
aiCalc = ActiveInformationCalculatorDiscrete . newInstance ( base , history ) ;
ateCalcs = new TransferEntropyCalculatorDiscrete [ numSources ] ;
ateCalcs [ i ] = TransferEntropyCalculatorDiscrete . newInstance ( base , k ) ;
if ( xyzNorms [ timeStepOfJthPoint ] [ 2 ] > eps_z ) {
locals [ t ] = fixedPartOfLocals -
pc . adjustAbilities ( AbilityCategory . FEAT , new BigDecimal ( String . valueOf ( cost ) ) ) ;
BigDecimal multbd = new BigDecimal ( String . valueOf ( mult ) ) ;
weight = weight . multiply ( new BigDecimal ( String . valueOf ( mult ) ) ) ;
thePC . setUserPoolBonus ( AbilityCategory . FEAT , new BigDecimal ( String . valueOf ( featPool ) ) ) ;
return BigDecimalHelper . trimZeros ( new BigDecimal ( String . valueOf ( aTotalSkillPoints ) ) ) ;
currentPC . setUserPoolBonus ( AbilityCategory . FEAT , new BigDecimal ( String . valueOf ( baseFeatPool ) ) ) ;
return new BigDecimal ( String . valueOf ( ranks ) ) ;
return Files . walk ( dir . toPath ( ) )
for ( int i = 2 ; i < 6 ; i + + )
for ( int i = 6 ; i < 12 ; i + + )
for ( int i = 12 ; i < 14 ; i + + )
import static org . junit . jupiter . api . Assertions . assertEquals ;
import org . junit . jupiter . api . Test ;
roll = 1 ;
Logging . errorPrint ( "str" + formula + "str" + parser . getErrorInfo ( ) ) ;
String aDesc = aCreator . getSafe ( StringKey . TEMP_DESCRIPTION ) ;
return new DerivedLoadContext ( this , toScope ) ;
setColor ( QUALIFIED_COLOR , Color . BLACK ) ;
return getInstance ( ) . initColor ( SOURCE_STATUS_RELEASE_COLOR , Color . black ) ;
public SpellBook clone ( )
public EquipSet clone ( )
public NoteItem clone ( )
public CDOMShell clone ( ) throws CloneNotSupportedException
+ "str" + "str" , prereq . toString ( ) ) ;
assertEquals ( formula , rv . toString ( ) ) ;
assertEquals ( formula , rv . toString ( ) ) ;
assertEquals ( formula , rv . toString ( ) ) ;
public void setUp ( ) throws Exception
| | ( answer = = JOptionPane . YES_OPTION ) )
if ( o instanceof AbstractItemConvertingFacet . Target )
data [ i ] [ 1 ] = equipSet . getQuantity ( path ) ;
+ "str" ) ;
"str" + value . substring ( 9 ) ) )
+ "str" ) ;
"str" + value . substring ( 9 ) ) )
if ( bonus > .01 | | bonus < - 0.01 )
message . add ( new JLabel ( "str" ) ) ;
return pc . getCNAbilities ( abCat , Nature . NORMAL ) ;
aPC . addAbility ( cnas , UserSelection . getInstance ( ) , UserSelection . getInstance ( ) ) ;
if ( "str" . equals ( obj ) | | obj = = null )
if ( level ! = null & & level instanceof CharacterLevelFacadeImpl & & charDisplay ! = null )
List < Movement > movements = ( ( Race ) race ) . getListFor ( ListKey . BASE_MOVEMENT ) ;
& & ! token . equals ( "str" ) & & ! token . equals ( "str" ) )
this . fixedConcentration = fixedConcentration ;
"str" + kind + "str" + formula
"str" + kind + "str" + formula
. errorPrint ( "str"
| | ! ( classFacade = = null | | classFacade instanceof PCClass ) )
if ( tempIndex > = pc . getNamedTempBonusList ( ) . size ( ) )
if ( tempIndex > = pc . getNamedTempBonusDescList ( ) . size ( ) )
if ( ! "str" . equals ( e . getActionCommand ( ) ) )
if ( ! isSpecialtySpell & & ( excNon > 0 ) & & ( excNon + excSpec > 0 ) )
thePC . getCharacterSpellForSpell ( aPCClass , aSpell , source ) ;
if ( ! isImporting ( ) )
if ( eqI . isWeapon ( ) & & ! eqI . isNatural ( ) )
if ( ChooseActivation . hasNewChooseToken ( obj ) )
if ( ChooseActivation . hasNewChooseToken ( template ) & & choice = = null )
Utility . viewInBrowser ( e . getURL ( ) ) ;
. errorPrint ( "str"
. errorPrint ( "str"
Logging . errorPrint ( "str" + lstLine + "str"
+ context . getObjectContext ( ) . getSourceURI ( ) + "str" ) ;
if ( slot ! = null & & equipSlotNodeMap . get ( slot ) ! = null )
+ context . getObjectContext ( ) . getSourceURI ( ) + "str" ) ;
Logging . log ( Logging . LST_ERROR , "str" + ability . getKeyName ( )
if ( ( file = = null | | ! file . isFile ( ) ) & & game . getDefaultCharSheet ( ) ! = null )
file = new File ( sheetDir , game . getDefaultCharSheet ( ) ) ;
"str" + firstItem + "str" + getTokenName ( ) + "str" + value
this . display = pc = = null ? null : pc . getDisplay ( ) ;
if ( renderer ! = null & & getColumnCount ( ) > 0 )
for ( EquipBonus eb : originObj . getSafeListFor ( ListKey . BONUS_EQUIP ) )
if ( ! selection . equals ( other . selection ) )
if ( ! owner . equals ( other . owner ) )
pcgenFrame . showErrorMessage ( "str" + name , "str" ) ;
pcgenFrame . showErrorMessage ( "str" + name , "str" ) ;
return "str" + getName ( ) + "str" ;
JOptionPane . showMessageDialog ( pane , "str" +
Logging . errorPrint ( "str" , ex ) ;
Logging . errorPrint ( "str" , ex ) ;
return "str" + getName ( ) + "str" ;
Logging . errorPrint ( "str" +
Logging . errorPrint ( "str" +
Logging . errorPrint ( "str" +
if ( spellLevel > = 0 & & knownList ! = null & & spellLevel < knownList . size ( ) )
+ ( int ) aPC . getTotalBonusTo ( "str" , "str"
+ ( int ) aPC . getTotalBonusTo ( "str" , "str"
baseSpellStat + = ( int ) getTotalBonusTo ( "str" , "str" + aClass . getKeyName ( ) ) ;
data [ i ] [ 1 ] = equipSet . getEquippedItems ( ) . getQuantity ( path . getEquipment ( ) ) ;
data [ i ] [ 1 ] = unequippedList . getQuantity ( equipmentFacade ) ;
setSize ( 1060 , 725 ) ;
Logging . debugPrint ( "str" + equipment . getName ( )
loadStatusLabel . setIcon ( Icons . Alert16 . getImageIcon ( ) ) ;
prereq . getOperand ( ) , prereq . getKey ( ) } ) ;
makeCacheString ( aSpell = = null ? null : aSpell , varString , src , spellLevelTemp ) ;
makeCacheString ( aSpell = = null ? null : aSpell , varString , src , spellLevelTemp ) ;
removeAll ( dfce . getCharID ( ) , dfce . getCDOMObject ( ) ) ;
if ( bakFile . exists ( ) & & outFile . exists ( ) & & outFile . length ( ) > 0 )
"str" , "str" ,
super ( "str" , LOG_COMMAND , "str" ) ;
super ( "str" , CONSOLE_COMMAND , "str" ) ;
updateSelectedIndex ( false ) ;
private void updateSelectedIndex ( boolean forceChange )
if ( ! model . isSelectionEmpty ( ) & & ! forceChange )
if ( theCharacter . hasTemplate ( template ) & & template . isRemovable ( ) )
sbuf . append ( base . getKeyName ( ) ) ;
detailsPane . validate ( ) ;
String title = titleString . substring ( 6 ) ;
setToolTipText ( LanguageBundle . getString ( "str" ) ) ;
setStringFor ( StringKey . HANDED , LanguageBundle . getString ( "str" ) ) ;
Logging . log ( Logging . INFO , "str" ) ;
super ( LanguageBundle . getString ( "str" ) ) ;
super ( LanguageBundle . getString ( "str" ) ) ;
putValue ( SHORT_DESCRIPTION , LanguageBundle . getString ( "str" ) ) ;
Utility . viewInBrowser ( "str" ) ;
Logging . debugPrint ( "str" + availCompList ) ;
Logging . debugPrint ( "str" + companionList ) ;
"str" , DescriptionFormatting . piDescSubString ( pc , aDeity ) ) ;
piString . append ( StringUtil . joinToStringBuffer ( set , "str" ) ) ;
aPC . setXP ( Math . max ( maxxp - 1 , 0 ) ) ;
private ListFacade < ? extends CompanionFacade > companions ;
private Map < String , Integer > finalLevelMap ;
this . finalLevelMap = new HashMap < String , Integer > ( ) ;
String c = levels . getClassTaken ( levels . getElementAt ( i ) ) . getKeyName ( ) ;
List < Object > data = availTable . getSelectedData ( ) ;
Logging . log ( Logging . INFO , "str" + locale + "str" ) ;
for ( StatFacade stat : dataSet . getStats ( ) )
ReferenceFacade < Integer > facade = getScoreBaseRef ( stat ) ;
synchronized ListFacade < TodoFacade > getTodoList ( )
synchronized void addTodo ( TodoFacade item )
synchronized void removeTodo ( String messageKey )
synchronized void removeTodo ( String messageKey , String fieldName )
setSize ( 1060 , 685 ) ;
Formula f = ( buy = = null ? null : buy . getObject ( aPC , this ) ) ;
eq_item . addEquipmentToLocation ( qty , EquipmentLocation . CONTAINED , false , aPC ) ;
eq_item . addEquipmentToLocation ( qty , EquipmentLocation . CARRIED_NEITHER , false , aPC ) ;
eq_item . addEquipmentToLocation ( qty , EquipmentLocation . NOT_CARRIED , false , aPC ) ;
Float quantity = ( qty . doubleValue ( ) < 2.0 ) ? 2.0f : qty ;
eq_item . addEquipmentToLocation ( qty , EquipmentLocation . EQUIPPED_NEITHER , true , aPC ) ;
| | fileName . startsWith ( Constants . EQUIPMENT_TEMPLATE_PREFIX )
sourceList . add ( Constants . SOURCE_CUSTOM ) ;
addChild ( Constants . SOURCE_CUSTOM , sourceRoot , true ) ;
if ( thisKey . startsWith ( Constants . AUTO_RESIZE_PREFIX ) )
int index = Constants . AUTO_RESIZE_PREFIX . length ( ) ;
return Constants . AUTO_RESIZE_PREFIX + finalSize + thisKey ;
String AUTO_RESIZE_PREFIX = "str" ;
Constants . AUTO_RESIZE_PREFIX + newSize . getAbbreviation ( ) . toUpperCase ( )
Constants . AUTO_RESIZE_PREFIX + newSize . getAbbreviation ( ) . toUpperCase ( ) . substring ( 0 , 1 )
Constants . AUTO_RESIZE_PREFIX + newSize . getAbbreviation ( ) . toUpperCase ( ) . substring ( 0 , 1 )
Constants . AUTO_RESIZE_PREFIX + newSize . getAbbreviation ( ) . toUpperCase ( ) . substring ( 0 , 1 )
String unExpectedKey = Constants . AUTO_RESIZE_PREFIX + "str" + this . OriginalKey ;
String expectedKey = Constants . AUTO_RESIZE_PREFIX + "str" + this . OriginalKey ;
String expectedKey = Constants . AUTO_RESIZE_PREFIX + "str" + this . OriginalKey ;
String expectedKey = Constants . AUTO_RESIZE_PREFIX + "str" + this . OriginalKey ;
String expectedKey = Constants . AUTO_RESIZE_PREFIX + "str" + this . OriginalKey ;
result . add ( Constants . EQUIP_LOCATION_PRIMARY ) ;
result . add ( Constants . EQUIP_LOCATION_SECONDARY + "str" + i ) ;
result . add ( Constants . EQUIP_LOCATION_SECONDARY ) ;
aList . add ( Constants . EQUIP_LOCATION_UNARMED ) ;
aList . add ( Constants . EQUIP_LOCATION_BOTH ) ;
aList . add ( Constants . EQUIP_LOCATION_TWOWEAPONS ) ;
aList = getWeaponLocationChoices ( hands , Constants . EQUIP_LOCATION_BOTH ) ;
aList . add ( Constants . EQUIP_LOCATION_DOUBLE ) ;
aList . add ( Constants . EQUIP_LOCATION_TWOWEAPONS ) ;
aList . add ( Constants . EQUIP_LOCATION_BOTH ) ;
aList . add ( Constants . EQUIP_LOCATION_DOUBLE ) ;
aList . add ( Constants . EQUIP_LOCATION_EQUIPPED ) ;
return Constants . EQUIP_LOCATION_NATURAL_PRIMARY ;
return Constants . EQUIP_LOCATION_NATURAL_SECONDARY ;
if ( locName . equals ( Constants . EQUIP_LOCATION_NATURAL_SECONDARY ) )
else if ( aLoc . startsWith ( Constants . EQUIP_LOCATION_CARRIED ) )
else if ( aLoc . startsWith ( Constants . EQUIP_LOCATION_NOTCARRIED ) )
else if ( aLoc . equals ( Constants . EQUIP_LOCATION_BOTH ) )
else if ( aLoc . equals ( Constants . EQUIP_LOCATION_DOUBLE ) )
else if ( aLoc . equals ( Constants . EQUIP_LOCATION_UNARMED ) )
else if ( aLoc . equals ( Constants . EQUIP_LOCATION_TWOWEAPONS ) )
else if ( aLoc . equals ( Constants . EQUIP_LOCATION_SHIELD ) )
return Constants . EQUIP_LOCATION_NATURAL_PRIMARY ;
return Constants . EQUIP_LOCATION_NATURAL_SECONDARY ;
if ( locName . equals ( Constants . EQUIP_LOCATION_NATURAL_SECONDARY ) )
String EQUIP_LOCATION_BOTH = "str" ;
String EQUIP_LOCATION_CARRIED = "str" ;
String EQUIP_LOCATION_DOUBLE = "str" ;
String EQUIP_LOCATION_EQUIPPED = "str" ;
String EQUIP_LOCATION_NATURAL_PRIMARY = "str" ;
String EQUIP_LOCATION_NATURAL_SECONDARY = "str" ;
String EQUIP_LOCATION_NOTCARRIED = "str" ;
String EQUIP_LOCATION_PRIMARY = "str" ;
String EQUIP_LOCATION_SECONDARY = "str" ;
String EQUIP_LOCATION_SHIELD = "str" ;
String EQUIP_LOCATION_TWOWEAPONS = "str" ;
String EQUIP_LOCATION_UNARMED = "str" ;
return Constants . EQUIP_LOCATION_NATURAL_PRIMARY ;
return Constants . EQUIP_LOCATION_NATURAL_SECONDARY ;
result . add ( Constants . EQUIP_LOCATION_PRIMARY ) ;
result . add ( Constants . EQUIP_LOCATION_SECONDARY + "str" + i ) ;
result . add ( Constants . EQUIP_LOCATION_SECONDARY ) ;
if ( locName . equals ( Constants . EQUIP_LOCATION_NATURAL_SECONDARY ) )
aList . add ( Constants . EQUIP_LOCATION_UNARMED ) ;
aList . add ( Constants . EQUIP_LOCATION_SHIELD ) ;
aList = getWeaponLocationChoices ( hands , Constants . EQUIP_LOCATION_BOTH ) ;
aList . add ( Constants . EQUIP_LOCATION_DOUBLE ) ;
aList . add ( Constants . EQUIP_LOCATION_BOTH ) ;
aList . add ( Constants . EQUIP_LOCATION_DOUBLE ) ;
aList . add ( Constants . EQUIP_LOCATION_EQUIPPED ) ;
pc . addEquipToTarget ( eSet , null , Constants . EQUIP_LOCATION_CARRIED , eq , null ) ;
int count = 1 ;
if ( equalLoc ! = set . lastIndexOf ( "str" ) )
statValue = Integer . parseInt ( name ) ;
private Formula poolFormula = FormulaFactory . ZERO ;
aClass . levelMap . put ( me . getKey ( ) , me . getValue ( ) . clone ( ) ) ;
+ extension ) ) ;
return referencedObject . getLSTformat ( ) . hashCode ( ) ;
for ( String mode : aCampaign . getSafeListFor ( ListKey . GAME_MODE ) )
super ( "str" , null , true ) ;
return Double . valueOf ( 0 ) ;
private static boolean loadCampaignsWithPC = false ;
setLoadCampaignsWithPC ( getPCGenOption ( "str" , false ) ) ;
autoWeap . add ( s . substring ( 11 ) ) ;
assertEquals ( "str" , INFOTEXT , camp . getSafeListFor ( ListKey . INFO_TEXT )
START_PC_MAXLEVEL ( "str" , new String [ ] { "str" } , true ) {
. getFormattedString ( "str" , dir
assertEquals ( listResult , "str" ) ;
assertEquals ( listResult , "str" ) ;
assertEquals ( listResult , "str" ) ;
assertEquals ( listResult , "str" ) ;
assertEquals ( listResult , "str" ) ;
assertEquals ( listResult , "str" ) ;
assertEquals ( listResult , "str" ) ;
assertEquals ( listResult , "str" ) ;
assertEquals ( listResult , "str" ) ;
assertEquals ( listResult , "str" ) ;
assertEquals ( listResult , "str" ) ;
assertEquals ( listResult , "str" ) ;
assertEquals ( listResult , "str" ) ;
assertEquals ( listResult , "str" ) ;
for ( Iterator < Set < CDOMObject > > it2 = foMap . values ( ) . iterator ( ) ; it2
for ( Iterator < Set < CDOMObject > > it2 = foMap . values ( ) . iterator ( ) ; it2
int pipeLoc = value . lastIndexOf ( "str" ) ;
int pipeLoc = value . lastIndexOf ( "str" ) ;
return new ParseResult . Fail ( "str"
return new ParseResult . Fail ( "str"
return new ParseResult . Fail ( "str"
sb . append ( "str" ) ;
sb . append ( "str" ) ;
while ( nameCount > 0 )
. getPurchaseScoreMin ( pc ) ;
if ( list ! = null )
for ( Ability ability : list )
final PObjectNode fol = new PObjectNode ( new SourcedFollower ( follower , me . getValue ( ) ) ) ;
if ( theEquipment . isType ( "str" ) | | ( sizeToPC ! = null & & sizeToPC )
abcm . setController ( new AbilityChooseController ( a , cat , aPC , abcm ) ) ;
if ( choiceString ! = null & & choiceString . startsWith ( "str" ) )
else if ( ! adding & & availableList . contains ( wp ) )
( isStackYes ( ) | | ! availableList . contains ( ability . getKeyName ( ) ) ) )
if ( ! hasEquip & & ! pc . getEquipmentMasterList ( ) . isEmpty ( ) )
+ toString ( ) . toLowerCase ( ) ) ;
if ( getCachedSet ( id , cat , nat ) . add ( obj ) | | isNew )
+ "str" + cycle + "str" ) ;
+ "str" ) ;
if ( useName ! = null & & useName )
if ( subrace ! = null )
return new String [ ] { "str" } ;
if ( subrace = = null )
return new String [ ] { subrace . toString ( ) } ;
if ( useName ! = null & & useName )
if ( subregion ! = null )
return new String [ ] { "str" } ;
if ( subregion = = null )
return new String [ ] { subregion . toString ( ) } ;
if ( useName ! = null & & useName )
if ( region ! = null )
return new String [ ] { "str" } ;
if ( region = = null )
return new String [ ] { region . toString ( ) } ;
return getSafeListFor ( ListKey . STAT_LIST ) ;
str [ i ] = "str" + str [ i ] . substring ( 7 ) ;
if ( tok . countTokens ( ) ! = 9 & & tok . countTokens ( ) ! = 1 )
+ "str" ) ;
return getTypeReference ( rm , s . substring ( 5 ) ) ;
if ( newactors ! = null )
for ( ChooseSelectionActor < ? > csa : newactors )
theChoices . add ( i , aWeight ) ;
Set < PCStat > set = new HashSet < PCStat > ( ) ;
if ( ! set . add ( stat ) )
if ( set . isEmpty ( ) )
pcs = new SimpleChoiceSet < PCStat > ( set ) ;
PCClass parent = ( PCClass ) obj . get ( ObjectKey . TOKEN_PARENT ) ;
. getAbbreviatedObject ( PCStat . class , "str" ) ;
"str" , prereq . getOperand ( ) , prereq . getKey ( ) } ;
PCClass parent = ( PCClass ) obj . get ( ObjectKey . PARENT ) ;
if ( currXpTableName = = null | | currXpTableName . equals ( "str" ) | | ! xpTableNames . contains ( currXpTableName ) )
if ( changes ! = null & & ! changes . isEmpty ( ) & & changes . hasAddedItems ( ) )
if ( changes ! = null & & ! changes . isEmpty ( ) & & changes . hasAddedItems ( ) )
if ( mAvailableList . size ( ) > 0 & & mAvailableList . get ( 0 ) instanceof Comparable )
if ( lista ! = null )
for ( PersistentTransitionChoice < ? > ptc : lista )
for ( String str : ptc . getChoices ( ) . getLSTformat ( ) . split ( "str" ) )
Integer hands = eq . get ( IntegerKey . SLOTS ) ;
for ( ClassSkillList st : csc . driveChoice ( pc ) )
for ( CDOMListObject < Spell > st : csc . driveChoice ( pc ) )
File in = new File ( uri ) ;
File in = new File ( uri ) ;
StringTokenizer st = new StringTokenizer ( value , Constants . COMMA ) ;
if ( addCharges )
+ "str" ) ;
1 , prereq . getKey ( ) , prereq . getOperand ( ) } ) ;
return validator ! = null & & validator . allow ( getReferenceClass ( ) , s ) ;
return validator ! = null & & validator . allow ( getReferenceClass ( ) , s ) ;
| | chooseString . indexOf ( "str" ) = = - 1 )
if ( mtl ! = null )
for ( CDOMReference < Ability > ab : mtl . getKeySet ( ) )
"str" , "str" ,
"str" , "str" ,
"str" , "str" ,
"str" , "str" ,
retString = ReferenceUtilities . joinLstFormat ( dwp , Constants . PIPE , true ) ;
"str" + getBaseString ( ) + "str"
"str" + getBaseString ( ) + "str"
+ "str" , "str" + getBaseString ( )
+ "str" , "str"
"str" , true ) ) ;
if ( ! validateOnlyMove ( hasArmor ) )
return ChoiceSetUtilities . joinLstFormat ( set , Constants . COMMA ) ;
AssociatedPrereqObject assoc = edits . negativeMasterMap . get (
theCampaign . put ( ObjectKey . IS_D20 , isD20 . getSelectedObjects ( ) ! = null ) ;
isD20 . setSelected ( theCampaign . getSafe ( ObjectKey . IS_D20 ) ) ;
showD20 | = campaign . getSafe ( ObjectKey . IS_D20 ) ;
return eq . getType ( ) . toUpperCase ( ) ;
return eq . typeIndex ( num ) . toUpperCase ( ) ;
retString + = aAbility . getType ( ) . toUpperCase ( ) ;
for ( EquipmentModifier aMod : head . getSafeListFor ( ListKey . EQMOD ) )
for ( EquipmentModifier aMod : head . getSafeListFor ( ListKey . EQMOD ) )
for ( EquipmentModifier aMod : head . getSafeListFor ( ListKey . EQMOD ) )
heads . set ( headsIndex , head ) ;
"str" + key + "str" + value ) ;
T good = active . get ( second . toString ( ) ) ;
if ( getPluginSystem ( ) . equals ( "str" ) )
if ( choiceActor = = null | | choiceActor . allow ( o , pc , allowStack ) )
c . setAvailableList ( new ArrayList < T > ( allowed ) ) ;
if ( actual = = null & & ( value = = null | | allowNull ) | | value ! = null
String LST_CROSSCLASS = "str" ;
"str" , "str" ,
refs . add ( skref ) ;
refs . add ( skref ) ;
private static final String SPACE = "str" ;
data . setText ( "str" + dataText + "str" ) ;
Logging . log ( Logging . INFO , sB . toString ( ) ) ;
return t1 = = null ? null : result1 ;
Logging . log ( Logging . DEBUG , e . toString ( ) ) ;
if ( followerIndex > - 1 & & followerIndex < aList . size ( ) )
if ( mods ! = null )
if ( ! PCClass . class . isAssignableFrom ( target . getClass ( ) ) )
if ( aString ! = null & & aString . length ( ) ! = 0 )
PlayerCharacterUtilities . getBestUDamString ( pObjDamage , pObj . getUdamForSize ( sizeInt ) ) ;
sbuf . append ( base ) ;
sbuf . append ( sep ) . append ( "str" ) . append ( endPart ) . append ( thisSize . getAbbreviation ( ) ) ;
public int getTotalCasterLevelWithSpellBonus ( final Spell aSpell ,
public int getLevelBefore ( final String classKey , final int charLevel )
public int countSpellsInBook ( final String aString )
public boolean addFavoredClass ( final String aString )
TableColumn col = colModel . getColumn ( i ) ;
Logging . debugPrint ( "str" + campaign . isLoaded ( ) + "str" + campaign . getBookType ( ) ) ;
Logging . errorPrint ( "str" + key + "str" + value ) ;
. errorPrint ( "str" + key + "str" + value ) ;
Logging . errorPrint ( "str" + key + "str" + value ) ;
PObjectNode [ ] tempNodes = new PObjectNode [ Constants . MAX_SPELL_LEVEL + 1 ] ;
super ( SwingConstants . CENTER , 5 , false ) ;
assertEquals ( "str" , "str" , bonusList . get ( 0 ) . toString ( ) ) ;
assertEquals ( "str" , "str" , bonusList . get ( 0 ) . toString ( ) ) ;
assertEquals ( "str" , "str" , bonusList . get ( 3 ) . toString ( ) ) ;
assertEquals ( "str" , "str" , bonusList . get ( 3 ) . toString ( ) ) ;
Logging . errorPrint ( aBonus + "str" ) ;
checkRequiredDeities ( context ) ;
private void checkRequiredDeities ( LoadContext context ) throws PersistenceLayerException
deityLoader . parseLine ( context , null , aLine , globalCampaign ) ;
purchaseMethodPanel . setBorder ( BorderFactory . createTitledBorder ( "str" ) ) ;
Logging . debugPrint ( "str" + key + "str" + index + "str" ) ;
Logging . debugPrint ( "str" + item . getKeyName ( ) + "str"
if ( value . equalsIgnoreCase ( "str" ) )
else if ( value . equalsIgnoreCase ( "str" ) )
else if ( value . equalsIgnoreCase ( "str" ) )
list . add ( factory . parse ( "str" ) ) ;
public double convertWeightFromUnitSet ( final double weight )
pc . setWeight ( ( int ) Globals . getGameModeUnitSet ( ) . convertWeightFromUnitSet (
pc . setWeight ( ( int ) Globals . getGameModeUnitSet ( ) . convertWeightFromUnitSet (
. getString ( "str" ) , 15 , null ) ) ;
sb . append ( "str" ) . append ( image . getURI ( ) ) . append ( "str" ) ;
sb . append ( "str" ) . append ( image . getURI ( ) ) . append ( "str" ) ;
if ( aArrayList ! = null & & aArrayList . equals ( selectedList ) )
if ( ( index ! = - 2 ) & & ( index > = 0 ) & & ( index < aPC . getStatList ( ) . size ( ) ) )
if ( selObj ! = null & & selRow < theTable . getRowCount ( ) )
public synchronized void refresh ( )
else if ( ! entry . getName ( ) . equalsIgnoreCase ( "str" ) )
subreq . setCountMultiples ( true ) ;
final AbilityInfo info = ( AbilityInfo ) kAbInnerIt . next ( ) ;
if ( ! info . qualifies ( aPC ) )
if ( info . getAbility ( ) ! = null )
info . getCategory ( ) ) ;
warnings . add ( "str" + info . getKeyName ( )
if ( aArrayList = = null | | aArrayList . equals ( selectedList ) )
+ getBaseString ( ) + "str" ) ;
+ getBaseString ( ) + "str" ) ;
if ( Globals . getDomainKeyed ( domainName ) = = null )
bSilent , this , bypassPrereqs ) )
desc . addPrerequisites ( token , "str" ) ;
desc . addPrerequisites ( token , "str" ) ;
for ( BonusObj bonus : aPC . getActiveBonusList ( ) )
sb . append ( String . valueOf ( getCreatorObject ( ) ) ) ;
. deprecationWarning ( "str" ) ;
final FORNode root = new FORNode ( null , "str" , "str" , "str" , false ) ;
if ( ! canAddEquip ( pc , eSet , location , eqI ) )
+ eqI . getName ( ) + "str" + location , "str" ,
else if ( PreParserFactory . isPreReqString ( key + "str" ) )
final StringTokenizer tok = new StringTokenizer ( "str" + desc , "str" ) ;
if ( buf . length ( ) ! = 0 )
AbilityInfo ability = ( AbilityInfo ) iter . next ( ) ;
AbilityInfo grantedFeat = ( AbilityInfo ) iter . next ( ) ;
Set < String > typesToGetBonusesFor = new HashSet < String > ( ) ;
buffer . append ( this . getOutputName ( ) ) . append ( "str" ) ;
return s1 . getOutputName ( ) . compareToIgnoreCase ( s2 . getOutputName ( ) ) ;
return s1 . getOutputName ( ) . compareToIgnoreCase ( s2 . getOutputName ( ) ) ;
deity . setText ( pc . getDeity ( ) . getOutputName ( ) + "str" ) ;
public String getRaceType ( )
return pc . getRaceType ( ) ;
return pc . getRaceType ( ) ;
statBuf . append ( pcOut . getRaceType ( ) ) ;
( int ) pc . getTotalBonusTo ( "str" ,
item . setText ( EqToken . getNameToken ( eq , pc ) ) ;
return raceMap . remove ( aKey . toLowerCase ( ) ) ! = null ;
if ( classSpellChoices = = null | | ( level < 1 ) ) {
+ "str" + key ) ;
return new ArrayList < Ability > ( abilities ) ;
aBonusList . add ( sTok . nextToken ( ) ) ;
Logging . errorPrint ( "str" + choices . get ( 1 ) ) ;
if ( repeatToken . countTokens ( ) ! = 3 )
Logging . errorPrint ( "str" + getTokenName ( ) + "str" + value
Logging . errorPrint ( "str" + getTokenName ( ) + "str" + value
Logging . errorPrint ( "str" + getTokenName ( ) + "str" + value
Logging . errorPrint ( "str" + getTokenName ( ) + "str" + value
locTypeName = PropertyFactory . getString ( "str" ) ;
public static int finaliseAbility (
double abilityCount = ( ability . getAssociatedCount ( ) * ability . getCost ( aPC ) ) ;
boolean adjustedAbilityPool = false ;
if ( "str" . equals ( choice ) | | choice = = null )
adjustedAbilityPool = ability . modChoices ( aPC , addIt ) ;
if ( singleChoice & & ! adjustedAbilityPool )
abilityCount + = ability . getCost ( aPC ) ;
abilityCount - = ability . getCost ( aPC ) ;
abilityCount - = ( listSize * ability . getCost ( aPC ) ) ;
& & it2 < ability . getAssociatedCount ( ) )
if ( ! aPC . getLanguagesList ( ) . contains ( ( Object ) aLang ) )
Logging . debugPrint ( "str" ) ;
private final List < String > armorProfList = new ArrayList < String > ( ) ;
private final SortedSet < Language > languages = new TreeSet < Language > ( ) ;
! availableList . contains ( ability . toString ( ) )
for ( int i = 0 ; i < getAssociatedCount ( ) ; i + + )
if ( selectedInd > = 0 & & selectedInd < anInputList . size ( ) )
buf . append ( "str" ) ;
public static final String APPLY_KIND = "str" ;
if ( prereq . getKind ( ) . equalsIgnoreCase ( Prerequisite . APPLY_KIND ) )
boolean firstCol = true ;
buffer . append ( CoreUtility . join ( pcClass . getCastListForLevel ( classLevel ) , "str" ) ) ;
if ( selectedList . size ( ) > 0 & & selectedList . get ( 0 ) ! = null )
setShowSkillModifier ( getPCGenOption ( "str" , true ) ) ;
Logging . errorPrint ( "str" + String . valueOf ( sourceURL ) + "str"
retString = getOutputNameToken ( template ) ;
File template = new File ( SettingsHandler . getPcgenSystemDir ( ) + File . separator + "str" + File . separator + SettingsHandler . getGame ( ) . getName ( ) + File . separator + "str" ) ;
private static int looknFeel = 1 ;
setLookAndFeel ( getPCGenOption ( "str" , 1 ) ) ;
primaryMatch = spell . levelForKeyContains ( aClass . getSpellKey ( ) , iLev , pc ) ;
dataBuffer . append ( new String ( inputLine , "str" ) ) ;
protected int requestedSelections = - 1 ;
private boolean useTempMods = true ;
Logging . errorPrint ( "str" + "str" + gameMode . getName ( ) + "str" + "str" + colString + "str" ) ;
botPane . setLayout ( new BorderLayout ( ) ) ;
if ( pcTemplate ! = null )
JOptionPane . showMessageDialog ( null , PropertyFactory . getString ( "str" ) ) ;
if ( qFilter = = null | |
"str" , new BioToken ( )
"str" , new BioToken ( )
if ( eh ! = null & & eh . getTemplateFile ( ) . getName ( ) . endsWith ( Constants . XSL_FO_EXTENSION ) ) {
retVal = new Float ( eq . qty ( ) ) ;
retString + = "str" ;
retString + = e . next ( ) . toString ( ) ;
private static int viewAvailMode = GuiConstants . INFOFEATS_VIEW_PREREQTREE ;
private static int equipTab_AvailableListMode = GuiConstants . INFOEQUIPPING_VIEW_EQUIPPED ;
private static int featTab_AvailableListMode = GuiConstants . INFOFEATS_VIEW_PREREQTREE ;
private static int gearTab_AvailableListMode = GuiConstants . INFOINVENTORY_VIEW_TYPE_NAME ;
setEquipTab_AvailableListMode ( getPCGenOption ( "str" , GuiConstants . INFOEQUIPPING_VIEW_EQUIPPED ) ) ;
setFeatTab_AvailableListMode ( getPCGenOption ( "str" , GuiConstants . INFOFEATS_VIEW_PREREQTREE ) ) ;
GuiConstants . INFOINVENTORY_VIEW_TYPE_NAME ) ) ;
viewMode = GuiConstants . INFOEQUIPPING_VIEW_EQUIPPED ;
private static int viewMode = GuiConstants . INFOINVENTORY_VIEW_TYPE_NAME ;
this ( Configuration . getConfig ( "str" ) , Configuration . getConfig ( "str" ) ) ;
return normalQueue . size ( ) + priorityQueue . size ( ) ;
params . add ( decode ( value ) ) ;
addParams ( name , Arrays . asList ( value ) ) ;
list . add ( value ) ;
httpRequest = webClient . postAbs ( request . getUrl ( ) ) ;
request . referer ( request . getUrlParser ( ) . getProtocol ( ) + "str" + request . getUrlParser ( ) . getHost ( ) ) ;
webDriver . quit ( ) ;
log = METHOD_TAG + request . getHttpMethod ( ) . name ( ) + DOUBLE_SEPARATOR +
. map ( new Function < Spider , Publisher > ( ) {
public Publisher apply ( Spider spider ) throws Exception {
httpRequest = webClient . getAbs ( request . getUrl ( ) ) ;
public Spider initialDelay ( long initialDelay ) {
httpRequest = webClient . get ( request . getUrl ( ) ) ;
public void initializeInternal ( ) {
rootAccount . setDataDomain ( GlobalConstant . DEFAULT_VALUE ) ;
private String dataDomain = GlobalConstant . DEFAULT_VALUE ;
removeRedundantCasts ( compilationUnit ) ;
private void removeRedundantCasts ( CompilationUnit compilationUnit ) {
J2clAsyncTestRunner . ErrorMessage . ASYNC_HAS_EXPECTED_EXCEPTION . format ( "str" ) )
J2clAsyncTestRunner . ErrorMessage . ASYNC_NO_TIMEOUT . format ( "str" ) )
ASYNC_NO_TIMEOUT ( "str" ) ,
AstUtils . getNumericBinaryExpressionTypeDescriptor (
return AstUtils . getNumericBinaryExpressionTypeDescriptor (
public static PrimitiveTypeDescriptor getNumericBinaryExpressionTypeDescriptor (
problems . error ( Message . ERR_CANNOT_OPEN_ZIP , zipPath , e . getMessage ( ) ) ;
+ "str" ) ;
public static final InnerClass EXPORTED_2 = new InnerClass ( 5 ) ;
TypeDescriptor boxType = expression . getTypeDescriptor ( ) . getRawTypeDescriptor ( ) ;
import com . google . j2cl . frontend . common . ZipFiles ;
public final class ZipFiles {
public static void unzipFile ( File zipFile , File targetDirectory ) throws IOException {
+ + rb ;
+ + rc ;
+ + rs ;
+ + ri ;
+ + rl ;
+ + rf ;
+ + rd ;
ManglingNameUtils . getFactoryMethodMangledName ( method . getDescriptor ( ) ) ) ;
ManglingNameUtils . getFactoryMethodMangledName ( method . getDescriptor ( ) ) ;
ManglingNameUtils . getFactoryMethodMangledName ( constructor . getDescriptor ( ) ) ;
ManglingNameUtils . getFactoryMethodMangledName ( expression . getTarget ( ) ) ;
private int gravity = Gravity . BOTTOM ;
String create = "str" ;
String status = isSuccess ( ) ? "str" : "str" ;
this . jwtEncryptionPreferences . setPrivateKeyPassword ( privateKeyPassword ) ;
BoxAPIConnection api = new BoxAPIConnection ( TestConfig . getAccessToken ( ) ) ;
BoxAPIConnection api = new BoxAPIConnection ( TestConfig . getAccessToken ( ) ) ;
BoxAPIConnection api = new BoxAPIConnection ( TestConfig . getAccessToken ( ) ) ;
BoxAPIConnection api = new BoxAPIConnection ( TestConfig . getAccessToken ( ) ) ;
BoxAPIConnection api = new BoxAPIConnection ( TestConfig . getAccessToken ( ) ) ;
BoxAPIConnection api = new BoxAPIConnection ( TestConfig . getAccessToken ( ) ) ;
BoxAPIConnection api = new BoxAPIConnection ( TestConfig . getAccessToken ( ) ) ;
BoxAPIConnection api = new BoxAPIConnection ( TestConfig . getAccessToken ( ) ) ;
BoxAPIConnection api = new BoxAPIConnection ( TestConfig . getAccessToken ( ) ) ;
BoxAPIConnection api = new BoxAPIConnection ( TestConfig . getAccessToken ( ) ) ;
BoxAPIConnection api = new BoxAPIConnection ( TestConfig . getAccessToken ( ) ) ;
BoxAPIConnection api = new BoxAPIConnection ( TestConfig . getAccessToken ( ) ) ;
BoxAPIConnection api = new BoxAPIConnection ( TestConfig . getAccessToken ( ) ) ;
BoxAPIConnection api = new BoxAPIConnection ( TestConfig . getAccessToken ( ) ) ;
BoxAPIConnection api = new BoxAPIConnection ( TestConfig . getAccessToken ( ) ) ;
private static final URLTemplate TASK_ASSIGNMENT_URL_TEMPLATE = new URLTemplate ( "str" ) ;
public void updateInfo ( BoxTaskAssignment . Info info ) {
} else if ( memberName . equals ( "str" ) ) {
this . filtersList . add ( key , opObj ) ;
this . filtersList . add ( key , opObj ) ;
EventLog ( BoxAPIConnection api , JsonObject json , String streamPosition , int limit ) {
this . nextStreamPosition = json . get ( "str" ) . asString ( ) ;
return getEnterpriseEvents ( api , null , after , before , types ) ;
public static EventLog getEnterpriseEvents ( BoxAPIConnection api , String position , Date after , Date before ,
if ( position ! = null | | types . length > 0 ) {
if ( position ! = null ) {
public String getStreamPosition ( ) {
public String getNextStreamPosition ( ) {
switch ( this . encryptionAlgorithm ) {
List < BoxFolder . Info > actualPathCollection = info . getPathCollection ( ) ;
assertThat ( actualPathCollection , hasItem ( Matchers . < BoxFolder . Info > hasProperty ( "str" , equalTo ( "str" ) ) ) ) ;
private List < BoxFolder . Info > pathCollection ;
public List < BoxFolder . Info > getPathCollection ( ) {
private List < BoxFolder . Info > parsePathCollection ( JsonObject jsonObject ) {
List < BoxFolder . Info > pathCollection = new ArrayList < BoxFolder . Info > ( count ) ;
if ( this . filter = = null | | this . filter . shouldInclude ( jsonObject ) ) {
private static final Logger LOGGER = Logger . getLogger ( BoxMultipartRequest . class . getName ( ) ) ;
private static final Logger LOGGER = Logger . getLogger ( BoxAPIResponse . class . getName ( ) ) ;
BoxFolder childFolder = rootFolder . createFolder ( "str" )
Map < String , Object > contentAsMap = response . getContent ( EcrCurl . jsonParser ( ) ) ;
nettyResponse . headers ( ) . set ( HttpHeaders . Names . CONTENT_TYPE ,
nettyResponse . headers ( ) . set ( HttpHeaders . Names . CONTENT_LENGTH ,
import static org . elasticsearch . search . suggest . SuggestBuilders . termSuggestion ;
super ( settings , restController , client ) ;
Main . removeAdView ( ( View ) param . thisObject , packageName , true ) ;
Main . removeAdView ( ( View ) param . thisObject , packageName , true ) ;
public final static String banner = "str" ;
rec_remove . setChecked ( pref . getBoolean ( key + "str" , false ) ) ;
private String submchid ;
private static String subMchID = PayProperties . getInstance ( ) . getWechat ( ) . getSubmchid ( ) ;
return getTokensMatchingType ( tokens , tokenType ) ;
public static final String COOKIE_WAS_REQUEST = "str" ;
ZipFileData ripestSlow = pendingSlowStorage . getFirst ( ) ;
healthCheckBeans . add ( beanManager . getReference ( bean , HealthCheck . class , beanManager . createCreationalContext ( bean ) ) ) ;
ExtendedApplicationInfo appInfo = appInfoFactory . createApplicationInfo ( getName ( ) ,
ArrayList < String > errorCodes = new ArrayList < String > ( ) ;
assertEquals ( err , "str" , json . getString ( "str" ) ) ;
assertEquals ( err , "str" , json . getString ( "str" ) ) ;
assertEquals ( err , "str" , json . getString ( "str" ) ) ;
assertEquals ( err , "str" , json . getString ( "str" ) ) ;
assertEquals ( err , "str" , json . getString ( "str" ) ) ;
assertEquals ( err , "str" , j . getString ( "str" ) ) ;
assertEquals ( err , "str" , json . getString ( "str" ) ) ;
assertEquals ( err , "str" , json . getString ( "str" ) ) ;
assertEquals ( err , "str" , json . getString ( "str" ) ) ;
private RegistryEntry getRegistry ( RegistryEntry parent , String name ) {
private RegistryEntry getRegistry ( RegistryEntry parent , String childNodeName ) {
resp . sendError ( 404 , MessageFormat . format ( nls . getString ( "str" , "str" ) , new Object [ ] { pathInfo } ) ) ;
private static final String DEFAULT_APP_UNDEPLOY_TIMEOUT = "str" ;
server . waitForMultipleStringsInLogUsingMark ( 2 , "str" ) ) ;
int start = injectionPointName . length ( ) + 23 ;
StringBuilder propName = new StringBuilder ( len ) . append ( injectionPointName ) . append ( "str" ) ;
int start = injectionPointName . length ( ) + 21 ;
StringBuilder propName = new StringBuilder ( len ) . append ( injectionPointName ) . append ( "str" ) ;
StringBuilder n = new StringBuilder ( member . getDeclaringClass ( ) . getTypeName ( ) ) . append ( "str" ) . append ( member . getName ( ) ) ;
n . append ( "str" ) . append ( ( ( AnnotatedParameter < ? > ) injectionPoint ) . getPosition ( ) + 1 ) ;
| | ! message . contains ( "str" )
ldap . setLdapCache ( new LdapCache ( new AttributesCache ( true , 4444 , 2222 , "str" ) , new SearchResultsCache ( true , 5555 , 3333 , "str" ) ) ) ;
Thread . sleep ( 9100 ) ;
Thread . sleep ( 18100 ) ;
. waitForStringInTraceUsingLastOffset ( "str" ) ;
String classPathValue = null ;
String methodPathValue = null ;
server . stopServer ( "str" ) ;
server . stopServer ( "str" ) ;
if ( "str" . equals ( defaultMethod ) & & requiredRoles . isEmpty ( ) ) {
if ( "str" . equals ( c . getKey ( ) ) | | "str" . equals ( c . getKey ( ) ) ) {
if ( "str" . equals ( authResult . getAuditAuthConfigProviderAuthType ( ) ) ) {
if ( ! child . getHasFactoryReference ( ) & & ! child . getHasIBMFinalWithDefault ( ) ) {
vmmService . setConfiguredRepository ( fa , fileConfigProps ) ;
vmmService . setConfiguredRepository ( fa , fileConfigProps ) ;
vmmService . setConfiguredRepository ( fa , fileConfigProps ) ;
protected void unsetWebModuleHandler ( ServiceReference < ModuleHandler > ref ) {
vmmService . setConfiguredRepository ( fa , fileConfigProps ) ;
vmmService . setConfiguredRepository ( fa , fileConfigProps ) ;
vmmService . setConfiguredRepository ( fa , fileConfigProps ) ;
vmmService . setConfiguredRepository ( fa , fileConfigProps ) ;
vmmService . setConfiguredRepository ( fa , fileConfigProps ) ;
vmmService . setConfiguredRepository ( fa , fileConfigProps ) ;
protected void setConfiguredRepository ( ConfiguredRepository configuredRepository , Map < String , Object > props ) {
protected void setCustomRepository ( CustomRepository customRepository , Map < String , Object > props ) {
vmmService . setConfiguredRepository ( fa , fileConfigProps ) ;
vmmService . setConfiguredRepository ( fa , fileConfigProps ) ;
vmmService . setConfiguredRepository ( fa , fileConfigProps ) ;
vmmService . setConfiguredRepository ( fa , fileConfigProps ) ;
vmmService . setConfiguredRepository ( fa , fileConfigProps ) ;
vmmService . setConfiguredRepository ( fa , fileConfigProps ) ;
public final static String BEARER = "str" ;
Tr . exit ( this , tc , "str" , rVal = = null ? "str" : Integer . toHexString ( rVal . hashCode ( ) ) ) ;
CollectorJsonHelpers . addToJSON ( sb , gcData . getSequenceKey1_1 ( ) , gcData . getSequence ( ) , false , false , false , false , false ) ;
CollectorJsonHelpers . addToJSON ( sb , gcData . getSequenceKey ( ) , gcData . getSequence ( ) , false , false , false , false , false ) ;
myServer . waitForStringInLog ( "str" ) ) ;
myServer . waitForStringInLog ( "str" ) ) ;
assertTrue ( "str" , combinedCookieValues . contains ( JwtFatConstants . JWT_COOKIE_NAME ) ) ;
assertTrue ( "str" , combinedCookieValues . contains ( JwtFatConstants . JWT_COOKIE_NAME + "str" ) ) ;
assertTrue ( "str" , combinedCookieValues . contains ( JwtFatConstants . JWT_COOKIE_NAME + "str" ) ) ;
String beginStr = "str" + JwtFatConstants . JWT_COOKIE_NAME + "str" ;
request . setAdditionalHeader ( "str" , JwtFatConstants . JWT_COOKIE_NAME + "str" + token ) ;
assertTrue ( "str" , combinedCookieValues . contains ( "str" ) ) ;
assertTrue ( "str" , combinedCookieValues . contains ( "str" ) ) ;
assertTrue ( "str" , combinedCookieValues . contains ( "str" ) ) ;
String beginStr = "str" ;
request . setAdditionalHeader ( "str" , "str" + token ) ;
assertTrue ( "str" , combinedCookieValues . contains ( JwtFatConstants . JWT_COOKIE_NAME ) ) ;
assertTrue ( "str" , combinedCookieValues . contains ( JwtFatConstants . JWT_COOKIE_NAME + "str" ) ) ;
assertTrue ( "str" , combinedCookieValues . contains ( JwtFatConstants . JWT_COOKIE_NAME + "str" ) ) ;
String beginStr = "str" + JwtFatConstants . JWT_COOKIE_NAME + "str" ;
request . setAdditionalHeader ( "str" , JwtFatConstants . JWT_COOKIE_NAME + "str" + token ) ;
if ( isJaspicSessionEnabled ( httpMessageContext ) & & httpMessageContext . getRequest ( ) . getUserPrincipal ( ) ! = null ) {
if ( isJaspicSessionEnabled ( httpMessageContext ) ) {
private boolean isJaspicSessionEnabled ( HttpMessageContext httpMessageContext ) {
return webAppSecurityConfig . isJaspicSessionEnabled ( ) ;
allowing ( webAppSecurityConfig ) . isJaspicSessionEnabled ( ) ;
boolean isJaspicSessionEnabled ( ) ;
if ( registerSession | | webAppSecurityConfig . isJaspicSessionEnabled ( ) ) {
allowing ( webAppSecurityConfig ) . isJaspicSessionEnabled ( ) ;
private final Boolean jaspicSessionEnabled = false ;
static final String CFG_KEY_JASPIC_SESSION_ENABLED = "str" ;
private final Boolean jaspicSessionEnabled ;
put ( CFG_KEY_JASPIC_SESSION_ENABLED , "str" ) ;
jaspicSessionEnabled = ( Boolean ) newProperties . get ( CFG_KEY_JASPIC_SESSION_ENABLED ) ;
if ( isJaspicSessionEnabled ( httpMessageContext ) & & httpMessageContext . getRequest ( ) . getUserPrincipal ( ) ! = null ) {
private boolean isJaspicSessionEnabled ( HttpMessageContext httpMessageContext ) {
return webAppSecurityConfig . isJaspicSessionEnabled ( ) ;
if ( isJaspicSessionEnabled ( httpMessageContext ) ) {
allowing ( webAppSecurityConfig ) . isJaspicSessionEnabled ( ) ;
private final Boolean jaspicSessionEnabled = false ;
public boolean isJaspicSessionEnabled ( ) {
return WebAppSecurityCollaboratorImpl . getGlobalWebAppSecurityConfig ( ) . isJaspicSessionEnabled ( ) ;
put ( "str" , Boolean . TRUE ) ;
put ( "str" , Boolean . FALSE ) ;
public void testIsJaspicSessionEnabled ( ) {
cfg . put ( "str" , expectedValue ) ;
assertEquals ( "str" , expectedValue , webCfg . isJaspicSessionEnabled ( ) ) ;
if ( isJaspicSessionEnabled ( httpMessageContext ) & & httpMessageContext . getRequest ( ) . getUserPrincipal ( ) ! = null ) {
private boolean isJaspicSessionEnabled ( HttpMessageContext httpMessageContext ) {
return webAppSecurityConfig . isJaspicSessionEnabled ( ) ;
if ( isJaspicSessionEnabled ( httpMessageContext ) ) {
String val = options . get ( PackageOption . INCLUDE ) ;
if ( includeAllorNoMinifyRunnable ( val ) ) {
Audit . audit ( Audit . EventID . SECURITY_AUTHZ_01 , webRequest , permitResult , uriName , Integer . valueOf ( HttpServletResponse . SC_OK ) ) ;
Audit . audit ( Audit . EventID . SECURITY_AUTHN_01 , webRequest , authResult , Integer . valueOf ( webReply . getStatusCode ( ) ) ) ;
throw new UnsupportedOperationException ( "str"
private static final String testClassesDir = System . getProperty ( "str" , "str" ) . replace ( "str" , "str" ) ;
private static final String testBuildDir = System . getProperty ( "str" , "str" ) . replace ( "str" , "str" ) ;
public static final boolean DEBUG = false ;
public class StoredResponse extends HttpServletResponseWrapper implements StoredResponseCompat , HttpServletResponse , Serializable , IResponseOutput , IExtendedResponse , IOutputStreamObserver
ProgramOutput po = server . installFeature ( USR_PRODUCT_NAME , "str" ) ;
public class StoredResponse extends HttpServletResponseWrapper implements StoredResponseCompat < CollectionEnumerationHybrid < String > > , HttpServletResponse , Serializable , IResponseOutput , IExtendedResponse , IOutputStreamObserver
public interface OAuth2DeleteService < E , PK > extends DeleteService < E , PK > , OAuth2ServiceSupport {
converter . setSplitter ( str - > Arrays . asList ( str . split ( sppliter ) ) ) ;
, OAuth2DeleteService < E , PK >
return new EnumDictValueConverter < EnumDict > ( ( ) - > ( List ) Arrays . asList ( javaType . getEnumConstants ( ) ) ) ;
JSONObject jsonObject = jsonArray . getJSONObject ( i ) ;
Assert . assertEquals ( permissionEntity . getOptionalFields ( ) . size ( ) , 3 ) ;
"str" + ( dsId = = null ? "str" : dsId ) + "str"
LOGGER . debug ( "str" + ( dataSourceId = = null ? "str" : dataSourceId ) + "str" + this . connection + "str" ) ;
lastDeployMetaData = formParser . parse ( lastDeploy ) ;
metaData . on ( "str" , var ) ;
TriggerResult triggerResult = metaData . on ( "str" , var ) ;
if ( helper ! = null & & ! sql . contains ( "str" ) ) {
processor . onSessionConnect ( session ) ;
@BindView ( R . id . button_save ) View save ;
save . setOnClickListener ( new View . OnClickListener ( ) {
scrambleBackgroundEnabled = Prefs . getBoolean ( R . string . pk_show_scramble_background , false ) ;
actionMode . setTitle ( getResources ( ) . getQuantityString ( R . plurals . selected_list , selectCount , selectCount ) ) ;
actionMode . setTitle ( getResources ( ) . getQuantityString ( R . plurals . selected_list , selectCount , selectCount ) ) ;
CSVReader csvReader = new CSVReader ( br , "str" , "str" , true ) ;
return getTarget ( ) . getUrl ( ) + "str" + getParent ( ) . getName ( ) + "str" + getNumber ( ) + "str" ;
return Hudson . getInstance ( ) . < PromotionCondition , PromotionConditionDescriptor > getDescriptorList ( PromotionCondition . class ) ;
doc1 . put ( "str" , "str" +
evalCmdResidual + = "str" + collection + "str" + model . getName ( ) + "str" + topic . getPath ( ) ;
builder . append ( "str" ) . append ( "str" ) . append ( "str" ) . append ( Paths . get ( getTopic_root ( ) , topic . getPath ( ) ) . toString ( ) ) ;
public String runtag = null ;
throw new RuntimeException ( "str" , e ) ;
throw new RuntimeException ( "str" , e ) ;
throw new RuntimeException ( "str" , e ) ;
throw new RuntimeException ( "str" , e ) ;
if ( e2 . getMessage ( ) ! = null & & e2 . getMessage ( ) . contains ( "str" ) ) {
throw new RuntimeException ( "str" , e ) ;
throw new RuntimeException ( "str" , e ) ;
throw new RuntimeException ( "str" , e ) ;
throw new RuntimeException ( "str" , e ) ;
throw new RuntimeException ( "str" , e ) ;
throw new RuntimeException ( "str" , e ) ;
private final DateFormat format = new SimpleDateFormat (
contents = nytDoc . getBody ( ) = = null ? "str" : nytDoc . getBody ( ) ;
if ( fileName . matches ( "str" ) ) {
searcher . search ( queries , submissionFile , new BM25Similarity ( 0.9f , 0.4f ) , 1000 , "str" ) ;
LOG . info ( "str" + dir ) ;
while ( ( wDoc = ClueWeb12WarcRecord . readNextWarcRecord ( inStream , ClueWeb12WarcRecord . WARC_VERSION ) ) ! = null ) {
while ( ( wDoc = ClueWeb09WarcRecord . readNextWarcRecord ( inStream , ClueWeb09WarcRecord . WARC_VERSION ) ) ! = null ) {
LOG . info ( "str" , dir ) ;
static byte [ ] readNextRecord ( DataInputStream in , StringBuilder headerBuffer , String WARC_VERSION ) throws IOException {
public static ClueWeb09WarcRecord readNextWarcRecord ( DataInputStream in , String WARC_VERSION ) throws IOException {
byte [ ] recordContent = readNextRecord ( in , recordHeader , WARC_VERSION ) ;
public static ClueWeb12WarcRecord readNextWarcRecord ( DataInputStream in , String WARC_VERSION ) throws IOException {
byte [ ] recordContent = ClueWeb09WarcRecord . readNextRecord ( in , recordHeader , WARC_VERSION ) ;
@Comment ( "str" ) public static boolean DEBUG = false ;
"str" + args [ 0 ] + "str" ) ;
if ( canRegen & & ( value [ 6 ] = = 0 ) & & PlotSquared . imp ( ) . getServerVersion ( ) [ 1 ] = = 13 ) {
if ( ! WorldUtil . IMP . isWorld ( name ) & & PlotId . fromStringOrNull ( name ) = = null ) {
public int THRESHOLD = - 1 ;
public int DAYS = 90 ;
idDataPair = new IdDataPair ( Integer . parseInt ( string ) , 0 ) ;
description = "str" ,
MainUtil . sendMessage ( player , String . format ( "str" , responseMessage ) ) ;
OfflinePlayer . class . getDeclaredMethod ( "str" ) ;
MainUtil . sendAdmin ( "str" + "str" + Integer . toHexString ( currentVersion . hash ) ) ;
Bukkit . unloadWorld ( world , true ) ;
this . MIN_BUILD_HEIGHT = config . getInt ( "str" ) ;
public static final String BIN_URL = "str" , USER_AGENT = "str" ;
return "str" + matcher . group ( 1 ) ;
Plot plot = area . getOwnedPlot ( loc ) ;
Plot plot = area . getOwnedPlot ( loc ) ;
Flag < ? > flag = getOrCreateFlag ( split [ 0 ] ) ;
aliases = { "str" , "str" } ,
return linearDouble ( Double . parseDouble ( expression . substring ( 0 , expression . length ( ) - 6 ) ) ) ;
MainUtil . sendMessage ( plr , "str" ) ;
boolean o = flag1 . get ( ) . removeAll ( ( Collection ) flag . parseValue ( value ) ) ;
int i3 = rest . indexOf ( "str" , i2 - name . length ( ) - 1 ) ;
String downloadURL = String . format ( "str" , PS . get ( ) . getPlatform ( ) ) ;
public void onWorldInit ( final WorldInitEvent event ) {
URL url = new URL ( asset . getString ( "str" ) ) ;
plotworld . loadConfiguration ( config . getConfigurationSection ( "str" + world ) ) ;
PS . debug ( "str" ) ;
PS . debug ( "str" ) ;
command = "str" ,
url = new URL ( Settings . WEB_URL + "str" + plr . getUUID ( ) + "str" + schem + "str" ) ;
options . put ( "str" , true ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . debug ( "str" + ( loc . x + x_offset ) + "str" + ( loc . y ) + "str" + ( loc . z + z_offset ) ) ;
PS . log ( ( prefix ? C . PREFIX . s ( ) : "str" ) + msg ) ;
plr . sendMessage ( ( prefix ? C . PREFIX . s ( ) : "str" ) + C . color ( msg ) ) ;
add ( String . format ( "str" , PS . get ( ) . IMP . getVersion ( ) ) ) ;
add ( String . format ( "str" ) ) ;
manager . createTables ( "str" ) ;
final File playerdataFolder = new File ( Bukkit . getWorldContainer ( ) , world + File . separator + "str" ) ;
final File playerdataFolder = new File ( Bukkit . getWorldContainer ( ) , worldname + File . separator + "str" ) ;
return MainUtil . sendMessage ( player , "str" ) ;
return MainUtil . sendMessage ( player , "str" ) ;
return MainUtil . sendMessage ( player , "str" ) ;
return MainUtil . sendMessage ( player , "str" ) ;
return MainUtil . sendMessage ( player , "str" + args [ 1 ] ) ;
MainUtil . sendMessage ( player , "str" ) ;
return MainUtil . sendMessage ( player , "str" ) ;
return MainUtil . sendMessage ( player , "str" + args [ 1 ] ) ;
return MainUtil . sendMessage ( player , "str" + args [ 1 ] ) ;
MainUtil . sendMessage ( player , "str" + ExpireManager . expiredPlots . get ( args [ 1 ] ) . size ( ) + "str" ) ;
MainUtil . sendMessage ( player , "str" + plot . world + "str" + plot . id . x + "str" + plot . id . y + "str" + UUIDHandler . getName ( plot . owner ) + "str" + stamp ) ;
return MainUtil . sendMessage ( player , "str" ) ;
return MainUtil . sendMessage ( player , "str" ) ;
return MainUtil . sendMessage ( player , "str" + args [ 1 ] ) ;
return MainUtil . sendMessage ( player , "str" + args [ 1 ] ) ;
return MainUtil . sendMessage ( player , "str" + args [ 1 ] ) ;
MainUtil . sendMessage ( player , "str" ) ;
if ( ( plot = = null ) | | ( ! plot . isOwner ( pp . getUUID ( ) ) & & ! plot . helpers . contains ( DBFunc . everyone ) & & ! plot . helpers . contains ( pp . getUUID ( ) ) ) ) {
final int currentPlots = ( Settings . GLOBAL_LIMIT ? MainUtil . getPlayerPlotCount ( other ) : MainUtil . getPlayerPlotCount ( loc . getWorld ( ) , other ) ) + size ;
if ( ( i < 1 ) | | ( i > plots . size ( ) ) ) {
MainUtil . teleportPlayer ( plr , plr . getLocation ( ) , plots . get ( i - 1 ) ) ;
final List < String > intFlags = Arrays . asList ( "str" , "str" , "str" ) ;
Flag monsterFlag = FlagManager . getPlotFlag ( plot , "str" ) ;
MainUtil . sendMessage ( plr , C . INVALID_PLAYER , args [ 2 ] ) ;
MainUtil . sendMessage ( plr , C . INVALID_PLAYER , args [ 2 ] ) ;
string . append ( "str" + x + "str" + c . world + "str" + c . id + "str" + c . senderName + "str" + color + c . comment + "str" ) ;
MainUtil . sendMessage ( plr , C . INVALID_PLAYER , args [ 0 ] ) ;
final PlotLoc loc = new PlotLoc ( ( X + x ) , ( Z + z ) ) ;
final PlotLoc loc = new PlotLoc ( absX , absZ ) ;
final PlotLoc loc = new PlotLoc ( absX , absZ ) ;
PlotLoc loc = new PlotLoc ( x , z ) ;
final PlotLoc loc = new PlotLoc ( ( X + x ) , ( Z + z ) ) ;
final PlotLoc loc = new PlotLoc ( x , z ) ;
public PlotLoc ( final int x , final int z ) {
public void movePlot ( final Plot original , final Plot newPlot ) {
MainUtil . setSimpleCuboid ( plotworld . worldname , new Location ( plotworld . worldname , sx , Math . min ( dpw . WALL_HEIGHT , dpw . ROAD_HEIGHT ) + 1 , sz ) , new Location ( plotworld . worldname , ex + 1 , 257 , ez + 1 ) , new PlotBlock ( ( short ) 0 , ( byte ) 0 ) ) ;
AbstractSetBlock . setBlockManager = new SetBlockSlow ( ) ;
super ( Command . BAN , "str" , "str" , CommandCategory . ACTIONS , true ) ;
super ( Command . UNBAN , "str" , "str" , CommandCategory . ACTIONS , true ) ;
super ( Command . DEOP , "str" , "str" , CommandCategory . ACTIONS , true ) ;
super ( Command . OP , "str" , "str" , CommandCategory . ACTIONS , true ) ;
super ( Command . SWAP , "str" , "str" , CommandCategory . ACTIONS , true ) ;
Location pos1 = PlotHelper . getPlotBottomLoc ( bukkitWorld , plot . id ) . add ( 1 , 0 , 1 ) ;
Location pos1 = PlotHelper . getPlotBottomLoc ( bukkitWorld , plot . id ) . add ( 1 , 0 , 1 ) ;
final Location q = new Location ( t . getWorld ( ) , t . getBlockX ( ) , 0 , t . getZ ( ) ) ;
if ( id ! = null & & plotworld . TYPE = = 2 ) {
if ( args . length ! = 2 ) {
if ( args . length ! = 1 ) {
if ( ! ( pW . CLAIMED_WALL_BLOCK . equals ( pW . WALL_BLOCK ) ) ) {
final World w = l . getWorld ( ) ;
public static boolean isPlotArea ( Location location ) {
if ( isPlotArea ( loc ) ) {
if ( isPlotArea ( loc ) ) { event . setCancelled ( true ) ; }
if ( isPlotArea ( loc ) ) {
if ( isPlotArea ( loc ) ) {
if ( isPlotArea ( e . getBlock ( ) . getLocation ( ) ) ) { e . setCancelled ( true ) ; }
if ( isPlotArea ( e . getBlock ( ) . getLocation ( ) ) ) { e . setCancelled ( true ) ; }
if ( isPlotArea ( e . getBlock ( ) . getLocation ( ) ) ) { e . setCancelled ( true ) ; }
if ( isPlotArea ( e . getBlock ( ) . getLocation ( ) ) ) { e . setCancelled ( true ) ; }
if ( isPlotArea ( e . getBlock ( ) . getLocation ( ) ) ) { e . setCancelled ( true ) ; }
if ( isPlotArea ( e . getBlock ( ) . getLocation ( ) ) ) { e . setCancelled ( true ) ; }
if ( isPlotArea ( e . getBlock ( ) . getLocation ( ) ) ) { e . setCancelled ( true ) ; }
if ( isPlotArea ( e . getBlock ( ) . getLocation ( ) ) ) { e . setCancelled ( true ) ; }
if ( isPlotArea ( e . getBlock ( ) . getLocation ( ) ) ) { e . setCancelled ( true ) ; }
if ( isPlotArea ( loc ) ) { e . getBlocks ( ) . remove ( i ) ; }
if ( isPlotArea ( loc ) ) {
if ( isPlotArea ( loc ) ) { event . setCancelled ( true ) ; }
if ( isPlotArea ( loc ) ) {
if ( isPlotArea ( loc ) ) { e . setCancelled ( true ) ; }
if ( isPlotArea ( loc ) ) {
if ( isPlotArea ( loc ) ) {
if ( isPlotArea ( loc ) ) {
if ( isPlotArea ( l ) ) {
if ( isPlotArea ( l ) ) {
if ( isPlotArea ( l ) ) {
if ( isPlotArea ( l ) ) {
if ( isPlotArea ( l ) ) {
if ( isPlotArea ( loc ) ) {
Settings . OFFLINE_MODE = config . getBoolean ( "str" ) ;
} else if ( plot ! = null & & plot . owner . equals ( uuid ) ) {
public class WorldEditListener implements Listener {
final String sTitleMain = C . TITLE_ENTERED_PLOT . s ( ) . replaceAll ( "str" , plot . id . x + "str" ) . replaceAll ( "str" , plot . id . y + "str" ) . replaceAll ( "str" , plot . world + "str" ) ;
new Rate ( ) ,
. replace ( "str" , cmd . alias . get ( 0 ) )
if ( command . cmd . equalsIgnoreCase ( args [ 0 ] ) | | command . alias . contains ( args [ 0 ] . toLowerCase ( ) ) ) {
} catch ( final Throwable e ) {
} catch ( final Throwable e ) {
Bukkit . getServer ( ) . getOnlineMode ( ) & & ! Settings . OFFLINE_MODE ;
private final static boolean online = Bukkit . getServer ( ) . getOnlineMode ( ) & & ! Settings . OFFLINE_MODE ;
if ( ( plot . owner = = null ) | | ! plot . getOwner ( ) . equals ( plr ) ) {
if ( ( plot . owner = = null ) | | ! plot . getOwner ( ) . equals ( plr ) ) {
. replace ( "str" , "str" + ( commands . size ( ) % perPage ) )
if ( player . hasPermission ( "str" + flag . getKey ( ) . toLowerCase ( ) ) ) {
connection . prepareStatement ( "str" + PREFIX + "str" ) ;
PLOT_INFO_DENIED ( "str" ) ,
ResultSet res = meta . getTables ( null , null , Settings . DB . PREFIX + "str" , null ) ;
res = meta . getTables ( null , null , Settings . DB . PREFIX + "str" , null ) ;
res = meta . getTables ( null , null , Settings . DB . PREFIX + "str" , null ) ;
options . put ( "str" , "str" ) ;
if ( ( pos2 . getBlockX ( ) - pos1 . getBlockX ( ) ) < 48 ) {
PlotHelper . setSimpleCuboid ( world , new Location ( world , max . getBlockX ( ) , dpw . PLOT_HEIGHT + 1 , min . getBlockZ ( ) ) , new Location ( world , plotMaxX + 1 , world . getMaxHeight ( ) + 1 , max . getBlockZ ( ) + 1 ) , new PlotBlock ( ( short ) 7 , ( byte ) 0 ) ) ;
PreparedStatement stmt = connection . prepareStatement ( "str" ) ;
Plot plot = getCurrentPlot ( event . getFrom ( ) ) ;
new Info ( ) , new list ( ) , new Help ( ) , new Debug ( ) , new Schematic ( ) , new plugin ( ) , new Inventory ( ) , new Purge ( ) ,
if ( ! PlotMain . hasPermission ( player , "str" ) ) {
if ( player = = null | | player . isOp ( ) ) {
new ConfigurationNode ( "str" , DefaultPlotWorld . PLOT_WIDTH_DEFAULT , "str" , Configuration . INTEGER , true ) ,
this . PLOT_WIDTH = config . getInt ( "str" ) ;
mWifiManager = ( WifiManager ) getApplicationContext ( ) . getSystemService ( WIFI_SERVICE ) ;
final int finalNetworkId = networkId ;
mWifiManager . enableNetwork ( finalNetworkId , true ) ;
for ( int i = 0 ; i < 50 ; i + + ) {
String [ ] strings = { "str" , "str" + data . getName ( ) } ;
child . setTranslationY ( TanTanLayoutManager . MAX_TRANSLATION_Y * ( level - Math . abs ( proportion ) ) ) ;
public static final int MAX_TRANSLATION_Y = 20 ;
child . setTranslationY ( MAX_TRANSLATION_Y * level ) ;
child . setTranslationY ( MAX_TRANSLATION_Y * ( level - 1 ) ) ;
config . getCountStyle ( ) . fillPaint ( paint ) ;
import android . support . multidex . MultiDexApplication ;
public class MainApplication extends MultiDexApplication {
private static final int ID_LENGTH = 255 ;
@ResponseStatus ( HttpStatus . INTERNAL_SERVER_ERROR )
final private String QUERY_DELETE_FINISHED_STEPS_FROM_QUEUES = "str" +
deletedRows = deleteFinishedStepsJDBCTemplate . update ( query , args ) ;
logger . debug ( "str" + deletedRows + "str" ) ;
logger . warn ( "str" + workerUuid + "str" + ( System . currentTimeMillis ( ) - time ) + "str" ) ;
ControlActionMetadata metadata = new ControlActionMetadata ( "str" , "str" ) ;
ControlActionMetadata metadata = new ControlActionMetadata ( "str" , "str" ) ;
ControlActionMetadata metadata = new ControlActionMetadata ( "str" , "str" ) ;
ControlActionMetadata metadata = new ControlActionMetadata ( "str" , "str" ) ;
private final static String navigationActionClassName = "str" ;
ExecutionStep executionStep = createExecutionStep ( 0 L , "str" , "str" , new HashMap < String , Serializable > ( ) ) ;
ExecutionStep executionStep2 = createExecutionStep ( 1L , "str" , "str" , new HashMap < String , Serializable > ( ) ) ;
ExecutionStep executionSplitStep = createExecutionStep ( 0 L , "str" , "str" , actionData ) ;
ExecutionStep executionStep2 = createExecutionStep ( 1L , "str" , "str" , new HashMap < String , Serializable > ( ) ) ;
ExecutionStep executionStep3 = createExecutionStep ( 2L , "str" , "str" , actionData ) ;
ExecutionStep executionSplitStep = createExecutionStep ( 0 L , "str" , "str" , actionData ) ;
ExecutionStep executionStep2 = createExecutionStep ( 1L , "str" , "str" , new HashMap < String , Serializable > ( ) ) ;
return createExecutionStep ( stepId , "str" , "str" , new HashMap < String , Serializable > ( ) ) ;
ExecutionStep executionPutDataStep = createExecutionStep ( stepId , "str" , "str" , new HashMap < String , Serializable > ( ) ) ;
ExecutionStep executionSplitStep = createExecutionStep ( 1L , "str" , "str" , actionData ) ;
ExecutionStep executionJoinStep = createExecutionStep ( 2L , "str" , "str" , new HashMap < String , Serializable > ( ) ) ;
props . setProperty ( "str" , "str" ) ;
emf . setPackagesToScan ( "str" ) ;
@EnableJpaRepositories ( "str" )
@EnableJpaRepositories ( "str" )
fb . setPackagesToScan ( "str" ) ;
@EnableJpaRepositories ( "str" )
fb . setPackagesToScan ( "str" ) ;
put ( WorkerManagerMBean . class , "str" ) ;
@EnableJpaRepositories ( "str" )
fb . setPackagesToScan ( "str" ) ;
@EnableJpaRepositories ( "str" )
fb . setPackagesToScan ( "str" ) ;
package org . openscore . events ;
@GenericGenerator ( name = "str" , strategy = "str" )
@EnableJpaRepositories ( "str" )
fb . setPackagesToScan ( "str" ) ;
@EnableJpaRepositories ( "str" )
put ( WorkersMBean . class , "str" ) ;
public static final String DEFAULT_IMAGE_REF = "str" ;
put ( WorkersMBean . class , "str" ) ;
if ( ! isDebuggerMode ( execution . getSystemContext ( ) ) & & reason . equals ( PauseReason . USER_PAUSED ) ) {
if ( eventsPersistencyOn ) {
public static final long EVENT_AGGREGATION_DEBUGGER_TIME_THRESHOLD = 750 ;
if ( isDebuggerMode ( execution . getSystemContext ( ) ) ) {
verify ( workerNodeService , atLeastOnce ( ) ) . up ( CREDENTIAL_UUID ) ;
PageRequest page = new PageRequest ( 0 , maxResultSize , Sort . Direction . ASC , END_TIME_COLUMN_NAME ) ;
Pageable page = new PageRequest ( 0 , 1 , Sort . Direction . ASC , "str" ) ;
assertEquals ( "str" , result . get ( result . size ( ) - 1 ) ) ;
page = new PageRequest ( 0 , 6 , Sort . Direction . ASC , "str" ) ;
if ( stepLogCategory . equals ( ExecutionEnums . StepLogCategory . STEP_END ) ) {
if ( stepLogCategory . equals ( ExecutionEnums . StepLogCategory . STEP_END ) | | stepLogCategory . equals ( ExecutionEnums . StepLogCategory . STEP_ERROR ) ) {
dumpExecutionEvents ( execution , false ) ;
throw new ServiceConnectorCreationException ( "str"
handleOutput ( "str" ) ;
import org . springframework . core . task . SyncTaskExecutor ;
private Executor taskExecutor = new SyncTaskExecutor ( ) ;
internalConfig . set ( "str" , fsUri . trim ( ) ) ;
internalConfig . set ( "str" , jtUri . trim ( ) ) ;
public class JobRunner implements FactoryBean < Boolean > , InitializingBean , DisposableBean {
public Boolean getObject ( ) throws Exception {
flow = createFlow ( ) ;
final Configuration cfg = ConfigurationUtils . createFrom ( configuration , properties ) ;
final Configuration cfg = ConfigurationUtils . createFrom ( configuration , properties ) ;
cfg = new JobConf ( ) ;
return path . toUri ( ) . getPath ( ) ;
return ( waitForJobs ? succesful : null ) ;
frequenciesToDetect , calculatedPowers . clone ( ) ) ;
button . setActionCommand ( value . name ( ) ) ;
"str" , e ) ;
public class java_io_PrintStream_println extends MethodStateMethod implements UnknownValuesMethod {
public java_io_PrintStream_println ( ) {
public void constantizableHandlesNull ( ) {
public void canNotConstantizeAddInt2Addr ( ) {
public void canNotConstantizeAGetWithUnknownArray ( ) {
public void canNotConstantizeAGetWithUnknownIndex ( ) {
public void canNotConstantizeIntegerValueOf ( ) {
public void canNotConstantizeMoveOp ( ) {
usage = "str" )
log . warn ( "str" + methodDescriptor , e ) ;
private int maxAddressVisits = 5000 ;
private int maxMethodVisits = maxAddressVisits * 20 ;
TIntList expected = new TIntArrayList ( new int [ ] { 2 } ) ;
. append ( parameterRegisters [ parameterRegisters . length - 1 ] ) ;
log . info ( "str" + methodDescriptor + "str" ) ;
result . setAudioCount ( data . getInt ( "str" ) ) ;
result . setVideoCount ( data . getInt ( "str" ) ) ;
Element resElement = wrapperElement . getElementsByClass ( "str" ) . first ( ) ;
Element sfwElement = document . select ( "str" ) . first ( ) ;
if ( sfwElement . toString ( ) . contains ( "str" ) ) {
Element imageUrlElement = document . select ( "str" ) . first ( ) ;
return Server . getServerConfig ( ) ;
Status status0 = new Status ( "str" , "str" ) ;
Status status1 = new Status ( "str" , "str" ) ;
Status status0 = new Status ( "str" , "str" ) ;
Status status1 = new Status ( "str" , "str" ) ;
Status status0 = new Status ( "str" , "str" ) ;
Status status1 = new Status ( "str" , "str" ) ;
URL subscribeUrl = URLImpl . valueOf ( protocol + "str" + serviceName ) ;
System . out . println ( "str" + Encode . forJava ( configFilename . substring ( 0 , configFilename . indexOf ( "str" ) ) ) + "str" ) ;
checkString = "str" + config . deregisterAfter + "str" + config . checkInterval + "str" ;
checkString = "str" + config . deregisterAfter + "str" + "str" + "str" + config . checkInterval + "str" ;
+ String . format ( checkString , id , address , port , name ) ;
Assert . assertEquals ( "str" , s ) ;
Assert . assertEquals ( "str" , s ) ;
Assert . assertEquals ( "str" , s ) ;
Assert . assertEquals ( "str" , s ) ;
Assert . assertEquals ( "str" , s ) ;
Assert . assertEquals ( "str" , s ) ;
( finalResult = = null ? 0 : finalResult . size ( ) ) + "str" + ( finalResult = = null ? null : finalResult . toString ( ) ) ) ;
InputStream anyInputStream = new ByteArrayInputStream ( expected . getBytes ( StandardCharsets . UTF_8 ) ) ;
if ( logger . isTraceEnabled ( ) ) logger . trace ( "str" + isInRenewWindow ) ;
if ( logger . isTraceEnabled ( ) ) logger . trace ( "str" ) ;
if ( logger . isTraceEnabled ( ) ) logger . trace ( "str" ) ;
if ( logger . isTraceEnabled ( ) ) logger . trace ( "str" ) ;
if ( logger . isTraceEnabled ( ) ) logger . trace ( "str" ) ;
if ( logger . isTraceEnabled ( ) ) logger . trace ( "str" ) ;
if ( logger . isTraceEnabled ( ) ) logger . trace ( "str" ) ;
if ( logger . isTraceEnabled ( ) ) logger . trace ( "str" ) ;
if ( logger . isTraceEnabled ( ) ) logger . trace ( "str" ) ;
if ( logger . isInfoEnabled ( ) ) logger . info ( "str" + Encode . forJava ( trustStoreName ) ) ;
if ( logger . isInfoEnabled ( ) ) logger . info ( "str" + Encode . forJava ( trustStoreName ) ) ;
static final String DEFAULT_ENV = "str" ;
connection = client . connect ( new URI ( configUri ) , Http2Client . WORKER , Http2Client . SSL , Http2Client . POOL , OptionMap . create ( UndertowOptions . ENABLE_HTTP2 , true ) ) . get ( ) ;
public static final String JWT_CLOCK_SKEW_IN_SECONDS = "str" ;
static int secondsOfAllowedClockSkew = ( Integer ) securityJwtConfig . get ( JWT_CLOCK_SKEW_IN_SECONDS ) ;
body = Config . getInstance ( ) . getMapper ( ) . readValue ( s , new TypeReference < List < Object > > ( ) {
if ( bootstrapFromKeyService = = null | | Boolean . FALSE . equals ( bootstrapFromKeyService ) ) {
latch . await ( 4 , TimeUnit . SECONDS ) ;
if ( startupHookProviders ! = null ) Arrays . stream ( startupHookProviders ) . forEach ( s - > s . onStartup ( ) ) ;
return "str" + status . getStatusCode ( )
Assert . assertEquals ( "str" , status . toString ( ) ) ;
Assert . assertEquals ( "str" , status . toString ( ) ) ;
A a = SingletonServiceFactory . getBean ( A . class ) ;
B b = SingletonServiceFactory . getBean ( B . class ) ;
C c = SingletonServiceFactory . getBean ( C . class ) ;
G g = SingletonServiceFactory . getBean ( G . class ) ;
KeyRequest keyRequest = new KeyRequest ( "str" ) ;
KeyRequest keyRequest = new KeyRequest ( kid ) ;
public KeyRequest ( String kid ) {
setUri ( ( String ) keyConfig . get ( URI ) + "str" + kid ) ;
NioUtils . list ( url . getPath ( ) . toString ( ) . replace ( "str" , "str" ) ) ;
NioUtils . unzip ( url . getPath ( ) . toString ( ) . replace ( "str" , "str" ) , NioUtils . getTempDir ( ) ) ;
Assert . assertTrue ( HashUtil . validatePassword ( p . toCharArray ( ) , hashedPass ) ) ;
Assert . assertTrue ( HashUtil . validatePassword ( s . toCharArray ( ) , hashedPass ) ) ;
public static boolean validatePassword ( char [ ] originalPassword , String storedPassword ) throws NoSuchAlgorithmException , InvalidKeySpecException
PBEKeySpec spec = new PBEKeySpec ( originalPassword , salt , iterations , hash . length * 8 ) ;
Assert . assertNull ( urls ) ;
private void registerMBean ( Object mBean , ObjectName objectName ) throws JMException {
public static void handleSingleImpl ( List < Class > interfaceClasses , List < Object > value ) throws Exception {
public static void handleMultipleImpl ( List < Class > interfaceClasses , List < Object > value ) throws Exception {
if ( ( queryParameterValues = = null | | queryParameterValues . isEmpty ( ) ) & & queryParameter . getRequired ( ) ) {
if ( ! TextUtils . isEmpty ( accountCreationModel . getManagementServer ( ) ) ) {
if ( isGranted & & mHardwareService . hasMicrophone ( ) ) {
} , mPreferenceService . getUserSettings ( ) . isHwEncoding ( ) , mPreferenceService . getUserSettings ( ) . isHD ( ) ) ;
settings . setHwEncoding ( appPrefs . getBoolean ( RING_HW_ENCODING , true ) ) ;
public void openCamera ( @NonNull Context context , VideoParams videoParams , TextureView surface , CameraListener listener , boolean hw_accel , boolean is_hd ) {
final Pair < MediaCodec , Surface > codec = hw_accel ? openCameraWithEncoder ( videoParams , MediaFormat . MIMETYPE_VIDEO_AVC , handler , is_hd ) : null ;
loadContactData ( contact ) . subscribe ( ( ) - > { } , e - > Log . e ( TAG , "str" ) ) ;
. subscribe ( ( ) - > view . displayContact ( mCallContact ) , rt - > view . displayContact ( mCallContact ) ) ) ;
mCompositeDisposable . add ( mContactService . getLoadedContact ( currentAccount . getAccountID ( ) , mCallContact )
. subscribe ( view : : displayContact , e - > Log . e ( TAG , "str" ) ) ) ;
messageNotificationBuilder . addAction ( 0 , mContext . getString ( R . string . notif_mark_as_read ) , PendingIntent . getService ( mContext , Long . valueOf ( System . currentTimeMillis ( ) ) . intValue ( ) , intentRead , 0 ) ) ;
if ( cameraExternal ! = null & & currentCamera . equals ( cameraBack ) ) {
public static final int MAX_SIZE_RINGTONE = 64 * 1024 ;
return ( lastEvent = = null ) ? 0 : lastEvent . getDate ( ) ;
showHideLinkButton ( ) ;
showHideLinkButton ( ) ;
FrameLayout preview = findViewById ( R . id . camera_preview ) ;
mPhoto = v . findViewById ( R . id . photo ) ;
super . onBackPressed ( ) ;
RingAccountViewModelImpl ringAccountViewModel = ( RingAccountViewModelImpl ) getArguments ( ) . get ( RingAccountCreationFragment . KEY_RING_ACCOUNT ) ;
Intent emailIntent = new Intent ( Intent . ACTION_SENDTO , Uri . parse ( "str" + "str" ) ) ;
mUserSettings . setAllowSystemContacts ( appPrefs . getBoolean ( RING_SYSTEM_CONTACTS , false ) ) ;
String keyHashMap = VCardUtils . MIME_RING_PROFILE_VCARD + "str" + key + "str" + i + "str" + nbTotal ;
if ( mSipCall ! = null & & mSipCall . getNumber ( ) . contains ( address ) ) {
if ( callState = = SipCall . State . SEARCHING | |
int SEARCHING = 1 ;
return mCallState = = State . CONNECTING | | mCallState = = State . RINGING | | mCallState = = State . NONE | | mCallState = = State . SEARCHING ;
if ( split . length > 1 ) {
boolean hasPane = mAccountID ! = null & & ! mAccountID . equals ( mAccountService . getCurrentAccount ( ) . getAccountID ( ) ) ;
return mAccount ! = null & & mAccount . get ( ) ! = null ;
fragmentManager . beginTransaction ( ) . replace ( R . id . main_frame , fContent , HOME_TAG ) . addToBackStack ( HOME_TAG ) . commitAllowingStateLoss ( ) ;
fragmentManager . beginTransaction ( ) . replace ( R . id . main_frame , fContent ) . addToBackStack ( HOME_TAG ) . commitAllowingStateLoss ( ) ;
if ( split . length > 1 ) {
public void hangUpClicked ( View view ) {
private final static int MAX_IMAGE_DIMENSION = 200 ;
if ( mService ! = null & & mAccountLoader ! = null ) {
if ( mAccountLoader ! = null & & mAccountLoader . isStarted ( ) ) {
bindService ( intent , mConnection , BIND_AUTO_CREATE | BIND_IMPORTANT | BIND_ABOVE_CLIENT ) ;
bindService ( intent , mConnection , BIND_AUTO_CREATE | BIND_IMPORTANT | BIND_ABOVE_CLIENT ) ;
boolean startOnBoot = sharedPreferences . getBoolean ( c . getString ( R . string . pref_startOnBoot_key ) , true ) ;
if ( ! mime . contentEquals ( Im . CONTENT_ITEM_TYPE ) | | new SipUri ( number ) . isRingId ( ) )
mLines . setColor ( mContext . getResources ( ) . getColor ( R . color . sfl_blue_lines ) ) ;
if ( b . isOnBorder ( model . width , model . height ) & & ! b . expanded ) {
Log . i ( TAG , "str" ) ;
final String TAG = "str" ;
Log . i ( TAG , "str" ) ;
Log . i ( TAG , "str" + b . getString ( "str" ) ) ;
return output * ( 1d - output ) ;
lms . calculateWeightChanges ( new double [ ] { 1D } ) ;
protected void calculateWeightChanges ( double [ ] patternError ) {
protected void calculateWeightChanges ( double [ ] outputError ) {
protected void calculateWeightChanges ( double [ ] patternError ) {
protected void calculateWeightChanges ( double [ ] outputError ) {
protected void calculateWeightChanges ( double [ ] outputError ) {
protected void calculateWeightChanges ( double [ ] desiredOutput ) {
initGridPoints ( ) ;
io = IOProvider . getDefault ( ) . getIO ( "str" , new Action [ ] { levelFine , levelInfo } ) ;
if ( positiveInputsOnly ( ) ) {
import org . neuroph . contrib . convolution . ConvolutionalUtils ;
Layer2D . Dimensions inputDimension ;
inputDimension = new Layer2D . Dimensions ( 1 , 1 ) ;
inputLayer = new InputMapsLayer ( inputDimension , 1 ) ;
Layer2D featureMap = new Layer2D ( hiddenLayer . getMapDimensions ( ) , PoolingLayer . DEFAULT_NEURON_PROP ) ;
ConvolutionalUtils . connectFeatureMaps ( inputLayer , hiddenLayer , 0 , 0 ) ;
Layer2D featureMap = new Layer2D ( hiddenLayer . getMapDimensions ( ) , PoolingLayer . DEFAULT_NEURON_PROP ) ;
ConvolutionalUtils . connectFeatureMaps ( inputLayer , hiddenLayer , 0 , 0 ) ;
inputDimension = new Layer2D . Dimensions ( 4 , 4 ) ;
inputLayer = new InputMapsLayer ( inputDimension , 1 ) ;
Layer2D featureMap = new Layer2D ( hiddenLayer . getMapDimensions ( ) , PoolingLayer . DEFAULT_NEURON_PROP ) ;
ConvolutionalUtils . connectFeatureMaps ( inputLayer , hiddenLayer , 0 , 0 ) ;
import org . neuroph . contrib . convolution . Layer2D . Dimensions ;
Layer2D . Dimensions inputDimension ;
ConvolutionalUtils . connectFeatureMaps ( inputLayer , hiddenLayer , inputMapIndex , hiddenMapIndex ) ;
ConvolutionalUtils . connectFeatureMaps ( inputLayer , hiddenLayer , 0 , 0 ) ;
ConvolutionalUtils . connectFeatureMaps ( inputLayer , hiddenLayer , 0 , 0 ) ;
Dimensions hiddenDimension = hiddenLayer . getMapDimensions ( ) ;
Layer2D . Dimensions inputDimension ;
inputLayer = new InputMapsLayer ( inputDimension , 1 ) ;
inputDimension = new Layer2D . Dimensions ( 4 , 4 ) ;
inputDimension = new Layer2D . Dimensions ( 4 , 4 ) ;
inputDimension = new Layer2D . Dimensions ( 3 , 5 ) ;
inputDimension = new Layer2D . Dimensions ( 3 , 5 ) ;
FeatureMapsLayer outputLayer = new ConvolutionalLayer ( hiddenLayer2 , new Kernel ( 3 , 3 ) ) ;
FeatureMapsLayer outputLayer = new ConvolutionalLayer ( hiddenLayer2 , new Kernel ( 3 , 3 ) ) ;
Layer2D . Dimensions dimension = new Layer2D . Dimensions ( 0 , 0 ) ;
Layer2D . Dimensions dimension = new Layer2D . Dimensions ( 4 , 3 ) ;
Layer2D . Dimensions dimension = new Layer2D . Dimensions ( 4 , 3 ) ;
import org . neuroph . core . data . BufferedDataSet ;
import org . neuroph . core . data . DataSet ;
if ( Build . VERSION . SDK_INT > = Build . VERSION_CODES . LOLLIPOP & & Daedalus . getPrefs ( ) . getBoolean ( "str" , false ) ) {
DNSMessage . Builder builder = dnsMsg . asBuilder ( ) . setQrFlag ( false ) ;
DNSMessage . Builder builder = dnsMsg . asBuilder ( ) . setQrFlag ( false ) ;
if ( connection ! = null )
+ "str" + Integer . toHexString ( RANDOM . nextInt ( 0x1_000000 ) ) ;
if ( bridges . size ( ) > = 2 )
BrewInstance instance = find ( getJid ( chatMember ) ) ;
public static final String PNAME_AUDIO_PACKET_DELAY = "str" ;
public static final String PNAME_CHANNEL_LAST_N = "str" ;
public static final String PNAME_DISABLE_RTX = "str" ;
public static final String PNAME_START_BITRATE = "str" ;
public static final String PNAME_STEREO = "str" ;
public static final String PNAME_USE_ROOM_AS_SHARED_DOC_NAME
private static final boolean DEFAULT_ENABLE_REMB = false ;
private static final boolean DEFAULT_ENABLE_TCC = true ;
private static final int DEFAULT_MIN_PARTICIPANTS = 2 ;
public static final int DEFAULT_START_BITRATE = 800 ;
String enforcedBridge = properties . get ( PNAME_ENFORCED_BRIDGE ) ;
return getInt ( PNAME_CHANNEL_LAST_N ) ;
return getBoolean ( PNAME_ENABLE_LIPSYNC ) ;
return getInt ( PNAME_AUDIO_PACKET_DELAY ) ;
String disableRtxStr = properties . get ( PNAME_DISABLE_RTX ) ;
Integer minParticipants = getInt ( PNAME_MIN_PARTICIPANTS ) ;
? minParticipants : DEFAULT_MIN_PARTICIPANTS ;
return getBoolean ( PNAME_OPEN_SCTP ) ;
return getInt ( PNAME_START_AUDIO_MUTED ) ;
return getInt ( PNAME_START_VIDEO_MUTED ) ;
Integer minBitrate = getInt ( PNAME_MIN_BITRATE ) ;
Boolean stereo = getBoolean ( PNAME_STEREO ) ;
Boolean useRoom = getBoolean ( PNAME_USE_ROOM_AS_SHARED_DOC_NAME ) ;
eventAdmin . postEvent (
eventAdmin . postEvent (
eventAdmin . postEvent (
eventAdmin . postEvent (
eventAdmin . postEvent (
eventAdmin . postEvent (
eventAdmin . postEvent ( event ) ;
catch ( Throwable e )
catch ( Throwable t )
catch ( Throwable e )
return sessionId ! = null ? authenticationSessions . get ( sessionId ) : null ;
jibriJid , roomName , iq . getStreamId ( ) ) ;
if ( ! useBundle )
List < SimulcastStream > layers
for ( SimulcastStream layer : layers )
public List < SimulcastStream > getSimulcastLayers (
SimulcastStream [ ] layers
. getSimulcastStreams ( ) ;
this . ignoreWarnings = Boolean . valueOf ( prop . getProperty ( SETTING_KEY . ignore_warnings . name ( ) , "str" ) ) ;
runner . delete ( "str" + option . getChangelogTable ( ) + "str" ,
private static final String CUSTOM_NEW_COMMAND_TEMPLATE_PROPERTY = "str" ;
String customConfiguredTemplate = getPropertyOption ( CUSTOM_NEW_COMMAND_TEMPLATE_PROPERTY ) ;
safeMigratorMain ( args ( "str" + f . getAbsolutePath ( ) , "str" , "str" ) ) ;
info . setLength ( 1584 ) ;
assertEquals ( 1584 , length ) ;
assertEquals ( 1584 , length ) ;
info . setLength ( 1584 ) ;
assertEquals ( "str" , actual . getHeaders ( ) . getFirstValue ( "str" ) ) ;
Response actual = instance . sendGETRequest ( new Range ( 10 , 50 , 1584 ) ) ;
assertEquals ( 1584 , length ) ;
assertEquals ( 1584 , length ) ;
assertEquals ( 1584 , length ) ;
assertEquals ( 1584 , bytes . length ) ;
assertEquals ( 1584 , os . toByteArray ( ) . length ) ;
assertEquals ( 1584 , is . available ( ) ) ;
assertEquals ( 1584 , is . length ( ) ) ;
assertEquals ( "str" , actual . getHeaders ( ) . getFirstValue ( "str" ) ) ;
assertEquals ( "str" ,
assertEquals ( 2 , newInstance ( "str" ) . getLoopCount ( ) ) ;
loopCount = ( b [ 2 ] & 0xFF < < 8 ) | ( b [ 1 ] & 0xFF ) ;
if ( userImpl ! = null & & ! userImpl . isEmpty ( ) ) {
} catch ( Exception | AssertionError e ) {
} catch ( Exception | AssertionError e ) {
} catch ( Exception | AssertionError e ) {
if ( userImpl ! = null & & ! userImpl . isEmpty ( ) ) {
return impls . toArray ( new String [ 0 ] ) ;
return TestUtil . getImage ( "str" ) ;
instance . setSourceFile ( TestUtil . getImage ( "str" ) ) ;
instance . setSourceFile ( TestUtil . getImage ( "str" ) ) ;
TestUtil . getImage ( "str" ) ) ;
TestUtil . getImage ( "str" ) ) ;
Path file = TestUtil . getImage ( "str" ) ;
return TestUtil . getImage ( "str" ) ;
instance . setSourceFile ( TestUtil . getImage ( "str" ) ) ;
instance . setSourceFile ( TestUtil . getImage ( "str" ) ) ;
getImage ( "str" ) ;
instance . setIdentifier ( new Identifier ( "str" ) ) ;
instance . setIdentifier ( new Identifier ( "str" ) ) ;
TestUtil . getImage ( "str" ) ) ;
reader . setSource ( TestUtil . getImage ( "str" ) ) ;
instance . setSource ( TestUtil . getImage ( "str" ) ) ;
instance . setSource ( TestUtil . getImage ( "str" ) ) ;
instance . setSource ( TestUtil . getImage ( "str" ) ) ;
instance . setSource ( TestUtil . getImage ( "str" ) ) ;
instance . setSource ( TestUtil . getImage ( "str" ) ) ;
UUID . randomUUID ( ) + "str" +
final Path devStdout = Paths . get ( "str" , "str" ) ;
LOGGER . debug ( "str" +
import org . apache . commons . lang3 . StringUtils ;
import org . apache . commons . lang3 . StringUtils ;
config . setProperty ( Key . HTTPRESOLVER_URL_PREFIX , server . getHTTPSURI ( ) + "str" ) ;
image = removeAlpha ( image ) ;
config . setProperty ( Key . HTTPRESOLVER_URL_PREFIX , server . getHTTPURI ( ) + "str" ) ;
return "str" + getHTTPPort ( ) ;
return "str" + getHTTPSPort ( ) ;
return bufferStream . read ( b , off , len ) ;
if ( ! Configuration . getInstance ( ) . getBoolean ( Key . API_ENABLED , false ) ) {
logger . debug ( "str" ,
logger . debug ( "str" , iioReader . getClass ( ) . getName ( ) ) ;
String BACKGROUND_COLOR_CONFIG_KEY = "str" ;
getOrDefault ( Processor . JPG_QUALITY_CONFIG_KEY , 80 ) ;
return new MediaType ( mediaType ) . toFormat ( ) ;
return getFloat ( key ) ;
throw new ProcessorException ( e . getMessage ( ) , e ) ;
msg + = "str" + errorStr + "str" ;
msg + = "str" + errorStr + "str" ;
super ( "str" + format . getName ( ) ) ;
super ( "str" + format . getName ( ) ) ;
format . getName ( ) + "str" ) ;
private static final short MAX_REDUCTION_FACTOR = 5 ;
private static final short MAX_REDUCTION_FACTOR = 5 ;
if ( config . getBoolean ( "str" , false ) ) {
public void testInvokeWithNoArgs ( ) throws Exception {
if ( regionName ! = null & & regionName . length ( ) > 0 ) {
float dpi = Application . getConfiguration ( ) . getFloat ( DPI_CONFIG_KEY , 150 ) ;
Format . GIF , Format . JPG , Format . PNG , Format . TIF ) ) ;
assertEquals ( 8 , ProcessorFactory . getAllProcessors ( ) . size ( ) ) ;
logger . debug ( "str" ) ;
if ( s . startsWith ( "str" ) & & s . endsWith ( "str" ) ) {
if ( ! ( proc instanceof StreamProcessor ) ) {
logger . debug ( "str" , identifier , file . getAbsolutePath ( ) ) ;
logger . debug ( "str" , identifier , url ) ;
if ( config . getBoolean ( "str" ) ) {
op . addImage ( "str" ) ;
if ( mWheelDrawable ! = null & & mWheelBounds ! = null ) {
return latestRevocationData ! = null & & ! latestRevocationData . isStatus ( ) & & latestRevocationData . getRevocationDate ( ) ! = null ;
signatureCryptographicVerification . setReferenceDataFound ( referenceDataFound ) ;
Indication indication = detailedReport . getHighestIndication ( signatureId ) ;
xmlSignature . setSubIndication ( detailedReport . getHighestSubIndication ( signatureId ) ) ;
public Indication getCertificateXCVIndication ( String certificateId ) {
private XmlConstraintsConclusion getHighestConclusion ( String signatureId ) {
collect ( type , result , getHighestConclusion ( signatureId ) ) ;
item . setIndication ( detailedReport . getCertificateXCVIndication ( certificate . getId ( ) ) ) ;
xmlRevocation . setCertHashExtensionMatch ( Arrays . equals ( expectedDigest , foundDigest ) ) ;
QUAL_QC_AT_ST ( "str" ) ,
QUAL_QC_AT_CC ( "str" ) ,
QUAL_QC_AT_VT ( "str" ) ,
BufferedImage img = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ;
XPathExpression exp = xpath . compile ( "str" ) ;
private boolean en319132 = true ;
if ( DSSASN1Utils . hasIdPkixOcspNoCheckExtension ( certToken ) ) {
if ( certificate . isIdPkixOcspNoCheck ( ) ) {
@XmlElement ( name = "str" )
@XmlElement ( name = "str" )
@XmlElement ( name = "str" )
@XmlElement ( name = "str" )
for ( final DSSTransform transform : reference . transforms ) {
private static final MediaType MEDIA_TYPE = MediaType . parse ( "str" ) ;
int priority ( ) default 100 ;
if ( type . equals ( info . type ) | | Types . getRawType ( type ) . equals ( info . type ) ) {
} else if ( type . equals ( info . arrayType ) | | Types . getRawType ( type ) . equals ( info . arrayType ) ) {
if ( ! typeNameMap . containsKey ( res . _type ) ) {
throw new AssertionError ( "str" + entry . getKey ( ) + "str" , e ) ;
private ContainerFactory < T > mContainerFactory ;
ContainerFactory < T > containerFactory ,
public void jsonApiDocument_deserialization ( ) throws Exception {
assertEquals ( "str" , useCaseRunner . runStepNames ( ) ) ;
if ( prefs . getShowDebugInfo ( ) & & mKey ! = null & & mKey . componentName ! = null ) {
LawnchairPreferences prefs = LawnchairPreferences . Companion . getInstanceNoCreate ( ) ;
LawnchairPreferences prefs = LawnchairPreferences . Companion . getInstanceNoCreate ( ) ;
prefs = LawnchairPreferences . Companion . getInstanceNoCreate ( ) ;
LawnchairPreferences prefs = Utilities . getLawnchairPrefs ( mLauncher ) ;
LawnchairPreferences prefs = Utilities . getLawnchairPrefs ( mLauncher ) ;
prefs = Utilities . getLawnchairPrefs ( context ) ;
mAH = new AdapterHolder [ allAppsTabs . getCount ( ) + 1 ] ;
if ( ! bitmap . isMutable ( ) | | bitmap . getConfig ( ) ! = Bitmap . Config . ARGB_8888 )
return FeatureFlags . NO_ALL_APPS_ICON ? mWorkspace . getPageIndicator ( ) : mAllAppsButton ;
super ( getContext ( ) , null , null ) ;
dispatchChildFocus ( mChildrenFocused & & focused ! = null ) ;
if ( DEBUG_LOADERS ) Log . d ( TAG , "str" + N ) ;
convertToDistanceFromEnd ( getAttributeValue ( parser , ATTR_X ) , mColumnCount ) ) ;
convertToDistanceFromEnd ( getAttributeValue ( parser , ATTR_Y ) , mRowCount ) ) ;
import com . android . launcher3 . backup . nano . BackupProtos . Favorite ;
InputMethodManager imm = ( InputMethodManager ) getSystemService (
static final boolean DEBUG_WIDGETS = false ;
if ( ! ProviderConfig . IS_DOGFOOD_BUILD & &
if ( ProviderConfig . IS_DOGFOOD_BUILD ) {
if ( ! ProviderConfig . IS_DOGFOOD_BUILD & &
Object tag = thumbnail . getTag ( ) ;
existingImageThumbnail = thumbnail ;
Log . e ( TAG , "str" + packageName + "str" + className , e ) ;
Log . w ( TAG , "str" ) ;
if ( info . user . equals ( targetInfo . user )
final String intentWithPkg , intentWithoutPkg ;
matrix = FocusLogic . createSparseMatrix ( iconLayout ,
matrix = FocusLogic . createSparseMatrix ( iconLayout , - 1 , row ) ;
? mManager . loadLabel ( ( LauncherAppWidgetProviderInfo ) b )
private static final boolean DEBUG = false ;
if ( DEBUG ) Log . d ( TAG , "str" + key ) ;
private static final boolean DEBUG = false ;
private static final boolean DEBUG_RECEIVER = false ;
String labelA , labelB ;
labelA = mLabelCache . get ( keyA ) . toString ( ) ;
labelB = mLabelCache . get ( keyB ) . toString ( ) ;
getContentResolver ( ) , SETTING_RESTORE_ENABLED , 1 ) ;
getContentResolver ( ) , SETTING_RESTORE_ENABLED , 0 ) ;
getContentResolver ( ) , SETTING_RESTORE_ENABLED , 1 ) ;
Log . e ( TAG , "str" +
mTmpIntPoint [ 0 ] = currPage . getMeasuredWidth ( ) ;
ArrayList < ItemInfo > added = new ArrayList < ItemInfo > ( ) ;
database . execSQL ( "str" + TABLE_NAME + "str" +
w - mForegroundPadding , h - mForegroundPadding ) ;
Drawable icon = mIconCache . getFullResIcon ( info ) ;
if ( info . icon > 0 ) icon = mIconCache . getFullResIcon ( packageName , info . icon ) ;
public Drawable getFullResIcon ( String packageName , int iconId ) {
icon = getIconFromCursor ( c , iconIndex , context ) ;
icon = getIconFromCursor ( c , iconIndex , context ) ;
icon = getIconFromCursor ( c , iconIndex , context ) ;
Bitmap getIconFromCursor ( Cursor c , int iconIndex , Context context ) {
View v = hostView . findViewById ( appWidgetInfo . autoAdvanceViewId ) ;
float distanceRatio = Math . min ( 1f , 1.0f * Math . abs ( delta ) / ( 2 * halfScreenSize ) ) ;
float scaleFactor = r . getInteger ( R . integer . config_appsCustomizeZoomScaleFactor ) / 100 f ;
child . layout ( mLeftPadding , mTopPadding , r - l - mRightPadding , b - t - mBottomPadding ) ;
( lp . cellY < = y ) & & ( y < lp . cellY + lp . cellVSpan ) ) {
float offsetFromCenter = ( wallpaperTravelHeight / ( float ) mWallpaperHeight ) / 2f ;
com . android . internal . R . mipmap . sym_def_app_icon ) ;
if ( LauncherApplication . isScreenXLarge ( ) & & mBackgroundAlpha > 0.0f ) {
int buttonId , ComponentName activityName , int fallbackDrawableId ) {
ImageView button = ( ImageView ) findViewById ( buttonId ) ;
updateButtonWithDrawable ( R . id . search_button , d ) ;
updateButtonWithDrawable ( R . id . voice_button , d ) ;
updateButtonWithDrawable ( R . id . market_button , d ) ;
if ( mNextPage ! = INVALID_PAGE ) return ;
if ( mNextPage ! = INVALID_PAGE ) return false ;
private static final int DRAG_SCALE = 40 ;
private boolean mAppsDirty = true ;
if ( mAppsDirty & & mAllAppsList ! = null ) {
if ( event . isTracking ( ) & & ! event . isCanceled ( ) ) {
extras . putBoolean ( "str" , ( "str" . compareToIgnoreCase ( mForFamily ) = = 0 ) ) ;
LOGGER . info ( ( ) - > "str" + key + "str" + getPreferencesFile ( ) . getAbsolutePath ( ) + "str" + defaultValue ) ;
polygon . addPoint ( timestamp + event . getPause ( ) , tenuredEvent . getPostUsed ( ) ) ;
polygon . addPoint ( timestamp + event . getPause ( ) , tenuredTotal + youngEvent . getPostUsed ( ) ) ;
return Desktop . isDesktopSupported ( ) & & Desktop . getDesktop ( ) . isSupported ( Action . BROWSE ) ;
event . setPreUsed ( getMemoryInKiloByte ( extractNumber ( line . substring ( start , end ) ) ,
event . setPostUsed ( getMemoryInKiloByte ( extractNumber ( line . substring ( start , end ) ) ,
event . setTotal ( getMemoryInKiloByte ( extractNumber ( line . substring ( start , end ) ) ,
detailEvent . setPreUsed ( ( int ) extractNumber ( line . substring ( start , end ) ) ) ;
detailEvent . setPostUsed ( ( int ) extractNumber ( line . substring ( start , end ) ) ) ;
detailEvent . setTotal ( ( int ) extractNumber ( line . substring ( start , end ) ) ) ;
fullGCDataAvailable ? isSignificant ( model . getFullGCPause ( ) . average ( ) , model . getFullGCPause ( ) . standardDeviation ( ) ) : false ) ;
exportValue ( out , "str" , isSignificant ( model . getFullGCPause ( ) . average ( ) , model . getFullGCPause ( ) . standardDeviation ( ) ) ) ;
assertEquals ( "str" , 0.14482200 , model . getPause ( ) . getMax ( ) , 0.000000001 ) ;
| | line . endsWith ( Type . G1_YOUNG_MARK_STACK_FULL . getType ( ) )
public static final Type G1_YOUNG_MARK_STACK_FULL = new Type ( "str" , "str" , Generation . YOUNG , Concurrency . SERIAL , GcPattern . GC_MEMORY_PAUSE ) ;
assertEquals ( "str" , 88.28044896 , model . getThroughput ( ) , 0.00000001 ) ;
assertEquals ( "str" , 94.17869828 , model . getThroughput ( ) , 0.00000001 ) ;
assertEquals ( "str" , 78.5579711577 , model . getThroughput ( ) , 0.00000001 ) ;
assertEquals ( "str" , 65.680128659 , model . getThroughput ( ) , 0.0000001 ) ;
assertEquals ( "str" , 47.75795226 , model . getThroughput ( ) , 0.000000001 ) ;
assertEquals ( "str" , 119.859 , model . getRunningTime ( ) , 0.000001 ) ;
invalidate ( ) ;
if ( textAreaLogHandler . hasErrors ( ) & & ! gcDocument . isWatched ( ) ) {
if ( event . getTimestamp ( ) - lastPauseTimeStamp > = 0 ) {
LOG . warning ( "str" + memUnit + "str" + line ) ;
LOG . severe ( "str" + pos . getLineNumber ( ) + "str" + line + "str" ) ;
if ( ( urlbase . contains ( "str" ) )
postView . checkPermissionSuccess ( true , 0 , "str" , false ) ;
postView . checkPermissionSuccess ( false , 0 , "str" , true ) ;
labelI18nKey ( "str" ) .
assertEquals ( "str" , settings . get ( "str" ) ) ;
super ( "str" + nodeId + "str" ) ;
super ( "str" + nodePath ) ;
if ( node = = null | | contentPendingOrExpired ( node , Instant . now ( ) ) )
if ( node = = null | | contentPendingOrExpired ( node , Instant . now ( ) ) )
this . values . addAll ( val . getAsStrings ( ) ) ;
this . values . addAll ( values ) ;
builder . append ( deleted ) . append ( "str" ) ;
builder . append ( pending ) . append ( "str" ) ;
if ( newParentPath . equals ( existingNode . path ( ) ) | | newParentPath . getParentPaths ( ) . contains ( existingNode . path ( ) ) )
public ApplicationJson getIdProvider ( @QueryParam ( "str" ) String key )
json . contentName ( contentService . getById ( failedContents . first ( ) ) . getDisplayName ( ) ) ;
assertEquals ( "str" , settings . get ( "str" ) ) ;
import com . enonic . xp . portal . impl . mapper . PortalErrorMapper ;
if ( ! "str" . equals ( file . getFileName ( ) . toString ( ) ) )
final Node importNode = Node . create ( ) .
final Node importNode2 = Node . create ( ) .
requireValid ( req . param ( "str" ) . value ( Boolean . class , true ) ) .
return ( this . quality > 0 ) & & ( this . quality < = 100 ) ? this . quality : DEFAULT_QUALITY ;
createBinaryFile ( Paths . get ( "str" , "str" ) , "str" , "str" . getBytes ( ) ) ;
private void createBinaryFile ( final Path exportPath , final String fileName , final byte [ ] bytes )
Paths . get ( temporaryFolder . getRoot ( ) . getPath ( ) , exportPath . toString ( ) , NodeExportPathResolver . SYSTEM_FOLDER_NAME ,
this . name = name ;
return name . equals ( workspace . name ) ;
final String systemId = locator ! = null ? locator . getSystemId ( ) : null ;
super ( SchemaKind . METADATA_SCHEMA ) ;
super ( "str" , metadataSchemaName ) ;
super ( MessageFormat . format ( "str" , Joiner . on ( "str" ) . join ( metadataSchemaNames ) ) ) ;
METADATA_SCHEMA ( "str" ) ;
public boolean isMetadataSchema ( )
return this = = SchemaKind . METADATA_SCHEMA ;
public boolean isMetadataSchema ( )
return this . type = = SchemaKind . METADATA_SCHEMA ;
return new SchemaKey ( SchemaKind . METADATA_SCHEMA , metadataSchemaName ) ;
return this . schemaRegistry . getAllMetadataSchemas ( ) ;
MetadataSchemas getAllMetadataSchemas ( ) ;
private MetadataSchemaDao dao ;
final MetadataSchema metadataSchema = dao . getMetadataSchema ( params . getName ( ) ) ;
GetMetadataSchemaCommand metadataSchemaDao ( final MetadataSchemaDao metadataSchemaDao )
this . dao = metadataSchemaDao ;
private MetadataSchemaDao dao ;
final MetadataSchemas metadataSchemas = getMetadataSchemas ( params . getNames ( ) , missingMetadatas ) ;
private MetadataSchemas getMetadataSchemas ( final MetadataSchemaNames metadataSchemaNames , final List < MetadataSchemaName > missingMetadatas )
final MetadataSchema metadataSchema = dao . getMetadataSchema ( metadataSchemaName ) ;
GetMetadataSchemasCommand metadataSchemaDao ( final MetadataSchemaDao metadataSchemaDao )
this . dao = metadataSchemaDao ;
public MetadataSchema getMetadata ( final MetadataSchemaName metadataName )
public MetadataSchemas getAllMetadataSchemas ( )
return MetadataSchemas . empty ( ) ;
return new GetMetadataSchemaCommand ( ) . metadataSchemaDao ( this . metadataSchemaDao ) . params ( params ) . execute ( ) ;
return new GetMetadataSchemasCommand ( ) . metadataSchemaDao ( this . metadataSchemaDao ) . params ( params ) . execute ( ) ;
contentData . addProperty ( "str" , Value . newLocalDateTime ( LocalDateTime . of ( 2015 , 8 , 12 , 10 , 45 , 59 ) ) ) ;
dataSet . add ( Property . newLocalDateTime ( "str" , LocalDateTime . of ( 2014 , 8 , 12 , 10 , 45 , 59 ) ) ) ;
return Value . newDateTime ( convert ( value ) ) ;
descriptor ( PartDescriptorKey . from ( "str" ) ) .
return new Builder < > ( new RuntimeException ( format ( message , args ) ) ) ;
final Iterator < Node > childContentNodes = doGetChildContentNodes ( parentContentAndNode . contentNode ) ;
protected void setParent ( final DataSet parent )
protected DataId getDataId ( )
protected DataId getDataId ( )
protected void setParent ( final DataSet entries )
QualifiedRelationshipTypeNames . from ( context . param ( "str" ) . required ( ) . asString ( ) ) ;
final QualifiedMixinName qualifiedMixinName = new QualifiedMixinName ( context . param ( "str" ) . required ( ) . asString ( ) ) ;
createOrUpdate ( "str" , "str" ) ;
registerError ( new ContentTypeValidationError ( "str" + contentType . getSuperType ( ) , contentType ) ) ;
contentTypeDao . retrieveContentTypes ( QualifiedContentTypeNames . from ( qualifiedContentTypeName ) , session ) ;
public static < L , R > Lens . Simple < Either < L , R > , Maybe < R > > _right ( ) {
public static < L , R > Lens . Simple < Either < L , R > , Maybe < L > > _left ( ) {
Lens . Simple < Either < String , Integer > , Maybe < Integer > > right = EitherLens . _right ( ) ;
Lens . Simple < Either < String , Integer > , Maybe < String > > left = EitherLens . _left ( ) ;
return appB . zip ( fmap ( constantly ( ) ) ) ;
isNull ( r2 . getRequestBody ( ) ) ;
protected void throwIfNotSupportBody ( ) {
protected boolean supportBody ( ) {
protected NextRequest part ( final BodyPart part ) {
protected NextRequest removeHeader ( String key ) {
protected NextRequest removeQuery ( String key ) {
protected NextRequest removeForm ( String key ) {
protected NextRequest removePart ( BodyPart part ) {
protected String getHeader ( String key ) {
protected String getQuery ( String key ) {
protected String getForm ( String key ) {
protected BodyPart getPart ( String key ) {
protected boolean hasHeader ( String key ) {
protected boolean hasQuery ( String key ) {
protected boolean hasForm ( String key ) {
protected boolean hasPart ( String key ) {
protected int queriesSize ( ) {
protected int formsSize ( ) {
protected int headersSize ( ) {
protected int partsSize ( ) {
protected Map < String , String > headers ( ) {
protected Map < String , String > queries ( ) {
protected Map < String , String > form ( ) {
protected List < BodyPart > parts ( ) {
protected boolean hasParts ( ) {
protected boolean hasForms ( ) {
protected void copy ( final NextRequest source ) {
protected RequestBody getRequestBody ( ) throws IOException {
requestBody = multipart . type ( MultipartBuilder . FORM ) . build ( ) ;
return submit ( runnable ) ;
SystemClock . sleep ( Math . abs ( RANDOM . nextInt ( ) ) % 3000 + 2000 ) ;
final File file = part . getFile ( ) ;
final byte [ ] bytes = part . getBytes ( ) ;
mOrientation = a . getInt ( R . styleable . FixedRatioImageView_fri_orientation , STRETCH_HORIZONTAL ) ;
if ( a . getBoolean ( R . styleable . CircularImageView_ci_shadow , false ) ) {
private static final String LOGTAG = "str" ;
mStretch = ta . getInt ( R . styleable . AspectRatioImageView_ari_stretch , STRETCH_UNDEFINED ) ;
private int mOrientation = STRETCH_HORIZONTAL ;
mOrientation = a . getInt ( R . styleable . FixedRatioImageView_orientation , STRETCH_HORIZONTAL ) ;
if ( mOrientation = = STRETCH_VERTICAL ) {
public class Md5FileNameGenerator implements FileNameGenerator {
defaultBasicFlags . put ( ClaimFlag . ITEM_USE . toString ( ) , false ) ;
defaultTownFlags . put ( ClaimFlag . ITEM_USE . toString ( ) , false ) ;
final int minSpongeBuild = 3235 ;
public static Tristate processResult ( GPClaim claim , String permission , Tristate permissionValue , Subject permissionSubject ) {
if ( permissionSubject = = null ) {
permissionSubject = eventSubject ;
permissionSubject = ( Subject ) currentEvent . getCause ( ) . root ( ) ;
permissionSubject = GriefPreventionPlugin . GLOBAL_SUBJECT ;
GriefPreventionPlugin . addEventLogEntry ( currentEvent , claim , eventLocation , eventSubject , eventSourceId , eventTargetId , permissionSubject , permission , permissionValue ) ;
GriefPreventionPlugin . addEventLogEntry ( currentEvent , claim , eventLocation , eventSubject , eventSourceId , eventTargetId , permissionSubject , permission , permissionValue ) ;
eventSourceId = id . toLowerCase ( ) ;
eventTargetId = id . toLowerCase ( ) ;
public static void addEventLogEntry ( Event event , GPClaim claim , Location < World > location , Subject eventSubject , String sourceId , String targetId , Subject permissionSubject , String permission , Tristate result ) {
this . addDefault ( Messages . ClaimLastActive , "str" , "str" ) ;
public boolean fireSpreadOutsideClaim = true ;
public boolean mobPlayerDamage = true ;
BlockRay < World > blockRay = BlockRay . from ( player ) . blockLimit ( maxDistance ) . build ( ) ;
public static Text getMessage ( Messages messageID , String . . . args ) {
public static void sendMessage ( CommandSource player , TextColor color , Messages messageID , String . . . args ) {
public boolean creativeRulesApply ( Location < World > location ) {
GriefPrevention . instance . getServer ( ) . getScheduler ( ) . scheduleSyncDelayedTask ( GriefPrevention . instance , task , 200L ) ;
@EventHandler ( ignoreCancelled = true , priority = EventPriority . LOWEST )
if ( claim ! = null & & ( claim . areExplosivesAllowed | | ! GriefPrevention . instance . config_blockClaimExplosions ) )
if ( claim = = null )
if ( ! applySurfaceRules | | block . getLocation ( ) . getBlockY ( ) < GriefPrevention . instance . getSeaLevel ( world ) - 7 )
if ( ownerName . isEmpty ( ) | | ownerName . startsWith ( "str" ) )
GriefPrevention . AddLogEntry ( "str" + ownerName + "str" ) ;
if ( line . toLowerCase ( ) . startsWith ( "str" ) )
if ( GriefPrevention . instance . config_claims_protectFires & & event . getClickedBlock ( ) ! = null )
String slashCommandsToMonitor = config . getString ( "str" , "str" ) ;
String whisperCommandsToMonitor = config . getString ( "str" , "str" ) ;
if ( player . isOnline ( ) & & visualization . elements . get ( 0 ) . location . getWorld ( ) . equals ( player . getWorld ( ) ) )
this . id = - 1L ;
swap ( arr , i , min ) ;
mActivity . showFragment ( "str" , args , true ) ;
( ( MessageActivity ) activity ) . showFragment ( MessageActivity . FRAGMENT_INFO , null , false ) ;
showFragment ( FRAGMENT_INFO , null , true ) ;
null , false ) ;
return mCursor = = null | | mCursor . isClosed ( ) ? 0 : mCursor . getCount ( ) ;
List < Span > chld = chunkify ( line , span . start + 1 , span . end , span . children ) ;
if ( host = = null | | ! host . equals ( mEndpoint . getHost ( ) ) ) {
last = mTinode . delMessage ( getName ( ) , toSoftDelete , false )
all . addAll ( phones ) ;
return am ! = null & & mode . equals ( am . mode ) & & want . equals ( am . want ) & & given . equals ( am . given ) ;
values . put ( COLUMN_NAME_NEXT_UNSENT_SEQ , st . nextUnsentId ) ;
protected void onConnect ( final boolean autoreconncted ) {
mListener . onConnect ( reconnecting ) ;
protected void onConnect ( boolean reconnected ) {
public PromisedReply < ServerMessage > onSuccess ( ServerMessage ignored_msg ) throws Exception {
Login ( AuthScheme . LOGIN_BASIC , AuthScheme . makeBasicToken ( uname , password ) ) ;
private static void updateOldest ( AtomicLong max , long time ) {
void notFromJava9toCurrentJavaFeatureNumber ( ) {
logger . info ( ( ) - > "str" + DEFAULT_SEED ) ;
assertFalse ( onJava14 ( ) ) ;
private boolean failIfNoTests ;
"str" ) ) ;
ResourceLock [ ] value ( ) ;
String logMessage = listener . stream ( ReflectionUtils . class , Level . FINE )
logger . debug ( error , ( ) - > "str" + clazz . getName ( ) ) ;
private static final OS CURRENT_OS = determineCurrentOs ( ) ;
private static OS determineCurrentOs ( ) {
assertThat ( expected ) . hasMessageStartingWith ( "str" + brokenTagExpression + "str" ) ;
assertThat ( parseErrorFromParsing ( "str" ) ) . contains ( "str" ) ;
"str" + infixTagExpression + "str" + message ) ) ;
logger . debug ( ex , ( ) - > format ( "str" ,
logger . debug ( throwable , ( ) - > format ( "str" ,
assertDebugMessageLogged ( listener , "str" ) ;
assertDebugMessageLogged ( listener , "str" ) ;
assertDebugMessageLogged ( listener , "str" ) ;
assertDebugMessageLogged ( listener , "str" ) ;
private void assertDebugMessageLogged ( LogRecordListener listener , String regex ) {
assertThat ( listener . getLogRecords ( ClasspathScanner . class , Level . FINE )
throw new IOException ( "str" ) ;
public static final String DEACTIVATE_CONDITIONS_PATTERN_PROPERTY_NAME = "str" ;
public static final String EXTENSIONS_AUTODETECTION_ENABLED_PROPERTY_NAME = "str" ;
void isNotEmpty ( ) {
return findAnnotation ( element . get ( ) , annotationType , new HashSet < > ( ) ) ;
ExceptionUtils . throwAs ( t ) ;
fail ( buildPrefix ( nullSafeGet ( messageSupplier ) ) + "str" + timeoutInMillis
assertMessageStartsWith ( error , "str" ) ;
assertMessageStartsWith ( error , "str" ) ;
assertMessageStartsWith ( error , "str" ) ;
assertMessageEquals ( error , "str" ) ;
assertMessageEquals ( error , "str" ) ;
assertMessageEquals ( error , "str" ) ;
. orElseGet ( ( ) - > generateDefaultDisplayName ( ) ) ;
String classDescription = clazz . getName ( ) ;
+ "str" + DiscoveryFilter . class . getSimpleName ( ) + "str" ) ;
assertEquals ( "str" ,
private static Iterable < TestEngine > validateUniqueIds ( Iterable < TestEngine > testEngines ) {
for ( TestEngine testEngine : this . testEngines ) {
private final Launcher launcher = DefaultLauncher . create ( ) ;
this ( options , DefaultLauncher : : create ) ;
Launcher launcher = DefaultLauncher . create ( ) ;
@ClassNamePattern ( "str" )
printlnTestDescriptor ( BLUE , "str" , testIdentifier ) ;
printlnTestDescriptor ( YELLOW , "str" , testIdentifier ) ;
printlnTestDescriptor ( NONE , "str" , testIdentifier ) ;
printlnTestDescriptor ( color , "str" , testIdentifier ) ;
println ( color , "str" , message , testIdentifier . getDisplayName ( ) , testIdentifier . getUniqueId ( ) ) ;
println ( color , "str" + message + "str" , detail ) ;
LOG . info ( "str" + testEngine . getId ( ) ) ;
this . testsSkipped . get ( ) , this . testsAborted . get ( ) , this . testsSucceeded . get ( ) , this . testsFailed . get ( ) ) ) ;
Class < ? extends Condition > [ ] value ( ) ;
dataObj . put ( "str" , oldDistinctId ) ;
private static final String QQ_USER_INFO_PATTERN = "str" ;
setTag ( getResources ( ) . getString ( R . string . view_inspector_view_tag ) ) ;
return application . getResources ( ) . getString ( R . string . view_inspector_view_tag ) ;
mLayoutHeight = res . getDimensionPixelSize ( R . dimen . view_inspector_toolbar_height ) ;
mLayoutHeight = res . getDimensionPixelSize ( R . dimen . view_inspector_toolbar_height_m ) ;
int width = res . getDimensionPixelSize ( R . dimen . view_inspector_menu_width ) ;
params . y = res . getDimensionPixelSize ( R . dimen . view_inspector_toolbar_height ) ;
params . y = res . getDimensionPixelSize ( R . dimen . view_inspector_toolbar_height_m ) ;
inflate ( context , R . layout . view_inspector_toolbar , this ) ;
inflate ( context , R . layout . view_inspector_checkable_linear_layout , this ) ;
inflate ( context , R . layout . view_inspector_checkable_linear_layout , this ) ;
inflate ( context , R . layout . view_inspector_checkable_linear_layout , this ) ;
setView ( View . inflate ( context , R . layout . view_inspector_profile_setting , null ) ) ;
inflate ( context , R . layout . view_inspector_boundary_menu , this ) ;
inflate ( context , R . layout . view_inspector_progressbar , this ) ;
inflate ( context , R . layout . view_inspector_layer_menu , this ) ;
inflate ( context , R . layout . view_inspector_event_menu , this ) ;
setView ( View . inflate ( context , R . layout . view_inspector_profile_result , null ) ) ;
inflate ( context , R . layout . view_inspector_settings_menu , this ) ;
if ( Build . VERSION . SDK_INT = = 23 ) {
if ( Build . VERSION . SDK_INT = = 23 ) {
getResources ( ) . getDrawable ( R . drawable . ic_chevron_left_white_24dp ) ) ;
getResources ( ) . getDrawable ( R . drawable . ic_chevron_right_white_24dp ) ) ;
getResources ( ) . getDrawable ( R . drawable . ic_chevron_left_white_24dp ) ) ;
public void testNewInstance_noArgsConstructorPresent ( ) {
public void testNewInstance_noArgsConstructorAbsent ( ) {
loader . loadFromResource ( "str" , Candidate . CandidateType . STANDARD ) ;
called . add ( "str" ) ;
ObjectInstantiator sun = new SunReflectionFactoryInstantiator ( Object . class ) ;
StringBuffer sb = new StringBuffer ( "str" + entry . getKey ( ) + "str" + entry . getValue ( ) . size ( ) + "str" ) ;
StringBuffer sb = new StringBuffer ( "str" + entry . getKey ( ) + "str" + entry . getValue ( ) . size ( ) + "str" ) ;
outputContent + = "str" + line . substring ( TUTORIAL_KEY_WORD . length ( ) ) + "str" ;
if ( can [ j ] & & ( j + A [ j ] > = i ) ) {
outputContent + = "str" + count + "str" + file . getName ( ) + "str" + file . getName ( ) + "str" + "str" ;
logger . warn ( "str" , e ) ;
if ( goCheck )
if ( selectedSenators = = null | | selectedSenators . isEmpty ( ) ) {
if ( ! keywordTxt . getText ( ) . equals ( "str" ) & & senatorTable . getItemCount ( ) = = 0 ) {
if ( ! doPreprocessing )
if ( ! doPreprocessing ) {
if ( ! doPreprocessing ) {
if ( ! doPreprocessing ) {
ppObj = new Preprocessor ( "str" , false ) ;
ConsoleView . printlInConsoleln ( "str" + Jsoup . parse ( search . getTitle ( ) ) . text ( ) ) ;
ConsoleView . printlInConsoleln ( "str" + Jsoup . parse ( search . getTitle ( ) ) . text ( ) ) ;
ConsoleView . printlInConsoleln ( "str" + Jsoup . parse ( search . getTitle ( ) ) . text ( ) ) ;
ConsoleView . printlInConsoleln ( "str" + Jsoup . parse ( search . getTitle ( ) ) . text ( ) ) ;
lda . initialize ( corpus , 5 , name , false ) ;
String fileName = "str" ;
ttStream . stream ( outputFile , true , 5 , true , 60000 ,
String fileName = "str" ;
ttStream . stream ( outputFile , true , 5 , false , 0 ,
"str" , null ,
for ( int i = initialize ( ) ; i < words . length ; i = increment ( i ) ) {
if ( currLine . trim ( ) . length ( ) ! = 0 ) {
currLine = currLine . toLowerCase ( ) ;
kValue = toolkit . createText ( output , "str" , SWT . BORDER ) ;
String classPath = corpus . getClasses ( ) . get ( i ) . getTacitLocation ( ) ;
final TreeViewer corpusViewer = new TreeViewer ( client , SWT . BORDER ) ;
corpusViewer . getTree ( ) . setLayoutData ( gd ) ;
corpusViewer . addSelectionChangedListener ( new ISelectionChangedListener ( ) {
inputParamsSection . setText ( "str" ) ;
section . setText ( "str" ) ;
inputParamsSection . setText ( "str" ) ;
+ File . separator + "str"
if ( count = = this . limitComments ) break breakCommentFetch ;
if ( count = = this . limitComments ) break breakCommentFetch ;
if ( previousSelectedCongress . isEmpty ( ) | | ! previousSelectedCongress . equals ( selectedCongress ) | | null = = availableRepresentatives | | availableRepresentatives . length = = 0 ) {
if ( previousSelectedCongress . isEmpty ( ) | | ! previousSelectedCongress . equals ( selectedCongress ) | | null = = availabileSenators | | availabileSenators . length = = 0 ) {
String district = "str" ;
if ( temp . length > = 3 ) district = temp [ 2 ] ;
for ( Element repItem : repList ) {
"str" , SWT . NONE ) ;
numLinksLabel . setText ( "str" ) ;
printPennToCSV ( inputFile , outputPath , numDictWords , isOverall ) ;
pennCSVbw . write ( "str" ) ;
public static final String PLUGIN_ID = "str" ;
. getBundle ( "str" ) ;
DateFormat df = new SimpleDateFormat ( "str" ) ;
fileWriter = new FileWriter ( this . outputDir + "str" + "str"
DateFormat df = new SimpleDateFormat ( "str" ) ;
csvWriter = new BufferedWriter ( new FileWriter ( new File ( outputDir + System . getProperty ( "str" ) + "str" + df . format ( dateobj ) + "str" ) ) ) ;
if ( stopWordsFile . equals ( null ) | | stopWordsFile . equals ( "str" ) | | ! this . weighted )
if ( isPreprocess ) preprocessTask . clean ( ) ;
bw . write ( "str" ) ;
+ labeling . getLabelAtRank ( j ) . toString ( ) + "str"
Pattern compoundPattern = Pattern . compile ( "str" ) ;
Pattern doubleHyphenPattern = Pattern . compile ( "str" ) ;
currentWord = currentWord . replaceFirst ( "str" , "str" ) . toLowerCase ( ) ;
String [ ] words = currentWord . split ( "str" , 2 ) ;
String [ ] words = currentWord . split ( "str" , 2 ) ;
invokeCooccurrence ( fppDir , fppSeedFile , fOutputDir , numTopics , ftxtThreshold , fOption ) ;
final NBClassifier nb = new NBClassifier ( ) ;
final NBClassifier nb = new NBClassifier ( ) ;
txtStopWords . setText ( dir + System . getProperty ( "str" ) + oFile ) ;
txtModelFilePath . setText ( dir + System . getProperty ( "str" ) + oFile ) ;
txtOutputFile . setText ( dir + System . getProperty ( "str" ) + oFile ) ;
txtClassifyOutput . setText ( dir + System . getProperty ( "str" ) + oFile ) ;
inputFiles [ i ] = ifDialog . getFilterPath ( ) + System . getProperty ( "str" ) + ifDialog . getFileNames ( ) [ i ] ;
sb . append ( ifDialog . getFilterPath ( ) + System . getProperty ( "str" ) + inputFile + "str" ) ;
txtDictionary . setText ( dfDialog . getFilterPath ( ) + System . getProperty ( "str" ) + dfDialog . getFileName ( ) ) ;
txtStopWords . setText ( sfDialog . getFilterPath ( ) + System . getProperty ( "str" ) + sfDialog . getFileName ( ) ) ;
txtOutputFile . setText ( ofDialog . getFilterPath ( ) + System . getProperty ( "str" ) + ofDialog . getFileName ( ) ) ;
int findex = inputFile . lastIndexOf ( System . getProperty ( "str" ) ) ;
File oFile = new File ( outputPath + System . getProperty ( "str" ) + fname + suffix + "str" + ext ) ;
intermediatePath = System . getProperty ( "str" ) + System . getProperty ( "str" ) + label1 + "str" + label2 + "str" + dateString + "str" + System . currentTimeMillis ( ) ;
this . intermediatePath = System . getProperty ( "str" ) + System . getProperty ( "str" ) + label1 + "str" + label2 + "str" + dateString + "str" + System . currentTimeMillis ( ) ;
throw new IllegalArgumentException ( "str" ) ;
private static final CommandWithActions DEFAULT_APPLY_CODE_CHANGES_TASK = nonBlockingCommand (
output . put ( "str" , def . projectDir . toString ( ) ) ;
@ServiceProviders ( { @ServiceProvider ( service = JavadocForBinaryQueryImplementation . class , position = 70 ) } )
public final class DefaultGradleModelLoader implements ModelLoader < NbGradleModel > {
public ProfileBasedSettingsCategory getSettingsCategory ( ) {
ProfileBasedSettingsCategory categoryDef = foreignDef . getSettingsCategory ( ) ;
selectGradleLocation ( value ) ;
Set < File > runtimeCP = sourceSet . getClasspaths ( ) . getRuntimeClasspaths ( ) ;
Arrays . asList ( projectTask ( "str" ) ) ,
Arrays . asList ( projectTask ( "str" ) ) ,
Arrays . asList ( projectTask ( "str" ) ) ,
return getRawLocation ( str ) ;
jDaemonTimeoutSpinner . setModel ( new SpinnerNumberModel ( 1 , 1 , Integer . MAX_VALUE , 30 ) ) ;
jProjectCacheSize . setModel ( new SpinnerNumberModel ( 1 , 1 , Integer . MAX_VALUE , 1 ) ) ;
return "str" + versionStr + "str" ;
return "str" + versionStr + "str" ;
String versionStr = version . getVersion ( ) ;
jCustomPanelContainer . add ( new JScrollPane ( customPanelLayer ) ) ;
jCustomPanelContainer = new javax . swing . JPanel ( ) ;
jCustomPanelContainer . setLayout ( new java . awt . GridLayout ( 1 , 1 ) ) ;
. addComponent ( jCustomPanelContainer , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , Short . MAX_VALUE )
. addComponent ( jCustomPanelContainer , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , Short . MAX_VALUE ) )
private javax . swing . JPanel jCustomPanelContainer ;
result . getChildBuilder ( asAttributeName ( attrName ) ) . setValue ( attrValue ) ;
public void waitForCall ( String taskName ) {
throw new OperationCanceledException ( "str" + taskName ) ;
result . init ( Cancellation . UNCANCELABLE_TOKEN ) ;
ModelLoadIssueReporter . reportBuildScriptError ( project , buildScriptEvaluationError ) ;
: getDefaultXmlOutput ( project ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , sourceSetName ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , mainName , subName ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , projectName ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , taskName ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , command ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , arguments ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , arguments ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , sourceSetName ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , sourceSetName ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , sourceSetName ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , baseName , inherited ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , projectName ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , name ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , numberOfProjects ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , profile ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , profile ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , projectName ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , entryName ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , projectName ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , projectName ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , error ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , errorText . toString ( ) ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , projectName ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , projectName ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , tasks ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , profileName ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , fileName ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , projectName ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , projectName , projectPath ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , projectName , projectPath ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" + strategy . name ( ) ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" ) ;
return NbBundle . getMessage ( NbStrings . class , "str" , gradleVersion ) ;
addDependencyGroup ( "str" + sourceSet . getName ( ) , compileNodes , toPopulate ) ;
addDependencyGroup ( "str" + sourceSet . getName ( ) , runtimeNodes , toPopulate ) ;
public final class AutoJavaJavadocForBinaryQuery extends AbstractJavadocForBinaryQuery {
return properties . getAuxConfig ( elementName , namespace ) ;
loadProject ( false , mayUseCache ) ;
Map < String , Object > values = new TreeMap < String , Object > ( ) ;
return new FilterNode ( fileData . getNodeDelegate ( ) . cloneNode ( ) ) {
jGradleHomeEdit . setText ( gradleHome ) ;
NbGradleProject . PROJECT_PROCESSOR . execute ( new Runnable ( ) {
Writer forwardedStdErr = new WriterForwarded ( buildErrOutput , taskDef . getStdErrListener ( ) ) ;
LOGGER . log ( Level . INFO , "str" + name , ex ) ;
LOGGER . log ( Level . INFO , "str" + name , ex ) ;
LOGGER . log ( Level . INFO , "str" + versionStr , ex ) ;
LOGGER . log ( Level . INFO , "str" , ex ) ;
LOGGER . log ( Level . INFO , "str" , ex ) ;
LOGGER . log ( Level . INFO , "str" , ex ) ;
LOGGER . log ( Level . INFO , "str" , ex ) ;
LOGGER . log ( Level . INFO , "str" + charsetName , ex ) ;
LOGGER . log ( Level . INFO , "str" + charsetName , ex ) ;
LOGGER . log ( Level . INFO , "str" , error ) ;
LOGGER . log ( Level . INFO , "str" + command , ex ) ;
LOGGER . log ( Level . INFO , "str" + buildDir , ex ) ;
LOGGER . log ( Level . INFO , "str" + testBuildDir , ex ) ;
return fileObject . getNodeDelegate ( ) . cloneNode ( ) ;
return Collections . < Event > emptyList ( ) . iterator ( ) ;
& & ! stackTraceElement . getMethodName ( ) . equals ( cachedFrames [ j ] . getMethod ( ) . getName ( ) ) ) {
logger . debug ( "str"
public static final String DEFAULT_DSN = "str" ;
logger . debug ( "str" ) ;
logger . debug ( "str" , ravenFactory ) ;
logger . debug ( "str" , ravenFactory ) ;
logger . debug ( "str" , builderHelper ) ;
logger . debug ( "str" , builderHelper ) ;
assertThat ( Dsn . dsnLookup ( ) , is ( "str" ) ) ;
public void testLazyInitialisation ( @Injectable final RavenFactory mockRavenFactory ) throws Exception {
RavenFactory . registerFactory ( mockRavenFactory ) ;
sentryAppender . setRavenFactory ( mockRavenFactory . getClass ( ) . getName ( ) ) ;
mockRavenFactory . createRavenInstance ( withEqual ( new Dsn ( dsnUri ) ) ) ;
public void testSimpleMessageLogging ( ) throws Exception {
LOGGER . error ( "str" ) ;
private boolean bypassSecurity = false ;
protected Connection createConnection ( Dsn dsn ) {
protected Connection createAsyncConnection ( Dsn dsn , Connection connection ) {
protected Connection createHttpConnection ( Dsn dsn ) {
protected Connection createUdpConnection ( Dsn dsn ) {
protected Marshaller createMarshaller ( Dsn dsn ) {
openSocket ( dsn . getHost ( ) , dsn . getPort ( ) ! = - 1 ? dsn . getPort ( ) : DEFAULT_UDP_PORT ) ;
sb . append ( line ) . append ( "str" ) ;
Map < String , Set < String > > unmodifiableTags = new HashMap < String , Set < String > > ( event . getTags ( ) . size ( ) ) ;
unmodifiableTags . put ( tag . getKey ( ) , Collections . unmodifiableSet ( tag . getValue ( ) ) ) ;
event . setTags ( Collections . unmodifiableMap ( unmodifiableTags ) ) ;
private void extractOptions ( URI dsnUri ) {
private static final String STACKTRACE_INTERFACE = "str" ;
private static final String EXCEPTION_INTERFACE = "str" ;
public void onUpdateError ( Throwable t ) {
checkCB . onCheckError ( new RuntimeException ( String . format ( "str" , filename ) ) ) ;
public void onUpdateError ( Throwable t ) {
downloadCB . onUpdateError ( t ) ;
innerCB . onUpdateError ( t ) ;
public void onCheckError ( Throwable t ) {
checkCB . onCheckError ( t ) ;
checkCB . onCheckError ( new RuntimeException ( "str" ) ) ;
downloadCB . onUpdateError ( new RuntimeException ( "str" ) ) ;
DEFAULT_AUTHOR = context . getPackageName ( ) + "str" ;
query . append ( "str" + ( index + + ) + "str" , "str" + pageQuery . query + "str" ) ;
query . append ( "str" + ( index + + ) + "str" , "str" + pageQuery . query + "str" ) ;
module app . jweb . admin {
return new String ( bytes , Charset . forName ( "str" ) ) ;
if ( Boolean . FALSE . equals ( spatial . getUserData ( AssetUtils . USER_DATE_KEY_REMOVABLE ) ) | | Boolean . FALSE . equals ( spatial . getParent ( ) . getParent ( ) . getUserData ( AssetUtils . USER_DATE_KEY_REMOVABLE ) ) ) {
target = getCreaturesCount ( playerId , creatureId ) ;
target = getRoomSlabsCount ( playerId , roomId ) ;
target = getRoomCount ( playerId , roomId ) ;
return new File ( AssetsConverter . getCurrentFolder ( ) . concat ( HISCORES_FILENAME ) ) ;
CAMERA_RIGHT ( Integer . class , KeyInput . KEY_D , SettingCategory . CONTROLS , "str" ) ,
private final static float [ ] ZERO_FLOATS = new float [ SBLIMIT ] ;
private final static int RECORDER_FPS_DEFAULT = 60 ;
REVEAL_THROUGH_FOG_OF_WAR ( 0x010 ) ,
List < AnimGeom > geometries = new ArrayList < > ( geomCount + 1 ) ;
public float getScale ( ) {
public void setScale ( float scale ) {
public int getFrames ( ) {
public void setFrames ( int frames ) {
private ArtResource ref1 [ ] ;
private int unk2d [ ] ;
private short unk2e [ ] ;
private Attraction attraction [ ] ;
private float height ;
private float eyeHeight ;
private int meleeRecharge ;
public ArtResource [ ] getRef1 ( ) {
protected void setRef1 ( ArtResource ref1 [ ] ) {
public int [ ] getUnk2d ( ) {
protected void setUnk2d ( int [ ] unk2d ) {
public short [ ] getUnk2e ( ) {
protected void setUnk2e ( short [ ] unk2e ) {
public Attraction [ ] getAttraction ( ) {
protected void setAttraction ( Attraction [ ] attraction ) {
public float getHeight ( ) {
protected void setHeight ( float height ) {
public float getEyeHeight ( ) {
protected void setEyeHeight ( float eyeHeight ) {
private float lightHeight ;
public float getLightHeight ( ) {
protected void setLightHeight ( float lightHeight ) {
public @interface TYPE {
this . showEvery = 1 ;
return executeTask ( configuration , task ) ;
return executeTask ( configuration , task ) ;
& & pagination . getPageNumber ( ) < pagination . getTotalPageNumber ( )
public static final int DEFAULT_RESULT_LIMIT = 300 ;
private final JTextField rowLimitField = new JTextField ( Integer . toString ( MongoQueryOptions . DEFAULT_RESULT_LIMIT ) ) ;
configuration . getAuthenticationDatabase ( ) ,
configuration . getAuthenticationDatabase ( ) ,
configuration . getAuthenticationDatabase ( ) ,
return String . format ( "str" , serverConfiguration . getServerUrls ( ) . get ( 0 ) , database = = null ? "str" : database . getName ( ) ) ;
private List < String > serverUrls = new LinkedList < String > ( ) ;
databaseForTesting = mongo . getDB ( "str" ) ;
private static final URL pluginSettingsUrl = GuiUtils . isUnderDarcula ( ) ? GuiUtils . getIconResource ( "str" ) : GuiUtils . getIconResource ( "str" ) ;
public void appendText ( ColoredTreeCellRenderer cellRenderer , boolean isNodeExpanded ) {
if ( ! isNodeExpanded ) {
int MAX_LENGTH = 150 ;
void appendText ( ColoredTreeCellRenderer cellRenderer , boolean isNodeExpanded ) ;
public void appendText ( ColoredTreeCellRenderer cellRenderer , boolean isNodeExpanded ) {
if ( ! isNodeExpanded ) {
cellRenderer . append ( String . format ( "str" , index ) , INDEX ) ;
super ( "str" , "str" , GuiUtil . loadIcon ( "str" ) ) ;
public void setFollowSymlinks ( String followSymlinks ) {
buildRule . executeTarget ( "str" ) ;
assumeThat ( "str" ,
if ( key . isEmpty ( ) | | ! Character . isJavaIdentifierStart ( key . charAt ( 0 ) ) ) {
sb . append ( String . format ( "str" , systemError ) ) ;
if ( url . getPath ( ) . toLowerCase ( Locale . ENGLISH ) . endsWith ( "str" ) ) {
throw new IllegalStateException ( "str" ) ;
private static final int INITIAL_SIZE = 132 ;
bufferInfo . buffer = new ByteArrayOutputStream ( INITIAL_SIZE ) ;
private static final int INITIAL_SIZE = 132 ;
= new ByteArrayOutputStream ( INITIAL_SIZE ) ;
upToDate & = check ( tmpBase , files ) ;
public void testNoDefaultConstructor ( ) throws Exception {
File tmpFile = FILE_UTILS . createTempFile ( "str" , "str" , null , true , true ) ;
FILE_UTILS . copyFile ( srcFile , tmpFile , null , fcv , true , false ,
if ( rawCentralDirectoryData . length < expectedLength ) {
if ( Os . isFamily ( "str" ) & & JavaEnvUtils . getJavaVersionNumber ( ) < = JavaEnvUtils . VERSION_1_6 ) {
ByteArrayOutputStream longName = new ByteArrayOutputStream ( ) ;
longName . write ( buf , 0 , length ) ;
public int compareTo ( DeweyDecimal other ) {
+ "str" + getURI ( ) + "str" ) ;
} else if ( ! ( logError | | outputStream = = null ) & & errorProperty = = null ) {
msg = StringUtils . LINE_SEP + name + "str" + now + "str"
msg = StringUtils . LINE_SEP + name + "str" + now
if ( children = = null | | ( children . length = = 0 & & file . isFile ( ) ) ) {
if ( children = = null | | file . isFile ( ) ) {
msg . append ( "str" ) ;
new String [ ] { extensionPoint , ( String ) itTarget . next ( ) ,
if ( myReply [ x ] ! = null & & myReply [ x ] . indexOf ( "str" ) = = - 1 ) {
| | ( best . isSiteLocalAddress ( ) & & ! hasHostName ( best ) ) ) {
if ( from . getAbsolutePath ( ) . equals ( to . getAbsolutePath ( ) ) ) {
if ( destFile . getAbsolutePath ( ) . equals ( sourceFile . getAbsolutePath ( ) ) ) {
private static final long MAX_IO_CHUNK_SIZE = 16 * 1024 * 1024 ;
long chunk = Math . min ( MAX_IO_CHUNK_SIZE , count - position ) ;
long chunk = Math . min ( MAX_IO_CHUNCK_SIZE , count - position ) ;
srcChannel . transferTo ( position , chunk ,
this . forceOverwrite = forceOverwrite ;
URL newURL = new URL ( aSource , newLocation ) ;
true ) ) ;
handle ( "str" + fsDir ) ;
+ zipFile . toString ( ) + "str" + t . getMessage ( ) ,
this . nameCRC32 = nameCRC32 ;
this . unicodeName = unicodeName ;
if ( dir . isDirectory ( ) ) {
public static final int MAX_LEVELS_OF_SYMLINKS = 5 ;
"str" + basedir + "str" ) ;
+ "str" ) ;
for ( Iterator i = logicalLines . iterator ( ) ; i . hasNext ( ) ; ) {
public void testPreserveEscapeName ( ) throws Exception {
private volatile Hashtable delegates = new Hashtable ( ) ;
return FileUtils . getFileUtils ( ) . getFileURL ( file ) ;
while ( ! channel . isClosed ( ) ) {
public static final String DATA_TYPE_NAME = "str" ;
private static class PropertyResolver implements PropertyHelper . PropertyEvaluator {
throw new BuildException ( "str" + property + "str" ) ;
if ( getModified ( ) > 0 ) {
expectBuildException ( "str" , "str" ) ;
expectBuildException ( "str" , "str" ) ;
expectBuildException ( "str" , "str" ) ;
Object uriObj = createMethod . invoke ( null , new Object [ ] { encodeURI ( uri ) } ) ;
throw new BuildException ( "str" + ch + "str" ) ;
expectBuildException ( "str" , "str" ) ;
private static class InvertedPatternSet extends PatternSet {
proxy = true ;
public static boolean respondsTo ( Object o , String methodName )
throw new BuildException ( "str" ) ;
private static final ResourceComparator DATE
private static final ResourceComparator REVERSE_DATE = new Reverse ( DATE ) ;
return getXest ( rc , REVERSE_DATE ) ;
return getXest ( rc , DATE ) ;
out = new FileOutputStream ( destinationFile , append ) ;
super . setFork ( true ) ;
fireMessageLogged ( project , message , null , priority ) ;
String base = new File ( File . separator ) . getAbsolutePath ( ) ;
String base = new File ( File . separator ) . getAbsolutePath ( ) ;
String base = new File ( File . separator ) . getAbsolutePath ( ) ;
String base = new File ( File . separator ) . getAbsolutePath ( ) ;
protected String message = "str" ;
protected void dieOnCircularReference ( Stack stk , Project p ) {
log ( message , Project . MSG_ERR ) ;
log ( "str" + getMessage ( e ) , Project . MSG_ERR ) ;
versionString . indexOf ( "str" ) + 17 ) ;
UnknownElement child = copy ( ( UnknownElement ) i . next ( ) ) ;
UnknownElement child = copy ( ( UnknownElement ) i . next ( ) ) ;
return choices . contains ( getInput ( ) ) | | ( "str" . equals ( getInput ( ) ) & & getDefaultValue ( ) ! = null ) ;
assertFileContains ( "str" , "str" ) ;
public void assertLogContaining ( String substring ) {
public void assertOutputContaining ( String substring ) {
& & timestamp > = lastModified ) ) {
float actual = getVersion ( ) ;
if ( coll = = null | | coll . isEmpty ( ) ) {
if ( Os . isFamily ( "str" ) & & ! Os . isFamily ( "str" ) ) {
log ( "str" + zipFile . toString ( ) + t . getMessage ( ) ,
+ "str" , quiet ? Project . MSG_VERBOSE : verbosity ) ;
+ "str" , quiet ? Project . MSG_VERBOSE : verbosity ) ;
throw new BuildException ( "str" + src , x ) ;
throw new BuildException ( "str" + src , ioe ) ;
out . println ( "str" ) ;
File reportFile = new File ( System . getProperty ( "str" ) , "str" ) ;
ResourceIterator ri = disc . findResources ( RESOURCE_NAME ) ;
if ( sql . length ( ) > 0 ) {
throw new IllegalStateException ( "str" ) ;
throw new IllegalStateException ( "str" ) ;
throw new IllegalStateException ( "str" ) ;
throw new IllegalStateException ( "str" ) ;
StringBuffer sb = new StringBuffer ( "str" ) ;
+ "str" + c + "str" ) ;
logVerbose ( Commandline . describeCommand ( newCommandLine ) ) ;
long filesize = Long . parseLong ( serverResponse . substring ( start , end ) ) ;
long totalLength = 0 ;
long initFilesize = filesize ;
long totalLength ) {
protected final int trackProgress ( long filesize , long totalLength ,
long filesize = localFile . length ( ) ;
long totalLength = 0 ;
long initFilesize = filesize ;
for ( int i = 0 ; i < env . length ; i + + ) {
public void testStackTraceLineBreaks ( ) throws Exception {
throw new IllegalStateException ( ) ;
throw new IllegalStateException ( ) ;
throw new IllegalStateException ( ) ;
throw new IllegalStateException ( ) ;
return remoteTimestamp + timeDiffMillis > = localTimestamp ;
return localTimestamp > = remoteTimestamp + timeDiffMillis ;
if ( f ! = null & & f . exists ( ) ) {
import org . apache . tools . ant . taskdefs . optional . Native2Ascii ;
msg . append ( "str"
assertEquals ( "str" , results ) ;
if ( exitCode ! = 0 ) {
if ( uri . equals ( parentUri ) | | uri . equals ( "str" ) ) {
& & ( uri . equals ( parentUri ) | | uri . equals ( "str" ) ) )
throw new BuildException ( workingDirectory + "str" ) ;
throw new BuildException ( workingDirectory + "str" ) ;
throw new BuildException ( dir + "str" ) ;
if ( msgLevel < = Project . MSG_INFO ) {
incompatibleWithSpawn | = timeout ! = null ;
if ( newPriority ! = null & & priority ! = newPriority . intValue ( ) ) {
if ( newPriority < Thread . MIN_PRIORITY | | newPriority > Thread . MAX_PRIORITY ) {
buildFile = fu . normalize ( buildFile . getAbsolutePath ( ) ) ;
public class Assertions extends DataType implements Cloneable {
public Object clone ( ) throws CloneNotSupportedException {
+ "str" + lSep
+ "str" + lSep
public void demuxOutput ( String output , boolean isWarning ) {
log ( output , isWarning ? MSG_WARN : MSG_INFO ) ;
if ( isWarning ) {
log ( output , Project . MSG_WARN ) ;
public static final String ANT_CORE_URI = "str" ;
private synchronized void checkNamespace ( String componentName ) {
private boolean includeDefaultReferences = true ;
throw new BuildException ( "str"
throw new BuildException ( "str"
props . store ( outstream , "str" ) ;
log ( "str" ) ;
log ( "str" , Project . MSG_VERBOSE ) ;
if ( arg . equals ( "str" ) | | arg . equals ( "str" ) ) {
} else if ( arg . equals ( "str" ) | | arg . equals ( "str" ) ) {
} else if ( arg . equals ( "str" ) | | arg . equals ( "str" ) ) {
} else if ( arg . equals ( "str" ) | | arg . equals ( "str" ) ) {
} else if ( arg . equals ( "str" ) | | arg . equals ( "str" ) ) {
filesExcluded . addElement ( name ) ;
+ "str" + uri , Project . MSG_VERBOSE ) ;
String msg = getTaskName ( ) + "str"
if ( ! delete ( file ) ) {
private String implementationVendorURL ;
this . implementationVendorURL = implementationURL ;
| | null ! = implementationVendorURL ) {
implementationVendorURL = other . implementationVendorURL ;
processBundle ( bundleFile , 6 , false ) ;
assertTrue ( fileUtils . contentEquals ( project . resolveFile ( "str" ) ,
tmpFile = fileUtils . createTempFile ( "str" , "str" , null ) ;
+ URLEncoder . encode ( dir . getPath ( ) ) + "str"
log ( "str" + proxy . getClass ( ) , Project . MSG_VERBOSE ) ;
log ( "str" + proxy . getClass ( ) , Project . MSG_VERBOSE ) ;
if ( iter = = null | | ! iter . hasNext ( ) ) {
private boolean ignoreFileTimes = true ;
public void testRootFilesInIndex ( ) throws IOException {
PrintStream out = new PrintStream ( new AntOutputStream ( outBuffer ) ) ;
PrintStream err = new PrintStream ( new AntOutputStream ( errBuffer ) ) ;
return sfs . restrict ( files , dir , null , mm ) . length = = 0 ;
if ( outputFile = = null ) {
throw new BuildException ( "str" + targetType
} else if ( option . equals ( "str" ) | | option . equals ( "str" ) ) {
} else if ( option . equals ( "str" ) | | option . equals ( "str" ) ) {
public void setErrorsBeginAt ( int errorsBeginAt ) {
StringUtils . LINE_SEP , false ) ;
StringUtils . LINE_SEP , false ) ;
newString = stringReplace ( newString , tok , val , true ) ;
filter . getReplaceValue ( ) , true ) ;
if ( watchdog ! = null & & watchdog . killedProcess ( ) ) {
while ( spaces . length ( ) < = maxlen ) {
definitionList . addElement ( define ) ;
throw new BuildException ( "str" + descriptorDirectory . getPath ( ) +
throw new BuildException ( "str" + generatedFilesDirectory . getPath ( ) +
throw new BuildException ( "str" + sourceDirectory . getPath ( ) +
if ( helperTask . executeJava ( ) ! = 0 ) {
StringBuffer tmp = new StringBuffer ( ) ;
private XMLCatalog xmlCatalog = new XMLCatalog ( ) ;
File fileDTD = project . resolveFile ( location ) ;
throw new BuildException ( "str" + ex , ex , location ) ;
public final class FilterChain extends DataType implements Cloneable {
String msg = r . getRefId ( ) + "str" ;
getProject ( ) . resolveFile ( "str" )
throw new BuildException ( message , nfe ) ;
throw new BuildException ( ioe ) ;
private File m_dir ;
public void setDir ( final File dir )
m_dir = dir ;
exe . setWorkingDirectory ( m_dir ) ;
if ( null = = m_dir )
private static final String DEFAULT_PROPERTY_NAME = "str" ;
private static final String DEFAULT_FILENAME = DEFAULT_PROPERTY_NAME ;
properties . put ( DEFAULT_PROPERTY_NAME ,
getContext ( ) . setProperty ( DEFAULT_PROPERTY_NAME ,
properties . getProperty ( DEFAULT_PROPERTY_NAME , "str" ) . trim ( ) ;
private static final String DEFAULT_PROPERTY_NAME = "str" ;
private static final String DEFAULT_FILENAME = DEFAULT_PROPERTY_NAME ;
properties . put ( DEFAULT_PROPERTY_NAME ,
getProject ( ) . setProperty ( DEFAULT_PROPERTY_NAME ,
properties . getProperty ( DEFAULT_PROPERTY_NAME , "str" ) . trim ( ) ;
message = ExceptionUtil . printStackTrace ( throwable , 8 , true , true ) ;
getWriter ( ) . println ( ExceptionUtil . printStackTrace ( throwable , 8 , true ) ) ;
+ "str" + lSep
import java . util . Enumeration ;
getElements ( ) . addElement ( aDTD ) ;
getElements ( ) . addElement ( dtd ) ;
Enumeration elements = getElements ( ) . elements ( ) ;
System . getProperties ( ) . put ( "str" , "str" ) ;
System . getProperties ( ) . put ( "str" , ls ) ;
filesets . addElement ( zf ) ;
groupfilesets . removeAllElements ( ) ;
import java . util . Enumeration ;
getElements ( ) . addElement ( aDTD ) ;
getElements ( ) . addElement ( dtd ) ;
Enumeration elements = getElements ( ) . elements ( ) ;
final String message = REZ . getString ( "str" , id ) ;
sb . append ( "str" ) ;
Project . MSG_WARN ) ;
final File propsFile = new File ( bundleFile + "str" ) ;
ins = new FileInputStream ( propsFile ) ;
log ( propsFile + "str" , Project . MSG_DEBUG ) ;
final String message = REZ . getString ( "str" , typeLib . getLibrary ( ) , file ) ;
assertEquals ( "str" ,
assertTrue ( "str" ,
assertEquals ( "str" ,
case TestRunEvent . SUITE_ENDED :
case TestRunEvent . SUITE_STARTED :
variant = st . nextToken ( ) ;
public abstract static class FilterElement {
public abstract static class FilterElement {
if ( ! result ) {
private int [ ] m_unzftab = new int [ 256 ] ;
int [ ] cftab = new int [ 257 ] ;
ch = m_ll8 [ i ] ;
if ( j2 < z )
ch2 ^ = ( ( m_rNToGo = = 1 ) ? 1 : 0 ) ;
if ( j2 < z )
final char [ ] yy = new char [ 256 ] ;
return bsR ( numBits ) ;
final char [ ] pos = new char [ N_GROUPS ] ;
final char [ ] [ ] len = new char [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ;
final boolean [ ] inUse16 = new boolean [ 16 ] ;
private static int [ ] CRC32_TABLE = new int [ ]
int [ ] RAND_NUMS = new int [ ]
final String baseDirectoryName = configuration . getAttribute ( "str" , null ) ;
final String message = REZ . getString ( "str" , name , object . getClass ( ) . getName ( ) ) ;
REZ . getString ( "str" ,
final InputStream input = m_process . getErrorStream ( ) ;
if ( files ! = null ) {
String [ ] args = { "str" , "str" , "str" , getAbsolutePath ( ) } ;
private final static boolean DEBUG = false ;
message = f + "str" ;
message = f + "str"
message = f + "str" ;
message = f + "str"
setFile ( file ) ;
message = f + "str" ;
message = f + "str" ;
setFile ( file ) ;
message = f + "str" ;
message = f + "str" ;
Reader r = null ;
if ( r ! = null ) {
r . close ( ) ;
protected static String INIT_FAILED_MSG = "str" ;
throw new BuildException ( "str" + afile ) ;
throw new BuildException ( "str" + afile , ex ) ;
File src = new File ( fs . getDir ( project ) , srcFiles [ j ] ) ;
doOneJar ( new File ( fs . getDir ( project ) , jarFiles [ j ] ) , null ) ;
throw new BuildException ( "str" ) ;
throw new BuildException ( "str" ) ;
import org . apache . myrmidon . interfaces . type . DefaultTypeFactory ;
newValue = + + value ;
newValue = - - value ;
new StringTokenizer ( depS , "str" , true ) ;
p1 . setSystemProperties ( ) ;
! ( error instanceof BuildException ) ) {
for ( int i = 0 , n = innerfiles . length ; i < n ; i + + ) {
public void addFileset ( ZipFileSet set ) {
catch ( InvocationTargetException exc ) {
throw new BuildException ( "str" , realexc ) ;
catch ( Exception exc ) {
throw new BuildException ( "str" , exc ) ;
Project . MSG_DEBUG ) ;
log ( "str" + name , Project . MSG_DEBUG ) ;
if ( ( tmpprop = project . getProperty ( "str" ) ) ! = null ) setUser ( tmpprop ) ;
private boolean doUpdate = false ;
factory = m_parent . getTypeFactory ( name ) ;
throw new DeploymentException ( "str" , ioe ) ;
assertNull ( project . getProperty ( "str" ) ) ;
assertNull ( project . getProperty ( "str" ) ) ;
protected final static String DEFAULT_FILENAME = "str" ;
protected DescriptorHandler getWeblogicDescriptorHandler ( File srcDir ) {
DescriptorHandler handler = getWeblogicDescriptorHandler ( ejbDescriptor . getParentFile ( ) ) ;
sysProperties . setSystem ( ) ;
public void setFiltersfile ( File filtersFile ) {
} catch ( Throwable t ) {
protected static String lSep = System . getProperty ( "str" ) ;
protected boolean emacsMode = false ;
protected static String formatTime ( long millis ) {
if ( foundJavaFile & & vpath . length ( ) > 0 ) {
public class Commandline implements Cloneable {
if ( ! autocommit & & conn ! = null ) {
if ( ! autocommit & & conn ! = null ) {
weblogicAdmin . setClasspath ( new Path ( execClassPath ) ) ;
ddCreatorTask . setClasspath ( new Path ( execClassPath ) ) ;
helperTask . setClasspath ( new Path ( execClassPath ) ) ;
weblogicServer . setClasspath ( new Path ( execClassPath ) ) ;
new StreamPumper ( proc . getInputStream ( ) , Project . MSG_INFO , project , fos ) ;
new StreamPumper ( proc . getErrorStream ( ) , Project . MSG_WARN , project , fos ) ;
private int messageLevel ;
this . fos = fos ;
project . log ( line , messageLevel ) ;
new Rexx ( compileArgs ) , new PrintWriter ( out ) ) ;
SimpleDateFormat dstamp = new SimpleDateFormat ( "str" ) ;
SimpleDateFormat tstamp = new SimpleDateFormat ( "str" ) ;
logger . debug ( "str" , messageId ) ;
double priority = message . getPriority ( ) / 100.0 ;
rq = new RedisQueues ( dynoClient , dynoClient , redisKeyPrefix , ss , 1_000 , 1_000_000 ) ;
. setSonarVersion ( System . getProperty ( "str" , "str" ) )
. setSonarVersion ( System . getProperty ( "str" , "str" ) )
. setSonarVersion ( System . getProperty ( "str" , "str" ) )
private static final String MESSAGE = "str" ;
private static final int DEFAULT_MAXIMUM_LINE_LENGTH = 180 ;
Preconditions . checkState ( successor ! = null , "str" , this ) ;
. map ( IdentifierTree : : symbol )
public static final String DEFAULT = "str" ;
private static class NullExpressionUsageVisitor extends DoubleDispatchVisitorCheck {
private static FilePredicate mainFilePredicate ( FileSystem fileSystem ) {
private static int getNumberOfCommas ( ExpressionTree expression ) {
newStack . push ( EqualToSymbolicValue . createEqual ( newStack . pop ( ) , newStack . pop ( ) ) ) ;
newStack . push ( EqualToSymbolicValue . createNotEqual ( newStack . pop ( ) , newStack . pop ( ) ) ) ;
newStack . push ( EqualToSymbolicValue . createStrictEqual ( newStack . pop ( ) , newStack . pop ( ) ) ) ;
newStack . push ( EqualToSymbolicValue . createStrictNotEqual ( newStack . pop ( ) , newStack . pop ( ) ) ) ;
public static SymbolicValue createEqual ( SymbolicValue operand1 , SymbolicValue operand2 ) {
public static SymbolicValue createNotEqual ( SymbolicValue operand1 , SymbolicValue operand2 ) {
public static SymbolicValue createStrictEqual ( SymbolicValue operand1 , SymbolicValue operand2 ) {
public static SymbolicValue createStrictNotEqual ( SymbolicValue operand1 , SymbolicValue operand2 ) {
Kind ( Class < ? extends Tree > associatedInterface ) {
JavaScriptPunctuator ( String word ) {
JavaScriptLegacyGrammar ( ) {
JavaScriptKeyword ( String value ) {
private static Symbol getSymbol ( @Nullable ExpressionTree object ) {
private static ExpressionTree getObject ( Tree element ) {
private static boolean hasTryBranchingTree ( CfgBlock block ) {
private static Truthiness getTypeOfConditionTruthiness ( Tree expression , String typeValue , ProgramState currentState , Symbol conditionVariable ) {
private static boolean isNullyComparison ( Tree lastElement ) {
private static boolean isStrictComparison ( Tree lastElement , SymbolicValue value ) {
assertThat ( profile . getActiveRulesByRepository ( CheckList . REPOSITORY_KEY ) . size ( ) ) . isGreaterThan ( 80 ) ;
getContext ( ) . addIssue ( this , tree , "str" , ( double ) jumpStatementNumber - 1 ) ;
if ( ! isJsDoc ( trivia ) & & ! isJsLint ( trivia ) & & ! isJsHint ( trivia ) & & ! isGlobals ( trivia ) ) {
private static boolean isJsLint ( SyntaxTrivia trivia ) {
private static boolean isJsHint ( SyntaxTrivia trivia ) {
private static boolean isGlobals ( SyntaxTrivia trivia ) {
SyntaxToken token = ( SyntaxToken ) tree ;
. next ( ) . atLine ( 57 )
if ( identifierWithName ( expr . property ( ) , "str" ) ) {
return identifierWithName ( subExpr . object ( ) , "str" ) & & identifierWithName ( subExpr . property ( ) , "str" ) ;
if ( identifierWithName ( pairProperty . key ( ) , propertyName ) ) {
private static boolean identifierWithName ( ExpressionTree tree , String value ) {
private static String expressionList ( List < ExpressionTree > expressions ) {
private static boolean isArrayElement ( ExpressionTree expression ) {
private static boolean canOnlyBeArray ( ExpressionTree expression ) {
private static boolean isJumpStatement ( StatementTree statement ) {
private static boolean hasDefaultCase ( SwitchStatementTree switchStmt ) {
private static boolean isElseIf ( AstNode astNode ) {
private static void highlightComments ( Highlightable . HighlightingBuilder highlighting , List < Token > tokens , SourceFileOffsets offsets ) {
private static boolean builtInArgumentsUsed ( Scope scope ) {
private static List < Boolean > getUsageInfo ( List < Symbol > symbols ) {
private static String getListOfArguments ( List < Symbol > unusedArguments ) {
private static boolean isLetterAround ( String line , String pattern ) {
private static int getLine ( Usage usage ) {
private static boolean isJsDoc ( Trivia trivia ) {
private static Usage getDeclaration ( Symbol symbol ) {
private static boolean usagesAreInitializations ( Collection < Usage > usages ) {
private static boolean isGlobalOrCatchVariable ( Symbol symbol ) {
private static boolean isElementCreation ( LiteralTree literalTree ) {
private static boolean isEquality ( ExpressionTree condition ) {
private static boolean isNullConditionException ( ForStatementTree forStatement ) {
private static boolean isOneVarDeclaration ( Tree tree ) {
private static Integer getInteger ( ExpressionTree expression ) {
private static boolean isUpdateOnOneWithAssign ( ExpressionTree update ) {
private static boolean endsWithNewline ( RandomAccessFile randomAccessFile ) throws IOException {
private static boolean isCalleeConsoleLogging ( DotMemberExpressionTree callee ) {
private static boolean isPotentialNanComparison ( BinaryExpressionTree tree ) {
private static boolean isOneOntoOneShifting ( BinaryExpressionTree tree ) {
private static ExpressionTree getCondition ( SwitchClauseTree clause ) {
private static boolean hasObjectOrArrayAttribute ( ObjectLiteralTree objectLiteral ) {
private static boolean isNullOrUndefined ( Tree tree ) {
private static boolean isUndefined ( ExpressionTree expression ) {
private static boolean isNaN ( ExpressionTree expression ) {
private static boolean isIfStatementWithoutElse ( StatementTree statement ) {
private static boolean hasRead ( List < Usage > usages ) {
stack = new Stack < > ( ) ;
private static void addArrowParametersToScope ( Tree parameters , Set < String > currentScope ) {
private static void addFormalParametersToScope ( ParameterListTreeImpl formalParameterList , Set < String > currentScope ) {
private static boolean isParseIntCall ( ExpressionTree callee ) {
private static boolean propertyIsDeprecated ( ExpressionTree property , List < String > deprecated ) {
private static boolean isNullLiteral ( ExpressionTree expressionTree ) {
private static final String MESSAGE = "str" ;
private static boolean isNewLine ( char [ ] input , int i ) {
( input [ i ] = = "str" & & ( i + 1 = = input . length | | input [ i + 1 ] ! = "str" ) ) ;
public SymbolVisitor ( SymbolModel symbolModel , @Nullable Symbolizable symbolizable , SourceFileOffsets sourceFileOffsets ) {
Usage . create ( symbolModel , symbol , identifier , kind ) ;
Usage . createInit ( symbolModel , symbol , identifier , usageKind ) ;
public class MethodDeclarationTreeImpl extends JavaScriptTree implements GeneratorMethodDeclarationTree , AccessorMethodDeclarationTree {
private static final GrammarRuleKey [ ] FUNCTION_NODES = {
AstNode block = functionNode . getFirstChild ( Kind . BLOCK ) ;
public interface FunctionTree extends ExpressionTree {
private final SeparatedList < ExpressionTree > parameters ;
private final SeparatedList < ExpressionTree > parameters ;
private final SeparatedList < ExpressionTree > parameters ;
public WithStatementTreeImpl ( InternalSyntaxToken withKeyword , InternalSyntaxToken openingParenthesis , AstNode expression , InternalSyntaxToken closingParenthesis , AstNode statement ) {
this . openingParenthesis = openingParenthesis ;
addChild ( openingParenthesis ) ;
public ContinueStatementTreeImpl ( IdentifierTree label , AstNode eos ) {
addChild ( ( AstNode ) label ) ;
return new ContinueStatementTreeImpl ( new IdentifierTreeImpl ( InternalSyntaxToken . create ( identifier ) ) , eos ) ;
subscribeTo ( EcmaScriptGrammar . CALL_EXPRESSION ) ;
private static final GrammarRuleKey [ ] FUNCTION_NODES = {
getContext ( ) . createLineViolation ( this , "str" , astNode , astNode . getTokenValue ( ) ) ;
name = "str" ,
project = false ) ,
name = "str" ,
. next ( ) . atLine ( 2 ) . withMessage ( "str" )
. withChannel ( new UnknownCharacterChannel ( ) )
private static final Logger LOG = LoggerFactory . getLogger ( LCOVParser . class ) ;
return EcmaScriptGrammar . EXPRESSION . equals ( t ) | | EcmaScriptGrammar . EXPRESSION_NO_IN . equals ( t ) | | EcmaScriptGrammar . CONDITION . equals ( t ) ;
getContext ( ) . createLineViolation ( this , "str" ,
. next ( ) . atLine ( 1 ) . withMessage ( "str" )
return EcmaScriptKeyword . NULL . getValue ( ) . equals ( node . getNextSibling ( ) . getTokenValue ( ) ) ;
String identifier = astNode . getFirstChild ( EcmaScriptTokenType . IDENTIFIER ) . getTokenValue ( ) ;
public static final String JSTEST_REPORTS_PATH = PROPERTY_PREFIX + "str" ;
public static final String FILE_SUFFIXES_DEFVALUE = "str" ;
public static final String LITERAL = "str"
public static final String COMMENT = "str"
public static final String IDENTIFIER = "str" ;
defaultValue = "str" + DEFAULT_MESSAGE )
defaultValue = "str" + DEFAULT_MESSAGE )
Violation violation = Violation . create ( annotationCheckFactory . getActiveRule ( message . getCheck ( ) ) , sonarFile )
source = "str" + classKey + "str" ;
File unitTestFile = new File ( "str" ) ;
Path javaHome = Paths . get ( coalesce (
public static final String PUBLIC_KEY = "str" ;
errorReport . append ( "str" ) ;
errorReport . append ( "str" ) ;
errorReport . append ( "str" ) ;
errorReport . append ( "str" ) ;
private String commaSeparatedEmailAddresses ;
this . commaSeparatedEmailAddresses = ( commaSeparatedEmailAddresses ! = null ) ? commaSeparatedEmailAddresses : "str" ;
reward . setQuantity ( REQUIRED_WOOD ) ;
npc . setDescription ( "str" ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
addHelp ( "str" ) ;
npc . setEntityClass ( "str" ) ;
npc . setEntityClass ( "str" ) ;
new PlayerStatLevelCondition ( "str" , ComparisonOperator . LESS_THAN , RATK_LIMIT ) ,
String safeRef = ref . split ( "str" ) [ 0 ] + "str" ;
if ( user ! = null & & ! user . stopped ( ) ) {
logger . error ( player . getName ( ) + "str" + username + "str"
assertEquals ( "str" , sentence . toString ( ) ) ;
npc . say ( "str" + itemName + "str" ) ;
npc . say ( "str" + itemName + "str" ) ;
return playerName + "str" + reply ;
private static final String QUEST_SLOT = "str" ;
res . add ( "str" ) ;
res . add ( "str" ) ;
res . add ( "str" ) ;
new SayTextAction ( "str" ) ,
put ( "str" , 0 L ) ;
put ( "str" , 0 L ) ;
SkinColor . isAllowed ( Integer . parseInt ( color ) ) ;
if ( logger . isDebugEnabled ( ) ) {
final String bodies = outfits + "str" ;
public static final int BODY_OUTFITS = 15 ;
new QuestInStateCondition ( QUEST_SLOT , 0 , "str" ) ,
return counter > = 3 ;
return levelData . length / ( HEIGHT + 1 ) - 1 ;
res . add ( "str" ) ;
sb . append ( "str" ) ;
BlockTarget targetOne = new BlockTarget ( 64 , 75 ) ;
BlockTarget targetTwo = new BlockTarget ( 65 , 75 ) ;
private final Set < String > items ;
double itemvalue = 0d ;
if ( ( victimsTarget = = null ) | | ! ( victimsTarget instanceof Player ) ) {
shops . add ( "str" , "str" , 1500 ) ;
logger . error ( e , e ) ;
logger . error ( e , e ) ;
logger . error ( e , e ) ;
logger . error ( e , e ) ;
logger . error ( e , e ) ;
logger . error ( e , e ) ;
logger . error ( e , e ) ;
logger . error ( e , e ) ;
sign . setPosition ( 47 , 119 ) ;
return immunities . contains ( StatusType . valueOf ( statusName . toUpperCase ( ) ) ) ;
return resistances . contains ( status . getStatusType ( ) ) ;
immunities . remove ( StatusType . valueOf ( statusName . toUpperCase ( ) ) ) ;
immunities . add ( StatusType . valueOf ( statusName . toUpperCase ( ) ) ) ;
public void remove ( T status , StatusList statusList ) ;
if ( object . has ( "str" ) ) {
if ( changes . has ( "str" ) ) {
onPoisoned ( Math . abs ( changes . getInt ( "str" ) ) ) ;
if ( changes . has ( "str" ) ) {
logger . debug ( "str" + Integer . toString ( ID ) + "str" + getName ( ) + "str" ) ;
logger . debug ( "str" + Integer . toString ( ID ) + "str" + getName ( ) + "str" ) ;
JOptionPane . showMessageDialog ( j2DClient . get ( ) . getMainFrame ( ) , errMsg + url ) ;
if ( player . isQuestInState ( QUEST_SLOT , 0 , "str" ) ) {
if ( painter ! = null & & barWidth > 0 ) {
npc . addReply ( "str" , "str" ) ;
npc . addReply ( "str" , "str" ) ;
import games . stendhal . server . entity . creature . Creature ;
private Object createObjectSameClass ( final Object object ) {
send ( cmd ) ;
private void send ( String cmd ) {
final SpeakerNPC npc = new SpeakerNPC ( "str" ) {
npc . setDescription ( "str" ) ;
private static Area arena ;
static class DeathMatchEmptyCondition implements ChatCondition {
if ( questState . split ( "str" ) . length > 0 ) {
setName ( "str" ) ;
public static final String VERSION = "str" ;
rewardAction . add ( new SetQuestAction ( QUEST_SLOT , 0 , "str" ) ) ;
crystal . setDescription ( "str" ) ;
crystal . setDescription ( "str" ) ;
crystal . setDescription ( "str" ) ;
result . add ( "str" ) ;
result . add ( "str" ) ;
String cartDescription = "str" ;
import games . stendhal . server . entity . npc . condition . QuestNotStartedCondition ;
new QuestInStateCondition ( QUEST_SLOT , 0 , "str" ) ,
new QuestInStateCondition ( QUEST_SLOT , 0 , "str" ) ,
new QuestNotStartedCondition ( QUEST_SLOT ) ,
new QuestInStateCondition ( QUEST_SLOT , 0 , "str" ) ,
addReply ( "str" , "str" ) ;
final CreatureRespawnPoint point = new CreatureRespawnPoint ( zone , 34 , 51 , creature , 1 ) ;
g . fillRect ( svx , tmpY , sw , sh ) ;
g . fillRect ( tmpX , svy , sw , sh ) ;
final Node [ ] start = new Node [ ] { new Node ( 115 , 6 ) , new Node ( 122 , 12 ) , new Node ( 117 , 10 ) } ;
+ "str" + data . flavor + "str" ) ;
String itemName = sentence . getTriggerExpression ( ) . toString ( ) ;
ConversationStates . ATTENDING , "str" ,
new SayTimeRemainingAction ( QUEST_SLOT , REQUIRED_MINUTES , "str" ) ) ;
String line = new String ( receivePacket . getData ( ) , receivePacket . getOffset ( ) , receivePacket . getLength ( ) , "str" ) ;
LOGGER . info ( "str" + ( minutes * 60 ) + "str" + jailer ) ;
texts . put ( "str" , "str"
texts . put ( "str" , "str" ) ;
texts . put ( "str" , "str" ) ;
texts . put ( "str" , "str" ) ;
loadSignFromHallOfFame = new LoadSignFromHallOfFameAction ( null , "str" , "str" , 2000 , true ) ;
assertEquals ( "str" ,
logger . debug ( "str" + mapsize + "str"
logger . debug ( "str" ) ;
addJob ( "str" ) ;
npc . setDescription ( "str" ) ;
import games . stendhal . server . core . pathfinder . RPZonePath ;
piedpiper . setPath ( new FixedPath ( fullpath . get ( 0 ) . get ( 0 ) . getPath ( ) , false ) ) ;
return sb . append ( nextState + "str" + condition + "str" + label + "str" ) . toString ( ) ;
sendMessage ( sender , "str" ) ;
npc . setDescription ( "str" ) ;
npc . setDescription ( "str" ) ;
addQuest ( "str" ) ;
npc . setDescription ( "str" ) ;
addHelp ( "str" ) ;
addReply ( "str" , "str" ) ;
addJob ( "str" ) ;
player . addXP ( 500 ) ;
user . drop ( ( Item ) first ) ;
npc . setDescription ( "str" ) ;
he = head . intValue ( ) ;
private final Integer hair ;
private final Integer head ;
private final Integer dress ;
private final Integer base ;
Iterator < String > i = products . iterator ( ) ;
product = ( String ) i . next ( ) ;
Iterator < String > i = products . iterator ( ) ;
product = ( String ) i . next ( ) ;
| | enoun . equals ( "str" ) | | enoun . equals ( "str" ) ) {
| | enoun . equals ( "str" ) | | enoun . equals ( "str" ) | | enoun . equals ( "str" ) ) {
res . add ( "str" ) ;
res . add ( "str" ) ;
addPropertyChangeListenerWithModifiedSupport ( pcs , "str" , listener ) ;
final OutfitChangerBehaviour behaviour = new OutfitChangerBehaviour ( priceList , 5 * 60 , "str" ) ;
static final Pattern patternNPCShout = Pattern . compile ( "str" ) ;
static final Pattern patternSupportAnswer = Pattern . compile ( "str" ) ;
static final Pattern patternAdminnote = Pattern . compile ( "str" ) ;
return new AdminNote ( message , sender , postmanIRC ) ;
return new Ban ( message , sender , postmanIRC ) ;
return new IrcBanAuth ( message , sender , postmanIRC ) ;
return new NPCShout ( message , sender , postmanIRC ) ;
return new SupportAnswer ( message , sender , postmanIRC ) ;
return new Support ( message , sender , postmanIRC ) ;
return new TellAll ( message , sender , postmanIRC ) ;
static final Pattern patternIrcBan = Pattern . compile ( "str" ) ;
static final Pattern patternTellall = Pattern . compile ( "str" ) ;
static final Pattern patternSupportAnswer = Pattern . compile ( "str" ) ;
static final Pattern patternBan = Pattern . compile ( "str" ) ;
addJob ( "str" ) ;
addReply ( "str" , "str" ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
if ( System . currentTimeMillis ( ) - player . getLastClientActionTimestamp ( ) > afkDisconnect * 1000 ) {
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( getReply ( npc ) . startsWith ( "str" ) , true ) ;
addJob ( "str" ) ;
pcs . addPropertyChangeListener ( "str" , listener ) ;
tavernMaid . setDescription ( "str" ) ;
npc . say ( "str" +
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
public static final String MAIN_NPC_NAME = "str" ;
return SingletonRepository . getNPCList ( ) . get ( MAIN_NPC_NAME ) ;
return TPPQuestHelperFunctions . MAIN_NPC_NAME ;
assertThat ( fl . describe ( ) , is ( "str" ) ) ;
if ( isVisible ( ) ) {
npc . setDescription ( "str" ) ;
new GameEvent ( null , "str" , comments ) . raise ( ) ;
new GameEvent ( null , "str" , comments ) . raise ( ) ;
final List < Achievement > achievements = new LinkedList < Achievement > ( ) ;
achievements . add ( createAchievement ( "str" , "str" , "str" ,
"str" , "str" , "str" , "str" , "str" ) ) ) ;
Achievement . HARD_BASE_SCORE , true , new QuestCompletedCondition ( "str" ) ) ) ;
GradientPaint p = new GradientPaint ( ins . left , ins . top , startColor , width / 2f , ins . top , midColor ) ;
p = new GradientPaint ( ins . left + width / 2f , ins . top , midColor , width , ins . top , endColor ) ;
assertThat ( item . describe ( ) , equalTo ( "str" ) ) ;
assertThat ( item . describe ( ) , equalTo ( "str" ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
BufferedReader reader = new BufferedReader ( new UnicodeSupportingInputStreamReader ( is , "str" ) ) ;
return Boolean . parseBoolean ( WtWindowManager . getInstance ( ) . getProperty ( "str" , "str" ) ) ;
return Boolean . parseBoolean ( WtWindowManager . getInstance ( ) . getProperty ( "str" , "str" ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
bootProp . put ( "str" + file , signature ) ;
entity . addAttribute ( "str" , Type . INT , ( byte ) ( Definition . HIDDEN | Definition . VOLATILE ) ) ;
if ( chestListener = = null ) {
logger . debug ( "str" + getZone ( ) . getName ( ) + "str" + getSlot ( "str" ) . size ( ) + "str" ) ;
logger . debug ( "str" + zone . getName ( ) + "str" + getSlot ( "str" ) . size ( ) + "str" ) ;
logger . error ( "str" ) ;
if ( ( name ! = null ) & & ( name . startsWith ( "str" ) | | name . startsWith ( "str" ) ) ) {
return fee . intValue ( ) < = ownedMoney ;
addGreeting ( "str" ) ;
addHelp ( "str" ) ;
setCapacity ( getInt ( "str" ) ) ;
private static final int DAYS_TO_REMOVING = 30 ;
if ( at . getActionCode ( ) . equals ( this . action . getActionCode ( ) ) ) {
logDir . mkdirs ( ) ;
if ( ! player . hasKilledShared ( creature . getName ( ) ) ) {
if ( ! characterDAO . hasCharacter ( transaction , player . getName ( ) , player . getName ( ) ) ) {
res . add ( "str" ) ;
assertThat ( "str" , getReply ( barMaid ) , is ( "str" ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
testPluralisationAndSingularisation ( "str" , "str" ) ;
assertEquals ( "str" ,
achievements . add ( createAchievement ( "str" , "str" , "str" ,
achievements . add ( createAchievement ( "str" , "str" , "str" ,
private static final double FINDING_PROBABILITY = 0.50 ;
player . sendPrivateText ( "str" ) ;
import games . stendhal . client . GameScreen ;
Dimension screenSize = GameScreen . get ( ) . getSize ( ) ;
list . add ( createAchievement ( "str" , "str" , "str" ,
player . sendPrivateText ( "str" + item . getTitle ( ) + "str" + dest . getContentSlotName ( ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
addReply ( "str" , "str" ) ;
LOGGER . error ( "str" + occupant . getName ( ) , new Throwable ( ) ) ;
addGoodbye ( "str" ) ;
ConversationStates . ATTENDING ,
ConversationStates . ATTENDING ,
ConversationStates . ATTENDING ,
ConversationStates . ATTENDING ,
ConversationStates . ATTENDING ,
ConversationStates . ATTENDING ,
ConversationStates . ATTENDING ,
handleError ( "str" ,
addReply ( "str" , "str" ) ;
super ( Events . GROUP_INVITE ) ;
addReply ( "str" , "str" ) ;
if ( pos . equals ( "str" ) ) {
new PlayerVisitedZonesInRegionCondition ( "str" , Boolean . TRUE , Boolean . FALSE ) ) ) ;
new PlayerVisitedZonesInRegionCondition ( "str" , Boolean . TRUE , Boolean . FALSE ) ) ) ;
new PlayerVisitedZonesInRegionCondition ( "str" , Boolean . TRUE , Boolean . FALSE ) ) ) ;
new PlayerVisitedZonesInRegionCondition ( "str" , Boolean . TRUE , Boolean . FALSE ) ) ) ;
xpAchievements . add ( createAchievement ( "str" , "str" , "str" , Achievement . EASY_BASE_SCORE ,
xpAchievements . add ( createAchievement ( "str" , "str" , "str" , Achievement . EASY_BASE_SCORE ,
xpAchievements . add ( createAchievement ( "str" , "str" , "str" , Achievement . EASY_BASE_SCORE ,
xpAchievements . add ( createAchievement ( "str" , "str" , "str" , Achievement . MEDIUM_BASE_SCORE ,
xpAchievements . add ( createAchievement ( "str" , "str" , "str" , Achievement . MEDIUM_BASE_SCORE ,
xpAchievements . add ( createAchievement ( "str" , "str" , "str" , Achievement . MEDIUM_BASE_SCORE ,
xpAchievements . add ( createAchievement ( "str" , "str" , "str" , Achievement . HARD_BASE_SCORE ,
xpAchievements . add ( createAchievement ( "str" , "str" , "str" , Achievement . HARD_BASE_SCORE ,
remove ( "str" ) ;
counter + + ;
if ( counter < zones . size ( ) - 1 ) {
stripped = line . substring ( 2 ) . trim ( ) ;
assertTrue ( getReply ( npc ) . matches ( "str" ) ) ;
if ( ( source . getEntity ( ) ! = null ) & & source . getEntity ( ) . hasSlot ( "str" ) & & source . getEntity ( ) . getSlot ( "str" ) . size ( ) > 0 ) {
npc . setDescription ( "str" ) ;
DAORegister . get ( ) . get ( StendhalBuddyDAO . class ) . saveBuddyList ( transaction , character , instance . getBuddies ( ) ) ;
if ( ! actionStr . equals ( "str" ) & & ! actionStr . equals ( "str" ) & & ! actionStr . equals ( "str" ) & & ! actionStr . equals ( "str" ) ) {
kick ( player , params ) ;
private void kick ( Player player , String targetPlayer ) {
if ( player . getName ( ) . equals ( targetPlayer ) ) {
if ( isReleased ( ) ) {
import games . stendhal . server . core . engine . dbcommand . SetOnlineStatusCommand ;
new PlayerHasKilledNumberOfCreaturesCondition ( 10 , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" ) ) ) ;
res . add ( "str" ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
addReply ( "str" , "str" ) ;
res . add ( "str" ) ;
npc . say ( "str" ) ;
LOGGER . error ( "str" + text + "str" ) ;
if ( containsKey ( "str" , buddyName ) ) {
boolean isNew = ! hasMap ( "str" ) | | ! getMap ( "str" ) . containsKey ( name ) ;
attackArmy . put ( "str" , 2 ) ;
addQuest ( "str" ) ;
addHelp ( "str" ) ;
addJob ( "str" ) ;
addReply ( "str" , "str" ) ;
npc . setDescription ( "str" ) ;
res . add ( "str" ) ;
if ( player . getQuest ( QUEST_SLOT , 0 ) . equals ( "str" ) & & ( new KilledForQuestCondition ( QUEST_SLOT , 1 ) ) . fire ( player , null , null ) ) {
if ( player . getQuest ( QUEST_SLOT , 0 ) . equals ( "str" ) ) {
res . add ( "str" ) ;
+ Grammar . quantityNumberStrNoun ( repetitions , "str" ) + "str" ) ;
playerNow . sendPrivateText ( source + "str" + message ) ;
questHistory . add ( "str" ) ;
questHistory . add ( "str" ) ;
questHistory . add ( "str" ) ;
questHistory . add ( "str" ) ;
questHistory . add ( "str" ) ;
questHistory . add ( "str" ) ;
history . add ( "str" ) ;
history . add ( "str" ) ;
logger . info ( "str" ) ;
assert idx = = newNumSamples ;
if ( ! isEnabled ( ) ) {
if ( ! isEnabled ( ) | | ( profiles . profiles . size ( ) = = 0 ) ) {
logger . error ( "str" + sound , new Throwable ( ) ) ;
return ( ! player . hasQuest ( questname ) | | player . isQuestInState ( questname , 0 , "str" ) | | player . isQuestCompleted ( questname ) ) ;
return ( player . hasQuest ( questname ) & & ! player . isQuestInState ( questname , 0 , "str" ) & & ! player . isQuestCompleted ( questname ) ) ;
final String info = getQuest ( name , 0 ) ;
return info . equals ( "str" ) ;
return ( player . hasQuest ( questname ) & & ! "str" . equals ( player . getQuest ( questname , 0 ) ) ) ;
return ( ! player . hasQuest ( questname ) | | "str" . equals ( player . getQuest ( questname , 0 ) ) ) ;
missingItems . addFromQuestStateString ( player . getQuest ( QUEST_SLOT ) ) ;
res . add ( "str" ) ;
new PlayerHasKilledNumberOfCreaturesCondition ( 10 , "str" , "str" , "str" ) ) ) ;
+ "str" + action + "str"
final String itemName = sentence . getOriginalText ( ) ;
if ( ( x < 0 ) | | ( x + w > width ) ) {
if ( ( y < 0 ) | | ( y + h > height ) ) {
npc . addReply ( Arrays . asList ( "str" , "str" , "str" ) , "str" ) ;
private boolean interior = true ;
base_mana = getInt ( "str" ) ;
addQuest ( "str" ) ;
addReply ( "str" , "str" ) ;
npc . addReply ( "str" , "str" ) ;
npc . addReply ( "str" , "str" ) ;
res . add ( "str" ) ;
addJob ( "str" ) ;
addReply ( "str" , "str" ) ;
if ( ! isEnabled ( ) | | ( profiles . profiles . size ( ) = = 0 ) ) {
LOGGER . debug ( "str" + type + "str" + eclass + "str" + subClass ) ;
user . sendPrivateText ( "str" ) ;
bottleGrower1 . setDescription ( "str" ) ;
bottleGrower1 . setDescription ( "str" ) ;
bottleGrower2 . setDescription ( "str" ) ;
bottleGrower1 . setDescription ( "str" ) ;
bottleGrower2 . setDescription ( "str" ) ;
bottleGrower1 . setDescription ( "str" ) ;
bottleGrower2 . setDescription ( "str" ) ;
bottleGrower1 . setDescription ( "str" ) ;
bottleGrower2 . setDescription ( "str" ) ;
bottleGrower1 . setDescription ( "str" ) ;
bottleGrower2 . setDescription ( "str" ) ;
bottleGrower1 . setDescription ( "str" ) ;
bottleGrower1 . setDescription ( "str" ) ;
npc . setDescription ( "str" ) ;
addJob ( "str" ) ;
requiredResources . put ( "str" , 5 ) ;
addHelp ( "str" ) ;
addQuest ( "str" ) ;
addHelp ( "str" ) ;
addQuest ( "str" ) ;
addGoodbye ( "str" ) ;
"str" , "str" ,
this ( frames , delay , animating , null ) ;
if ( ( detail = = null ) | | detail . equals ( other . detail ) ) {
newDetail = detail ;
if ( ( hair = = null ) | | hair . equals ( other . hair ) ) {
newHair = hair ;
if ( ( head = = null ) | | head . equals ( other . head ) ) {
newHead = head ;
if ( ( dress = = null ) | | dress . equals ( other . dress ) ) {
newDress = dress ;
if ( ( base = = null ) | | base . equals ( other . base ) ) {
newBase = base ;
history . add ( "str" ) ;
Set < String > getAchievements ( ) {
public TeleporterBehaviour ( final SpeakerNPC speakerNPC , final String repeatedText , final boolean useHighProbabilityZones ) {
if ( useHighProbabilityZones ) {
+ "str" ) ;
connection . setConnectTimeout ( myTimeout ) ;
xpAchievements . add ( createAchievement ( "str" , "str" , "str" , Achievement . MEDIUM_BASE_SCORE ,
bottleGrower1 . setDescription ( "str" ) ;
+ "str" + price + "str" + amount + "str"
addHelp ( "str" ) ;
System . out . println ( "str" ) ;
entity . addAttribute ( "str" , Type . LONG_STRING , Definition . HIDDEN ) ;
addGreeting ( "str" ) ;
zogfangNPC . setDescription ( "str" ) ;
addOffer ( "str" ) ;
addGoodbye ( "str" ) ;
addGreeting ( "str" ) ;
addGoodbye ( "str" ) ;
npc . setDescription ( "str" ) ;
new AndCondition ( new QuestInStateCondition ( QUEST_SLOT , "str" ) , new PlayerHasItemWithHimCondition ( "str" , 25 ) ) ,
new AndCondition ( new QuestInStateCondition ( QUEST_SLOT , "str" ) , new NotCondition ( new PlayerHasItemWithHimCondition ( "str" , 25 ) ) ) ,
res . add ( "str" ) ;
addEventLine ( new HeaderLessEventLine ( "str" + Debug . VERSION + "str" + Debug . PRE_RELEASE_VERSION , NotificationType . CLIENT ) ) ;
res . add ( "str" ) ;
raiser . say ( "str" ) ;
"str" , null ) ;
history . add ( "str" ) ;
history . add ( "str" ) ;
history . add ( "str" ) ;
history . add ( "str" ) ;
questHistory . add ( "str" ) ;
private static final List < String > NEEDED_ITEMS = Arrays . asList ( "str" ) ;
Arrays . asList ( "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" ) ,
history . add ( "str" ) ;
res . add ( "str" ) ;
history . add ( "str" ) ;
history . add ( "str" ) ;
history . add ( "str" ) ;
history . add ( "str" ) ;
history . add ( "str" ) ;
res . add ( "str" ) ;
addQuest ( "str" ) ;
setErrorMessage ( ( ( Entity ) getOwner ( ) ) . getDescriptionName ( true ) + "str" ) ;
"str" , null ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
ConversationStates . ATTENDING ,
ConversationStates . ATTENDING ,
text = text . substring ( 0 , 1000 ) + "str" ;
"str" , null ) ;
fisherman . setDescription ( "str" ) ;
if ( rpentity ! = null ) {
private long playerChatTimeout = 100 ;
private static class QuitConfirmCB implements ActionListener {
List < HousePortal > tempAllHousePortals = new LinkedList < HousePortal > ( ) ;
tempAllHousePortals . add ( ( HousePortal ) portal ) ;
final String metaSymbols = "str" ;
assertEquals ( "str" , "str" , getReply ( npc ) ) ;
xpAchievements . add ( createAchievement ( "str" , "str" , "str" , Achievement . EASY_BASE_SCORE ,
xpAchievements . add ( createAchievement ( "str" , "str" , "str" , Achievement . EASY_BASE_SCORE ,
xpAchievements . add ( createAchievement ( "str" , "str" , "str" , Achievement . EASY_BASE_SCORE ,
xpAchievements . add ( createAchievement ( "str" , "str" , "str" , Achievement . MEDIUM_BASE_SCORE ,
xpAchievements . add ( createAchievement ( "str" , "str" , "str" , Achievement . MEDIUM_BASE_SCORE ,
xpAchievements . add ( createAchievement ( "str" , "str" , "str" , Achievement . MEDIUM_BASE_SCORE ,
xpAchievements . add ( createAchievement ( "str" , "str" , "str" , Achievement . HARD_BASE_SCORE ,
xpAchievements . add ( createAchievement ( "str" , "str" , "str" , Achievement . HARD_BASE_SCORE ,
questAchievements . add ( createAchievement ( "str" , "str" , "str" ,
questAchievements . add ( createAchievement ( "str" , "str" , "str" ,
questAchievements . add ( createAchievement ( "str" , "str" , "str" ,
questAchievements . add ( createAchievement ( "str" , "str" , "str" ,
questAchievements . add ( createAchievement ( "str" , "str" , "str" ,
questAchievements . add ( createAchievement ( "str" , "str" , "str" ,
questAchievements . add ( createAchievement ( "str" , "str" , "str" ,
questAchievements . add ( createAchievement ( "str" , "str" , "str" ,
questAchievements . add ( createAchievement ( "str" , "str" , "str" ,
questAchievements . add ( createAchievement ( "str" , "str" , "str" ,
questAchievements . add ( createAchievement ( "str" , "str" , "str" ,
questAchievements . add ( createAchievement ( "str" , "str" , "str" ,
tablePathArea = new Area ( zone , 35 , 2 , 40 , 8 ) ;
public static final String STENDHAL_FOLDER ;
} catch ( final RuntimeException ex ) {
} catch ( final RuntimeException ep ) {
private static boolean showWorld ;
if ( showWorld ) {
showWorld = true ;
if ( ( filename . indexOf ( "str" ) > - 1 ) | | filename . startsWith ( "str" ) ) {
return attsToCopy . toArray ( new String [ attsToCopy . size ( ) ] ) ;
logger . debug ( "str" + query ) ;
public static final String JOKER = "str" ;
if ( ! rpObject . has ( "str" ) ) {
date . add ( Calendar . HOUR , hours ) ;
entity . addAttribute ( "str" , Type . INT ) ;
res . add ( "str" ) ;
res . add ( "str" ) ;
res . add ( "str" ) ;
res . add ( "str" ) ;
assertEquals ( "str" ,
npc . setDescription ( "str" ) ;
npc . setDescription ( "str" ) ;
addJob ( "str" ) ;
ThePiedPiper . getPhase ( ) ) , new LinkedList < String > ( ) ) ;
raiser . say ( "str" ) ;
setVersion ( "str" ) ;
super . startShouts ( timings . get ( SHOUT_TIME ) , RatsProblem ( ) ) ;
transaction . execute ( "str" , null ) ;
message . append ( Grammar . quantityplnoun ( i . getQuantity ( ) , i . getName ( ) , "str" ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
addGoodbye ( "str" ) ;
"str" , null ) ;
import games . stendhal . server . maps . quests . piedpiper . ITPPQuestConstants ;
public class ThePiedPiperTest implements ITPPQuestConstants {
import games . stendhal . server . maps . quests . piedpiper . ITPPQuestConstants ;
public class ThePiedPiper extends AbstractQuest implements ITPPQuestConstants {
if ( ( user ! = null ) & & ! user . hasPet ( ) ) {
questAchievements . add ( createAchievement ( "str" , "str" , "str" ,
logger . error ( "str" + zone + "str" + this , new Throwable ( ) ) ;
questAchievements . add ( createAchievement ( "str" , "str" , "str" ,
throw new FileNotFoundException ( "str" ) ;
new BuyerAdder ( ) . add ( dishwasher , new BuyerBehaviour ( shops . get ( "str" ) ) , false ) ;
new BuyerAdder ( ) . add ( this , new BuyerBehaviour ( shops . get ( "str" ) ) , false ) ;
new BuyerAdder ( ) . add ( magearcher , new BuyerBehaviour ( offerings ) , false ) ;
new BuyerAdder ( ) . add ( dwarfguy , new BuyerBehaviour ( offerings ) , false ) ;
addOffer ( "str" ) ;
addHelp ( "str" ) ;
if ( ! DAORegister . get ( ) . get ( CharacterDAO . class ) . hasCharacter ( "str" ) ) {
identifiers . add ( resultSet . getString ( 1 ) ) ;
final List < Entity > bankAccess = getListAddingUnknownBanks ( bank ) ;
private List < Entity > getListAddingUnknownBanks ( final Banks bank ) {
return getListAddingUnknownBanks ( bank ) ;
npc . addJob ( "str" ) ;
addTemplate ( "str" , "str" ) ;
npc . addReply ( "str" , "str" ) ;
history . remove ( "str" ) ;
final Class clazz = Class . forName ( "str" ) ;
final Class [ ] paramTypes = new Class [ 2 ] ;
final Class < ? > clazz = Class . forName ( "str" ) ;
final Class < ? > [ ] paramTypes = new Class [ 2 ] ;
Class < ? > componentType = field . getClass ( ) . getComponentType ( ) ;
protected QuestInfo questInfo = new QuestInfo ( ) ;
addOffer ( "str" ) ;
if ( ! player . hasQuest ( QUEST_SLOT ) | | ! player . getQuest ( QUEST_SLOT , 0 ) . equals ( "str" ) ) {
if ( ! player . hasQuest ( QUEST_SLOT ) | | ! player . getQuest ( QUEST_SLOT , 0 ) . equals ( "str" ) ) {
if ( player . hasQuest ( QUEST_SLOT ) & & player . getQuest ( QUEST_SLOT , 0 ) . equals ( "str" ) ) {
private static Logger logger = Logger . getLogger ( KilledInSumForQuestCondition . class ) ;
if ( mute | | devices = = null | | devices . size ( ) = = 0 )
ConversationStates . QUEST_OFFERED , "str" +
npc . say ( "str" ) ;
addQuest ( "str" ) ;
"str" + killsnumb +
assertEquals ( "str" + monstersType + "str" , getReply ( npc ) ) ;
"str" + killsnumb +
"str" + killsnumb +
enemyForces . put ( "str" ,
enemyForces . put ( "str" ,
enemyForces . put ( "str" ,
enemyForces . put ( "str" ,
enemyForces . put ( "str" ,
enemyForces . put ( "str" ,
enemyForces . put ( "str" ,
enemyForces . put ( "str" ,
enemys . put ( "str" ,
enemys . put ( "str" ,
enemys . put ( "str" ,
enemys . put ( "str" ,
enemys . put ( "str" ,
enemys . put ( "str" ,
enemys . put ( "str" ,
enemys . put ( "str" ,
"str" + enemyForces . get ( monstersType ) . first ( ) +
npc . say ( "str" + monsters + "str" ) ;
assertTrue ( cmd . hasError ( ) ) ;
player . setQuest ( "str" , "str" ) ;
KilledInSumForQuestCondition . class ) ;
final String creatureName = tokens . get ( i * 5 ) ;
+ "str" + i * 5 ) ;
if ( defaultSpell ! = null ) {
Entity entityFromTargetName = EntityHelper . entityFromTargetName ( "str" , player ) ;
while ( ! mEndOfStream & & numSamplesReadPerChannel < outputNumSamplesPerChannel )
logger . debug ( ex , ex ) ;
if ( ( layers . getCollisionDetection ( ) ! = null ) & & layers . getCollisionDetection ( ) . collides ( ( int ) point2 . getX ( ) , ( int ) point2 . getY ( ) ) ) {
logger . debug ( "str" + parent + "str" + baseItemId + "str" + slotName
private Class < ? > implementationClass ;
this . implementationClass = ( Class < ? > ) Class . forName ( clazzName ) ;
public Class < ? > getImplementationClass ( ) {
return DamageType . valueOf ( type . toUpperCase ( ) ) ;
private DamageType damageType = DamageType . CUT ;
return ( getSoloKill ( creature ) + getSharedKill ( creature ) - solo - shared ) ;
teleRules . disallowOut ( x , y , width , height ) ;
Rectangle r = new Rectangle ( 0 , 0 , Integer . MAX_VALUE , Integer . MAX_VALUE ) ;
| | enoun . endsWith ( "str" ) | | enoun . endsWith ( "str" )
Logger . getLogger ( DamageType . class ) . error ( "str" + type ) ;
return StendhalCursor . UNKNOWN ;
if ( ! checkEntityIsDomesticAnimal ( player , entity ) ) {
+ "str" ) ;
npc . add ( ConversationStates . QUESTION_1 , ConversationPhrases . YES_MESSAGES ,
public boolean loadSound ( String name , String fileURI , Type fileType , boolean enableStreaming ) ;
public boolean loadSound ( String name , String fileURI , Type fileType , boolean enableStreaming ) {
"str" + this + "str" + at ) ;
if ( args . size ( ) < 4 ) {
if ( args . size ( ) < 3 ) {
} else if ( args . get ( 3 ) . equals ( "str" ) ) {
return new LevelCheckingPortal ( Integer . parseInt ( args . get ( 4 ) ) , Integer . parseInt ( args . get ( 5 ) ) , rejectMessage ) ;
logger . debug ( "str" + entity ) ;
throw new IllegalArgumentException ( "str" + basecode ) ;
shops . add ( "str" , "str" , 10 ) ;
assertNotNull ( "str" , loaded ) ;
assertEquals ( "str" , getReply ( npc1 ) ) ;
out . println ( "str" ) ;
AudibleArea area = new AudibleCircleArea ( new float [ ] { ( float ) x , ( float ) y } , radius / 2 , radius ) ;
public BackgroundMusicSource ( String sound , int radius , int volume ) {
source = new BackgroundMusicSource ( getSound ( ctx ) , getRadius ( ctx ) , getVolume ( ctx ) ) ;
if ( SoundMaster . USE_NEW_SOUND_SYSTEM ) {
for ( int x = 0 ; x < tileLayer . getWidth ( ) ; x + + ) {
params . put ( "str" , ( int ) instance . getKarma ( ) ) ;
String mySoundName = soundName . replaceAll ( "str" , "str" ) . replaceAll ( "str" , "str" ) . replaceAll ( "str" , "str" ) ;
if ( tmpX < sw ) {
new GameEvent ( player . getName ( ) , "str" , animal . getRPClass ( ) . getName ( ) , animal . getTitle ( ) ) . raise ( ) ;
screen . addText ( x , y , text , type , isTalking ) ;
if ( ( hairnumber > = 50 ) & & ( hairnumber < 94 ) ) {
final GregorianCalendar notXmas = new GregorianCalendar ( 2010 , Calendar . JANUARY , 6 ) ;
logger . error ( "str" , e ) ;
public static final boolean USE_NEW_SOUND_SYSTEM = Boolean . parseBoolean ( System . getProperty ( "str" , "str" ) ) ;
"str" , null ) ;
SignalProcessor . createChain ( mInterruptor , this , mGlobalVolume , mDirectedSound , mOutput ) ;
price = price + "str" ;
npc . say ( "str" ) ;
tmpy + = zone . getHeight ( ) ;
assertThat ( ring . describe ( ) , is ( "str" ) ) ;
assertThat ( ring . describe ( ) , is ( "str" ) ) ;
"str" + type + "str" ) ;
npc . say ( "str" + Grammar . quantityplnoun ( quantity , item . getName ( ) ) + "str" ) ;
assertThat ( george . getTradescore ( ) , is ( 0 ) ) ;
alter . put ( "str" , "str" ) ;
private static final double FEE_BONUS_CONSTANT = 10 ;
public static float EPSILON = 0.0000001f ;
} else if ( other instanceof ExpressionMatcher ) {
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npcXin ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertThat ( "str" , getReply ( barMaid ) , is ( "str" ) ) ;
assertThat ( "str" , getReply ( barMaid ) , is ( "str" ) ) ;
assertThat ( "str" , getReply ( barMaid ) , is ( "str" ) ) ;
assertThat ( "str" , getReply ( barMaid ) , is ( "str" ) ) ;
assertThat ( "str" , getReply ( barMaid ) , is ( "str" ) ) ;
assertThat ( "str" , getReply ( barMaid ) , is ( "str" ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
assertEquals ( "str" , getReply ( npc ) ) ;
final String playerName = sentence . getOriginalText ( ) . substring ( "str" . length ( ) ) . trim ( ) ;
html . append ( "str" ) ;
price = price + "str" ;
price = price + "str" ;
new NotCondition ( behaviour . getTransactionCondition ( ) ) ) ;
behaviour . getTransactionCondition ( ) ) ;
public ChatCondition getTransactionCondition ( ) {
new NotCondition ( behaviour . getTransactionCondition ( ) ) ) ;
behaviour . getTransactionCondition ( ) ) ;
assertEquals ( "str" , getReply ( npcGhost ) ) ;
getReply ( npcGhost ) ) ;
assertEquals ( "str" , getReply ( npcGhost ) ) ;
assertEquals ( "str" , getReply ( npcGhost ) ) ;
sbuf . append ( getY ( ) ) ;
TurnNotifier . get ( ) . notifyInSeconds ( DAYS_TO_OFFER_EXPIRE_WARNING_DELAY * MathHelper . SECONDS_IN_ONE_DAY , offerExpireWarner ) ;
TurnNotifier . get ( ) . notifyInSeconds ( ( DAYS_TO_OFFER_EXPIRING_AFTER_WARNING + DAYS_TO_OFFER_EXPIRE_WARNING_DELAY ) * MathHelper . SECONDS_IN_ONE_DAY , offerExpirer ) ;
TurnNotifier . get ( ) . notifyInSeconds ( ( DAYS_TO_OFFER_EXPIRING_AFTER_WARNING + DAYS_TO_OFFER_EXPIRE_WARNING_DELAY + DAYS_TO_OFFER_GETTING_REMOVED_COMPLETELY ) * MathHelper . SECONDS_IN_ONE_DAY , offerRemover ) ;
add ( ConversationStates . ATTENDING , "str" , null , ConversationStates . ATTENDING , null , new ShowOffersChatAction ( ) ) ;
new SetQuestAction ( QUEST_SLOT , "str" ) ) ;
offersMessage . append ( "str" ) ;
if ( line . matches ( "str" ) ) {
add ( ConversationStates . ATTENDING , "str" , null , null , ConversationStates . ATTENDING , null , new PrepareOfferChatAction ( ) ) ;
final int sx = srect . x + srect . width - ICON_OFFSET ;
classLoader . loadClass ( "str" ) ;
final Token token = ( Token ) SingletonRepository . getEntityManager ( ) . getItem ( "str" ) ;
tokenTypes = Arrays . asList ( "str" , "str" ) ;
james . addReply ( Arrays . asList ( "str" , "str" , "str" , "str" ) ,
result . remove ( result . iterator ( ) . next ( ) ) ;
result . remove ( result . iterator ( ) . next ( ) ) ;
super . onPutOnGround ( false ) ;
npc . addJob ( "str" ) ;
npc . say ( board . getPlayers ( ) . get ( 0 ) + "str" + player . getName ( ) + "str" ) ;
logger . warn ( "str"
if ( ! this . hasSlot ( EXPIRED_OFFERS_SLOT_NAME ) ) {
if ( offer . getOfferer ( ) . equals ( offerer . getName ( ) ) ) {
if ( lastPlayerAdded + 60000 < System . currentTimeMillis ( ) ) {
TurnNotifier . get ( ) . notifyInTurns ( DAYS_TO_OFFER_EXPIRING_AFTER_WARNING + DAYS_TO_OFFER_EXPIRE_WARNING_DELAY + DAYS_TO_OFFER_GETTING_REMOVED_COMPLETELY * MathHelper . SECONDS_IN_ONE_DAY , offerRemover ) ;
if ( board [ xIndex ] [ yIndex ] = = null ) {
board = new BoardToken [ 3 ] [ 3 ] ;
if ( ! token . getName ( ) . equals ( board . getCurrentTokenType ( ) ) ) {
} else if ( sentence . getExpressions ( ) . iterator ( ) . next ( ) . toString ( ) . equals ( "str" ) ) {
npc . setPosition ( 89 , 106 ) ;
logger . error ( "str" + zone + "str" + this ) ;
logger . error ( "str" + name + "str" + object ) ;
logger . error ( "str" + name + "str" + object ) ;
. loadFromPath ( "str" ) ;
final String path = "str" + clazz + "str" + subClass
dump ( transaction ) ;
logger . warn ( "str" + object . get ( "str" ) + "str" + object ) ;
assertEquals ( startTurn + 1 , TurnNotifier . get ( ) . getCurrentTurnForDebugging ( ) ) ;
groundPanel . setSize ( stendhal . screenSize ) ;
+ Grammar . quantityplnounWithHash ( amount , entity . getTitle ( ) ) + "str" ) ;
+ "str" , npc . getText ( ) ) ;
+ System . getProperty ( "str" , "str" ) + "str"
final String [ ] tokens = ( questString + "str" ) . split ( "str" ) ;
private static final int ARC_DIAMETER = 2 * MARGIN_WIDTH + 2 ;
timeSinceChecked = 2 * TAX_CHECKING_PERIOD * 1000 ;
logger . debug ( "str" ) ;
logger . debug ( "str" ) ;
debug ( "str" ) ;
debug ( "str" ) ;
debug ( "str" ) ;
npc . say ( "str"
assertEquals ( wc . firstAskForMissingItems ( wc . getNeededItems ( ) ) , npc . get ( "str" ) ) ;
if ( creature . getLevel ( ) < = magiclevel & & ! creature . isRare ( ) ) {
client = this ;
logger . warn ( "str"
logger . warn ( "str"
String msg = "str" ;
private static final Color COLOR_BACKGROUND = new Color ( 0.8f , 0.8f , 0.8f ) ;
npc . say ( "str" ) ;
addOffer ( "str" ) ;
addJob ( "str" ) ;
addHelp ( "str" ) ;
"str" , null ) ;
"str" , null ) ;
addJob ( "str" ) ;
addQuest ( "str" ) ;
postman . sendPrivateText ( "str" + ( ( RPEntity ) entity ) . getName ( ) + "str"
postman . sendPrivateText ( "str" + ( ( RPEntity ) entity ) . getName ( ) + "str"
postman . sendPrivateText ( "str" + ( ( RPEntity ) entity ) . getName ( ) + "str"
System . err . println ( "str"
if ( ! nextTo ( player ) | | ! player . isZoneChangeAllowed ( ) ) {
public boolean isZoneChangeAllowed ( ) {
"str" , null ) ;
} else if ( mininps ) {
} else if ( mininps ) {
if ( ( player = = null ) | | player . isDisconnected ( ) ) {
if ( player ! = null ) {
if ( ( player ! = null ) & & ( ! player . isDisconnected ( ) ) ) {
addHelp ( "str" ) ;
final Item item2 = addPersistentItem ( "str" , zone , 11 , 9 ) ;
weapon2 . put ( "str" , 6 ) ;
for ( final String playerSays : Arrays . asList ( "str" , "str" , "str" , "str" ) ) {
for ( final String playerSays : Arrays . asList ( "str" , "str" , "str" , "str" ) ) {
shape . setRect ( 88 , 77 , 112 - 88 + 1 , 94 - 77 + 1 ) ;
maxX = creature . getX ( ) + 2 + ( int ) ( creature . getWidth ( ) ) ;
maxY = creature . getY ( ) + 2 + ( int ) ( creature . getHeight ( ) ) ;
| | creature . getZone ( ) . collides ( creature , creature . getX ( ) + currentDir . getdx ( ) ,
& & ! creature . getZone ( ) . collides ( creature , creature . getX ( ) + currentDir . getdx ( ) ,
roll - = roll * karma ;
prop . put ( "str" , newVersion ) ;
text = "str" ;
text = "str" ;
text = "str" ;
logger . warn ( "str" + getZone ( ) . getName ( ) + "str" + getX ( ) + "str" + getY ( ) ) ;
logger . warn ( "str" + getZone ( ) . getName ( ) + getX ( ) + "str" + getY ( ) ) ;
sb . append ( "str" ) ;
sb . append ( bootProp . getProperty ( "str" , "str" ) ) ;
bootProp . put ( "str" , sb . toString ( ) ) ;
final String jarNameString = bootProp . getProperty ( "str" , "str" ) ;
bootProp . remove ( "str" ) ;
private List < Item > drops ;
for ( Item item : this . drops ) {
drops = new LinkedList < Item > ( ) ;
npc . say ( "str"
npc . say ( "str"
int ydiff = object . getInt ( "str" ) - Integer . parseInt ( Y_COORD ) ;
"str" , null ) ;
wishman . setPosition ( 30 , 28 ) ;
if ( view ! = null & & ! this . getParent ( ) . isMinimized ( ) ) {
logger . debug ( "str" + state ) ;
ConversationStates . ATTENDING ,
reward . add ( new IncreaseKarmaAction ( 10.0 ) ) ;
shops . add ( "str" , "str" , 10 ) ;
assertThat ( bob . getPrivateTextString ( ) , is ( "str" ) ) ;
player . sendPrivateText ( "str" ) ;
addGoodbye ( "str" ) ;
d = Direction . rand ( ) ;
public static String quoteHash ( String str ) {
dishwasher . addReply ( "str" , "str" ) ;
if ( player . hasQuest ( QUEST_SLOT ) & & player . getQuest ( QUEST_SLOT ) . startsWith ( "str" ) ) {
show ( e . getComponent ( ) , e . getX ( ) - 10 , e . getY ( ) - 10 ) ;
new CommandList ( entity . getType ( ) , actions , view ) . show ( e . getComponent ( ) , e . getX ( ) - 10 , e . getY ( ) - 10 ) ;
menu . show ( e . getComponent ( ) , e . getX ( ) - 10 , e . getY ( ) - 10 ) ;
processStep . add ( new DecreaseKarmaAction ( 100.0 ) ) ;
Logger . getLogger ( DeathMatchCreature . class ) . error ( this + "str" + damageReceived ) ;
creature . attack ( ) ;
return ! ( creature . squaredDistance ( creature . getAttackTarget ( ) ) > 50 | | creature . getZone ( ) . collidesOnLine ( creature . getX ( ) ,
screen . drawInScreen ( sprite , x - screen . getScreenViewX ( ) , y - screen . getScreenViewY ( ) ) ;
if ( ! ( user ! = null & & user . isGhostMode ( ) )
logger . warn ( "str" + parent + "str" + baseItemId + "str" + slotName
+ "str" ) ;
StendhalUI . get ( ) . addEventLine ( "str" + params [ 2 ] ) ;
assertEquals ( "str" , clientUI . getEventBuffer ( ) ) ;
CommandCenter . register ( "str" , wrap , 800 ) ;
assertEquals ( "str" , clientUI . getEventBuffer ( ) ) ;
StendhalUI . get ( ) . addEventLine ( "str" + params [ 0 ] ) ;
public final void testWordEntry ( ) {
new QuestNotCompletedCondition ( QUEST_SLOT ) ,
logger . warn ( "str" + this ) ;
logger . warn ( "str" + this ) ;
logger . warn ( "str" ) ;
logger . warn ( "str" ) ;
logger . warn ( "str" ) ;
logger . warn ( "str" ) ;
logger . warn ( "str" ) ;
logger . warn ( "str" ) ;
if ( obj = = null ) {
+ "str" ) ;
"str" + Integer . toString ( house ) ,
"str" + Integer . toString ( house ) ,
"str" + Integer . toString ( house ) ,
& & sentence . getTriggerExpression ( ) . matches ( trigger ) ;
return ( state = = this . state ) & & trigger . matches ( this . trigger ) ;
return ( state = = this . state ) & & trigger . matchesNormalized ( this . trigger ) ;
Arrays . asList ( "str" , "str" ) , null ,
Arrays . asList ( "str" , "str" ) , null ,
Arrays . asList ( "str" , "str" ) , null ,
assertEquals ( "str" , npc . get ( "str" ) ) ;
assertEquals ( "str" , npc . get ( "str" ) ) ;
npc . addReply ( "str" , "str" ) ;
new IllegalArgumentException ( "str" ) ) ;
npc . add ( ConversationStates . QUESTION_1 , Arrays . asList ( "str" , "str" , "str" ) , null ,
npc . setPosition ( 4 , 17 ) ;
private void addHealer ( final SpeakerNPC npc , int cost ) {
while ( first . isQuestion ( ) & & it . hasNext ( ) ) {
return ctx . getInt ( "str" , LevelCheckingPortal . DEFAULT_MIN ) ;
String itemName = remainder ;
assertTrue ( player . isQuestCompleted ( "str" ) ) ;
assertTrue ( player2 . isQuestCompleted ( "str" ) ) ;
import games . stendhal . server . maps . semos . guardhouse . RetiredAdventurerNPC ;
return ( player . hasQuest ( questname ) & & ! player . isQuestInState ( questname , "str" ) & & ! player . isQuestCompleted ( questname ) ) ;
protected Set < String > playersToReward ;
playersToReward = new HashSet < String > ( ) ;
playersToReward = new HashSet < String > ( ) ;
playersToReward . add ( ( ( Player ) player ) . getName ( ) ) ;
addReply ( "str" , "str" ) ;
assertEquals ( "str" , npc . get ( "str" ) ) ;
new SetQuestAndModifyKarmaAction ( QUEST_SLOT , "str" , - 10.0 ) ) ;
player . drop ( "str" ) ;
ProducerBehaviour behaviour = new ProducerBehaviour ( "str" , "str" , "str" ,
super ( object , "str" + name + "str" , "str" + name + "str" , "str" , 1 , 1 , 1 ) ;
super ( "str" + name + "str" , "str" + name + "str" , "str" , 1 , 1 , 1 ) ;
public GrowingPassiveEntityRespawnPoint ( RPObject object , String type , String itemName ,
super ( object , itemName , GROWING_RATE ) ;
public GrowingPassiveEntityRespawnPoint ( String type , String itemName , String actionName ,
super ( itemName , GROWING_RATE ) ;
super ( object , "str" , "str" , "str" , RIPE , 1 , 2 ) ;
super ( "str" , "str" , "str" , RIPE , 1 , 2 ) ;
if ( player . hasQuest ( QUEST_SLOT ) ) {
assertThat ( player . getQuest ( "str" ) . split ( "str" ) [ 0 ] , not ( containsString ( "str" ) ) ) ;
assertEquals ( "str" , npc . get ( "str" ) ) ;
assertThat ( player . getQuest ( "str" ) . split ( "str" ) [ 1 ] , not ( containsString ( "str" ) ) ) ;
assertThat ( player . getQuest ( "str" ) . split ( "str" ) [ 1 ] , containsString ( "str" ) ) ;
assertThat ( player . getQuest ( "str" ) . split ( "str" ) [ 1 ] , not ( containsString ( "str" ) ) ) ;
assertThat ( player . getQuest ( "str" ) . split ( "str" ) [ 1 ] , containsString ( "str" ) ) ;
assertThat ( player . getQuest ( "str" ) , not ( containsString ( "str" ) ) ) ;
assertThat ( player . getQuest ( "str" ) , is ( "str" ) ) ;
private static final String RPCLASS_NAME = "str" ;
String targetString = action . get ( TARGET ) ;
addHelp ( "str" ) ;
if ( ! it1 . hasNext ( ) & & ! it2 . hasNext ( ) ) {
package games . stendhal . server . maps . semos . city ;
npc . addGreeting ( "str" ) ;
npc . addHelp ( "str" ) ;
reply = reply + "str" ;
npcs . remove ( object ) ;
player . sendPrivateText ( "str" ) ;
return "str" + level + "str" ;
return "str" + level + "str" ;
buildFisherman ( zone , attributes ) ;
private void buildFisherman ( StendhalRPZone zone , Map < String , String > attributes ) {
buildTeacher ( zone , attributes ) ;
private void buildTeacher ( StendhalRPZone zone , Map < String , String > attributes ) {
String msg = "str" ;
Item entity = removeFromWorld ( player ) ;
ItemLogger . equipAction ( player , entity , srcInfo , dest . getLogInfo ( ) ) ;
public Item removeFromWorld ( Player player ) {
logger . error ( "str" + itemLocation + "str" + entry ) ;
if ( ! DatabaseFactory . getDatabase ( ) . getCharacters ( trans , "str" ) . isEmpty ( ) ) {
if ( ! DatabaseFactory . getDatabase ( ) . getCharacters ( trans , "str" ) . isEmpty ( ) ) {
if ( chr < "str" | | chr > "str" ) {
if ( this . name = = null | | ! this . name . equals ( name ) ) {
private static final int MAX_ZONE_NPCS = 50 ;
if ( this . error = = null ) {
logger . error ( copy . getName ( ) + "str" + itemType ) ;
if ( killerRPEntity . drop ( oldItemType ) ) {
if ( getZone ( ) . has ( attending . getID ( ) ) & & nextTo ( attending ) ) {
fail ( "str" + access . getError ( ) ) ;
UpdateGUIDialogs . messageBox ( "str" ) ;
UpdateGUIDialogs . messageBox ( "str"
UpdateGUIDialogs . messageBox ( "str"
assertTrue ( npc . get ( "str" ) . startsWith ( "str" ) ) ;
int pos = quest ! = null ? quest . indexOf ( "str" ) : - 1 ;
if ( brideName = = null ) {
if ( brideName = = null ) {
logger . error ( player . getName ( ) + "str" + slot + "str" + parent + "str" + player . getZone ( ) + "str" + parent . getZone ( ) ) ;
import games . stendhal . common . NotificationType ;
import games . stendhal . server . entity . npc . condition . QuestStateStartsWithCondition ;
new QuestStateStartsWithCondition ( QUEST_SLOT , "str" ) ,
public void makeNoise ( ) {
creature . makeNoise ( ) ;
new OrCondition ( new QuestInStateCondition ( QUEST_SLOT , "str" ) , new QuestInStateCondition ( QUEST_SLOT , "str" ) ) ,
public class LootableSlot extends EntitySlot {
ZARAS ( "str" ) ;
} catch ( RuntimeException e ) {
logger . debug ( method ) ;
logger . debug ( "str" + name ) ;
logger . warn ( caster + "str" + type ) ;
long expireDelay = 60 * 60 * 24 * 7 * 1000 ;
long expireDate = System . currentTimeMillis ( ) + ( 1000L * 60L * minutes ) ;
long delay = 60 * 60 * 24 * 1000 ;
long expireDelay = 60 * 60 * 24 * 7 * 1000 ;
player . sendPrivateText ( "str" + entity . getDescriptionName ( true ) + "str" ) ;
RPSlot slot = getSlot ( equippedItem . slot ) ;
Item item = manager . getItem ( equippedItem . name ) ;
( ( StackableItem ) item ) . setQuantity ( equippedItem . quantity ) ;
if ( ( item ! = null ) & & isItemBelowOtherPlayer ( ) ) {
npc . addGreeting ( "str" ) ;
addProducer ( mixerBehaviour , "str" ) ;
npc . addProducer ( mixerBehaviour , "str" ) ;
private String badPasswordReason ;
logger . debug ( "str" + text ) ;
logger . debug ( "str" + speakerNPC . get ( "str" ) ) ;
return ! ( player . isQuestCompleted ( QUEST_SLOT ) | | ( player . hasQuest ( QUEST_SLOT ) & & player . getQuest ( QUEST_SLOT ) . equals ( "str" ) ) ) ;
logger . warn ( "str" + existing + "str" + state + "str" + trigger + "str" + nextState + "str" + condition + "str" ) ;
teleport . put ( "str" , remainder ) ;
String [ ] names = matcher . group ( 1 ) . split ( "str" ) ;
String [ ] words = text . split ( "str" ) ;
stake = Integer . parseInt ( words [ 1 ] ) ;
String [ ] strwords = playerChatText . getText ( ) . split ( "str" ) ;
String [ ] words = text . split ( "str" ) ;
String [ ] words = text . split ( "str" ) ;
String [ ] words = text . split ( "str" ) ;
String [ ] words = text . split ( "str" ) ;
amount = Integer . parseInt ( words [ 1 ] ) ;
item = words [ 2 ] . toLowerCase ( ) ;
item = words [ 1 ] . toLowerCase ( ) ;
String [ ] words = text . split ( "str" ) ;
amount = Integer . parseInt ( words [ 1 ] ) ;
item = words [ 2 ] . toLowerCase ( ) ;
item = words [ 1 ] . toLowerCase ( ) ;
String [ ] words = text . split ( "str" ) ;
item = words [ words . length - 1 ] . toLowerCase ( ) ;
String [ ] words = text . split ( "str" ) ;
amount = Integer . parseInt ( words [ 1 ] ) ;
"str" ) . split ( "str" ) ;
String [ ] words = text . split ( "str" ) ;
& & ! words [ 2 ] . toLowerCase ( ) . equals (
amount = Integer . parseInt ( words [ 1 ] ) ;
player . addAttribute ( "str" , Type . FLAG ) ;
player . heal ( ( ( ConsumableItem ) item . splitOff ( 1 ) ) . getAmount ( ) , true ) ;
if ( ! ( entity instanceof Item ) | | ( entity = = null ) ) {
logger . debug ( "str" + clazz ) ;
+ Grammar . quantityplnoun ( - amount ,
for ( String buddyName : buddies ) {
Player buddy = StendhalRPRuleProcessor . get ( ) . getPlayer ( buddyName ) ;
player . notifyOffline ( buddyName ) ;
new Destination ( "str" , 22 , 75 ) ,
addJob ( "str" ) ;
addOffer ( "str" ) ;
} else if ( destinationZone . equals ( "str" ) ) {
int actualDamage = Math . round ( Math . max ( 1 , attack - defense ) ) ;
logger . debug ( path ) ;
engine . say ( "str" ) ;
engine . say ( "str" ) ;
npc . setEntityClass ( "str" ) ;
npc . setEntityClass ( "str" ) ;
npc . setEntityClass ( "str" ) ;
npc . setEntityClass ( "str" ) ;
return "str" + getQuantity ( ) + "str" ;
npc = new CherubNPC ( "str" , 48 , 60 ) ;
npc = new CherubNPC ( "str" , 105 , 17 ) ;
npc = new CherubNPC ( "str" , 105 , 79 ) ;
npc = new CherubNPC ( "str" , 95 , 30 ) ;
npc = new CherubNPC ( "str" , 47 , 27 ) ;
npc = new CherubNPC ( "str" , 16 , 3 ) ;
npc = new CherubNPC ( "str" , 67 , 24 ) ;
private long soundWait ;
private CreatureLogic creatureLogic ;
private String urlString ;
private HttpURLConnection connection ;
private InputStream is ;
private ProgressListener progressListener ;
private boolean tryVeryHard ;
protected String name ;
private String questString ;
private StendhalRPZone zone ;
private Area arena ;
private DeathmatchInfo deathmatchInfo ;
private PlayerSheepManager playerSheepManager ;
private PlayerPetManager playerPetManager ;
private int pushCounter ;
private Banks bank ;
private String gameServer ;
public int healAmount ;
private Script script ;
private String classname ;
protected ScriptingSandbox sandbox ;
private IRPZone zone ;
private Shape shape ;
private Player admin ;
private int counter ;
private TreeNode nodeGoal ;
private TreeNode nodeStart ;
private TreeNode nodeBest ;
private Entity owner ;
instance = new BankAccessorManager ( ) ;
private static LoginNotifier instance ;
private int m_stepCounter ;
private static long lastShoutTime ;
private String cryForHelp ;
protected static int XP ;
card = "str" ;
private String filename ;
private String type ;
private String version ;
private WikipediaAccess access ;
private SpeakerNPC npc ;
private TokenMoveListener tokenMoveListener ;
private long soundWait ;
protected ScriptingNPC npc ;
protected String winner ;
private DeathmatchLifecycle lifecycleState ;
private int level ;
private long date ;
private static boolean ShowWorld ;
private static StendhalPlayerDatabase playerDatabase ;
private Player player ;
private SpeakerNPC speakerNPC ;
private int maxState ;
private static ClientGameConfiguration instance ;
private static TurnNotifier instance ;
private static GameObjects instance ;
private String slotName ;
private Player player ;
private String title ;
private boolean isContent ;
private boolean finished ;
private String error ;
private static final String ZONE_CONTENT = "str" ;
private String privateText ;
private Area area ;
private SpeakerNPC . ChatCondition condition ;
private String questname ;
private String questname ;
private String questname ;
private String questname ;
private String questname ;
private String state ;
private String questname ;
private String state ;
private String questname ;
private String state ;
private Map < String , QuestInfo > questInfos ;
private String classname ;
private String filename ;
private PrintStream ps ;
private long lastTimestamp ;
FIRST_DEATH ( "str" ) ,
private Engine engine ;
private SpeakerNPC speakerNPC ;
amount = 1 ;
ConversationStates . ATTENDING , "str" ,
amount = 1 ;
ConversationStates . ATTENDING , "str" ,
ConversationStates . ATTENDING , null ,
ConversationStates . ATTENDING , null ,
engine . add ( ConversationStates . IDLE , ConversationPhrases . GREETING_MESSAGES ,
engine . add ( ConversationStates . ATTENDING , behaviour . getProductionActivity ( ) ,
ConversationStates . ATTENDING , null ,
amount = 1 ;
ConversationStates . ATTENDING , null ,
ConversationStates . ATTENDING , null ,
engine . add ( ConversationStates . IDLE , ConversationPhrases . GREETING_MESSAGES ,
private int sizeOfLastFiles ;
private JPanel contentPane ;
private JProgressBar progressBar ;
private static List < String > adminNames ;
private Dimension prefferedSize ;
private boolean scrollingStarted ;
private String filename ;
private int counter ;
private int textCounter ;
private boolean beamed ;
private int counter ;
public static final boolean EMULATE_PERCEPTION_LOSS = false ;
public static boolean SHOW_LIST_SIZES ;
private int i ;
private RPEntity master ;
private Sprite [ ] hairs ;
private Sprite [ ] heads ;
private Sprite [ ] bodies ;
private Sprite [ ] clothes ;
private int heads_index ;
private int bodies_index ;
private int clothes_index ;
private Timer timer ;
private static StendhalClient client ;
private int contentToLoad ;
private JFrame jFrame ;
private JSplitPane jSplitPane ;
private JScrollPane jScrollPane ;
private FileTree jTree ;
private JPanel jPanel ;
private ImageViewerSwing imageViewerSwing ;
private ImageViewerSwing imageViewerSwing1 ;
private ImageViewerSwing imageViewerSwing2 ;
private ImageViewerSwing imageViewerSwing3 ;
private ImageViewerSwing imageViewerSwing4 ;
private AnimationRunner [ ] animations ;
private String jarFolder ;
private Properties bootProp ;
private String serverFolder ;
private Properties updateProp ;
private UpdateProgressBar updateProgressBar ;
protected long lastPerceptionTimestamp ;
private SpeakerNPC npc ;
private boolean clear ;
private static User _instance ;
protected Postman postman ;
protected long lastPerceptionTimestamp ;
private ScriptingSandbox sandbox ;
private Player player ;
soundArray = Sound . soundArray ;
private ScriptRecorder recorder ;
if ( ! "str" . equals ( name ) ) {
private StendhalRPZone zone ;
private Area arena ;
private DeathmatchInfo deathmatchInfo ;
private int quantity ;
private Shape arena ;
private Player player ;
protected String [ ] moveSounds ;
protected boolean inAdd ;
private StendhalRPZone zone ;
private ArrayList < StendhalRPZone > zones ;
private SpeakerNPC speakerNPC ;
private int turnToThink ;
private StringBuilder dumpedTable ;
public static boolean doLogin ;
public static String STENDHAL_FOLDER ;
private String pathSep ;
private String jarFolder ;
private Properties bootProp ;
private Properties bootPropOrg ;
private String className ;
private String [ ] args ;
int res = JOptionPane . showConfirmDialog ( null , "str" ,
private JPanel jContentPane ;
private JPanel jPanel ;
private JProgressBar jProgressBar ;
private JButton jButton ;
private JButton jButton1 ;
private JEditorPane jEditorPane ;
private int signcounter ;
Class < ? > clazz = Class . forName ( "str" ) ;
Class < ? > clazz = classLoader . loadClass ( "str" ) ;
Class < ? > clazz = classLoader . loadClass ( className ) ;
Class < ? > clazz = Class . forName ( className ) ;
return targets . contains ( entity . getID ( ) ) ;
npc . put ( "str" , "str" ) ;
npc . say ( "str" + text + "str" ) ;
if ( ! hasKilledSolo ( name ) ) {
assertEquals ( "str" , mo . toString ( ) ) ;
for ( RPEntity zentity : getZone ( ) . getPlayerAndFriends ( ) ) {
return ( zone . getPlayerAndFriends ( ) . size ( ) = = 0 ) ;
return zone . getPlayerAndFriends ( ) ;
enemyList = zone . getPlayerAndFriends ( ) ;
public List < RPEntity > getPlayerAndFriends ( ) {
public static boolean SHOW_LIST_SIZES = false ;
logger . error ( "str" , e ) ;
logger . error ( "str" ) ;
public void fillRPAction ( RPAction action ) {
xp [ 2 ] = 100 ;
return ( path ! = null ) ? path . getNodeList ( ) : null ;
return ( path ! = null ) ? path . isLoop ( ) : false ;
if ( nextTo ( player , 0.25 ) ) {
if ( nextTo ( player , 0.25 ) ) {
if ( nextTo ( player , 0.25 ) ) {
logger . debug ( "str" + slotName + "str" + px + "str" + py + "str" + ix + "str" + iy + "str" + orig ) ;
logger . debug ( "str" ) ;
HealingSpell ( String name , Map < String , String > attributes ) {
int res = JOptionPane . showConfirmDialog ( null , "str" ,
ProducerBehaviour behaviour = new ProducerBehaviour ( "str" , "str" , "str" ,
private static final int HEIGHT = 180 ;
private GameButtonHelper gbh ;
ui . addWindow ( buywindow ) ;
gbh = new GameButtonHelper ( this , StendhalUI . get ( ) ) ;
ui . addWindow ( gbh ) ;
player . getSlot ( "str" ) . add ( new RPObject ( ) ) ;
String playername = p . getName ( ) ;
private static final String [ ] ITEMS = { "str" , "str" , "str" , "str" , "str" , "str" ,
private static final String [ ] ITEMS_2 = { "str" , "str" , "str" , "str" , "str" ,
player . removeKill ( "str" ) ;
& & player . hasKilled ( "str" ) ) {
super ( item ) ;
public static final String VERSION = "str" ;
logger . debug ( "str" + filename + "str" + ( gid ) + "str" + ( gid + amount ) ) ;
logger . debug ( "str" + name ) ;
private static final double SERVER_DROP_GENEROSITY = 1 ;
chest . addRPSlot ( "str" , 30 ) ;
"str" , null ) ;
"str" , null ) ;
SpeakerNPC npc1 = new SpeakerNPC ( "str" ) {
addHelp ( "str" ) ;
plantGrower = new VegetableGrower ( "str" ) ;
if ( ( Math . abs ( dvx ) > ( sw / 2 ) ) | | ( Math . abs ( dvy ) > ( sh / 2 ) ) ) {
int creatureCount = 1 ;
setDEFXP ( def_xp ) ;
private static int LEVELS = 480 ;
if ( Math . abs ( screenx - x ) > 15 | | Math . abs ( screeny - y ) > 15 ) {
logger . debug ( "str" + layer . getName ( ) + "str" + width + "str" + height ) ;
logger . debug ( "str" + e . getMessage ( ) + "str" ) ;
map . put ( ActiveEntity . STATE_UP ,
map . put ( ActiveEntity . STATE_RIGHT ,
map . put ( ActiveEntity . STATE_DOWN ,
map . put ( ActiveEntity . STATE_LEFT ,
if ( ! parent . hasSlot ( slot ) ) {
. sendPrivateText ( "str" ) ;
quotes . put ( "str" , "str" ) ;
StendhalRPZone zone = ( StendhalRPZone ) StendhalRPWorld . get ( ) . getRPZone ( player . getID ( ) ) ;
npc . say ( "str" + MAX_STAKE + "str" ) ;
super ( object , "str" , "str" , RIPE , 1 , 2 ) ;
super ( "str" , "str" , RIPE , 1 , 2 ) ;
player . teleport ( islandDocksZone , 16 , 89 , Direction . LEFT , null ) ;
Dimension minimumSize = new Dimension ( 50 , 50 ) ;
logger . error ( "str" + actionsMap . get ( action ) . getClass ( ) + "str" + action + "str" + actionClass . getClass ( ) ) ;
CreateGuildAction . register ( ) ;
zone . add ( entity , player ) ;
c . insets = new Insets ( 4 , 4 , 4 , 4 ) ;
int xpEarn = ( int ) ( xpReward * ( ( float ) damageDone / ( float ) totalDamageReceived ) ) ;
engine . say ( "str" +
logger . info ( "str" + player . getName ( ) + "str" ) ;
engine . say ( "str" ) ;
npc . say ( "str" ) ;
if ( ! changed . equip ( slotName , item ) ) {
RPSlot slot = new LootableSlot ( this ) ;
static void loadFromPropertiesintoXML ( ) {
static void loadPropertiesFromXML ( ) {
logger . debug ( "str" + entity . get ( "str" ) + "str" + zone ) ;
entity . add ( "str" , RPClass . FLOAT ) ;
Log4J . startMethod ( logger , "str" ) ;
Log4J . finishMethod ( logger , "str" ) ;
Log4J . startMethod ( logger , "str" ) ;
Log4J . finishMethod ( logger , "str" ) ;
player . setMana ( newmana ) ;
private class PrivilegedBoot < T > implements PrivilegedAction < T > {
public PrivilegedBoot ( String className , String [ ] args ) {
AccessController . doPrivileged ( new PrivilegedBoot < Object > ( className , args ) ) ;
if ( ( ! has ( "str" ) | | getInt ( "str" ) = = 1 ) & & ( ! has ( "str" ) | | getInt ( "str" ) = = 1 ) ) {
if ( ( ! has ( "str" ) | | getInt ( "str" ) = = 1 ) & & ( ! has ( "str" ) | | getInt ( "str" ) = = 1 ) ) {
projectilesItem = attacker . getMissileIfNotHoldingOtherWeapon ( ) ;
Sprite sprite = store . getSprite ( "str" + name + "str" ) ;
height = diff . getDouble ( "str" ) ;
height = base . getDouble ( "str" ) ;
if ( player . getKeyedSlot ( "str" , zoneName ) = = null ) {
MessageCommand messageCommand = ( MessageCommand ) SlashCommandFactory . get ( "str" ) ;
MessageCommand messageCommand = ( MessageCommand ) SlashCommandFactory . get ( "str" ) ;
admin . sendPrivateText ( "str" ) ;
if ( clientid ! = - 1 ) {
logger . debug ( "str" + token ) ;
Log4J . finishMethod ( logger , "str" ) ;
String soundBase = prop . getProperty ( "str" , "str" ) ;
soundData = getData ( soundBase + filename ) ;
if ( deathmatchLifecycle . questString . equals ( questState ) ) {
return matchingTurns . get ( 0 ) - currentTurn ;
return ( getRemainingTurns ( turnListener , message ) * StendhalRPWorld . MILLISECONDS_PER_TURN ) / 1000 ;
database = ( StendhalPlayerDatabase ) StendhalPlayerDatabase . getDatabase ( ) ;
if ( ( shownSlot = = null ) | | ! shownSlot . equals ( rpslot ) ) {
import games . stendhal . server . config . CreaturesXMLLoader ;
List < DefaultCreature > creatures = CreaturesXMLLoader . get ( ) . load (
player . sendPrivateText ( "str" ) ;
player . sendPrivateText ( "str" ) ;
protected abstract boolean mayBeOpened ( Player user ) ;
if ( mayBeOpened ( ( Player ) user ) ) {
protected boolean mayBeOpened ( Player user ) {
if ( mayBeOpened ( null ) ) {
protected boolean mayBeOpened ( Player player ) {
say ( "str" ) ;
plantGrower . setDescription ( "str" ) ;
player . teleport ( islandDocksZone , 144 , 89 , Direction . LEFT , null ) ;
jessica . set ( 144 , 89 ) ;
SET_OUTFIT ( "str" , "str" ) ;
bootProp . put ( "str" , sb . toString ( ) ) ;
STOP_ATTACK ( "str" , "str" ) ,
entity . onAction ( StendhalClient . get ( ) , action , Integer . toString ( parent . getID ( ) . getObjectID ( ) ) , getName ( ) ) ;
URL url = Bootstrap . class . getClassLoader ( ) . getResource ( "str" ) ;
sb . append ( bootProp . getProperty ( "str" , "str" ) ) ;
bootProp . put ( "str" + Version . VERSION , sb . toString ( ) ) ;
String jarNameString = bootProp . getProperty ( "str" , "str" ) ;
public static final String VERSION = "str" ;
public static final String VERSION = "str" ;
if ( questLast ! = null & & ( new Date ( ) ) . getTime ( ) - Long . parseLong ( questLast ) > bailDelay ) {
defense = helmet . getInt ( "str" ) ;
if ( questLast ! = null & & ( new Date ( ) ) . getTime ( ) - Long . parseLong ( questLast ) > spawnDelay )
int currentLevel = Integer . parseInt ( questLevel ) ;
int k = Integer . parseInt ( questLevel ) ;
defense = helmet . getInt ( "str" ) ;
sandbox . privateText ( player , "str" ) ;
logger . info ( "str" + object ) ;
String msg = "str" + text + "str" + condition ;
assertEquals ( "str" , Grammar . plural ( "str" ) ) ;
String msg = "str" + t + "str" + object1 + "str" + object2 + "str" ;
if ( access . getText ( ) ! = null & & access . getText ( ) . length ( ) > 0 ) {
if ( zoneName . startsWith ( "str" ) & & ! zoneName . equals ( "str" )
TurnNotifier . get ( ) . notifyInTurns ( 5 * 60 * 3 , this , null ) ;
buttonMap . put ( "str" , new WtButton ( "str" , 150 , 30 , "str" ) ) ;
if ( name . equals ( "str" ) ) {
buttonMap . get ( "str" ) . setPressed ( false ) ;
buttonMap . get ( "str" ) . setPressed ( true ) ;
super ( "str" , j2DClient . SCREEN_WIDTH - 132 , 265 , 132 , 200 ) ;
if ( args . size ( ) < 2 ) {
addArea ( "str" ) ;
buildSemosTownhallAreaMayor ( ( StendhalRPZone ) world . getRPZone ( new IRPZone . ID (
private void buildSemosTownhallAreaMayor ( StendhalRPZone zone ) {
public static final String VERSION = "str" ;
public static final String VERSION = "str" ;
System . err . println ( "str" + urlString + "str" + "str" + e . toString ( ) ) ;
System . err . println ( "str" + urlString + "str" ) ;
return player . has ( "str" ) ;
sign . setText ( "str" ) ;
pos = Math . max ( temp . lastIndexOf ( "str" ) , temp . lastIndexOf ( "str" ) ) ;
TurnNotifier . get ( ) . notifyInTurns ( 1 , new FinishNotifier ( ) , null ) ;
if ( ( ! ( base instanceof EquipListener ) ) | | ( ! ( ( EquipListener ) base ) . canBeEquiped ( ) ) ) {
if ( Version . compare ( version , stendhal . VERSION ) > 0 ) {
public static final String VERSION = "str" ;
plantGrower . setDescription ( "str" ) ;
addHelp ( "str" ) ;
sign . setText ( "str" ) ;
sign . setText ( "str" ) ;
sign . setText ( "str" ) ;
sign . setText ( "str" ) ;
sign . setText ( "str" ) ;
sign . setText ( "str" ) ;
sign . setText ( "str" ) ;
sign . setText ( "str" ) ;
sign . setText ( "str" ) ;
addHelp ( "str" ) ;
engine . say ( "str" ) ;
engine . say ( "str" ) ;
loretta . setDescription ( "str" ) ;
"str" , null ) ;
addHelp ( "str" ) ;
if ( script ! = null ) {
String usage = "str" ;
text + = "str" + name1 + "str" ;
text + = "str" + name2 + "str" ;
text + = "str" ;
player1 . sendPrivateText ( "str" + name2 + "str" ) ;
String text = "str" + name + "str" ;
messages . storeToXML ( new FileOutputStream ( System . getProperty ( "str" ) + "str" ) , "str" ) ;
messages . storeToXML ( new FileOutputStream ( System . getProperty ( "str" ) + "str" ) , "str" ) ;
"str" + STAKE + "str" ,
item . setY ( getY ( ) + 1 ) ;
for ( int i = 0 ; i < 3 ; i + + ) {
portal . setX ( 14 + i ) ;
portal . setDestination ( "str" , 7 + i ) ;
portal . setDestination ( "str" , i ) ;
setEnabled ( true ) ;
portal . setDestination ( "str" , 10 ) ;
Item markedScroll = StendhalRPWorld . get ( ) . getRuleManager ( ) . getEntityManager ( ) . getItem (
npc . add ( 50 , "str" , null , 0 , "str" , null ) ;
npc . addReply ( "str" , "str" ) ;
addHelp ( "str" ) ;
say ( "str" ) ;
engine . say ( "str" + player . getName ( )
addHelp ( "str" ) ;
ConsumableItem poison = poisonToConsume . get ( 0 ) ;
if ( turn % poison . getFrecuency ( ) ! = 0 ) {
kill ( poison ) ;
sign . setText ( "str" ) ;
sign . setText ( "str" ) ;
currentState = ConversationStates . IDLE ;
return currentState ! = ConversationStates . IDLE ;
addHelp ( "str" ) ;
new String [ ] { "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" } ,
portal . sety ( 51 ) ;
sb . append ( item + "str" + items . get ( item ) + "str" ) ;
StringBuffer sb = new StringBuffer ( header + "str" ) ;
sb . append ( item + "str" + items . get ( item ) + "str" ) ;
sign . setText ( "str" ) ;
sign . setText ( "str" ) ;
addHelp ( "str" ) ;
sign . setText ( "str" ) ;
sign . setText ( "str" ) ;
sign . setText ( "str" ) ;
sign . setText ( "str" ) ;
sign . setText ( "str" ) ;
. setText ( "str" ) ;
sign . setText ( "str" ) ;
sign . setText ( "str" ) ;
sign . setText ( "str" ) ;
sign . setText ( "str" ) ;
sign . setText ( "str" ) ;
sign . setText ( "str" ) ;
String [ ] lines = text . split ( "str" ) ;
player . sendPrivateText ( "str" ) ;
add ( - 1 ) ;
if ( Version . compare ( stendhal . VERSION , version ) < - 1 ) {
private XMLZone currentZone ;
currentZone = new XMLZone ( ) ;
currentZone . name = attrs . getValue ( "str" ) ;
addArea ( "str" ) ;
private void buildMagicianHouseArea ( StendhalRPZone zone ) {
world . getRPZone ( new IRPZone . ID ( "str" ) ) ;
portal . setDestination ( "str" , 103 ) ;
npc . put ( "str" , "str" ) ;
if ( player . isQuestInState ( QUEST_SLOT , "str" , "str" , "str" , "str" , "str" ) ) {
if ( player . isQuestInState ( QUEST_SLOT , "str" , "str" ) ) {
if ( Float . parseFloat ( version ) < 1.5f ) {
String message = player . getName ( ) + "str" + action . get ( "str" ) + "str" + action . get ( "str" ) ;
super . connect ( host , port , protocol ) ;
onError ( 3 , "str" ) ;
List < Node > path = Path . searchPath ( entity , zone , x , y ,
this . dropsItems = dropItems ;
c . insets = new Insets ( 4 , 4 , 4 , 4 ) ;
public static final String VERSION = "str" ;
static protected StendhalRPRuleProcessor rules ;
npc . add ( ConversationStates . ATTENDING ,
ConversationStates . ATTENDING ,
objectsIterator = slot . iterator ( ) ;
objectsIterator = slot . iterator ( ) ;
if ( ! ( other instanceof PassiveEntity ) & & ! ( other instanceof Blood ) & & ! ( other instanceof PlantGrower ) ) {
public static final String VERSION = "str" ;
public static final String [ ] SERVERS_LIST = { "str" , "str" ,
} else if ( type = = 104 ) {
String text = "str" + getName ( ) . replace ( "str" , "str" ) + "str" ;
stats = "str" + stats . trim ( ) + "str" ;
shops . add ( "str" , "str" , 250 ) ;
engine . say ( "str" ) ;
engine . say ( "str" ) ;
return player . hasQuest ( "str" ) ;
engine . setActualState ( ConversationStates . ATTENDING ) ;
npc . add ( ConversationStates . QUEST_OFFERED ,
if ( zoneName . equals ( player . get ( "str" ) ) )
private static final int TITLEBAR_SIZE = 14 ;
private static final int TITLEBAR_FONT_SIZE = 12 ;
clientHeight - = TITLEBAR_SIZE ;
clienty + = TITLEBAR_SIZE ;
height + = TITLEBAR_SIZE ;
this . height + = TITLEBAR_SIZE ;
localHeight = TITLEBAR_SIZE + FRAME_SIZE * 2 ;
panelGraphics = panelGraphics . create ( 0 , TITLEBAR_SIZE + 2 , width
- TITLEBAR_SIZE - 2 ) ;
panelGraphics = panelGraphics . create ( 0 , TITLEBAR_SIZE + 2 , width
- TITLEBAR_SIZE - 2 ) ;
height = TITLEBAR_SIZE + ( frame ? FRAME_SIZE * 2 : 0 ) ;
| | y > FRAME_SIZE + TITLEBAR_SIZE )
this . children = new LinkedList < WtPanel > ( ) ;
for ( WtPanel child : children ) {
TILLEBAR_FONT_SIZE ) ) ;
for ( Iterator < WtPanel > childIt = children . iterator ( ) ; childIt . hasNext ( ) ; ) {
for ( WtPanel panel : children ) {
for ( WtPanel panel : children ) {
for ( WtPanel panel : children ) {
for ( WtPanel panel : children ) {
for ( WtPanel panel : children ) {
if ( ! children . remove ( child ) )
children . addFirst ( child ) ;
engine . say ( "str" ) ;
engine . say ( "str" ) ;
super ( "str" ) ;
query = "str" ;
public static final String VERSION = "str" ;
public Door ( String key , String clazz , Direction dir ) throws AttributeNotFoundException
door . add ( "str" , RPClass . STRING , RPClass . PRIVATE ) ;
private static long TIMEOUT_PLAYER_CHAT = 90 ;
return "str" + state + "str" + trigger + "str" + nextState + "str" + condition + "str" ;
npc . add ( 0 , "str" , new SpeakerNPC . ChatCondition ( )
npc . add ( 0 , "str" , new SpeakerNPC . ChatCondition ( )
npc . add ( 0 , "str" , new SpeakerNPC . ChatCondition ( )
portal . setDestination ( "str" , 2 ) ;
if ( actualState ! = 0 & & state . absoluteJump ( actualState , text ) )
if ( item . getRegen ( ) > 0 & & itemsToConsume . size ( ) > 5 & & ! item . getName ( ) . contains ( "str" ) )
if ( layer . getName ( ) . equals ( "str" ) | | layer . getName ( ) . equals ( "str" ) | | layer . getName ( ) . equals ( "str" ) | | layer . getName ( ) . equals ( "str" ) )
private boolean rightMouseButtonPressed ;
rightMouseButtonPressed = true ;
rightMouseButtonPressed = false ;
if ( rightMouseButtonPressed )
if ( changes . has ( "str" ) & & client . getPlayer ( ) ! = null & & distance ( client . getPlayer ( ) ) < 15 * 15 )
private static final String LOG4J_PROPERTIES = "str" ;
if ( Debug . CREATURES_DEBUG_SERVER )
if ( Debug . CREATURES_DEBUG_SERVER )
if ( Debug . CREATURES_DEBUG_SERVER )
if ( Debug . CREATURES_DEBUG_SERVER )
if ( Debug . CREATURES_DEBUG_SERVER )
if ( Debug . CREATURES_DEBUG_SERVER )
if ( Debug . CREATURES_DEBUG_SERVER )
if ( Debug . CREATURES_DEBUG_SERVER )
if ( Debug . CREATURES_DEBUG_SERVER )
if ( Debug . CREATURES_DEBUG_SERVER )
if ( Debug . CREATURES_DEBUG_SERVER )
if ( Debug . CREATURES_DEBUG_SERVER )
if ( Debug . CREATURES_DEBUG_SERVER )
if ( Debug . CREATURES_DEBUG_SERVER )
if ( Debug . CREATURES_DEBUG_SERVER )
if ( Debug . CREATURES_DEBUG_SERVER )
if ( Debug . CREATURES_DEBUG_SERVER )
if ( Debug . CREATURES_DEBUG_CLIENT & & ! hidePath )
if ( changes . has ( "str" ) & & Debug . CREATURES_DEBUG_CLIENT )
if ( ! Debug . CREATURES_DEBUG_CLIENT )
private static int TURNS_WHILE_ATK_DEF_XP_INCREASE = 40 ;
blood = TURNS_WHILE_ATK_DEF_XP_INCREASE ;
client . addEventLine ( getName ( ) + "str" + ( changes . getInt ( "str" ) - object . getInt ( "str" ) ) + "str" , Color . blue ) ;
client . addEventLine ( getName ( ) + "str" + healing + "str" , Color . green ) ;
numberValue = changed . getInt ( stat ) + numberValue ;
numberValue = changed . getInt ( stat ) - numberValue ;
payPlayer ( player , ( int ) ( itemPrice * ( ( 1.0f * sheep . getWeight ( ) ) / sheep . MAX_WEIGHT ) ) ) ;
chatAction = new RPClass ( "str" ) ;
slotPanels . put ( "str" , new EntitySlot ( "str" , slotSprite , dist , dist * 2 , gameObjects ) ) ;
super ( parent , false ) ;
sign = new Sign ( ) ;
public synchronized boolean collides ( Entity entity , double x , double y ) throws AttributeNotFoundException
StendhalClient . get ( ) . addEventLine ( line , Color . gray ) ;
if ( text . charAt ( 0 ) ! = "str" )
entity = new Corpse ( object ) ;
if ( leftHP > 0 )
if ( base instanceof Player & & ! player . getID ( ) . equals ( base . getID ( ) ) )
if ( base instanceof Player & & ! player . getID ( ) . equals ( base . getID ( ) ) )
if ( ( center ! = null ) & & ( getDistance ( node , center ) > radius ) )
double patk = 2.0 + level / 3.0 ;
double playerHp = 100.0 + ( 10.0 * level ) / 3.0 ;
while ( creatureHP > 0 )
player . addXP ( sheep . getWeight ( ) ) ;
say ( "str" + get ( "str" ) + "str" ) ;
say ( "str" ) ;
say ( "str" ) ;
say ( "str" ) ;
say ( "str" ) ;
say ( "str" ) ;
say ( "str" ) ;
say ( "str" ) ;
say ( "str" ) ;
say ( "str" ) ;
say ( "str" + amount + "str" ) ;
say ( "str" ) ;
say ( "str" ) ;
say ( "str" ) ;
say ( "str" ) ;
say ( "str" ) ;
say ( "str" ) ;
say ( "str" + player . get ( "str" ) + "str" ) ;
say ( "str" ) ;
say ( "str" ) ;
say ( "str" + amount + "str" ) ;
if ( sign . getx ( ) = = 11 & & sign . gety ( ) = = 19 ) sign . setText ( "str" ) ;
public static void face ( RPEntity entity , double dx , double dy )
public static void move ( RPEntity entity ) throws AttributeNotFoundException , NoRPZoneException
public class RPEntity extends Entity
if ( leftHP > = 0 )
private static void moveto ( RPEntity entity , double x , double y , double speed )
private RPEntity entity ;
public NavigableStendhalNode ( RPEntity entity , StendhalRPZone zone )
public static List < Node > searchPath ( RPEntity entity , double x , double y )
public static boolean followPath ( RPEntity entity , double speed )
Logger . trace ( "str" , "str" , "str" + object . getID ( ) + "str" ) ;
return new Rectangle . Double ( x , y , 1 , 2 ) ;
return new Rectangle . Double ( x , y , 1 , 2 ) ;
for ( double i = x ; i < = x + w ; i + = 1 )
for ( double j = y ; j < = y + h ; j + = 1 )
. add_first_party_caveat ( "str" )
assertThat ( D . signature ) . isEqualTo ( "str" ) ;
assertThat ( DP . signature ) . isEqualTo ( "str" ) ;
. add_first_party_caveat ( "str" )
assertThat ( D . signature ) . isEqualTo ( "str" ) ;
assertThat ( DP . signature ) . isEqualTo ( "str" ) ;
verifier . satisfyExact ( "str" ) ;
. satisfyExact ( "str" )
public MacaroonsVerifier satisfyExact ( String caveat ) {
verifier . satisfyExact ( "str" ) ;
verifier . satisfyExact ( "str" ) ;
. satisfyExact ( "str" )
. satisfyExact ( "str" )
. satisfyExact ( "str" )
private void falseVersionValue ( ) {
@SuppressWarnings ( { "str" , "str" } )
if ( null ! = vl & & ! vl . value ( ) ) {
if ( null ! = vl & & ! vl . value ( ) ) {
m = mapper . getDeclaredMethod ( id . substring ( pos + 1 ) , paramCls ) ;
LOGGER . trace ( "str" , bean , propertyName ) ;
return isNullOrEmpty ( arrays ) ? Collections . < T > emptyList ( ) : new ArrayList < > ( Arrays . asList ( arrays ) ) ;
return isNullOrEmpty ( arrays ) ? Collections . < T > emptySet ( ) : new LinkedHashSet < > ( Arrays . asList ( arrays ) ) ;
import com . feilong . core . bean . ConvertUtil ;
LOGGER . trace ( "str" , parameterizedType ) ;
LOGGER . trace ( "str" , ConvertUtil . toString ( actualTypeArguments , null ) ) ;
assertArrayEquals ( null , toArray ( ( List < String > ) null , String . class ) ) ;
public static String format ( Object obj , String [ ] excludes , int indentFactor , int indent ) {
public static Map < String , String > readToMap ( String baseName , Locale locale ) {
public static < T > T readToAliasBean ( String baseName , Class < T > aliasBeanClass ) {
return BeanUtil . populateAliasBean ( newInstance ( aliasBeanClass ) , readToMap ( baseName ) ) ;
Map < String , String > propertyMap = ResourceBundleUtil . readToMap ( baseName , locale ) ;
import static com . feilong . core . util . ResourceBundleUtil . readToMap ;
Map < String , String > readPropertiesToMap = ResourceBundleUtil . readToMap ( "str" ) ;
public static DynaBean newDynaBean ( Map < String , Class < ? > > typeMap , Map < String , Object > valueMap ) {
DynaBean dynaBean = BeanUtil . newDynaBean ( typeMap , valueMap ) ;
BeanUtil . newDynaBean ( null , valueMap ) ;
BeanUtil . newDynaBean ( typeMap , null ) ;
BeanUtil . newDynaBean ( typeMap , valueMap ) ;
LOGGER . debug ( "str" , propertyName ) ;
logger . error ( "str" , e ) ;
protected int limit = 10 ;
private final int limit = 10 ;
} else if ( Timestamp . class . isAssignableFrom ( clazz ) | | "str" . equals ( clazz . getName ( ) ) ) {
datasetSelectionParameters = datasetParameters . get ( selectionsFilters . get ( 0 ) . getDataset ( ) . getLabel ( ) ) ;
datasetFilter = fil . getDataset ( ) . getLabel ( ) ;
String width = getConfiguratedElementStyle ( null , CellType . DATA , measureConfig , crossTab , "str" ) ;
Pattern dataPattern = Pattern . compile ( "str" ,
Pattern domElementID = Pattern . compile ( "str" , Pattern . CASE_INSENSITIVE | Pattern . MULTILINE | Pattern . DOTALL ) ;
if ( domId . length ( ) > 50 ) {
} else if ( link . equals ( domId ) ) {
private static final int HTTP_TIMEOUT_DEFAULT_VALUE = 30 * 1000 ;
Double value = ( valueRecord . get ( colName ) . equals ( "str" ) ) ? 0 : Double . valueOf ( String . valueOf ( valueRecord . get ( colName ) ) ) ;
if ( columnsHeaderList . contains ( header ) | | columnsHeaderIdList . contains ( header ) ) {
} else if ( rowsHeaderList . contains ( header ) | | rowsHeaderIdList . contains ( header ) ) {
} else if ( measuresHeaderList . contains ( header ) | | measuresHeaderIdList . contains ( header ) ) {
String columnForGroupingSerie = dataColumnsMapper . get ( groupedSerie ) . toLowerCase ( ) ;
dataColumnsMapper . remove ( categorieColumns . get ( "str" ) . toLowerCase ( ) ) ;
primCat = dataColumnsMapper . get ( categorieColumns . get ( "str" ) . toLowerCase ( ) ) ;
seria = dataColumnsMapper . get ( categorieColumns . get ( "str" ) . toLowerCase ( ) ) ;
String groupSeriesCateg , Map < String , String > dataColumnsMapper , Map < String , String > categorieColumns , String groupedSerie ) throws JSONException {
auditlogger . info ( "str" + userProfile . getUserId ( ) + "str" + ( ( JPQLDataSet ) dataset ) . getSQLQuery ( false ) ) ;
auditlogger . info ( "str" + userProfile . getUserId ( ) + "str" + ( ( HQLDataSet ) dataset ) . getSQLQuery ( false ) ) ;
value = getMultiValue ( tempVal , type , dsType ) ;
value = getSingleValue ( tempVal , type , dsType ) ;
static String getSingleValue ( String value , String type , String dsType ) {
if ( ( ! ( value . startsWith ( "str" ) & & value . endsWith ( "str" ) ) ) & & ! dsType . equals ( DataSetConstants . QBE ) ) {
private String getMultiValue ( String value , String type , String dsType ) {
toReturn = getSingleValue ( tempValue , type , dsType ) ;
toReturn = toReturn + "str" + getSingleValue ( tempValue , type , dsType ) ;
case Cell . CELL_TYPE_BLANK :
conn = getDataSource ( ) . getConnection ( ) ;
Query hibQuery = aSession . createQuery ( "str" ) ;
JAR , LOG , SBIMODEL
if ( property ! = null & & ! property . equals ( "str" ) ) {
if ( ! ds . checkIsJndi ( ) ) {
private static final String DEFAULT_TIMESTAMP_PATTERN = "str" ;
primCat = "str" ;
seria = "str" ;
primCat = "str" ;
seria = "str" ;
categories . add ( ( ( Map ) singleObject ) . get ( primCat ) . toString ( ) ) ;
map . put ( ( ( Map ) singleObject ) . get ( seria ) . toString ( ) , newListOfOrderColumnItems ) ;
JSONObject jo = newListOfOrderColumnItems . get ( categoriesListIndexMap . get ( ( ( Map ) singleObject ) . get ( primCat ) . toString ( ) ) ) ;
logger . debug ( "str" + profile ) ;
if ( value ! = null & & ! value . toString ( ) . isEmpty ( ) ) {
String userId = ( String ) getUserProfile ( ) . getUserUniqueIdentifier ( ) ;
if ( sourceJoinPath . isEmpty ( ) | | sourceJoinPath = = null | | targetJoinPath . isEmpty ( ) | | targetJoinPath = = null )
throw new SpagoBIDAOException ( "str" , t ) ;
throw new SpagoBIServiceException ( req . getPathInfo ( ) , "str" ) ;
return Response . ok ( checksResult . toString ( ) ) . build ( ) ;
JSONObject accessibility = createMenuItem ( "str" , "str" , messageBuilder . getMessage ( "str" , locale ) , false , "str" ) ;
templateDir = new File ( getClass ( ) . getResource ( "str" ) . toURI ( ) . getPath ( ) ) ;
public static final String DATAMART_NAME = "str" ;
lowFunctionality . setDescription ( paramsObj . getString ( "str" ) ) ;
lowFunctionality . setDescription ( paramsObj . getString ( "str" ) ) ;
returnMsg = "str" ;
returnMsg = "str" ;
returnMsg = "str" ;
if ( jsWait < 0 | | jsInterval < 0 ) {
. withJavaScriptExecutionDetails ( 5000L , 15000L ) ) ;
jsonData . put ( "str" , schemaName ) ;
String itemDescr = descrList . size ( ) > k ? descrList . get ( k ) : itemVal ;
String parDescription = descriptions . size ( ) > z ? descriptions . get ( z ) : parValue ;
if ( array . get ( i ) instanceof JSONObject ) {
Map profileAttributes = UserProfileUtils . getProfileAttributes ( ( UserProfile ) engineInstance . getEnv ( ) . get ( EngineConstants . ENV_USER_PROFILE ) ) ;
engineInstance . getDocumentLabel ( ) , engineInstance . getUserProfile ( ) ) ;
Map profileAttributes = UserProfileUtils . getProfileAttributes ( ( UserProfile ) engineInstance . getEnv ( ) . get ( EngineConstants . ENV_USER_PROFILE ) ) ;
logger . warn ( "str" + parameterName + "str" + e . getMessage ( ) ) ;
private final static int DEFAULT_DECIMALS = 4 ;
path = "str" ;
for ( OrganizationSummary orgSummary : orgs ) {
String fileName = inputItemJSON . getString ( "str" ) ;
String fileName = inputItemJSON . getString ( "str" ) ;
objToInsert . put ( "str" , f . getId ( ) . getFileName ( ) ) ;
public void sortRecords ( int fieldIndex , Comparator fieldComparator ) {
final Comparator fComparator = fieldComparator ;
return fComparator . compare ( field1 , field2 ) ;
if ( y < celltypeOfRows . size ( ) & & celltypeOfRows . get ( y ) . equals ( type ) ) {
if ( columnsHeaderList . contains ( header ) ) {
} else if ( rowsHeaderList . contains ( header ) ) {
} else if ( measuresHeaderList . contains ( header ) ) {
restritions . add ( new CriteriaParameter ( "str" , Short . valueOf ( "str" ) , Match . EQ ) ) ;
if ( realtimeDatasets . contains ( datasetInvolved ) ) {
if ( sbiObject . getSbiEngines ( ) ! = null & & ! sbiObject . getSbiEngines ( ) . equals ( "str" ) & & sbiObject . getSbiEngines ( ) . getDriverNm ( ) ! = null ) {
groupCriteria = getGroupCriteria ( label , categoriesObject , measuresObject ) ;
protected List < GroupCriteria > getGroupCriteria ( String dataset , JSONArray categoriesObject , JSONArray measuresObject ) throws JSONException {
throw new SpagoBIRestServiceException ( "str" , buildLocaleFromSession ( ) , exception ) ;
throw new SpagoBIRestServiceException ( "str" , buildLocaleFromSession ( ) , exception ) ;
aColumn . setAttribute ( NG_CLICK_ATTRIBUTE , "str" + crossTab . getCrosstabDefinition ( ) . getRows ( ) . get ( i ) . getEntityId ( ) + "str" + text
if ( orderColumn ! = null & & ! orderColumn . isEmpty ( ) ) {
if ( orderType . isEmpty ( ) )
if ( orderType . isEmpty ( ) )
if ( ! columnAndCategoryAreTheSame & & ! keepCategoryForOrdering . isEmpty ( ) )
if ( ! appendColumnForCategories . isEmpty ( ) ) {
if ( orderColumn ! = null & & ! orderColumn . isEmpty ( ) & & ! orderColumn . equals ( columnName ) ) {
@UserConstraint ( functionalities = { SpagoBIConstants . KPI_MANAGEMENT , SpagoBIConstants . MANAGE_KPI_VALUE } )
. split ( "str" ) ;
String signature = dataSet . getSignature ( ) ;
assertEquals ( "str" , str ) ;
sb . append ( getParamsMap ( ) ) ;
attributes . put ( "str" , "str" ) ;
attributes . put ( "str" , "str" ) ;
attributes . put ( "str" , "str" ) ;
attributes . put ( "str" , "str" ) ;
attributes . put ( "str" , "str" ) ;
attributes . put ( "str" , "str" ) ;
attributes . put ( "str" , "str" ) ;
attributes1 . put ( "str" , "str" ) ;
Number lastId = ( Number ) session . createSQLQuery ( "str" + escapedSequenceName + "str" )
REXP rexp = null ;
double [ ] intArr = rexp . asDoubles ( ) ;
int [ ] doubleArr = rexp . asIntegers ( ) ;
| | upperCaseString . contains ( "str" ) | | upperCaseString . contains ( "str" ) )
if ( sbiObject . getSbiEngines ( ) ! = null & & ! sbiObject . getSbiEngines ( ) . equals ( "str" ) ) {
columnNames . add ( DataStore . DEFAULT_TABLE_NAME + "str" + AbstractJDBCDataset . encapsulateColumnName ( columnName , null ) ) ;
sb . append ( AbstractJDBCDataset . encapsulateColumnName ( columnsArray [ j ] , null ) ) ;
filter = DataStore . DEFAULT_TABLE_NAME + "str" + AbstractJDBCDataset . encapsulateColumnName ( column , null ) + "str" + value + "str" ;
String defaultTableNameDot = DataStore . DEFAULT_TABLE_NAME + "str" ;
Operand leftOperand = new Operand ( defaultTableNameDot + AbstractJDBCDataset . encapsulateColumnName ( columnsArray [ 0 ] , null ) ) ;
sb . append ( defaultTableNameDot ) ;
if ( kpi . getPlaceholder ( ) ! = null & & ! kpi . getPlaceholder ( ) . isEmpty ( ) ) {
private JSError addMsg ( String msg , MSG_TYPE type ) {
private JSError addMsgKey ( String msgKey , MSG_TYPE type , String . . . args ) {
String str = RestUtilities . readBodyAsJSONObject ( req ) . toString ( ) ;
if ( dataSource ! = null & & dataSource . checkIsMultiSchema ( ) ) {
Integer scopeID = domainScopeIds . get ( scopeCode . toUpperCase ( ) ) ;
Set < String > temporalFieldTypesInSelect = getTemporalFieldsInSelect ( query . getSelectFields ( false ) , hierarchyFullColumnMap ) ;
domainScopeIds . put ( domainsScope . get ( i ) . getValueCd ( ) , domainsScope . get ( i ) . getValueId ( ) ) ;
logger . error ( "str" , e ) ;
logger . error ( "str" , e ) ;
logger . error ( "str" , e ) ;
logger . error ( "str" , e ) ;
logger . error ( "str" , e ) ;
logger . error ( "str" , e ) ;
SbiObjects hibBIObject = ( SbiObjects ) aSession . get ( SbiObjects . class , biObjectID ) ;
Method readFunctionalitiesMethod = licenseManager . getMethod ( "str" , SpagoBIUserProfile . class ) ;
if ( UserUtilities . hasDeveloperRole ( profile ) & & ! UserUtilities . hasAdministratorRole ( profile ) ) {
boolean isDev = UserUtilities . hasDeveloperRole ( profile ) & & ! UserUtilities . hasAdministratorRole ( profile ) ;
if ( ( SourceBean ) EnginConf . getInstance ( ) . getConfig ( ) . getAttribute ( "str" ) ! = null ) {
} else if ( type . equalsIgnoreCase ( "str" ) | | type . equalsIgnoreCase ( "str" ) ) {
PhysicalTable destinationTable = physicalModel . getTable ( tableName ) ;
innerJoinRelationshipDescriptor . getDestinationColumns ( ) . add ( destinationColumn ) ;
innerJoinRelationshipDescriptor . getSourceColumns ( ) . add ( sourceCol ) ;
businessModelInitializer . initialize ( modelName , physicalTableFilter , physicalModel ) ;
@UserConstraint ( functionalities = { SpagoBIConstants . FEDERATED_DATASET_MANAGEMENT } )
@UserConstraint ( functionalities = { SpagoBIConstants . META_MODELS_CATALOGUE_MANAGEMENT } )
axisColumnsCell . setCellValue ( axisColumns ) ;
jsonParamRet = jsonParamRet . replaceAll ( "str" , "str" ) ;
public class RestExceptionMapper implements ExceptionMapper < RuntimeException > {
public Response toResponse ( RuntimeException t ) {
private Response toResponseFromGenericException ( RuntimeException t ) {
private JSONObject serializeException ( RuntimeException t ) {
PyLib . execScript ( "str" + "str" ) ;
} else if ( ! isFromSaveNoMetadata ) {
if ( fieldValue . getClass ( ) . toString ( ) . contains ( "str" ) ) {
if ( fieldValue . getClass ( ) . toString ( ) . contains ( "str" ) ) {
if ( fieldValue . getClass ( ) . toString ( ) . contains ( "str" ) ) {
callback . setCornerStyleClass ( null ) ;
Query query = new MultiFieldQueryParser ( Version . LUCENE_CURRENT , fields , analyzer ) . parse ( queryString . replace ( "str" , "str" ) ) ;
Query query = new FuzzyQuery ( new Term ( fields [ i ] , queryString . replace ( "str" , "str" ) ) ) ;
if ( crossDao . documentIsCrossable ( env . get ( "str" ) . toString ( ) ) ) {
path = aLayer . getPathFile ( ) + File . separator + "str" + File . separator ;
String ERROR = "str" ;
measureList . getJSONObject ( i ) . put ( "str" , version ) ;
persistentSbiKpiKpi . setCardinality ( new JSONObject ( persistentSbiKpiKpi . getCardinality ( ) ) . put ( "str" , measureList ) . toString ( ) ) ;
ret . add ( new DefaultOutputParameter ( "str" , TYPE . String ) ) ;
String documentName = documentsLabels [ i ] . substring ( 0 , documentsLabels [ i ] . lastIndexOf ( "str" ) ) ;
if ( ( "str" . equals ( ssl ) ) & & ( ! StringUtilities . isEmpty ( user ) ) & & ( ! StringUtilities . isEmpty ( pwd ) ) ) {
if ( ( "str" . equals ( ssl ) ) ) {
iterator . remove ( ) ;
if ( errorList ! = null & & ! errorList . isEmpty ( ) ) {
BIObject biobj = biobjdao . loadBIObjectByLabel ( docLbls [ i ] . substring ( 0 , docLbls [ i ] . lastIndexOf ( "str" ) ) ) ;
String objId = uniqueDispatchContextName . substring ( 0 , uniqueDispatchContextName . lastIndexOf ( "str" ) ) ;
String objId = objIdentifier . substring ( 0 , objIdentifier . lastIndexOf ( "str" ) ) ;
String parameterValues = ( parDef . length = = 2 ? parDef [ 1 ] : "str" ) ;
String parameterValues = ( parDef . length = = 2 ? parDef [ 1 ] : "str" ) ;
jo . put ( "str" , job . getJobGroupName ( ) ) ;
if ( jsonTemplate . getJSONObject ( "str" ) . getString ( "str" ) . equals ( "str" ) ) {
if ( defaultValues ! = null & & defaultValues . size ( ) = = 1 & & ! defaultValues . get ( 0 ) . containsKey ( "str" ) ) {
List < SbiAlertAction > lst = list ( SbiAlertAction . class ) ;
insert ( aAction ) ;
insert ( aAction ) ;
List < SbiAlertListener > lst = list ( SbiAlertListener . class ) ;
insert ( aListener ) ;
insert ( aListener ) ;
if ( parentNodeUniqueName . equals ( name ) & & ! parentCallNode . getOperatorName ( ) . equalsIgnoreCase ( "str" ) ) {
objectResult . put ( "str" , array . toString ( ) ) ;
role , biObject , biObjectParameter , requestVal , treeLovNodeLevel , treeLovNodeValue , req ) ;
return Response . ok ( new JSError ( ) . addErrorKey ( "str" ) ) . build ( ) ;
Integer lastId = ( Integer ) session . createSQLQuery ( "str" + escapedSequenceName + "str" )
session . createSQLQuery ( "str" + escapedSequenceName + "str" + newRowsCount + "str" )
"str" + newRowsCount + "str" + escapedSequenceName + "str" )
endDtDate = ( Date ) endDtField . getValue ( ) ;
filterDate , hierNameForDim , filterHierType , hierTableName , prefix , exludeHierLeaf ) ;
public void setSubset ( Integer startRow , Integer startColumn , Integer rowSet , Integer columnSet ) {
args . add ( Literal . create ( rowSet ) ) ;
args . add ( Literal . create ( columnSet ) ) ;
model . setSubset ( modelConfig . getStartRow ( ) , modelConfig . getStartColumn ( ) , modelConfig . getRowsSet ( ) , modelConfig . getColumnSet ( ) ) ;
String signature = dataSetDao . loadDataSetByLabel ( v1 ) . getSignature ( ) ;
columnSet = 11 ;
private static final String TYPE_SINGLE = "str" ;
setExpression ( TYPE_SINGLE ) ;
if ( expression . indexOf ( TYPE_SINGLE ) ! = - 1 | | "str" . equalsIgnoreCase ( expression ) ) {
public Map < String , List < String > > listPlaceholderByKpiList ( List < String > kpiNames ) ;
Map < String , List < String > > lst = dao . listPlaceholderByKpiList ( kpiNames ) ;
public static TriggerInfo getTriggerInfo ( String jobName , String jobGroupName , String triggerName , String triggerGroup ) {
parameterDescriptions . add ( ( defaultValue ! = null ) ? defaultValue . getDescription ( ) : "str" ) ;
if ( objParameter . getValueSelection ( ) . equalsIgnoreCase ( "str" ) & & ! objParameter . getSelectionType ( ) . equalsIgnoreCase ( "str" ) ) {
int axisOrdinal = context . getAxis ( ) . axisOrdinal ( ) ;
+ "str" ) ;
+ "str" ) ;
this . rowsSet = rowsSet ;
this . rowCount = rowCount ;
this . columnSet = columnSet ;
this . columnCount = columnCount ;
rexp = re . parseAndEval ( outVal ) ;
public void swapAxisSort ( ModelConfig modelConfig ) {
if ( modelConfig . getSortingEnabled ( ) ) {
model . swapAxisSort ( ei . getModelConfig ( ) ) ;
json = os . toString ( ) . replaceAll ( "str" , "str" ) ;
iterator . remove ( ) ;
@Path ( "str" )
executeQuery ( rule . getDataSourceId ( ) , rule . getDefinition ( ) , 1 , rule . getPlaceholders ( ) , getProfile ( req ) ) ;
return Response . ok ( ) . build ( ) ;
sre . addHint ( "str" ) ;
cache . setProperty ( "str" , "str" ) ;
return Response . ok ( ret . toString ( ) ) . build ( ) ;
logger . debug ( "str" + engineLabel ) ;
logger . debug ( "str" + driver + "str" ) ;
logger . debug ( "str" ) ;
logger . debug ( "str" ) ;
logger . debug ( "str" ) ;
logger . debug ( "str" ) ;
REXP datasetNameInR = re . parseAndEval ( ds . getName ( ) ) ;
re . parseAndEval ( stringToEval ) ;
re . eval ( stringToEval ) ;
throw new SpagoBIServiceException ( SERVICE_NAME , "str" , e ) ;
String defaultValue = obj . optString ( DEFAULT_VALUE_PARAM ) ;
expression = "str" + fieldClaculationDescriptor . getString ( QuerySerializationConstants . FIELD_EXPRESSION ) + "str" ;
response . put ( "str" , getDataStore ( label , null , selections , null ) ) ;
newValues . add ( value . replaceFirst ( "str" , "str" ) ) ;
if ( ! intersection . equals ( baseSet ) & & intersection . size ( ) > 0 ) {
private final String orderedEdgeNames ;
this . orderedEdgeNames = StringUtils . join ( orderedEdgeNames . iterator ( ) , "str" ) ;
result = prime * result + ( ( orderedEdgeNames = = null ) ? 0 : orderedEdgeNames . hashCode ( ) ) ;
} else if ( ! orderedEdgeNames . equals ( other . orderedEdgeNames ) )
String associationString = edgeGroup . getOrderedEdgeNames ( ) ;
SbiFederationDefinitionDAOHibImpl dao = ( SbiFederationDefinitionDAOHibImpl ) DAOFactory . getFedetatedDatasetDAO ( ) ;
public List < DataSource > getAllDataSources ( ) {
public String postDataSource ( @Valid DataSource dataSource ) {
public List < DataSource > putDataSource ( DataSourceModel dataSource ) {
public List < DataSource > deleteDataSourceById ( @PathParam ( "str" ) Integer dsId ) throws EMFUserError {
String pathToFile = folder . getPath ( ) + File . separator + listOfFiles [ i ] . getName ( ) ;
sqlQuery = getStatement ( ) ;
logger . error ( "str" + sqlQuery ) ;
response = request . post ( ) ;
response = request . get ( ) ;
if ( ( wsEngine ! = null & & typeDocWizard = = null ) | | ( typeDocWizard ! = null & & typeDocWizard . equalsIgnoreCase ( "str" ) ) ) {
String id = ( ( Integer ) requestBodyJSON . opt ( "str" ) ) . toString ( ) ;
UserProfile profile = ( UserProfile ) req . getSession ( ) . getAttribute ( IEngUserProfile . ENG_USER_PROFILE ) ;
result . put ( SHORT_NAME , objName . substring ( 0 , SHORT_NAME_CHARACTERS_LIMIT - 1 ) + "str" ) ;
q . addSelectFiled ( serieColumn , serieFunction , serieColumn + "str" + serieFunction , true , true , false , null , null ) ;
velocityContext . put ( "str" , mapTemplate . get ( "str" ) ! = null ? mapTemplate . get ( "str" ) : mapTemplate . get ( "str" ) ) ;
result . put ( kv [ 0 ] , kv . length > 1 ? kv [ 1 ] : "str" ) ;
String chartType = extractChartType ( jsonTemplateFromXML ) ;
if ( suppressAllComments | | ! addRemarkComments ) {
if ( introspectedColumn . getFullyQualifiedJavaType ( ) . isPrimitive ( ) & & ! introspectedTable . isJava5Targeted ( ) ) {
if ( introspectedColumn . getFullyQualifiedJavaType ( ) . isPrimitive ( ) & & ! introspectedTable . isJava5Targeted ( ) ) {
public static class JdbcTypeInformation {
String . format ( "str" ,
String . format ( "str" ,
String annotation = String . format ( "str" ,
this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( "str" ) ,
publishProgress ( context . getResources ( ) . getString ( R . string . convert_populating_working_directory ) ) ;
publishProgress ( context . getResources ( ) . getString ( R . string . convert_downloading ) + "str" + library . name ) ;
publishProgress ( context . getResources ( ) . getString ( R . string . convert_converting ) + "str" + library . name ) ;
publishProgress ( context . getResources ( ) . getString ( R . string . convert_downloading ) + "str" + version . id ) ;
publishProgress ( context . getResources ( ) . getString ( R . string . convert_converting ) + "str" + version . id ) ;
publishProgress ( context . getResources ( ) . getString ( R . string . convert_preparing_to_launch_minecraft ) ) ;
Log . v ( TAG , String . format ( "str" , event . getActionMasked ( ) , event . getX ( ptr ) , event . getY ( ptr ) , event . getPressure ( ptr ) ) ) ;
if ( state = = TiPresenter . State . VIEW_ATTACHED & & ! hasLifecycleMethodBeenCalled ) {
if ( state = = TiPresenter . State . DESTROYED & & ! hasLifecycleMethodBeenCalled ) {
final boolean hasLifecycleMethodBeenCalled ) {
if ( state = = TiPresenter . State . VIEW_ATTACHED & & ! hasLifecycleMethodBeenCalled ) {
if ( state = = TiPresenter . State . DESTROYED & & ! hasLifecycleMethodBeenCalled ) {
final boolean hasLifecycleMethodBeenCalled ) {
public void baseClassOverride ( ) {
public void getInstantiator_Overridden ( ) {
public void orderedCallsSuccess ( ) {
public void testGreaterThan ( ) {
public void testGreaterOrEqual ( ) {
value = convertNumberClassIfNecessary ( value ) ;
value = convertNumberClassIfNecessary ( value ) ;
private Object convertNumberClassIfNecessary ( Object o ) {
throw new InternalError ( "str" + methodName + "str"
fail ( "str" ) ;
public void orderedCallsSuccess ( ) {
fail ( "str" ) ;
fail ( "str" ) ;
fail ( "str" ) ;
fail ( "str" ) ;
fail ( "str" ) ;
return Long . valueOf ( f . getLong ( null ) ) ;
while ( rightbound < predicate . getStart ( ) & & predicate . getSentence ( ) . getChunkTag ( rightbound ) . equals ( "str" ) ) {
values . put ( DatabaseOpenHelper . ARTIST_NAME , "str" ) ;
private Location bestLastKnownLocation ( float minAccuracy , long maxAge ) {
if ( bestAccuracy > minAccuracy | | ( System . currentTimeMillis ( ) - bestTime ) > maxAge ) {
private Location bestLastKnownLocation ( float minAccuracy , long maxAge ) {
if ( bestAccuracy > minAccuracy | | ( System . currentTimeMillis ( ) - bestAge ) > maxAge ) {
if ( bestAccuracy > minAccuracy | | ( System . currentTimeMillis ( ) - bestTime ) > minTime ) {
. parse ( "str"
binder . bindConstant ( ) . annotatedWith ( Names . named ( "str" ) ) . to ( 8291 ) ;
private final long globalIngestionHeapLimitBytes = ( long ) ( Runtime . getRuntime ( ) . maxMemory ( ) / 6 ) ;
return Long . valueOf ( raw . substring ( 0 , raw . length ( ) - 1 ) ) ;
final long timestampMillis = Long . valueOf ( timestamp ) ;
private final Provider < QuerySegmentWalker > walkerProvider ;
public MovingAverageQueryToolChest ( Provider < QuerySegmentWalker > walkerProvider , RequestLogger requestLogger )
Objects . equals ( rollup , that . rollup ) & &
Objects . equals ( legacy , scanQuery . legacy ) & &
public static final String MISSING_SEGMENTS_KEY = "str" ;
public static final String BLOOM_FILTER_TYPE_NAME = "str" ;
public static final Logger LOG = new Logger ( TestQueryHelper . class ) ;
private static final List < String > UNSECURED_PATHS = Lists . newArrayList (
protected static final List < String > UNSECURED_PATHS_FOR_UI = ImmutableList . of (
public static final BitmapSerdeFactory LEGACY_FACTORY = new BitmapSerde . LegacyBitmapSerdeFactory ( ) ;
protected static final Comparator < String > comparator = StringComparators . ALPHANUMERIC ;
public static final int DEFAULT_RETRY_COUNT = 30 ;
public static final long DEFAULT_RETRY_SLEEP = TimeUnit . SECONDS . toMillis ( 10 ) ;
public static final String NULL_HANDLING_CONFIG_STRING = "str" ;
public static final String FN_NAME = "str" ;
protected static final List < String > UNSECURED_PATHS = ImmutableList . of (
public static final RelOptRule AGGREGATE = new DruidOuterQueryRule (
public static final RelOptRule FILTER_AGGREGATE = new DruidOuterQueryRule (
public static final RelOptRule FILTER_PROJECT_AGGREGATE = new DruidOuterQueryRule (
public static final RelOptRule PROJECT_AGGREGATE = new DruidOuterQueryRule (
public static final RelOptRule AGGREGATE_SORT_PROJECT = new DruidOuterQueryRule (
return Boolean . valueOf ( props . getProperty ( PROPERTY_SQL_ENABLE , "str" ) ) ;
Response response = resource . getUser ( req , AUTHORIZER_NAME , user , "str" , null ) ;
public void testComputeResultLevelCacheKeyWithDifferentPostAgg ( )
private static final Logger log = new Logger ( CliRealtimeExample . class ) ;
throw new IAE ( "str" , name ) ;
final SystemSchema systemSchema = CalciteTests . createMockSystemSchema ( druidSchema , walker , plannerConfig ) ;
final SystemSchema systemSchema = CalciteTests . createMockSystemSchema ( druidSchema , walker , plannerConfig ) ;
final SystemSchema systemSchema = CalciteTests . createMockSystemSchema ( druidSchema , walker , plannerConfig ) ;
final SystemSchema systemSchema = CalciteTests . createMockSystemSchema ( druidSchema , walker , plannerConfig ) ;
. intervals ( QueryRunnerTestHelper . fullOnIntervalSpec )
@QueryParam ( "str" ) final String createdTimeInterval ,
@JsonTypeInfo ( use = JsonTypeInfo . Id . NAME , property = "str" , defaultImpl = TmpFileSegmentWriteOutMediumFactory . class )
return ExprEval . ofLong ( null ) ;
return ExprEval . ofDouble ( null ) ;
@QueryParam ( "str" ) final String interval ,
import com . fasterxml . jackson . annotation . JsonCreator ;
public static URL makeWorkerURL ( Worker worker , String pathFormat , String . . . pathParams )
Arrays . stream ( pathParams ) . map ( StringUtils : : urlEncode ) . toArray ( )
Preconditions . checkNotNull ( pair . rhs , "str" ) ;
Resource . newClassPathResource ( "str" ) ,
Resource . newClassPathResource ( "str" ) ,
command . add ( StringUtils . format ( "str" , childPort ) ) ;
if ( file . length ( ) > Integer . MAX_VALUE ) {
private static final long DEFAULT_TARGET_COMPACTION_SIZE_BYTES = 400 * 1024 * 1024 ;
description = "str" ,
String value = System . getProperty ( DOUBLE_STORAGE_TYPE_PROPERTY , "str" ) ;
public int maxRowsPerFrame = 5000 ;
log . debug ( "str" ) ;
private int numLookupLoadingThreads = Math . max ( 1 , Runtime . getRuntime ( ) . availableProcessors ( ) / 2 ) ;
@JsonTypeInfo ( use = JsonTypeInfo . Id . NAME , property = "str" , defaultImpl = EqualDistributionWorkerSelectStrategy . class )
objectSelector = new TestObjectColumnSelector < > ( pairs ) ;
objectSelector = new TestObjectColumnSelector < > ( pairs ) ;
objectSelector = new TestObjectColumnSelector < > ( pairs ) ;
public class TestObjectColumnSelector < T > implements ObjectColumnSelector
public TestObjectColumnSelector ( T [ ] objects )
public Capabilities build ( )
return new Capabilities (
selector = new TestObjectColumnSelector < > ( values ) ;
Sequence < ? > seq = helper . createIndexAndRunQueryOnSegment (
selector = new TestObjectColumnSelector < > ( values ) ;
objectSelector = new TestObjectColumnSelector < > ( pairs ) ;
objectSelector = new TestObjectColumnSelector < > ( pairs ) ;
objectSelector = new TestObjectColumnSelector < > ( pairs ) ;
selector = new TestObjectColumnSelector < > ( values ) ;
this . aggregators = aggregators = = null ? new AggregatorFactory [ ] { } : aggregators ;
if ( "str" . equals ( config . get ( "str" ) ) | | "str" . equals ( config . get ( "str" ) ) ) {
if ( timeLeft < = 0 ) {
log . info ( "str" , workingDirPath ) ;
pause ( - 1 ) ;
throw new RuntimeException ( "str" ) ;
private final ThreadLocal < SimpleDateFormat > timeFormatter ;
private final ThreadLocal < SimpleDateFormat > resultFormatter ;
catch ( Throwable e ) {
Assert . assertEquals ( true , config . getBuildV9Directly ( ) ) ;
Assert . assertEquals ( false , config . getBuildV9Directly ( ) ) ;
private static final Boolean defaultBuildV9Directly = Boolean . TRUE ;
Assert . assertEquals ( true , config . getBuildV9Directly ( ) ) ;
Assert . assertEquals ( true , config . getBuildV9Directly ( ) ) ;
Assert . assertEquals ( false , config . getBuildV9Directly ( ) ) ;
private static final Boolean DEFAULT_BUILD_V9_DIRECTLY = Boolean . TRUE ;
private static final Boolean DEFAULT_BUILD_V9_DIRECTLY = Boolean . TRUE ;
. setName ( String . format ( "str" , currThreadName , query . getType ( ) , query . getDataSource ( ) . getNames ( ) , queryId ) ) ;
log . warn ( e , "str" , queryId ) ;
if ( ! ( dimensionsSpec . hasCustomDimensions ( ) & & dimensionsSpec . getDimensionNames ( ) . contains ( timestampColumn ) ) ) {
feed , kafkaSimpleConsumer , partition , startOffset = = null ? - 1 : startOffset
log . warn ( e , "str" , topic , partitionId ) ;
Preconditions . checkArgument ( this . queueBufferLength > 0 , "str" ) ;
new PartitionHolder < ObjectType > ( object . getPartitionHolder ( ) )
new PartitionHolder < ObjectType > ( val . getPartitionHolder ( ) )
searchSortSpec , QueryGranularities . ALL , Integer . MAX_VALUE ) . apply ( r1 , r2 ) ;
protected static final String PERSIST_FILE_NAME = "str" ;
private Period minWait = new Period ( "str" ) ;
private Period maxWait = new Period ( "str" ) ;
private long maxRetryCount = 60 ;
return new BooleanValueMatcher ( predicate . apply ( null ) ) ;
log . error ( e , "str" ) ;
private static final int defaultMaxRowsInMemory = 75000 ;
this . defaultRowFlushBoundary = defaultRowFlushBoundary = = null ? 75000 : defaultRowFlushBoundary ;
private static final int DEFAULT_ROW_FLUSH_BOUNDARY = 75000 ;
private static final int DEFAULT_ROW_FLUSH_BOUNDARY = 75000 ;
final int maxRequests = Integer . parseInt ( properties . getProperty ( MAX_CHAT_REQUESTS_PROPERTY ) ) ;
return fName . startsWith ( "str" ) & & fName . endsWith ( "str" ) & & ! fName . endsWith ( "str" ) ;
Assert . assertNotNull ( new ExtractionDimFilter ( "str" , null , new RegexDimExtractionFn ( "str" , null , null ) , null ) . getCacheKey ( ) ) ;
return Optional . fromNullable ( resourceManagement . getStats ( ) ) ;
@NotNull @JacksonInject @Named ( "str" )
public abstract String apply ( @NotNull String key ) ;
public Map < String , String > applyAll ( Iterable < String > keys )
public Map < String , List < String > > unapplyAll ( Iterable < String > values )
public abstract byte [ ] getCacheKey ( ) ;
private static final int TIMEOUT_SECONDS = 20 ;
makeRemoteTaskRunner ( new TestRemoteTaskRunnerConfig ( new Period ( "str" ) ) ) ;
@JsonTypeInfo ( use = JsonTypeInfo . Id . NAME , property = "str" )
return HadoopDruidIndexerConfig . INDEX_MERGER . mergeQueryableIndex (
import io . druid . segment . BaseProgressIndicator ;
return new BaseProgressIndicator ( )
rootExtensionsDir = new File ( temporaryFolder . getRoot ( ) , "str" ) ;
private String directory = "str" ;
private String hadoopDependenciesDir = "str" ;
throw new IndexSizeExceededException ( "str" , maxRowCount ) ;
public IndexSizeExceededException ( String formatText , Object . . . arguments )
super ( String . format ( formatText , arguments ) ) ;
public IndexSizeExceededException ( Throwable cause , String formatText , Object . . . arguments )
super ( String . format ( formatText , arguments ) , cause ) ;
throw new IndexSizeExceededException ( "str" , getOutOfRowsReason ( ) ) ;
while ( ! cursor . isDone ( ) & & rowUpdater . getNumRows ( ) < config . getMaxIntermediateRows ( ) ) {
if ( unprocessedKeys ! = null ) {
@JsonTypeName ( "str" )
import io . druid . segment . IndexMerger ;
IndexMerger . mergeQueryableIndex ( indexes , schema . getAggregators ( ) , fileToUpload , config . getIndexSpec ( ) ) ;
IndexMerger . persist (
return new ColumnAnalysis ( typeName , 0 , null , null ) ;
return new ColumnAnalysis ( typeName , size , null , null ) ;
Preconditions . checkNotNull ( pathSpec , "str" ) ;
@JsonProperty ( "str" ) String nick ,
String . format ( "str" , tableName ) ,
if ( jarFile . getName ( ) . matches ( "str" ) | | ! fs . exists ( hdfsPath ) ) {
String . format ( "str" , table ) ,
ImmutableList . < Module > of ( simpleJsonConfigModule )
ImmutableList . < Module > of ( simpleZkConfigModule )
@Consumes ( { MediaType . APPLICATION_JSON , SmileMediaTypes . APPLICATION_JACKSON_SMILE , APPLICATION_SMILE } )
ServerDiscoverySelector retVal = selectorMap . get ( brokerServiceName ) ;
retVal = selectorMap . get ( tierConfig . getDefaultBrokerServiceName ( ) ) ;
final ServerDiscoverySelector retVal = selectorMap . get ( brokerServiceName ) ;
Key . get ( ServiceAnnouncingChatHandlerProvider . class )
binder , Key . get ( DruidNode . class , Self . class ) , new DruidNode ( "str" , "str" , null )
EasyMock . expectLastCall ( ) . times ( 1 ) ;
queryNotifyLatch . await ( 1000 , TimeUnit . MILLISECONDS ) ;
queryNotifyLatch . await ( 1000 , TimeUnit . MILLISECONDS ) ;
queryNotifyLatch . await ( 1000 , TimeUnit . MILLISECONDS ) ;
queryNotifyLatch . await ( 1000 , TimeUnit . MILLISECONDS ) ;
waitYieldLatch . await ( 1000 , TimeUnit . MILLISECONDS ) ;
waitLatch . await ( 1000 , TimeUnit . MILLISECONDS ) ;
@JsonTypeInfo ( use = JsonTypeInfo . Id . NAME , property = "str" , defaultImpl = BatchServerInventoryViewProvider . class )
@JsonTypeInfo ( use = JsonTypeInfo . Id . NAME , property = "str" , defaultImpl = FilteredBatchServerViewProvider . class )
private int numConnections = 20 ;
"str" , indexOutURI . toString ( )
private int announceIntervalMillis = 0 ;
metricsSet . addAll ( timelineObjectHolder . getObject ( ) . getChunk ( 0 ) . getObject ( ) . getMetrics ( ) ) ;
Math . min ( interval . getStartMillis ( ) + offset , now + offset ) ,
holder . addCallback ( callback ) ;
holder . addCallback ( callback ) ;
return ByteBuffer . allocate ( dimensionBytes . length + directionBytes . length )
"str" + bound +
log . info ( "str" , basePath , segment . getIdentifier ( ) ) ;
Key . get ( NoopChatHandlerProvider . class )
Key . get ( NoopChatHandlerProvider . class )
log . info ( "str" , request . asString ( ) , path ) ;
log . info ( "str" , request . asString ( ) ) ;
log . info ( "str" , event . getData ( ) . getPath ( ) ) ;
return String . format ( "str" , segment . getIdentifier ( ) ) ;
return String . format ( "str" , segment . getIdentifier ( ) ) ;
@JsonTypeInfo ( use = JsonTypeInfo . Id . NAME , property = "str" , defaultImpl = HighestPriorityTierSelectorStrategy . class )
JsonConfigProvider . bind ( binder , "str" , TierSelectorStrategy . class ) ;
Key . get ( ServiceAnnouncingChatHandlerProvider . class )
Key . get ( ServiceAnnouncingChatHandlerProvider . class )
private int dropSegmentDelayMillis = 30 * 1000 ;
@JsonProperty ( "str" ) RejectionPolicyFactory rejectionPolicyFactory ,
@JsonProperty ( "str" ) RejectionPolicyFactory rejectionPolicyFactory ,
this . tuningConfig = tuningConfig = = null ? new IndexTuningConfig ( 0 , 0 ) : tuningConfig ;
@QueryParam ( "str" ) String full
this ( 15 * 60 * 1000L , 524288000L , 100 , 5 , 15 , 10 , 1 , false ) ;
this ( 15 * 60 * 1000L , 100000000L , 100 , 5 , 15 , 10 , 1 , false ) ;
JsonConfigProvider . bind ( binder , "str" , ServerSelectorStrategy . class ) ;
Math . max ( Runtime . getRuntime ( ) . availableProcessors ( ) - 1 , 1 )
null , null , null , null
null , null , null , null
null , null , null , null
this . balancerReferenceTimestamp = DateTime . now ( ) ;
return currInterval . overlaps ( interval ) & & interval . getStartMillis ( ) > = currInterval . getStartMillis ( ) ;
Assert . assertTrue ( rule . appliesTo ( builder . interval ( new Interval ( "str" ) ) . build ( ) , now ) ) ;
Assert . assertTrue (
& & cacheConfig . isUseCache ( ) ;
final int priority = query . getContextPriority ( 0 ) ;
if ( row = = null | | row . size ( ) = = 0 ) {
public QueryIDProvider ( @Self DruidNode node )
private final QueryIDProvider idProvider ;
private final QueryToolChestWarehouse warehouse ;
this . warehouse = warehouse ;
return new DirectDruidClient ( warehouse , smileMapper , httpClient , server . getHost ( ) ) ;
String invalidURL = "str" ;
@Path ( "str" )
@Path ( "str" )
Preconditions . checkArgument ( maxPendingPersists < = 0 , "str" ) ;
Assert . assertEquals ( INSTANCE_ID , deleted . getNodeIds ( ) . get ( 0 ) ) ;
catch ( Exception e ) {
import org . jets3t . service . impl . rest . httpclient . RestS3Service ;
private final RestS3Service s3Client ;
@JacksonInject ( "str" ) RestS3Service s3Client ,
new Rename ( "str" , "str" ) ,
Key . get ( DbSegmentPublisher . class )
publisherBinder . addBinding ( "str" ) . to ( NoopSegmentPublisher . class ) ;
this . isSmile = this . objectMapper . getFactory ( ) instanceof SmileFactory ;
jp = objectMapper . getFactory ( ) . createParser ( future . get ( ) ) ;
retVal . getFactory ( ) . setCodec ( retVal ) ;
private int numThreads = Math . max ( 10 , Runtime . getRuntime ( ) . availableProcessors ( ) + 1 ) ;
> = config . getWorkerIdleTimeout ( ) . toStandardDuration ( ) . getMillis ( ) ;
Assert . assertTrue ( "str" , queryNotifyLatch . await ( 100 , TimeUnit . MILLISECONDS ) ) ;
log . info ( "str" , coordinate , clazz . getName ( ) ) ;
log . info ( "str" , module . getClass ( ) , clazz . getName ( ) ) ;
@Default ( "str" )
byte [ ] valueBytes = ( value = = null ) ? new byte [ ] { } : value . getBytes ( ) ;
RemoteTaskRunnerWorkItem taskRunnerWorkItem = runningTasks . remove ( assignedTask ) ;
Assert . assertEquals ( 1 , referenceCountingSegment . getNumReferences ( ) ) ;
Assert . assertEquals ( 1 , factory . getAdapters ( ) . size ( ) ) ;
log . debug (
log . debug ( "str" , ips , retVal ) ;
log . debug ( "str" , nodeIds , retVal ) ;
@Config ( "str" )
return getCurrCapacityUsed ( ) > = worker . getCapacity ( ) ;
return ( worker . getCapacity ( ) - getCurrCapacityUsed ( ) > = task . getTaskResource ( ) . getRequiredCapacity ( )
return - Ints . compare ( zkWorker . getCurrCapacityUsed ( ) , zkWorker2 . getCurrCapacityUsed ( ) ) ;
super ( null , null , null , null , null ) ;
private ScheduledExecutorFactory scheduledExecutorFactory ;
log . makeAlert ( e , "str" )
runningTasks . remove ( taskId ) ;
log . debug ( "str" , zkWorkers . values ( ) ) ;
log . info ( "str" , deadContainer ) ;
private final List < OrderByColumnSpec > columns ;
@JsonProperty ( "str" ) List < OrderByColumnSpec > columns ,
this . columns = ( columns = = null ) ? ImmutableList . < OrderByColumnSpec > of ( ) : columns ;
public List < OrderByColumnSpec > getColumns ( )
for ( OrderByColumnSpec columnSpec : columns ) {
"str" + columns + "str" +
@JsonProperty ( "str" )
File cacheFile = getLocalStorageDir ( segment ) ;
root . addFilter ( GuiceFilter . class , "str" , 0 ) ;
@Path ( "str" )
root . addFilter ( GuiceFilter . class , "str" , 0 ) ;
log . info ( "str" , taskId ) ;
Set < String > tasksToRetry = Sets . newHashSet (
@QueryParam ( "str" ) String interval
@QueryParam ( "str" ) String interval
return ( server . getSegment ( segment . getIdentifier ( ) ) ! = null | | peon . getSegmentsToLoad ( ) . contains ( segment ) ) ;
this . rejectionPolicyFactory = rejectionPolicyFactory = = null ? new ServerTimeRejectionPolicyFactory ( ) : rejectionPolicyFactory ;
} else if ( config . getStrategyImpl ( ) . equalsIgnoreCase ( "str" ) ) {
this ( entity , resultReader , joinPaths , null ) ;
this . startingPrefix = startingPrefix ;
Object associated = readAssociation ( hasPrefix ? prefix : "str" , ( hasPath ? path : "str" ) , rs , ( Association ) prop , hasPrefix ) ;
Object associated = readAssociation ( prefix , ( hasPath ? path : "str" ) , rs , association , hasPrefix ) ;
Object associated = readAssociation ( prefix , ( hasPath ? path : "str" ) , rs , association , hasPrefix ) ;
Object associated = readAssociation ( hasPrefix ? prefix : "str" , ( hasPath ? path : "str" ) , rs , association , hasPrefix ) ;
private Object readAssociation ( String prefix , String path , RS resultSet , Association association , boolean hasPrefix ) {
! hasPrefix ? "str" + association . getAliasName ( ) : prefix + association . getAliasName ( )
Object v = resultReader . readDynamic ( resultSet , hasPrefix ? prefix + persistedName : persistedName , identity . getDataType ( ) ) ;
Object v = resultReader . readDynamic ( resultSet , hasPrefix ? prefix + persistedName : persistedName , identity . getDataType ( ) ) ;
public MethodMatchInfo buildMatchInfo ( @NonNull MethodMatchContext matchContext ) {
import edu . umd . cs . findbugs . annotations . NonNull ;
@NonNull String getName ( ) ;
@NonNull List < PersistentProperty > getPersistentProperties ( ) ;
@NonNull List < Association > getAssociations ( ) ;
@NonNull List < Embedded > getEmbedded ( ) ;
@NonNull List < String > getPersistentPropertyNames ( ) ;
default @NonNull String getDecapitalizedName ( ) {
default @NonNull PersistentEntity getRootEntity ( ) {
static @NonNull PersistentEntity of ( @NonNull Class < ? > type ) {
static @NonNull PersistentEntity of ( @NonNull BeanIntrospection < ? > introspection ) {
public MethodMatchInfo buildMatchInfo ( @NonNull MethodMatchContext matchContext ) {
import edu . umd . cs . findbugs . annotations . NonNull ;
import edu . umd . cs . findbugs . annotations . Nullable ;
protected boolean isValidReturnType ( @NonNull ClassElement returnType , MatchContext matchContext ) {
import edu . umd . cs . findbugs . annotations . NonNull ;
DefaultExistsByInterceptor ( @NonNull Datastore datastore ) {
import edu . umd . cs . findbugs . annotations . NonNull ;
@NonNull Criteria idEquals ( QueryParameter parameter ) ;
@NonNull Criteria isEmpty ( @NonNull String propertyName ) ;
@NonNull Criteria isNotEmpty ( @NonNull String propertyName ) ;
@NonNull Criteria isNull ( @NonNull String propertyName ) ;
@NonNull Criteria isNotNull ( String propertyName ) ;
@NonNull Criteria eq ( String propertyName , QueryParameter parameter ) ;
@NonNull Criteria idEq ( QueryParameter parameter ) ;
@NonNull Criteria ne ( @NonNull String propertyName , @NonNull QueryParameter parameter ) ;
@NonNull Criteria between ( @NonNull String propertyName , @NonNull QueryParameter start , @NonNull QueryParameter finish ) ;
@NonNull Criteria gte ( @NonNull String property , @NonNull QueryParameter parameter ) ;
@NonNull Criteria ge ( @NonNull String property , @NonNull QueryParameter parameter ) ;
@NonNull Criteria gt ( @NonNull String property , @NonNull QueryParameter parameter ) ;
@NonNull Criteria lte ( @NonNull String property , @NonNull QueryParameter parameter ) ;
@NonNull Criteria le ( @NonNull String property , @NonNull QueryParameter parameter ) ;
@NonNull Criteria lt ( @NonNull String property , @NonNull QueryParameter parameter ) ;
@NonNull Criteria like ( @NonNull String propertyName , @NonNull QueryParameter parameter ) ;
@NonNull Criteria ilike ( @NonNull String propertyName , @NonNull QueryParameter parameter ) ;
@NonNull Criteria rlike ( @NonNull String propertyName , @NonNull QueryParameter parameter ) ;
@NonNull Criteria and ( @NonNull Criteria other ) ;
@NonNull Criteria or ( @NonNull Criteria other ) ;
@NonNull Criteria not ( @NonNull Criteria other ) ;
@NonNull Criteria inList ( @NonNull String propertyName , @NonNull Query subquery ) ;
@NonNull Criteria inList ( @NonNull String propertyName , @NonNull QueryParameter parameter ) ;
@NonNull Criteria notIn ( @NonNull String propertyName , @NonNull Query subquery ) ;
@NonNull Criteria sizeEq ( @NonNull String propertyName , @NonNull QueryParameter size ) ;
@NonNull Criteria sizeGt ( @NonNull String propertyName , @NonNull QueryParameter size ) ;
@NonNull Criteria sizeGe ( @NonNull String propertyName , @NonNull QueryParameter size ) ;
@NonNull Criteria sizeLe ( @NonNull String propertyName , @NonNull QueryParameter size ) ;
@NonNull Criteria sizeLt ( @NonNull String propertyName , @NonNull QueryParameter size ) ;
@NonNull Criteria sizeNe ( @NonNull String propertyName , @NonNull QueryParameter size ) ;
@NonNull Criteria eqProperty ( @NonNull java . lang . String propertyName , @NonNull java . lang . String otherPropertyName ) ;
@NonNull Criteria neProperty ( @NonNull java . lang . String propertyName , @NonNull java . lang . String otherPropertyName ) ;
@NonNull Criteria gtProperty ( @NonNull java . lang . String propertyName , @NonNull java . lang . String otherPropertyName ) ;
@NonNull Criteria geProperty ( @NonNull java . lang . String propertyName , @NonNull java . lang . String otherPropertyName ) ;
@NonNull Criteria ltProperty ( @NonNull java . lang . String propertyName , @NonNull java . lang . String otherPropertyName ) ;
@NonNull Criteria leProperty ( java . lang . String propertyName , @NonNull java . lang . String otherPropertyName ) ;
@NonNull Criteria allEq ( @NonNull Map < String , QueryParameter > propertyValues ) ;
@NonNull Criteria eqAll ( @NonNull String propertyName , @NonNull Criteria propertyValue ) ;
@NonNull Criteria gtAll ( @NonNull String propertyName , @NonNull Criteria propertyValue ) ;
@NonNull Criteria ltAll ( @NonNull String propertyName , @NonNull Criteria propertyValue ) ;
@NonNull Criteria geAll ( @NonNull String propertyName , @NonNull Criteria propertyValue ) ;
@NonNull Criteria leAll ( @NonNull String propertyName , @NonNull Criteria propertyValue ) ;
@NonNull Criteria gtSome ( @NonNull String propertyName , @NonNull Criteria propertyValue ) ;
@NonNull Criteria geSome ( @NonNull String propertyName , @NonNull Criteria propertyValue ) ;
@NonNull Criteria ltSome ( @NonNull String propertyName , @NonNull Criteria propertyValue ) ;
@NonNull Criteria leSome ( @NonNull String propertyName , @NonNull Criteria propertyValue ) ;
import edu . umd . cs . findbugs . annotations . NonNull ;
DefaultDeleteOneInterceptor ( @NonNull Datastore datastore ) {
protected HibernateJpaDatastore ( @NonNull SessionFactory sessionFactory ) {
public < T > T findOne ( @NonNull Class < T > type , @NonNull Serializable id ) {
public < T > T findOne ( @NonNull Class < T > resultType , @NonNull String query , @NonNull Map < String , Object > parameters ) {
public < T > Iterable < T > findAll ( @NonNull Class < T > rootEntity , @NonNull Pageable pageable ) {
public < T > long count ( @NonNull Class < T > rootEntity , @NonNull Pageable pageable ) {
public < T > T persist ( @NonNull T entity ) {
public < T > Iterable < T > persistAll ( @NonNull Iterable < T > entities ) {
public < T > void deleteAll ( @NonNull Class < T > entityType , @NonNull Iterable < ? extends T > entities ) {
public < T > void deleteAll ( @NonNull Class < T > entityType ) {
private < T > void bindParameters ( @NonNull Query < T > query , Map < String , Object > parameters ) {
private < T > void bindPageable ( Query < T > q , @NonNull Pageable pageable ) {
private < T > void bindCriteriaSort ( CriteriaQuery < T > criteriaQuery , Root < ? > root , CriteriaBuilder builder , @NonNull Sort sort ) {
import edu . umd . cs . findbugs . annotations . Nullable ;
import edu . umd . cs . findbugs . annotations . NonNull ;
public QueryParameter ( @NonNull String name ) {
public static @NonNull QueryParameter of ( @NonNull String name ) {
import edu . umd . cs . findbugs . annotations . Nullable ;
import edu . umd . cs . findbugs . annotations . NonNull ;
import edu . umd . cs . findbugs . annotations . NonNull ;
DefaultCountInterceptor ( @NonNull Datastore datastore ) {
import edu . umd . cs . findbugs . annotations . NonNull ;
public DefaultFindOptionalInterceptor ( @NonNull Datastore datastore ) {
import edu . umd . cs . findbugs . annotations . NonNull ;
import edu . umd . cs . findbugs . annotations . Nullable ;
@NonNull MethodMatchContext matchContext ) {
@NonNull String getName ( ) ;
default @NonNull String getCapitilizedName ( ) {
@NonNull String getTypeName ( ) ;
@NonNull PersistentEntity getOwner ( ) ;
import edu . umd . cs . findbugs . annotations . NonNull ;
protected boolean isValidReturnType ( @NonNull ClassElement returnType , MatchContext matchContext ) {
protected MethodMatchInfo buildMatchInfo ( @NonNull MethodMatchContext matchContext , @NonNull RawQuery query ) {
import edu . umd . cs . findbugs . annotations . NonNull ;
public AssociationQuery ( @NonNull Association association ) {
@NonNull String getQuery ( ) ;
@NonNull Map < String , String > getParameters ( ) ;
import edu . umd . cs . findbugs . annotations . NonNull ;
import edu . umd . cs . findbugs . annotations . NonNull ;
import edu . umd . cs . findbugs . annotations . NonNull ;
import edu . umd . cs . findbugs . annotations . NonNull ;
public PreparedQuery buildQuery ( @NonNull Query query ) {
public PreparedQuery buildUpdate ( @NonNull Query query , List < String > propertiesToUpdate ) {
public PreparedQuery buildDelete ( @NonNull Query query ) {
import edu . umd . cs . findbugs . annotations . NonNull ;
protected DefaultQuery ( @NonNull PersistentEntity entity ) {
public @NonNull Query add ( @NonNull Query . Criterion criterion ) {
public Criteria eqAll ( @NonNull String propertyName , @NonNull Criteria propertyValue ) {
public Criteria gtAll ( @NonNull String propertyName , @NonNull Criteria propertyValue ) {
public Criteria ltAll ( @NonNull String propertyName , @NonNull Criteria propertyValue ) {
public Criteria geAll ( @NonNull String propertyName , @NonNull Criteria propertyValue ) {
public Criteria leAll ( @NonNull String propertyName , @NonNull Criteria propertyValue ) {
public Criteria gtSome ( @NonNull String propertyName , @NonNull Criteria propertyValue ) {
public Criteria geSome ( @NonNull String propertyName , @NonNull Criteria propertyValue ) {
public Criteria ltSome ( @NonNull String propertyName , @NonNull Criteria propertyValue ) {
public Criteria leSome ( @NonNull String propertyName , @NonNull Criteria propertyValue ) {
public Criteria ne ( @NonNull String propertyName , @NonNull QueryParameter parameter ) {
public DefaultQuery like ( @NonNull String propertyName , @NonNull QueryParameter parameter ) {
public DefaultQuery ilike ( @NonNull String propertyName , @NonNull QueryParameter parameter ) {
public DefaultQuery rlike ( @NonNull String propertyName , @NonNull QueryParameter parameter ) {
public Criteria and ( @NonNull Criteria other ) {
public Criteria or ( @NonNull Criteria other ) {
public Criteria not ( @NonNull Criteria other ) {
public DefaultQuery inList ( @NonNull String propertyName , @NonNull Query subquery ) {
public DefaultQuery notIn ( @NonNull String propertyName , @NonNull Query subquery ) {
public DefaultQuery sizeEq ( @NonNull String propertyName , @NonNull QueryParameter size ) {
public DefaultQuery sizeGt ( @NonNull String propertyName , @NonNull QueryParameter size ) {
public DefaultQuery sizeGe ( @NonNull String propertyName , @NonNull QueryParameter size ) {
public DefaultQuery sizeLe ( @NonNull String propertyName , @NonNull QueryParameter size ) {
public DefaultQuery sizeLt ( @NonNull String propertyName , @NonNull QueryParameter size ) {
public DefaultQuery sizeNe ( @NonNull String propertyName , @NonNull QueryParameter size ) {
public DefaultQuery eqProperty ( @NonNull String propertyName , @NonNull String otherPropertyName ) {
public DefaultQuery neProperty ( @NonNull String propertyName , @NonNull String otherPropertyName ) {
public DefaultQuery gtProperty ( @NonNull String propertyName , @NonNull String otherPropertyName ) {
public DefaultQuery geProperty ( @NonNull String propertyName , @NonNull String otherPropertyName ) {
public DefaultQuery ltProperty ( @NonNull String propertyName , @NonNull String otherPropertyName ) {
public DefaultQuery leProperty ( String propertyName , @NonNull String otherPropertyName ) {
protected AbstractPatternBasedMethod ( @NonNull Pattern pattern ) {
protected void matchProjections ( @NonNull MethodMatchContext matchContext , List < ProjectionMethodExpression > projectionExpressions , String projectionSequence ) {
import edu . umd . cs . findbugs . annotations . NonNull ;
public DefaultDeleteAllInterceptor ( @NonNull Datastore datastore ) {
public MethodMatchInfo buildMatchInfo ( @NonNull MethodMatchContext matchContext ) {
public MethodMatchInfo buildMatchInfo ( @NonNull MethodMatchContext matchContext ) {
import edu . umd . cs . findbugs . annotations . NonNull ;
public MethodMatchInfo buildMatchInfo ( @NonNull MethodMatchContext matchContext ) {
import edu . umd . cs . findbugs . annotations . NonNull ;
public @NonNull DefaultSort order ( @NonNull Order order ) {
public @NonNull List < Order > getOrderBy ( ) {
public DefaultSort order ( @NonNull String propertyName ) {
public DefaultSort order ( @NonNull String propertyName , @NonNull Order . Direction direction ) {
import edu . umd . cs . findbugs . annotations . Nullable ;
import edu . umd . cs . findbugs . annotations . NonNull ;
protected DefaultFindOneInterceptor ( @NonNull Datastore datastore ) {
import edu . umd . cs . findbugs . annotations . Nullable ;
import edu . umd . cs . findbugs . annotations . NonNull ;
protected boolean isValidReturnType ( @NonNull ClassElement returnType , MatchContext matchContext ) {
public final MethodMatchInfo buildMatchInfo ( @NonNull MethodMatchContext matchContext ) {
protected MethodMatchInfo buildMatchInfo ( @NonNull MethodMatchContext matchContext , @NonNull RawQuery query ) {
private RawQuery buildRawQuery ( @NonNull MethodMatchContext matchContext ) {
import edu . umd . cs . findbugs . annotations . NonNull ;
public Sort order ( @NonNull String propertyName ) {
public Sort order ( @NonNull Order order ) {
public Sort order ( @NonNull String propertyName , @NonNull Order . Direction direction ) {
import edu . umd . cs . findbugs . annotations . NonNull ;
import edu . umd . cs . findbugs . annotations . NonNull ;
protected boolean isValidReturnType ( @NonNull ClassElement returnType , MatchContext matchContext ) {
import edu . umd . cs . findbugs . annotations . Nullable ;
import edu . umd . cs . findbugs . annotations . NonNull ;
import edu . umd . cs . findbugs . annotations . NonNull ;
protected RawQuery ( @NonNull PersistentEntity entity , @NonNull Map < String , String > parameterBinding ) {
protected boolean isValidReturnType ( @NonNull ClassElement returnType , MatchContext matchContext ) {
} while ( ! shape . relate ( p ) . intersects ( ) ) ;
context . startActivity ( intent ) ;
mNavigator . switchTo ( tabIdToScreenName ( tabId ) ) ;
equalTo ( "str" ) ) ;
} catch ( final IllegalAccessException ex ) {
@SupportedSourceVersion ( SourceVersion . RELEASE_7 )
@Test ( expected = Exception . class )
@Test ( expected = RuntimeException . class )
import java . util . LinkedHashSet ;
final Set < K > keys = new LinkedHashSet < K > ( this . entries . length ) ;
new LinkedHashSet < Map . Entry < K , V > > ( Arrays . asList ( this . entries ) )
@Target ( ElementType . TYPE )
if ( method . isAnnotationPresent ( Valid . class ) & & result ! = null ) {
if ( Logger . isDebugEnabled ( method . getDeclaringClass ( ) ) ) {
throw new IllegalStateException ( "str" ) ;
@Around ( "str" )
method . getDeclaringClass ( ) . getAnnotation ( Loggable . class )
@Around ( "str" )
@Around ( "str" )
if ( attempt > = rof . attempts ( ) ) {
if ( arg ! = null & & ! arg . toString ( )
@Target ( ElementType . METHOD )
Set < String > hs = new TreeSet < String > ( ) ;
int mNum = m / 5 ;
hmDistance = Math . min ( hmDistance ( hashCode , hc ) , hmDistance ) ;
protected static final String DATEPICKER_POPUP_ATTRIBUTE = "str" ;
TaskEntity task = new TaskEntity ( ) ;
TaskEntity task = new TaskEntity ( ) ;
TaskEntity task = new TaskEntity ( ) ;
@WatchLogger ( loggerNames = CONTEXT_LOGGER , level = "str" )
@WatchLogger ( loggerNames = CONTEXT_LOGGER , level = "str" )
return value . contains ( "str" ) ;
return new ProcessEngineException ( exceptionMessage ( "str" , "str" , variable , type ) ) ;
saxParser . setProperty ( "str" , "str" ) ;
addWarning ( "str" + elementName + "str" + linkName
if ( category ! = null | | processDefinitionKey ! = null ) {
flushDbOperations ( batch , operationsToFlush ) ;
protected void flushDbOperations ( List < DbOperation > operationsToFlush , List < DbOperation > allOperations ) {
throw LOG . flushDbOperationException ( allOperations , dbOperation , e ) ;
throw LOG . flushDbOperationsException ( allOperations , e ) ;
this . ids = ids ! = null ? Arrays . asList ( ids ) : null ;
@RequiredHistoryLevel ( ProcessEngineConfiguration . HISTORY_FULL )
@RequiredHistoryLevel ( ProcessEngineConfiguration . HISTORY_FULL )
assertThat ( historicIncident . getCreateTime ( ) ) . isEqualTo ( CREATE_TIME ) ;
assertThat ( exceptions . size ( ) , is ( 0 ) ) ;
assertEquals ( 0 , exceptions . size ( ) ) ;
assertThat ( managementService . createJobQuery ( ) . withException ( ) . list ( ) . size ( ) , is ( 0 ) ) ;
return new BatchConfiguration ( processInstanceIds , false ) ;
return new DeleteProcessInstanceBatchConfiguration ( processInstanceIds , deleteReason , skipCustomListeners , skipSubprocesses , false ) ;
. statusCode ( Status . NOT_FOUND . getStatusCode ( ) )
if ( ! isCurrentUserAuthorized ) {
. post ( USER_UNLOCK ) ;
. post ( USER_UNLOCK ) ;
. post ( USER_UNLOCK ) ;
public void setVariable ( String taskId , String variableName , Object value ) {
setVariables ( taskId , variables , false ) ;
public void setVariableLocal ( String taskId , String variableName , Object value ) {
setVariables ( taskId , variables , true ) ;
protected void setVariables ( String taskId , Map < String , ? extends Object > variables , boolean local ) {
commandExecutor . execute ( new SetTaskVariablesCmd ( taskId , variables , local ) ) ;
return value > 1 & & ( value & ( value - 1 ) ) = = 0 ;
throw new InvalidRequestException ( Status . BAD_REQUEST , "str" + fileName + "str" ) ;
return Context . getProcessEngineConfiguration ( )
return Context . getProcessEngineConfiguration ( )
processEngineConfiguration . setJdbcUrl ( "str" + CustomHistoryLevelIncident . class . getSimpleName ( ) ) ;
return evt . getProcessInstanceId ( ) . equals ( evt . getRootProcessInstanceId ( ) ) ;
if ( type ! = null & & type . equals ( INTERMEDIATE_TIMER ) | | isAsync ( activity ) ) {
assertEquals ( fixedDate . toString ( ) , byteArrayEntity . getCreateTime ( ) . toString ( ) ) ;
assertEquals ( expectedDate . toString ( ) , entity . getCreateTime ( ) . toString ( ) ) ;
return Variables . objectValue ( untypedValue . getValue ( ) , untypedValue . isTransient ( ) ) . create ( ) ;
return Variables . byteArrayValue ( ( byte [ ] ) value , untypedValue . isTransient ( ) ) ;
return Variables . byteArrayValue ( data , untypedValue . isTransient ( ) ) ;
return Variables . doubleValue ( ( Double ) untypedValue . getValue ( ) , untypedValue . isTransient ( ) ) ;
TypedValue typedValue = Variables . untypedValue ( value , true ) ;
assertTextPresent ( "str" , e . getMessage ( ) ) ;
return Variables . objectValue ( untypedValue . getValue ( ) , untypedValue . isTransient ( ) ) . create ( ) ;
assertTextPresent ( "str" , e . getMessage ( ) ) ;
return Variables . shortValue ( ( Short ) untypedValue . getValue ( ) , untypedValue . isTransient ( ) ) ;
return Variables . integerValue ( ( Integer ) untypedValue . getValue ( ) , untypedValue . isTransient ( ) ) ;
return Variables . longValue ( ( Long ) untypedValue . getValue ( ) , untypedValue . isTransient ( ) ) ;
return Variables . booleanValue ( ( Boolean ) untypedValue . getValue ( ) , untypedValue . isTransient ( ) ) ;
return Variables . stringValue ( ( String ) untypedValue . getValue ( ) , untypedValue . isTransient ( ) ) ;
return Variables . dateValue ( ( Date ) untypedValue . getValue ( ) , untypedValue . isTransient ( ) ) ;
return ! untypedValue . isTransient ( ) ? NullValueImpl . INSTANCE : NullValueImpl . INSTANCE_TRANSIENT ;
TypedValue previousTypeValue = getVariableInstanceLocal ( variableName ) . getTypedValue ( false ) ;
. queryParam ( "str" , true )
private Boolean startablePermissionCheck ;
if ( TRUE . equals ( startablePermissionCheck ) ) {
protected String resourceWhitelistPattern = "str" ;
ProcessInstance processInstance = engineRule . getRuntimeService ( ) . createProcessInstanceQuery ( ) . processInstanceBusinessKey ( "str" ) . singleResult ( ) ;
ProcessInstance processInstance = engine . getRuntimeService ( ) . startProcessInstanceByKey ( "str" , "str" ) ;
constants . put ( "str" , "str" ) ;
constants . put ( "str" , "str" ) ;
if ( artifactFactory = = null & & applicationContext ! = null ) {
assertEquals ( from , mimeMessage . getHeader ( "str" , null ) ) ;
assertEquals ( from , mimeMessage . getHeader ( "str" , null ) ) ;
assertEquals ( from , mimeMessage . getHeader ( "str" , null ) ) ;
assertEquals ( from , mimeMessage . getHeader ( "str" , null ) ) ;
private static final SimpleDateFormat TIME_FORMAT_WITHOUT_SECONDS_WITH_TIMEZONE = new SimpleDateFormat ( "str" ) ;
private static final SimpleDateFormat DATE_FORMAT_WITHOUT_TIME = new SimpleDateFormat ( "str" ) ;
public static synchronized Date parseTimeConfiguration ( String time ) throws ParseException {
final WebArchive webArchive = initWebArchiveDeployment ( "str" , "str" )
final WebArchive webArchive = initWebArchiveDeployment ( "str" , "str" )
addError ( "str" + bpmnElement + "str" , bpmnShapeElement ) ;
. body ( "str" , containsString ( "str" + invalidComparator ) )
. body ( "str" , containsString ( "str" + invalidComparator ) )
thrown . expectMessage ( "str" ) ;
addError ( "str" + ( ( ConditionalEventDefinition ) subscription ) . getConditionAsString ( ) + "str" , element ) ;
engine1 . getRepositoryService ( ) . createDeploymentQuery ( ) . singleResult ( ) ;
engine1 . getManagementService ( ) . unregisterProcessApplication ( deployment . getId ( ) , false ) ;
engine1 . getRuntimeService ( ) . deleteProcessInstance ( processInstance . getId ( ) , "str" ) ;
processInstance = engine1 . getRuntimeService ( ) . startProcessInstanceByKey ( "str" ) ;
Job job = engine1 . getManagementService ( ) . createJobQuery ( ) . processInstanceId ( processInstance . getProcessInstanceId ( ) ) . singleResult ( ) ;
Job job = engine1 . getManagementService ( ) . createJobQuery ( ) . processInstanceId ( processInstance . getProcessInstanceId ( ) ) . singleResult ( ) ;
Job job = engine1 . getManagementService ( ) . createJobQuery ( ) . processInstanceId ( processInstance . getProcessInstanceId ( ) ) . singleResult ( ) ;
Job job = engine1 . getManagementService ( ) . createJobQuery ( ) . processInstanceId ( processInstance . getProcessInstanceId ( ) ) . singleResult ( ) ;
return initWebArchiveDeployment ( "str" , "str" )
protected Date endDate = new Date ( ClockUtil . getCurrentTime ( ) . getTime ( ) + 1000 ) ;
public void testGetDeployedTaskFormWithoutAuthorization ( ) {
ClockUtil . setCurrentTime ( DateUtils . addDays ( oldCurrentTime , - 6 ) ) ;
parsedBatchOperationsForHistoryCleanup = new HashMap < String , Integer > ( ) ;
public final static String HISTORY_CLEANUP_REMOVED_BATCH_OPERATIONS = "str" ;
final long removedBatches = managementService . createMetricsQuery ( ) . name ( Metrics . HISTORY_CLEANUP_REMOVED_BATCH_OPERATIONS ) . sum ( ) ;
recordValue ( Metrics . HISTORY_CLEANUP_REMOVED_BATCH_OPERATIONS , historicBatchIds . size ( ) ) ;
engineRule . getExternalTaskService ( ) . extendLock ( task . getId ( ) , "str" , 2000L ) ;
ensureNotNull ( BadUserRequestException . class , "str" , ( Object [ ] ) ids ) ;
ensureNotNull ( BadUserRequestException . class , "str" , ( Object [ ] ) ids ) ;
when ( runtimeServiceMock . createIncident ( anyString ( ) , anyString ( ) , anyString ( ) , anyString ( ) ) ) . thenReturn ( mock ( Incident . class ) ) ;
verify ( runtimeServiceMock ) . createIncident ( "str" , MockProvider . EXAMPLE_EXECUTION_ID , "str" , "str" ) ;
doThrow ( new BadUserRequestException ( ) ) . when ( runtimeServiceMock ) . createIncident ( anyString ( ) , anyString ( ) , anyString ( ) , anyString ( ) ) ;
assertTextPresent ( "str" , e . getCause ( ) . getMessage ( ) ) ;
assertTextPresent ( "str" , e . getCause ( ) . getMessage ( ) ) ;
assertTextPresent ( "str" , e . getCause ( ) . getMessage ( ) ) ;
configureQuery ( query , DECISION_DEFINITION , "str" , READ_HISTORY ) ;
configureQuery ( query , PROCESS_DEFINITION , "str" , READ_HISTORY ) ;
configureQuery ( query , PROCESS_DEFINITION , "str" , READ_HISTORY ) ;
configureQuery ( query , PROCESS_DEFINITION , "str" , READ_HISTORY ) ;
configureQuery ( query , PROCESS_DEFINITION , "str" , READ_HISTORY ) ;
configureQuery ( query , PROCESS_DEFINITION , "str" , READ_HISTORY ) ;
configureQuery ( query , PROCESS_DEFINITION , "str" , READ_HISTORY ) ;
configureQuery ( query , PROCESS_DEFINITION , "str" , READ_HISTORY ) ;
this . entityType = entityType ;
getAuthorizationManager ( ) . configureQuery ( parameterObject , Resources . PROCESS_DEFINITION , "str" , Permissions . READ , Permissions . READ_HISTORY ) ;
public static final String DEFAULT_DATE_FORMAT = "str" ;
databaseSpecificOrderByStatements . put ( MSSQL , defaultOrderBy ) ;
@Path ( "str" )
protected static final String FIND_HISTORY_CLEANUP_JOB_URL = TEST_RESOURCE_ROOT_PATH + "str" ;
return repositoryService . deployWithResult ( this ) ;
public DeploymentWithDefinitions deployWithResult ( DeploymentBuilderImpl deploymentBuilder ) {
LOG . debugHistoryCleanupWrongConfiguration ( ) ;
verify ( runtimeServiceMock ) . createModification ( null ) ;
verify ( runtimeServiceMock ) . createModification ( null ) ;
. addModelInstance ( "str" , modelInstance ) . deployWithResult ( ) ;
. addModelInstance ( "str" , modelInstance ) . deployWithResult ( ) ;
DeploymentWithDefinitions deployment = deploymentBuilder . deployWithResult ( ) ;
. addModelInstance ( "str" , modelInstance ) . deployWithResult ( ) ;
. addModelInstance ( "str" , modelInstance ) . deployWithResult ( ) ;
return deployWithResult ( ) ;
public DeploymentWithDefinitions deployWithResult ( ) {
. deployWithResult ( ) ;
when ( mockDeploymentBuilder . deployWithResult ( ) ) . thenReturn ( mockDeploymentWithDefinitions ) ;
when ( mockDeploymentBuilder . deployWithResult ( ) ) . thenReturn ( mockDeployment ) ;
when ( mockDeploymentBuilder . deployWithResult ( ) ) . thenReturn ( mockDeployment ) ;
when ( mockDeploymentBuilder . deployWithResult ( ) ) . thenReturn ( mockDeployment ) ;
when ( mockDeploymentBuilder . deployWithResult ( ) ) . thenReturn ( mockDeployment ) ;
when ( mockDeploymentBuilder . deployWithResult ( ) ) . thenReturn ( mockDeployment ) ;
when ( mockDeploymentBuilder . deployWithResult ( ) ) . thenThrow ( new AuthorizationException ( message ) ) ;
verify ( mockDeploymentBuilder ) . deployWithResult ( ) ;
verify ( mockDeploymentBuilder ) . deployWithResult ( ) ;
verify ( mockDeploymentBuilder ) . deployWithResult ( ) ;
verify ( mockDeploymentBuilder ) . deployWithResult ( ) ;
verify ( mockDeploymentBuilder ) . deployWithResult ( ) ;
verify ( mockDeploymentBuilder ) . deployWithResult ( ) ;
verify ( mockDeploymentBuilder ) . deployWithResult ( ) ;
verify ( mockDeploymentBuilder ) . deployWithResult ( ) ;
doThrow ( new NotFoundException ( message ) ) . when ( mockDeploymentBuilder ) . deployWithResult ( ) ;
doThrow ( new NotValidException ( message ) ) . when ( mockDeploymentBuilder ) . deployWithResult ( ) ;
doThrow ( new ProcessEngineException ( message ) ) . when ( mockDeploymentBuilder ) . deployWithResult ( ) ;
doThrow ( new AuthorizationException ( message ) ) . when ( mockDeploymentBuilder ) . deployWithResult ( ) ;
return builder . deployWithResult ( ) ;
DeploymentWithDefinitions deployWithResult ( ) ;
DeploymentWithDefinitions deployment = deploymentBuilder . deployWithResult ( ) ;
ProcessDefinition sourceDefinition1 = testRule
ProcessInstance processInstance1 = engineRule . getRuntimeService ( ) . startProcessInstanceById ( sourceDefinition1 . getId ( ) ) ;
ProcessInstance processInstance3 = engineRule . getRuntimeService ( ) . startProcessInstanceById ( sourceDefinition1 . getId ( ) ) ;
ProcessInstance processInstance5 = engineRule . getRuntimeService ( ) . startProcessInstanceById ( sourceDefinition1 . getId ( ) ) ;
firstLeaf . getSubProcessInstance ( ) . deleteCascade ( execution . getDeleteReason ( ) , firstLeaf . isSkipCustomListeners ( ) , firstLeaf . isSkipIoMappings ( ) ) ;
public RuleChain ruleChain = RuleChain . outerRule ( bootstrapRule ) . around ( engineRule ) . around ( testRule ) ;
engineRule . getProcessEngineConfiguration ( ) . setHistoryCleanupBatchWindowStartTime ( "str" ) ;
engineRule . getProcessEngineConfiguration ( ) . setHistoryCleanupBatchWindowEndTime ( "str" ) ;
public static final SimpleDateFormat TIME_FORMAT_WITHOUT_SECONDS_WITH_TIMEZONE = new SimpleDateFormat ( "str" ) ;
String procDefId = repositoryService . createProcessDefinitionQuery ( ) . singleResult ( ) . getId ( ) ;
assertTrue ( result . get ( 0 ) . getName ( ) . equals ( "str" ) ) ;
public List < User > findUsersWithoutGroupId ( LdapUserQueryImpl query , String userBaseDn , boolean ignorePagination ) {
while ( enumeration . hasMoreElements ( ) & & ( userList . size ( ) < query . getMaxResults ( ) | | ignorePagination ) ) {
String searchPattern = "str" ;
String searchPattern = "str" ;
String fromWhereClauses = String . format ( "str" ,
. beginScope ( "str" , "str" , "str" )
. beginScope ( "str" , "str" , "str" )
import org . camunda . bpm . engine . impl . persistence . AbstractHistoricManager ;
public class HistoricJobLogManager extends AbstractHistoricManager {
private static String PROCESS_DEFINITION_KEY_2 = "str" ;
. addClasspathResource ( "str" )
runtimeService . startProcessInstanceByKey ( PROCESS_DEFINITION_KEY_2 , "str" ) ;
repositoryService . suspendProcessDefinitionByKey ( PROCESS_DEFINITION_KEY ) ;
repositoryService . suspendProcessDefinitionByKey ( PROCESS_DEFINITION_KEY , true , null ) ;
repositoryService . suspendProcessDefinitionByKey ( PROCESS_DEFINITION_KEY ) ;
repositoryService . suspendProcessDefinitionByKey ( PROCESS_DEFINITION_KEY , true , null ) ;
wa . addAsLibraries ( resolver . resolve ( "str" ) . withTransitivity ( ) . asFile ( ) ) ;
if ( deployedDecisionDefinitions ! = null ) {
configureQuery ( query , PROCESS_DEFINITION , "str" , READ_HISTORY ) ;
@Deployment ( resources = { "str" } )
historicProcessInstance = historyService . createHistoricProcessInstanceQuery ( ) . executeActivityBefore ( hourBeforeNow . getTime ( ) ) . singleResult ( ) ;
schema = schema = = null ? schema : schema . toLowerCase ( ) ;
String schema = null ;
String defaultOrderBy = "str" ;
databaseSpecificOrderByStatements . put ( MSSQL , "str" ) ;
if ( processEngines ! = null & & processEngines . size ( ) = = 1 ) {
return new String [ ] { ProcessApplication . DEFAULT_META_INF_PROCESSES_XML } ;
String DEFAULT_META_INF_PROCESSES_XML = "str" ;
String [ ] deploymentDescriptors ( ) default { DEFAULT_META_INF_PROCESSES_XML } ;
import org . camunda . bpm . engine . impl . persistence . entity . EventSubscriptionEntity ;
private RuntimeService runtimeService ;
private BusinessProcess businessProcess ;
List < EventSubscriptionEntity > findSignalEventSubscriptionsByEventName = commandContext
for ( EventSubscriptionEntity signalEventSubscriptionEntity : findSignalEventSubscriptionsByEventName ) {
LOGGER . info ( "str" + execution . getVariable ( "str" ) + "str" ) ;
databaseSpecificToTimestamp2 . put ( POSTGRES , "str" ) ;
assertEquals ( 2 , taskReportResults . get ( 0 ) . getCount ( ) , 0 ) ;
assertEquals ( 2 , taskReportResults . get ( 1 ) . getCount ( ) , 0 ) ;
assertEquals ( 1 , taskReportResults . get ( 1 ) . getCount ( ) , 0 ) ;
verify ( externalTaskService ) . handleFailure ( "str" , "str" , "str" , null , 5 , 12345 ) ;
. handleFailure ( any ( String . class ) , any ( String . class ) , any ( String . class ) , any ( String . class ) , anyInt ( ) , anyLong ( ) ) ;
. handleFailure ( any ( String . class ) , any ( String . class ) , any ( String . class ) , any ( String . class ) , anyInt ( ) , anyLong ( ) ) ;
. handleFailure ( any ( String . class ) , any ( String . class ) , any ( String . class ) , any ( String . class ) , anyInt ( ) , anyLong ( ) ) ;
query . taskName ( "str" ) ;
public static final BpmnModelInstance ONE_TASK_PROCESS = Bpmn . createExecutableProcess ( "str" )
public static final BpmnModelInstance BOUNDARY_EVENT_PROCESS = Bpmn . createExecutableProcess ( "str" )
boolean isExecutable = ! deployment . isNew ( ) ;
public void FAILING_testShouldNotThrowErrorInLoopFromCallActivityToEventSubProcess ( ) {
if ( ( ! isReThrowingErrorEventSubprocess ( activityHandler ) ) & & ( ( exception ! = null & & errorEventDefinition . catchesException ( exception ) )
protected boolean isReThrowingErrorEventSubprocess ( PvmActivity activityHandler ) {
public MigratingActivityInstance getClosestAncestorActivityInstance ( ) {
MigratingActivityInstance ancestorInstance = migratingEventScopeInstance . getClosestAncestorActivityInstance ( ) ;
MigratingActivityInstance ancestorInstance = migratingEventSubscriptionInstance . getClosestAncestorActivityInstance ( ) ;
. hasInstructionFailures ( "str" , "str"
report . addFailure ( "str"
Boolean skipCustomListeners = ( Boolean ) migrationExecution . get ( MigrationExecutionDtoBuilder . PROP_SKIP_CUSTOM_LISTENERS ) ;
processEngine . getTaskService ( ) . complete ( task . getId ( ) , createVariables ( ) . putValue ( "str" , false ) ) ;
report . addFailure ( "str" ) ;
miBodyCollector . firstMiBody . getId ( ) + "str" ) ;
report . addFailure ( "str" ) ;
report . addFailure ( "str" + ancestorScopeInstruction . getSourceActivity ( ) . getId ( ) + "str" +
testRule . deployForTenant ( TENANT_ONE , Bpmn . createExecutableProcess ( "str" )
testRule . deployForTenant ( TENANT_TWO , Bpmn . createExecutableProcess ( "str" )
+ jobDefinition . getProcessDefinitionId ( ) + "str" ) ;
+ jobDefinition . getProcessDefinitionId ( ) + "str" ) ;
+ jobDefinition . getProcessDefinitionId ( ) + "str" ) ;
+ jobDefinition . getProcessDefinitionId ( ) + "str" ) ;
ProcessInstance newProcessInstance = engineRule . getRuntimeService ( ) . startProcessInstanceByKey ( key ) ;
protected int numOfThreads = Math . max ( 1 , Runtime . getRuntime ( ) . availableProcessors ( ) - 1 ) ;
configureQuery ( query , PROCESS_DEFINITION , "str" ) ;
public void attachState ( MigratingTransitionInstance targetTransitionInstance ) {
public void attachState ( MigratingTransitionInstance targetTransitionInstance ) {
public void attachState ( MigratingTransitionInstance targetTransitionInstance ) {
public void attachState ( MigratingTransitionInstance targetTransitionInstance ) {
public void attachState ( MigratingTransitionInstance targetTransitionInstance ) {
void attachState ( MigratingTransitionInstance targetTransitionInstance ) ;
public void attachState ( MigratingTransitionInstance targetTransitionInstance ) {
public void attachState ( MigratingTransitionInstance targetTransitionInstance ) {
dependentInstance . attachState ( targetTransitionInstance ) ;
protected int totalJobs ;
when ( historicBatch . getTotalJobs ( ) ) . thenReturn ( totalJobs ) ;
. totalJobs ( EXAMPLE_BATCH_TOTAL_JOBS )
. totalJobs ( EXAMPLE_BATCH_TOTAL_JOBS )
protected int totalJobs ;
when ( batch . getTotalJobs ( ) ) . thenReturn ( totalJobs ) ;
import java . util . Arrays ;
acquiredJobBatches . add ( Arrays . asList ( jobId ) ) ;
"str" , "str" , string ) ;
"str" , "str" , e . getMessage ( ) , e ) ;
Assert . assertEquals ( 6 , listenerInvocationCount . intValue ( ) ) ;
Assert . assertEquals ( 7 , listenerInvocationCount . intValue ( ) ) ;
Assert . assertEquals ( 5 , listenerInvocationCount . intValue ( ) ) ;
deploymentId = createDeployment ( null , "str" ,
throw new InvalidRequestException ( Status . BAD_REQUEST , e , "str" + batchId + "str" ) ;
throw new InvalidRequestException ( Status . BAD_REQUEST , e , "str" + batchId + "str" ) ;
@Deployment ( resources = { "str" } )
@Deployment ( resources = { "str" } )
@Deployment ( resources = { "str" } )
@Deployment ( resources = { "str" } )
@Deployment ( resources = { "str" } )
@Deployment ( resources = { "str" } )
@Deployment ( resources = { "str" } )
wait . until ( ExpectedConditions . textToBePresentInElementLocated ( By . cssSelector ( "str" ) , "str" ) ) ;
public class MultipartPayloadProvider implements MessageBodyReader < MultipartFormData > {
properties . put ( ServerProperties . TRACING , "str" ) ;
assertTextPresent ( "str" , e . getMessage ( ) ) ;
import org . camunda . bpm . engine . exception . NotValidException ;
webArchive . addAsLibraries ( DeploymentHelper . getSpinJacksonJsonDataFormatForServer ( "str" ) ) ;
webArchive . addAsLibraries ( DeploymentHelper . getJodaTimeModuleForServer ( "str" ) ) ;
inOrder . verify ( mockedQuery ) . orderByTenantId ( ) ;
inOrder . verify ( mockedQuery ) . orderByTenantId ( ) ;
configureQuery ( query , PROCESS_DEFINITION , "str" , READ_HISTORY ) ;
configureQuery ( query , PROCESS_DEFINITION , "str" , READ_HISTORY ) ;
configureQuery ( query , PROCESS_DEFINITION , "str" , READ_HISTORY ) ;
configureQuery ( query , PROCESS_DEFINITION , "str" , READ_HISTORY ) ;
configureQuery ( query , PROCESS_DEFINITION , "str" , READ_HISTORY ) ;
configureQuery ( query , PROCESS_DEFINITION , "str" , READ_HISTORY ) ;
configureQuery ( query , PROCESS_DEFINITION , "str" , READ_HISTORY ) ;
configureQuery ( query , DECISION_DEFINITION , "str" , READ_HISTORY ) ;
configureQuery ( query , PROCESS_DEFINITION , "str" , READ_HISTORY ) ;
inOrder . verify ( mockedQuery ) . orderByTenantId ( ) ;
String errorMessage = String . format ( "str" , caseDefinitionKey ) ;
String errorMessage = String . format ( "str" , decisionDefinitionKey ) ;
wait . until ( ExpectedConditions . textToBePresentInElementLocated ( By . tagName ( "str" ) , "str" ) ) ;
assertEquals ( 2 , definitionsJson . length ( ) ) ;
@ProcessApplication ( "str" )
@Deployment ( name = "str" )
return ShrinkWrap . create ( WebArchive . class , "str" )
@OperateOnDeployment ( "str" )
@OperateOnDeployment ( "str" )
@OperateOnDeployment ( "str" )
@OperateOnDeployment ( "str" )
public void testAddEscalationBoundaryEventToSubProcessAndThrowEscalation ( ) {
public static final String TIMER_DATE = "str" ;
"str" , "str" , job , exception ) ;
"str" , "str" , nextJobId , t ) ;
"str" , cause . getMessage ( ) , cause ) ;
@ProcessApplication ( "str" )
@ProcessApplication ( "str" )
( DataFormat < SpinXmlElement > ) dataFormats . getDataFormatByName ( DataFormats . XML_DATAFORMAT_NAME ) ;
this . dmnEngineConfiguration = dmnEngineConfiguration ;
if ( ! LOG . isInfoEnabled ( ) ) {
thrown . expectMessage ( "str" ) ;
"str" , jndi , string ) ;
return isDebugEnabled ( ) ;
"str" , serviceType , serviceName , t . getMessage ( ) , t ) ;
. resolve ( "str" )
assertEquals ( "str" , decisionDefinition . getCategory ( ) ) ;
assertEquals ( "str" , decisionDefinition . getCategory ( ) ) ;
public void noElResolverProvided ( String paName , String string ) {
. addAsResource ( "str" , "str" ) ;
protected static final String TEST_DECISION = "str" ;
public static final String DECISION_SINGLE_OUTPUT_DMN = "str" ;
. addAsResource ( "str" ) ;
protected static final String DMN_RESOURCE_NAME = "str" ;
public static final String [ ] DMN_RESOURCE_SUFFIXES = new String [ ] { "str" , "str" } ;
public static final String DMN_FILE = "str" ;
public static final String EXAMPLE_DEPLOYMENT_DMN_XML_RESOURCE_NAME = "str" ;
String resourceName = "str" ;
assertEquals ( resourcePrefix + "str" , decisionDefinition . getResourceName ( ) ) ;
return ( String ) result . getSingleOutput ( ) . get ( "str" ) ;
return ( String ) result . getSingleOutput ( ) . get ( "str" ) ;
wait . until ( ExpectedConditions . textToBePresentInElementLocated ( By . tagName ( "str" ) , "str" ) ) ;
. userEmailLike ( "str" )
processEngineConfiguration . getMetricsRegistry ( ) . getMeterByName ( Metrics . EXECUTED_DECISION_ELEMENTS ) . getAndClear ( ) ;
logDebug ( "str" , "str" , activityId ) ;
logDebug ( "str" , "str" , activityId ) ;
logDebug ( "str" , "str" , sequenceFlowId ) ;
logDebug ( "str" , "str" , activityId ) ;
logDebug ( "str" , "str" , activityId ) ;
logDebug ( "str" , "str" , activity ) ;
logDebug ( "str" , "str" , state ) ;
logDebug ( "str" , "str" , elementType , elementId ) ;
private static final int STATEMENT_TIMEOUT_IN_SECONDS = 1 ;
private static final int TEST_TIMEOUT_IN_MILLIS = 10000 ;
. setJdbcStatementTimeout ( STATEMENT_TIMEOUT_IN_SECONDS )
thread2 . waitForSync ( TEST_TIMEOUT_IN_MILLIS ) ;
protected String mailServerDefaultFrom = "str" ;
assertEmailSend ( message , false , "str" , "str" , "str" ,
assertEmailSend ( messages . get ( 0 ) , false , "str" , "str" , "str" ,
assertEmailSend ( messages . get ( 0 ) , true , "str" , "str" , "str" , Arrays . asList ( "str" ) , null ) ;
EmailServiceTaskTest . assertEmailSend ( message , false , "str" , "str" , "str" ,
EmailServiceTaskTest . assertEmailSend ( message , false , "str" , "str" , "str" ,
assertEmailSend ( message , false , "str" , "str" , "str" ,
assertEmailSend ( messages . get ( 0 ) , false , "str" , "str" , "str" ,
assertEmailSend ( messages . get ( 0 ) , true , "str" , "str" , "str" , Arrays . asList ( "str" ) , null ) ;
public static final String CAMUNDA_BPMN_EXTENSIONS_NS = "str" ;
return initWebArchiveDeployment ( "str" , "str" )
return initWebArchiveDeployment ( "str" , "str" )
public final static String VALUE_INFO_FILE_NAME = "str" ;
log . fine ( "str" + this ) ;
public void testCompensateSubprocessWithBoundaryEvent ( ) {
super . leave ( execution ) ;
assertEquals ( 3 , runtimeService . createEventSubscriptionQuery ( ) . count ( ) ) ;
Mockito . when ( mockClassloader . getResources ( Mockito . anyString ( ) ) ) . thenReturn ( Collections . enumeration ( Collections . < URL > emptyList ( ) ) ) ;
Mockito . when ( mockClassloader . getResources ( Mockito . anyString ( ) ) ) . thenReturn ( Collections . enumeration ( Collections . < URL > emptyList ( ) ) ) ;
TabularResultSet tabularResultSet = createAggregatedResultsInstance ( ) ;
protected abstract TabularResultSet createAggregatedResultsInstance ( ) ;
protected TabularResultSet createAggregatedResultsInstance ( ) {
protected TabularResultSet createAggregatedResultsInstance ( ) {
protected TabularResultSet createAggregatedResultsInstance ( ) {
protected TabularResultSet createAggregatedResultsInstance ( ) {
ResourceAuthorizationProvider provider = getResourceAuthorizationProvider ( ) ;
ResourceAuthorizationProvider provider = getResourceAuthorizationProvider ( ) ;
ResourceAuthorizationProvider provider = getResourceAuthorizationProvider ( ) ;
protected ResourceAuthorizationProvider getResourceAuthorizationProvider ( ) {
. body ( "str" , equalTo ( "str" ) )
setTime ( 1427547759000l ) ;
if ( taskDefinitionKeyIn ! = null & & taskDefinitionKeyIn . length > 0 ) {
return o1 . getPriority ( ) - o2 . getPriority ( ) ;
. body ( "str" , equalTo ( "str"
protected Providers providers ;
expressions . remove ( "str" ) ;
expressions . put ( "str" , followUpDateExpression ) ;
Boolean found = wait . until ( ExpectedConditions . textToBePresentInElement ( By . tagName ( "str" ) , "str" ) ) ;
assertEquals ( "str" , definitionJson . getString ( "str" ) ) ;
assertEquals ( 3 , definitionsJson . length ( ) ) ;
when ( variableInstanceQueryMock . disableCustomObjectDeserialization ( ) ) . thenReturn ( variableInstanceQueryMock ) ;
verify ( variableInstanceQueryMock , times ( 1 ) ) . disableCustomObjectDeserialization ( ) ;
. disableCustomObjectDeserialization ( )
public void testAsyncServiceNoListeners ( ) {
public void testAsyncServiceListeners ( ) {
public void testAsyncServiceConcurrent ( ) {
public void testFailingAsyncServiceTimer ( ) {
public void FAILING_testFailingAsyncServiceTimer ( ) {
public void testAsyncServiceSubProcessTimer ( ) {
public void testAsyncServiceSubProcess ( ) {
public void testAsyncTask ( ) {
public void testAsyncScript ( ) {
return createHistoricVariableEvent ( variableInstance , sourceVariableScope , HistoryEventTypes . VARIABLE_INSTANCE_DELETE ) ;
VARIABLE_INSTANCE_DELETE ( "str" , "str" ) ,
} else if ( HistoryEventTypes . VARIABLE_INSTANCE_DELETE . getEventName ( ) . equals ( historyEvent . getEventType ( ) ) ) {
if ( historyLevel . isHistoryEventProduced ( HistoryEventTypes . VARIABLE_INSTANCE_DELETE , variableInstance ) ) {
public static final String VARIABLE_EVENT_TYPE_DELETE = HistoryEventTypes . VARIABLE_INSTANCE_DELETE . getEventName ( ) ;
if ( ldapConfiguration . isAllowAnonymousLogin ( ) & & password . isEmpty ( ) ) {
String groupSearchFilter = "str" + ldapConfiguration . getGroupSearchFilter ( ) + "str" ;
SearchResult result = enumeration . nextElement ( ) ;
SearchResult result = enumeration . nextElement ( ) ;
if ( userId = = null | | userId . isEmpty ( ) ) {
if ( ! ldapConfiguration . isAllowAnonymousLogin ( ) & & password . equals ( "str" ) ) {
SearchResult result = enumeration . nextElement ( ) ;
protected Properties loadTestProperties ( ) throws IOException {
throw new RuntimeException ( "str" , ex ) ;
addDatabaseSpecificStatement ( POSTGRES , "str" , "str" ) ;
public void FAILING_testExitOnParentSuspendInsideStage ( ) {
public void FAILING_testExitOnParentResumeInsideStage ( ) {
public void FAILING_testParentResumeInsideStageDifferentPlanItemOrder ( ) {
public void FAILING_testParentSuspendInsideStageDifferentPlanItemOrder ( ) {
public void FAILING_testEnableOnParentSuspendInsideStage ( ) {
public void FAILING_testEnableOnParentResumeInsideStage ( ) {
protected boolean failed = false ;
throw new ServletException ( "str" , e ) ;
throw new ServletException ( "str" , e ) ;
throw new ServletException ( "str" , e ) ;
throw new ServletException ( "str" +
FilterDto dto = FilterDto . fromFilter ( MockProvider . createMockFilter ( ) ) ;
FilterDto dto = FilterDto . fromFilter ( eq ( MockProvider . createMockFilter ( ) ) ) ;
verify ( filterServiceMock ) . list ( eq ( MockProvider . EXAMPLE_FILTER_ID ) , isNull ( Query . class ) ) ;
verify ( filterServiceMock ) . list ( eq ( MockProvider . EXAMPLE_FILTER_ID ) , isNull ( Query . class ) ) ;
verify ( filterServiceMock ) . list ( eq ( MockProvider . EXAMPLE_FILTER_ID ) , isNull ( Query . class ) ) ;
verify ( filterServiceMock ) . list ( eq ( MockProvider . EXAMPLE_FILTER_ID ) , isNull ( Query . class ) ) ;
verify ( filterServiceMock ) . list ( eq ( MockProvider . NON_EXISTING_ID ) , isNull ( Query . class ) ) ;
verify ( filterServiceMock ) . listPage ( eq ( MockProvider . EXAMPLE_FILTER_ID ) , isNull ( Query . class ) , eq ( 1 ) , eq ( 2 ) ) ;
deploymentBuilder . enableDuplicateFiltering ( PropertyHelper . getBooleanProperty ( processArchive . getProperties ( ) , ProcessArchiveXml . PROP_IS_DEPLOY_CHANGED_ONLY , false ) ) ;
List < Task > tasks = taskService . createNativeTaskQuery ( ) . sql ( "str" + managementService . getTableName ( Task . class ) + "str" + managementService . getTableName ( VariableInstanceEntity . class ) + "str" ) . list ( ) ;
databaseSpecificLimitBetweenClobStatements . put ( H2 , databaseSpecificLimitBetweenStatements . get ( H2 ) ) ;
databaseSpecificLimitBetweenClobStatements . put ( MYSQL , databaseSpecificLimitBetweenStatements . get ( MYSQL ) ) ;
databaseSpecificLimitBetweenClobStatements . put ( POSTGRES , databaseSpecificLimitBetweenStatements . get ( POSTGRES ) ) ;
databaseSpecificLimitBetweenClobStatements . put ( ORACLE , databaseSpecificLimitBetweenStatements . get ( ORACLE ) ) ;
databaseSpecificLimitBetweenClobStatements . put ( MSSQL , databaseSpecificLimitBetweenStatements . get ( MSSQL ) ) ;
public void testPostCreateTaskDelegationStateResolved ( ) {
public void testPostCreateTaskDelegationStatePending ( ) {
public void testPostCreateTaskUnsupportedDelegationState ( ) {
public void testPostCreateTaskLowercaseDelegationState ( ) {
public void testPutUpdateTaskDelegationStateResolved ( ) {
public void testPutUpdateTaskDelegationStatePending ( ) {
public void testPutUpdateTaskUnsupportedDelegationState ( ) {
public void testPutUpdateTaskLowercaseDelegationState ( ) {
Group group = identityService . createGroupQuery ( ) . groupNameLike ( "str" ) . singleResult ( ) ;
group = identityService . createGroupQuery ( ) . groupNameLike ( "str" ) . singleResult ( ) ;
LOG . fine ( "str" + language + "str" ) ;
throw new InvalidRequestException ( Status . BAD_REQUEST , "str" + engineName + "str" ) ;
assertFalse ( "str" , contains ( scanResult , "str" ) ) ;
assertFalse ( "str" , contains ( scanResult , "str" ) ) ;
private boolean contains ( Map < String , byte [ ] > scanResult , String suffix ) {
if ( string . endsWith ( suffix ) ) {
public void testMultipleNonInterruptingInEmbeddedSubprocess ( ) {
monitor . sync ( ) ;
monitor . sync ( ) ;
final Thread controlThread = Thread . currentThread ( ) ;
controlThread . interrupt ( ) ;
protected boolean syncAvailable = false ;
if ( ! syncAvailable ) {
syncAvailable = false ;
public void sync ( ) {
syncAvailable = true ;
Task task = taskService . createTaskQuery ( ) . processInstanceId ( processInstance . getId ( ) ) . singleResult ( ) ;
this . jdbcUrl = "str" ;
assertFalse ( properties . isEmpty ( ) ) ;
. camundaDelegateExpression ( "str" )
context . bind ( "str" + BPM_PLATFORM_XML_LOCATION , BPM_PLATFORM_XML_FILE_ABSOLUTE_LOCATION ) ;
String jndi = "str" + BPM_PLATFORM_XML_LOCATION ;
if ( processEngineConfiguration . getHistoryLevel ( ) > = ProcessEngineConfigurationImpl . HISTORYLEVEL_FULL ) {
constants . put ( "str" , "str" ) ;
Date executionDate = DateTimeUtil . parseDateTime ( MockProvider . EXAMPLE_PROCESS_DEFINITION_DELAYED_EXECUTION ) . toDate ( ) ;
Date executionDate = DateTimeUtil . parseDateTime ( MockProvider . EXAMPLE_PROCESS_DEFINITION_DELAYED_EXECUTION ) . toDate ( ) ;
Date executionDate = DateTimeUtil . parseDateTime ( MockProvider . EXAMPLE_PROCESS_DEFINITION_DELAYED_EXECUTION ) . toDate ( ) ;
Date executionDate = DateTimeUtil . parseDateTime ( MockProvider . EXAMPLE_PROCESS_DEFINITION_DELAYED_EXECUTION ) . toDate ( ) ;
@Deployment ( resources = { "str" } )
@Deployment ( resources = { "str" } )
return byte [ ] . class . getSimpleName ( ) ;
return new Short ( valueFields . getLongValue ( ) . shortValue ( ) ) ;
return new Integer ( valueFields . getLongValue ( ) . intValue ( ) ) ;
return valueFields . getLongValue ( ) = = 1 ;
valueFields . setLongValue ( 1L ) ;
valueFields . setLongValue ( 0 L ) ;
return mappings . isJPAEntity ( value ) ;
EntityManagerSession entityManagerSession = Context
valueFields . setTextValue2 ( idString ) ;
valueFields . setTextValue2 ( null ) ;
return mappings . getJPAEntity ( valueFields . getTextValue ( ) , valueFields . getTextValue2 ( ) ) ;
dbSqlSession . insert ( historyEvent ) ;
dbSqlSession . insert ( historyEvent ) ;
. getProcessApplicationInfo ( "str" ) ) ;
. getProcessApplicationInfo ( "str" ) ) ;
. body ( "str" , equalTo ( fullUserUrl + "str" ) )
. body ( "str" , equalTo ( fullUserUrl + "str" ) )
. body ( "str" , equalTo ( fullUserUrl + "str" ) )
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 60 * 1000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 60 * 1000 ) ;
waitForJobExecutorToProcessAllJobs ( 60 * 1000 ) ;
waitForJobExecutorToProcessAllJobs ( 10000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 60 * 1000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 2000 ) ;
waitForJobExecutorToProcessAllJobs ( 2000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 60 * 1000 ) ;
waitForJobExecutorToProcessAllJobs ( 16000 ) ;
waitForJobExecutorToProcessAllJobs ( 16000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 60 * 1000 ) ;
waitForJobExecutorToProcessAllJobs ( 16000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 60 * 1000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 60 * 1000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 16000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 60 * 1000 ) ;
waitForJobExecutorToProcessAllJobs ( 2000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 16000 ) ;
waitForJobExecutorToProcessAllJobs ( 16000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 60 * 1000 ) ;
waitForJobExecutorToProcessAllJobs ( 30000 ) ;
waitForJobExecutorToProcessAllJobs ( 180000 ) ;
waitForJobExecutorToProcessAllJobs ( 6000 ) ;
waitForJobExecutorToProcessAllJobs ( 60 * 1000 ) ;
waitForJobExecutorToProcessAllJobs ( 10000 ) ;
protected String orderBy = "str" ;
public void deploy ( ) {
public void undeploy ( ) {
when ( runtimeServiceMock . getActivityInstance ( MockProvider . EXAMPLE_PROCESS_INSTANCE_ID ) ) . thenReturn ( EXAMPLE_ACTIVITY_INSTANCE ) ;
when ( runtimeServiceMock . getActivityInstance ( anyString ( ) ) ) . thenReturn ( null ) ;
when ( runtimeServiceMock . getActivityInstance ( anyString ( ) ) ) . thenThrow ( new ProcessEngineException ( "str" ) ) ;
activityInstance = runtimeService . getActivityInstance ( processInstanceId ) ;
waitForJobExecutorToProcessAllJobs ( 180000 , 500 ) ;
waitForJobExecutorToProcessAllJobs ( 90000 , 500 ) ;
waitForJobExecutorToProcessAllJobs ( 30000 , 500 ) ;
protected CommandExecutor getCommandExecutor ( ) {
protected QueryService getQueryService ( ) {
protected ProcessEngine getProcessEngine ( ) {
waitForJobExecutorToProcessAllJobs ( 10000 , 500 ) ;
waitForJobExecutorToProcessAllJobs ( 10000 , 500 ) ;
public final static String MODULE_JNDI_NAME = "str" ;
. append ( BpmPlatform . MODULE_JNDI_NAME )
. append ( BpmPlatform . MODULE_JNDI_NAME )
if ( ! failed & & ! cancelled & & value = = null ) {
if ( ! failed & & ! cancelled & & value = = null ) {
if ( ! failed & & ! cancelled & & value = = null ) {
if ( ! failed & & ! cancelled & & value = = null ) {
if ( value = = null ) {
throw new FoxPlatformException ( "str" + jobAcquisitionStrategyName + "str" + discoveredStrategies . keySet ( ) ) ;
return repositoryService . createProcessDefinitionQuery ( ) . processDefinitionKey ( processDefinitionKey ) . latestVersion ( ) . singleResult ( ) ;
public void startTask ( String taskId , String callbackUrl ) {
when ( ops . increment ( anyString ( ) , anyLong ( ) ) ) . thenReturn ( 0 L ) ;
assertEquals ( new File ( "str" ) . getAbsolutePath ( ) , cpSubsystemConfig . getBaseDir ( ) . getAbsolutePath ( ) ) ;
assertEquals ( new File ( keyStorePath ) . getAbsolutePath ( ) , keyStoreConfig . getPath ( ) . getAbsolutePath ( ) ) ;
assertEquals ( new File ( keyStorePath ) . getAbsolutePath ( ) , keyStoreConfig . getPath ( ) . getAbsolutePath ( ) ) ;
public Executor defaultExecutor ( ) {
public Executor defaultExecutor ( ) {
= new HazelcastProperty ( "str" , true ) ;
= new HazelcastProperty ( "str" , true ) ;
= new HazelcastProperty ( "str" , true ) ;
public int getOperationExecutorQueueSize ( ) {
final AtomicReference < Throwable > exception = new AtomicReference < > ( ) ;
return createHazelcastInstanceFactory ( 1 ) . newInstances ( getConfig ( ) ) ;
return createHazelcastInstanceFactory ( 2 ) . newInstances ( getConfig ( ) ) ;
private volatile PacketFilter packetFilter ;
= new HazelcastProperty ( "str" , - 1 , SECONDS ) ;
= new HazelcastProperty ( "str" , 10 , SECONDS ) ;
map . put ( 0 , new HazelcastJsonValue ( Json . object ( ) . toString ( ) ) ) ;
map . put ( 0 , new HazelcastJsonValue ( Json . object ( ) . add ( "str" , "str" ) . toString ( ) ) ) ;
map . put ( 0 , new HazelcastJsonValue ( Json . value ( 5 ) . toString ( ) ) ) ;
map . put ( 0 , new HazelcastJsonValue ( Json . object ( )
return new HazelcastJsonValue ( createJsonString ( stringValue , longValue , doubleValue , nestedLongValue ) ) ;
Config config = new UrlXmlConfig ( "str" + file . getPath ( ) , properties ) ;
Config config = new UrlYamlConfig ( "str" + file . getPath ( ) , properties ) ;
throw new IllegalStateException ( "str" ) ;
final String [ ] strList = bytesToString ( data ) . split ( "str" , - 1 ) ;
private static final String SIMPLE_ARRAY = Json . array ( new int [ ] { 1 , 2 , 3 , 4 } ) . toString ( ) ;
. add ( "str" , Json . array ( new int [ ] { 31 , 32 , 33 , 34 } ) )
LIST . add ( Json . array ( new int [ ] { 1 , 2 , 3 , 4 , 5 } ) ) ;
. add ( Json . array ( new int [ ] { 101 , 102 , 103 } ) )
LIST . add ( Json . object ( ) . add ( "str" , Json . array ( new int [ ] { 1 , 2 , 3 , 4 , 5 } ) ) ) ;
String jsonString = Json . array ( new int [ ] { 1 , 2 , 3 } ) . toString ( ) ;
hz3 = newHazelcastInstance ( initOrCreateConfig ( new Config ( ) ) , randomName ( ) , new StaticMemberNodeContext ( factory , member3 ) ) ;
return newHazelcastInstance ( initOrCreateConfig ( new Config ( ) ) , randomName ( ) , nodeContext ) ;
@PowerMockIgnore ( { "str" , "str" , "str" } )
httpsServer = HttpServer . create ( new InetSocketAddress ( 0 ) , 0 ) ;
private boolean asyncStart ;
this . asyncStart = clientConnectionStrategyConfig . isAsyncStart ( ) ;
if ( asyncStart ) {
if ( asyncStart & & ! disconnectedFromCluster ) {
systemLogger . info ( "str" ) ;
assertEquals ( HttpURLConnection . HTTP_NOT_FOUND , communicator . headRequestToGarbageClusterHealthURI ( ) . responseCode ) ;
return allowEmpty ? splitWithEmptyValues : subtraction ( splitWithEmptyValues , new String [ ] { "str" } ) ;
public static String [ ] subtraction ( String [ ] arr1 , String [ ] arr2 ) {
import com . hazelcast . test . annotation . SlowTest ;
@Category ( { SlowTest . class , ParallelTest . class } )
ExecutorService executor = nodeEngine . getExecutionService ( ) . getExecutor ( ExecutionService . SYSTEM_EXECUTOR ) ;
final EventJournalTestContext < String , String , EJ_TYPE > context = createContext ( ) ;
final EventJournalTestContext < String , String , EJ_TYPE > context = createContext ( ) ;
private void assertEventJournalSizeEventually ( final EventJournalTestContext < String , String , EJ_TYPE > context ,
metricsRegistry . scanAndRegister ( executor , "str" + name + "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
import static com . hazelcast . spi . properties . GroupProperty . MAP_LOAD_ALL_PUBLISHES_ADDED_EVENT ;
config . setProperty ( MAP_LOAD_ALL_PUBLISHES_ADDED_EVENT . getName ( ) , "str" ) ;
import static com . hazelcast . spi . properties . GroupProperty . MAP_LOAD_ALL_PUBLISHES_ADDED_EVENT ;
config . setProperty ( MAP_LOAD_ALL_PUBLISHES_ADDED_EVENT . getName ( ) , "str" ) ;
import static com . hazelcast . spi . properties . GroupProperty . MAP_LOAD_ALL_PUBLISHES_ADDED_EVENT ;
this . addEventPublishingEnabled = nodeEngine . getProperties ( ) . getBoolean ( MAP_LOAD_ALL_PUBLISHES_ADDED_EVENT ) ;
+ "str" ) ;
public static JCacheCacheEntryListenerFactory instance ;
instance = this ;
public static JCacheExpiryPolicyFactory instance ;
instance = this ;
public static JCacheCacheLoader instance ;
instance = this ;
JCacheCacheLoaderFactory . instance . getDummyBean ( ) ) ;
JCacheCacheLoader . instance . getDummyBean ( ) ) ;
JCacheCacheWriterFactory . instance . getDummyBean ( ) ) ;
JCacheCacheWriter . instance . getDummyBean ( ) ) ;
JCacheExpiryPolicyFactory . instance . getDummyBean ( ) ) ;
JCacheExpiryPolicy . instance . getDummyBean ( ) ) ;
JCachePartitionLostListener . instance . getDummyBean ( ) ) ;
JCacheCacheEntryListenerFactory . instance . getDummyBean ( ) ) ;
JCacheCacheEntryListener . instance . getDummyBean ( ) ) ;
public static JCachePartitionLostListener instance ;
instance = this ;
public static JCacheCacheEntryListener instance ;
instance = this ;
public static JCacheCacheWriter instance ;
instance = this ;
public static JCacheExpiryPolicy instance ;
instance = this ;
public static JCacheCacheLoaderFactory instance ;
instance = this ;
public static JCacheCacheWriterFactory instance ;
instance = this ;
onError ( t ) ;
onError ( t ) ;
errorHandler . onError ( channel , cause ) ;
onError ( t ) ;
onError ( t ) ;
verify ( handler ) . onError ( isA ( CancelledKeyException . class ) ) ;
verify ( handler ) . onError ( isA ( ExpectedRuntimeException . class ) ) ;
pipeline . onError ( t ) ;
map . put ( "str" , ( long ) clMxBean . getLoadedClassCount ( ) ) ;
private static final long DELAY_FACTOR = 100L ;
{ 11 , 7.0f } ,
return priority ? outboundPipeline . priorityWriteQueue : outboundPipeline . writeQueue ;
public final Queue < OutboundFrame > priorityWriteQueue = new ConcurrentLinkedQueue < OutboundFrame > ( ) ;
return bytesWritten . get ( ) ;
return writeQueue . size ( ) + priorityWriteQueue . size ( ) ;
return bytesPending ( priorityWriteQueue ) ;
priorityWriteQueue . offer ( frame ) ;
OutboundFrame frame = priorityWriteQueue . poll ( ) ;
if ( writeQueue . isEmpty ( ) & & priorityWriteQueue . isEmpty ( ) ) {
priorityWriteQueue . clear ( ) ;
throw new GuardianException ( "str" + throwable , e ) ;
protected final int loadType = Integer . getInteger ( "str" , LOAD_BALANCING_BYTE ) ;
switch ( loadType ) {
switch ( loadType ) {
private volatile boolean isAuthenticatedAsOwner ;
assertOpenEventually ( latch ) ;
new ClientInvocation ( client , clientMessage , null , ownerConnection ) . invokeUrgent ( ) ;
ClientInvocationFuture future = invocation . invokeUrgent ( ) ;
= new HazelcastProperty ( "str" , 60 ) ;
assertOpenEventually ( flushMapStore . latch ) ;
assertOpenEventually ( latch ) ;
assertOpenEventually ( latch ) ;
assertOpenEventually ( latch ) ;
assertOpenEventually ( latch2 ) ;
assertOpenEventually ( latch ) ;
assertOpenEventually ( latch ) ;
assertOpenEventually ( latch ) ;
+ "str" ) ;
ByteBuffer inputBuffer = newInputBuffer ( channel , ioService . getSocketClientReceiveBufferSize ( ) ) ;
{ 14 , 3.5f } ,
logger . info ( "str" + getCallerAddress ( ) + "str" ) ;
logger . info ( "str" ) ;
System . out . println ( "str" + className + "str" + methodName + "str" ) ;
import com . hazelcast . test . annotation . SlowTest ;
@Category ( SlowTest . class )
@Test ( timeout = 1800000 )
public static final int DEFAULT_MAX_ATTEMPT = 2 ;
assertEquals ( 2 , icmpPingConfig . getMaxAttempts ( ) ) ;
super ( attributeName ) ;
super . writeData ( out ) ;
super . readData ( in ) ;
super ( attributeName ) ;
super . writeData ( out ) ;
super . readData ( in ) ;
runPingTask ( member ) ;
runPingTask ( member ) ;
private void runPingTask ( final Member member ) {
logger . info ( "str" + bindAddress ) ;
assertUtilityConstructor ( SetUtil . class ) ;
+ "str" + ( port + portTrialCount - 1 ) ;
logger . warning ( "str" + connection ) ;
logger . warning ( "str" + connection , t ) ;
logger . warning ( "str" + connection ) ;
logger . warning ( "str" + connection ) ;
logger . warning ( "str" + connection , t ) ;
logger . warning ( "str" + connection ) ;
private final ConcurrentMap < Long , ClientInvocation > invocations ;
this . invocations = extractInvocations ( client ) ;
int currentSize = invocations . size ( ) ;
private ConcurrentMap < Long , ClientInvocation > extractInvocations ( HazelcastInstance client ) {
private static final boolean SPOOFING_CHECKS = parseBoolean ( getProperty ( "str" , "str" ) ) ;
queue . poll ( 15 , TimeUnit . SECONDS ) ;
final Config config = new Config ( ) . setProperty ( OPERATION_CALL_TIMEOUT_MILLIS . getName ( ) , "str" ) ;
final Config config = new Config ( ) . setProperty ( OPERATION_CALL_TIMEOUT_MILLIS . getName ( ) , "str" ) ;
ex . getMessage ( ) . equals ( "str" ) ) ;
ex . getMessage ( ) . equals ( "str" ) ) ;
ex . getMessage ( ) . equals ( "str" ) ) ;
assertContains ( "str" ) ;
int callTimeoutMillis = 6000 ;
import com . hazelcast . client . impl . protocol . task . AbstractCallableMessageTask ;
final InternalPartitionService ps = getNode ( instances [ instances . length - 1 ] ) . nodeEngine . getPartitionService ( ) ;
assertTrue ( object . isClusterVersionUnknownOrGreaterOrEqual ( CURRENT_CLUSTER_VERSION ) ) ;
assertTrue ( object . isClusterVersionUnknownOrLessOrEqual ( CURRENT_CLUSTER_VERSION ) ) ;
boolean isClusterVersionUnknownOrLessOrEqual ( Version version ) {
return clusterVersion . isUnknownOrLessOrEqual ( version ) ;
boolean isClusterVersionUnknownOrGreaterOrEqual ( Version version ) {
return clusterVersion . isUnknownOrGreaterOrEqual ( version ) ;
public boolean isUnknownOrGreaterOrEqual ( Version version ) {
public boolean isUnknownOrLessOrEqual ( Version version ) {
assertTrue ( UNKNOWN . isUnknownOrGreaterOrEqual ( ANY_VERSION ) ) ;
assertTrue ( UNKNOWN . isUnknownOrGreaterOrEqual ( UNKNOWN ) ) ;
assertTrue ( UNKNOWN . isUnknownOrLessOrEqual ( ANY_VERSION ) ) ;
assertTrue ( UNKNOWN . isUnknownOrLessOrEqual ( UNKNOWN ) ) ;
assertFalse ( ANY_VERSION . isUnknownOrGreaterOrEqual ( UNKNOWN ) ) ;
assertFalse ( ANY_VERSION . isUnknownOrLessOrEqual ( UNKNOWN ) ) ;
address . getHost ( ) , 1 ) ;
= new HazelcastProperty ( "str" , 60 , SECONDS ) ;
= new HazelcastProperty ( "str" , 30 , SECONDS ) ;
clientConfig . setProperty ( ClientProperty . HEARTBEAT_TIMEOUT . getName ( ) , "str" ) ;
clientConfig . setProperty ( ClientProperty . HEARTBEAT_TIMEOUT . getName ( ) , "str" ) ;
assertEquals ( config . getInstanceName ( ) , osgiInstance . getConfig ( ) . getInstanceName ( ) ) ;
assertEquals ( config . getInstanceName ( ) , instance . getConfig ( ) . getInstanceName ( ) ) ;
assertEquals ( config . getInstanceName ( ) , osgiInstance . getConfig ( ) . getInstanceName ( ) ) ;
assertEquals ( config . getInstanceName ( ) , instance . getConfig ( ) . getInstanceName ( ) ) ;
assertFalse ( iterator . hasNext ( ) ) ;
if ( fieldsAreAnnotated ( ) ) {
assertTrue ( config . isSerializeKeys ( ) ) ;
return serializeKeys | | inMemoryFormat = = InMemoryFormat . NATIVE ;
assertTrue ( ncConfig . isSerializeKeys ( ) ) ;
assertTrue ( ncConfig . isSerializeKeys ( ) ) ;
"str" + parameters . name + "str" + parameters . jobId ) ;
throw new IllegalArgumentException ( "str" ) ;
return toDataWithStrategy ( key ) ;
+ "str" + localAddress
final String [ ] runsCounterlatchNames ;
if ( future . isSetAndInitialized ( ) ) {
if ( ! future . isSetAndInitialized ( ) ) {
assertFalse ( future . isSetAndInitialized ( ) ) ;
assertTrue ( future . isSetAndInitialized ( ) ) ;
public void isSet_returnsFalse_whenSetUninitialized ( ) throws Exception {
assertFalse ( future . isSetAndInitialized ( ) ) ;
assertTrue ( future . isSetAndInitialized ( ) ) ;
+ outputThreadCount + "str" ) ;
public static final int DEFAULT_BUFFER_SIZE_BYTE = 128 * KILO_BYTE ;
static final int DEFAULT_BUFFER_SIZE = 128 ;
assertEquals ( 128 , config . getNetworkConfig ( ) . getSocketOptions ( ) . getBufferSize ( ) ) ;
= new HazelcastProperty ( "str" , 128 ) ;
= new HazelcastProperty ( "str" , 128 ) ;
. setCapacity ( 100 ) . setTimeToLiveSeconds ( 30 ) ) ;
put ( key , value , null , SOURCE_NOT_AVAILABLE , false , true , IGNORE_COMPLETION ) ;
if ( ! currentMasterAddress . equals ( master ) ) {
1062476.184 , 1068942.337 , 1075524.95 , 1081932.864 , 1088426.025 , 1094776.005 , 1101327.448 , 1107901.673 ,
throw new IllegalArgumentException ( "str" + service ) ;
@Parameterized.Parameters ( name = "str" )
System . out . println ( object . getClass ( ) . getSimpleName ( ) + "str" + object + "str" + readObject ) ;
throw new HazelcastSerializationException ( "str"
+ "str" + itemId ) ;
logger . warning ( "str" + e . getMessage ( ) ) ;
+ "str" + response ) ;
+ "str" + e . getMessage ( ) , e ) ;
+ "str" + e . getMessage ( ) , e ) ;
sb . append ( "str" + total / STATS_SECONDS + "str" ) ;
"str" + eventType . name ( ) ) ;
super ( "str" + className + "str" + message ) ;
logger . finest ( "str" + handler ) ;
logger . finest ( "str" + handler ) ;
systemLogger . info ( "str" + buildInfo . getSerializationVersion ( ) ) ;
logger . finest ( "str" + connection + "str"
logger . warning ( "str" + connection ) ;
logger . warning ( "str" + connection ) ;
+ target + "str" + principal ) ) ;
"str" + parameters . name + "str" + parameters . jobId ) ;
log ( "str" + messagesSend . getAndSet ( 0 ) / STATS_SECONDS + "str" + messagesReceived
assertTrue ( "str" + map2Cost , map2Cost > 0 ) ;
throw new IOException ( "str" + partitionId ) ;
throw new IOException ( "str" ) ;
throw new IOException ( "str" + partitionId ) ;
throw new TargetNotMemberException ( "str" + target + "str" ) ;
throw new IllegalArgumentException ( "str" + field ) ;
command = new ErrorCommand ( ERROR_CLIENT , "str" + cmd ) ;
logger . severe ( "str" + failReasonMsg ) ;
System . out . println ( "str" + j + "str" + map . get ( key ) + "str" + getStore ( map , key ) . getVersion ( ) ) ;
logger . info ( "str" + total / STATS_SECONDS ) ;
logger . fine ( "str" + type . getName ( ) ) ;
+ connection + "str" + e . getMessage ( ) ) ;
logger . info ( "str" + total / STATS_SECONDS ) ;
logger . warning ( "str" + master ) ;
Logger . getLogger ( this . getClass ( ) ) . info ( "str" + event ) ;
assertTrue ( format ( "str" , ASSERT_TRUE_EVENTUALLY_TIMEOUT ,
logger . warning ( "str" + connection + "str" + principal + "str" ) ;
logFailure ( "str" , subscriber ) ;
throw new HazelcastOverloadException ( "str"
println ( entry . getKey ( ) + "str" + entry . getValue ( ) ) ;
println ( entry . getKey ( ) + "str" + entry . getValue ( ) ) ;
println ( "str" + result ) ;
Logger . getLogger ( MockedNodeConnection . class ) . warning ( "str" + reason , cause ) ;
println ( entry . getKey ( ) + "str" + entry . getValue ( ) ) ;
println ( entry . getKey ( ) + "str" + entry . getValue ( ) ) ;
+ "str" + partition + "str" + migrationInfo ) ;
System . out . println ( "str" + currentStats . total ( )
when ( plugin . getPeriodMillis ( ) ) . thenReturn ( 1L ) ;
when ( plugin . getPeriodMillis ( ) ) . thenReturn ( - 2L ) ;
when ( plugin . getPeriodMillis ( ) ) . thenReturn ( 0 L ) ;
return new SerializationV1Portable ( ( byte ) 99 , true , "str" , ( short ) 11 , 1234134 , 1341431221L , 1.12312f , 432.424 ,
when ( mockLockServiceImpl . getMaxLeaseTimeInMillis ( ) ) . thenReturn ( 1L ) ;
assertThat ( remainingLeaseTime , greaterThan ( 0 L ) ) ;
flyweight . set ( 0x12345678L ) ;
flyweight . set ( 0x12345678L ) ;
assertEquals ( 0x12345678L , flyweight . getLong ( ) ) ;
flyweight . set ( 0x12345678L ) ;
. setCorrelationId ( 0x1234567812345678L )
assertEquals ( new Long ( - 1L ) , addOperation . getResponse ( ) ) ;
handlerEventsCounter . set ( handler1 , 100L ) ;
assertEquals ( - 1L , addOperation . getResponse ( ) ) ;
when ( selector1Handler1 . getEventCount ( ) ) . thenReturn ( 10000L ) ;
when ( selector2Handler . getEventCount ( ) ) . thenReturn ( 200L ) ;
when ( selector2Handler2 . getEventCount ( ) ) . thenReturn ( 200L ) ;
if ( ! isAllowedToRetryDuringMigration ( op ) & & internalPartition . isMigrating ( ) ) {
this . inMemoryFormat = isNotNull ( inMemoryFormat , "str" ) ;
throw new XAException ( "str" + flags ) ;
throw new IllegalStateException ( "str" + threadId ) ;
LOGGER . warning ( "str" ) ;
throw new IOException ( "str" + ownerConnectionAddress ) ;
"str" + maxVersion ) ;
"str" + maxVersion ) ;
throw new HazelcastException ( "str" , e ) ;
invocationLogger . severe ( "str" + packet + "str" + getName ( ) , e ) ;
logger . warning ( "str" + eventType ) ;
throw new TransactionException ( "str" + itemId ) ;
throw new IllegalStateException ( "str" + nameWithPrefix + "str" ) ;
throw new IllegalStateException ( "str" + nameWithPrefix + "str" ) ;
throw new RejectedExecutionException ( "str" + ringItems . length + "str" ) ;
throw new IllegalStateException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new IllegalArgumentException ( "str" ) ;
throw new IllegalArgumentException ( "str" ) ;
throw new CacheNotExistsException ( "str" + name + "str" ) ;
+ "str" + clazz . getClassLoader ( ) + "str"
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
logger . severe ( "str" , e ) ;
this . inMemoryFormat = isNotNull ( inMemoryFormat , "str" ) ;
throw new HazelcastException ( "str" , e ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new HazelcastException ( "str" ) ;
throw new HazelcastException ( "str" ) ;
onFailure ( new AuthenticationException ( "str" + principal ) ) ;
onFailure ( new AuthenticationException ( "str"
checkNotNull ( cacheMaxSizePolicy , "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
+ "str" + itemId ) ;
+ "str" + itemId ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new HazelcastException ( member + "str" ) ;
+ "str" + fd . getName ( ) + "str" + cd ) ;
throw new IllegalStateException ( "str" + nameWithPrefix + "str" ) ;
throw new IllegalStateException ( "str" + nameWithPrefix + "str" ) ;
throw new XAException ( "str" + flags ) ;
sb . append ( in + "str" + in . getEventCount ( ) + "str" ) ;
sb . append ( in + "str" + in . getEventCount ( ) + "str" ) ;
throw new InvalidConfigurationException ( "str" + url . getPath ( ) + "str" ) ;
sendClientMessage ( new IllegalStateException ( "str" + authenticationStatus ) ) ;
throw new UnsupportedOperationException ( "str" ) ;
logger . severe ( "str" , e ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
final int partitionId = clientContext . getPartitionService ( ) . getPartitionId ( keyData ) ;
assertEquals ( 100 , ( ( Integer ) strategy . getOrNull ( third ) ) . intValue ( ) ) ;
assertEquals ( 300 , ( ( Integer ) strategy . getOrNull ( "str" , third ) ) . intValue ( ) ) ;
Aggregator < Map . Entry < BigDecimal , BigDecimal > , Long > resultAggregation = Aggregators . count ( "str" ) ;
Aggregator < Map . Entry < BigDecimal , BigDecimal > , Long > resultAggregation = Aggregators . count ( "str" ) ;
protected final ConstructorFunction < String , CacheContext > cacheContextsConstructorFunction =
return ConcurrencyUtil . getOrPutIfAbsent ( cacheContexts , name , cacheContextsConstructorFunction ) ;
if ( nearCache = = null ) {
return getIndexes ( ) . hasIndex ( ) & & OBJECT . equals ( mapConfig . getInMemoryFormat ( ) ) ;
. close ( ) ;
. close ( ) ;
. close ( ) ;
. node ( "str" , wan . getMergePolicy ( ) ) ;
. close ( ) ;
. open ( "str" ) ;
. appendProperties ( ssl . getProperties ( ) ) ;
. appendProperties ( socket . getProperties ( ) ) ;
. node ( "str" , hrCfg . getBaseDir ( ) . getAbsolutePath ( ) ) ;
throw new HazelcastInstanceNotActiveException ( "str" + localAddress + "str" + op ) ;
logger . warning ( "str" + e . getMessage ( ) ) ;
systemLogger . info ( "str" + newVersion ) ;
return new ScheduledExecutorPermission ( handler . getSchedulerName ( ) , ActionConstants . ACTION_READ ) ;
return new ScheduledExecutorPermission ( handler . getSchedulerName ( ) , ActionConstants . ACTION_READ ) ;
return new ScheduledExecutorPermission ( parameters . schedulerName , ActionConstants . ACTION_READ ) ;
return new ScheduledExecutorPermission ( handler . getSchedulerName ( ) , ActionConstants . ACTION_READ ) ;
return new ScheduledExecutorPermission ( handler . getSchedulerName ( ) , ActionConstants . ACTION_READ ) ;
String result = String . format ( "str" ,
assertEquals ( "str" , communicator . listClusterNodes ( "str" , "str" ) ) ;
clearFromMember . join ( ) ;
config . setProperty ( OPERATION_CALL_TIMEOUT_MILLIS . getName ( ) , "str" ) ;
assertOpenEventually ( latch , 30 ) ;
assertOpenEventually ( latch , 5 ) ;
assertOpenEventually ( "str" , latch , 30 ) ;
assertOpenEventually ( latch , 10 ) ;
assertOpenEventually ( latch , 10 ) ;
assertOpenEventually ( latch , 10 ) ;
assertOpenEventually ( latch , 30 ) ;
write ( calendar . get ( MONTH ) + 1 ) ;
responseData = nodeEngine . toData ( response = = null ? null : new LegacyCacheConfig ( ( CacheConfig ) response ) ) ;
double expectation = Sums . sumValueContainer ( values , DOUBLE ) . doubleValue ( ) ;
long expectation = Sums . sumValueContainer ( values , INTEGER ) . intValue ( ) ;
long expectation = Sums . sumValueContainer ( values , LONG ) . longValue ( ) ;
double expectation = Sums . sumValueContainer ( values , NUMBER ) . doubleValue ( ) ;
double expectation = Sums . sumValueContainer ( values , NUMBER ) . doubleValue ( ) ;
} else if ( context . invocationRegistry . deregister ( this ) ) {
final long lastTimePacketReceived = connection . lastReadTimeMillis ( ) ;
if ( lastTimePacketReceived + timeoutInMillis < currentTimeMillis ) {
: ioService . getSocketClientSendBufferSize ( ) ;
public static final int QUEUE_TRANSACTION_LOG_RECORD = 44 ;
logger . finest ( "str" ) ;
calculatedVersion + = Integer . parseInt ( patchVersionString ) ;
import static java . util . Calendar . HOUR_OF_DAY ;
int hour = calendar . get ( HOUR_OF_DAY ) ;
public boolean isInvalidatedOnChange ( ) {
invalidateOnChange = this . nearCache . isInvalidatedOnChange ( ) ;
if ( nearCache ! = null & & nearCache . isInvalidatedOnChange ( ) ) {
if ( nearCache ! = null & & nearCache . isInvalidatedOnChange ( ) ) {
public boolean isInvalidatedOnChange ( ) {
public boolean isInvalidatedOnChange ( ) {
boolean isInvalidatedOnChange ( ) ;
if ( nearCache . isInvalidatedOnChange ( ) ) {
IMap < String , String > map = instance . getMap ( mapName ) ;
String addressString = address . getHost ( ) . replace ( "str" , "str" ) + "str" + address . getPort ( ) ;
import com . hazelcast . test . annotation . SlowTest ;
@Category ( { SlowTest . class , ParallelTest . class } )
@Test ( timeout = 4 * MINUTE )
for ( int i = 0 ; System . currentTimeMillis ( ) < deadLine & & map . size ( ) < 1000 ; i + + ) {
. setTimeToLiveSeconds ( 3 ) ;
printWriter = new PrintWriter ( "str" + File . separator + System . getProperty ( "str" ) , "str" ) ;
map . set ( key , "str" , 5 , TimeUnit . SECONDS ) ;
private static final int NUMBER_OF_IDS_PER_THREAD = 40000 ;
verify ( handler ) . onOutOfMemory ( oome , new HazelcastInstance [ ] { hz } ) ;
static final String GC_OVERHEAD_LIMIT_EXCEEDED = "str" ;
if ( attribute . startsWith ( keyPrefix ) & & attribute . length ( ) > keyPrefix . length ( ) ) {
private volatile boolean stop ;
int callTimeout = 5000 ;
long callTimeoutMs = 10000 ;
opService . invokeOnPartition ( new SlowOperation ( callTimeoutMs * 2 ) . setPartitionId ( partitionId ) ) ;
Future f = opService . invokeOnPartition ( new DummyOperation ( ) . setPartitionId ( partitionId ) ) ;
long callTimeoutMs = 10000 ;
opService . invokeOnPartition ( new SlowOperation ( callTimeoutMs * 2 ) . setPartitionId ( partitionId ) ) ;
ICompletableFuture f = opService . invokeOnPartition ( new DummyOperation ( ) . setPartitionId ( partitionId ) ) ;
int callTimeout = 5000 ;
config . setProperty ( OPERATION_CALL_TIMEOUT_MILLIS . getName ( ) , "str" ) ;
int callTimeout = 10000 ;
. setCapacity ( 3 * 1000 )
if ( mm . tryLock ( key , 10 , TimeUnit . SECONDS ) ) {
import static com . hazelcast . instance . OutOfMemoryErrorDispatcher . inspectOutOfMemoryError ;
inspectOutOfMemoryError ( t ) ;
inspectOutOfMemoryError ( t ) ;
import static com . hazelcast . instance . OutOfMemoryErrorDispatcher . inspectOutOfMemoryError ;
inspectOutOfMemoryError ( t ) ;
public static void inspectOutOfMemoryError ( Throwable throwable ) {
import static com . hazelcast . instance . OutOfMemoryErrorDispatcher . inspectOutOfMemoryError ;
inspectOutOfMemoryError ( t ) ;
inspectOutOfMemoryError ( e ) ;
import static com . hazelcast . instance . OutOfMemoryErrorDispatcher . inspectOutOfMemoryError ;
inspectOutOfMemoryError ( t ) ;
OutOfMemoryErrorDispatcher . inspectOutOfMemoryError ( e ) ;
import static com . hazelcast . instance . OutOfMemoryErrorDispatcher . inspectOutOfMemoryError ;
inspectOutOfMemoryError ( throwable ) ;
inspectOutOfMemoryError ( throwable ) ;
inspectOutOfMemoryError ( throwable ) ;
int callTimeoutMillis = 3000 ;
} , 20 ) ;
if ( e instanceof TargetNotMemberException | | e . getCause ( ) instanceof MemberLeftException ) {
protected static final boolean THREAD_DUMP_ON_FAILURE = getBoolean ( "str" ) ;
if ( THREAD_DUMP_ON_FAILURE ) {
final LockService lockService = nodeEngine . getSharedService ( LockService . SERVICE_NAME ) ;
final LockService lockService = nodeEngine . getSharedService ( LockService . SERVICE_NAME ) ;
LockService lockService = nodeEngine . getSharedService ( LockService . SERVICE_NAME ) ;
final LockService lockService = nodeEngine . getSharedService ( LockService . SERVICE_NAME ) ;
final LockService lockService = nodeEngine . getSharedService ( LockService . SERVICE_NAME ) ;
final LockService lockService = nodeEngine . getSharedService ( LockService . SERVICE_NAME ) ;
final LockService lockService = nodeEngine . getSharedService ( LockService . SERVICE_NAME ) ;
throw new IllegalArgumentException ( "str" + fullPath ) ;
int index = Integer . parseInt ( quantifier ) ;
String url = address + "str" ;
String url = address + "str" ;
public static final String URI_SHUTDOWN_CLUSTER_URL = URI_CLUSTER_MANAGEMENT_BASE_URL + "str" ;
public static final String URI_KILLNODE_CLUSTER_URL = URI_CLUSTER_MANAGEMENT_BASE_URL + "str" ;
while ( queue . size ( ) > 100000 ) {
int committedVersion = getPartitionStateVersion ( ) + migrationInfos . length ;
if ( nodeEngine ! = null & & nodeEngine . getNode ( ) . getState ( ) ! = NodeState . SHUT_DOWN ) {
int delta = migrations . size ( ) + 1 ;
boolean isSync = getFutureResultSilently ( future , REPLICA_SYNC_CHECK_TIMEOUT_SECONDS , TimeUnit . SECONDS ) ;
private boolean getFutureResultSilently ( Future future , long seconds , TimeUnit unit ) {
logger . finest ( "str" , t ) ;
Config config = getConfig ( ) ;
= new HazelcastProperty ( "str" , false ) ;
checkNotNull ( plugin , "str" ) ;
private static class BlockingCallback implements AuthenticationCallback {
map . lock ( key , 2 , TimeUnit . SECONDS ) ;
} catch ( Exception e ) {
throw new UnsupportedOperationException ( ) ;
assertOpenEventually ( connectedLatch ) ;
assertOpenEventually ( shutdownLatch ) ;
R record = createRecord ( value , now , expiryTime ) ;
sb . append ( "str" ) . append ( System . identityHashCode ( this ) ) ;
CacheConfig cacheConfig = service . getCacheConfig ( name ) ;
final int CREATED_EXPIRY_TIME_IN_MSEC = 100 ;
Duration duration = new Duration ( TimeUnit . MILLISECONDS , CREATED_EXPIRY_TIME_IN_MSEC ) ;
sleepAtLeastMillis ( CREATED_EXPIRY_TIME_IN_MSEC + 1 ) ;
public static final String PYTHON = "str" ;
. setTimeToLiveSeconds ( 2 ) ;
. setTimeToLiveSeconds ( 30 ) ;
. setTimeToLiveSeconds ( 2 ) ;
. setTimeToLiveSeconds ( 2 ) ;
. setTimeToLiveSeconds ( 30 ) ;
. setTimeToLiveSeconds ( 2 ) ;
public static final class CallIdSequenceFailFast extends CallIdSequence {
public CallIdSequenceFailFast ( int maxConcurrentInvocations ) {
callIdSequence = new CallIdSequence . CallIdSequenceFailFast ( maxAllowedConcurrentInvocations ) ;
callIdSequence = new CallIdSequence . CallIdSequenceFailFast ( maxAllowedConcurrentInvocations ) ;
public static final class CallIdSequenceFailFast extends CallIdSequence {
public CallIdSequenceFailFast ( int maxConcurrentInvocations ) {
discoveryConfig . addDiscoveryStrategyConfig ( strategyConfig ) ;
discoveryConfig . addDiscoveryStrategyConfig ( strategyConfig ) ;
discoveryConfig . addDiscoveryStrategyConfig ( new DiscoveryStrategyConfig ( clazz , properties ) ) ;
public void addDiscoveryStrategyConfig ( DiscoveryStrategyConfig discoveryStrategyConfig ) {
public void test_DiscoveryConfigReadOnly_addDiscoveryStrategyConfig ( ) {
discoveryConfig . addDiscoveryStrategyConfig ( discoveryStrategyConfig ) ;
public void test_DiscoveryConfigReadOnly_addDiscoveryStrategyConfig_thenUnsupportedOperationException ( ) {
readOnly . addDiscoveryStrategyConfig ( discoveryStrategyConfig ) ;
discoveryConfig . addDiscoveryStrategyConfig ( new DiscoveryStrategyConfig ( clazz , properties ) ) ;
discoveryConfig . addDiscoveryStrategyConfig ( new DiscoveryStrategyConfig ( clazz , properties ) ) ;
discoveryConfig . addDiscoveryStrategyConfig ( strategyConfig ) ;
discoveryConfig . addDiscoveryStrategyConfig ( strategyConfig ) ;
discoveryConfig . addDiscoveryStrategyConfig ( strategyConfig ) ;
public void addDiscoveryStrategyConfig ( DiscoveryStrategyConfig discoveryStrategyConfig ) {
assertClusterSizeEventually ( 2 , h2 ) ;
private volatile Object value ;
protected volatile Data value ;
protected volatile Data value ;
private volatile Object value ;
throw new InvalidConfigurationException ( "str" , e ) ;
TransactionOptions options = TransactionOptions . getDefault ( ) . setTimeout ( 30 , TimeUnit . SECONDS ) ;
TransactionOptions options = new TransactionOptions ( ) . setDurability ( 0 ) . setTimeout ( 30 , TimeUnit . SECONDS ) ;
collector . add ( null ) ;
private static final String FAILURE = "str" ;
private final static String FAILURE = "str" ;
resultString = FAILURE + e . getMessage ( ) ;
expected . add ( "str" ) ;
expected . add ( "str" ) ;
map . put ( localKey1 , "str" ) ;
assertEquals ( localKey1 , serializationService . toObject ( row . getKey ( ) ) ) ;
assertOpenEventually ( countDownLatch , 300 ) ;
public void addTaskAndWakeup ( Runnable task ) {
target . addTaskAndWakeup ( task ) ;
capacity = ( Long ) invoke ( request ) ;
import com . hazelcast . test . HazelcastSerialClassRunner ;
@RunWith ( HazelcastSerialClassRunner . class )
import com . hazelcast . test . HazelcastSerialClassRunner ;
@RunWith ( HazelcastSerialClassRunner . class )
public static final int F_ID = FactoryIdHelper . getFactoryId ( FactoryIdHelper . RINGBUFFER_PORTABLE_FACTORY , - 29 ) ;
logger . severe ( "str" + responsePacket + "str" + getName ( ) , e ) ;
private static class EmptyIterator implements Iterator {
private static final FutureUtil . ExceptionHandler DESTROY_PROXY_EXCEPTION_HANDLER = FutureUtil . logAllExceptions ( Level . WARNING ) ;
private static final long DESTROY_TIMEOUT_SECONDS = 30 ;
waitWithDeadline ( calls , DESTROY_TIMEOUT_SECONDS , TimeUnit . SECONDS , DESTROY_PROXY_EXCEPTION_HANDLER ) ;
putToCacheAndRemoveFromOtherNodeThenCantGetUpdatedFromClientNearCache ( InMemoryFormat . OBJECT ) ;
sendSingleInvalidationEvent ( name , null , sourceUuid ) ;
for ( int i = 0 ; ! node . joined ( ) & & i < 2000 ; i + + ) {
MapService mapService = ( MapService ) mapProxy . getService ( ) ;
if ( connection . equals ( invocation . getSendConnection ( ) ) ) {
if ( connection . equals ( invocation . getSendConnection ( ) ) ) {
if ( connection . equals ( invocation . getSendConnection ( ) ) ) {
if ( connection . equals ( invocation . getSendConnection ( ) ) ) {
ENTERPRISE_WAN_REP_OP_TIMEOUT_MILLIS = new GroupProperty ( config , PROP_ENTERPRISE_WAN_REP_OP_TIMEOUT_MILLIS , "str" ) ;
seq = ringbuffer . headSequence ( ) ;
seq = ringbuffer . headSequence ( ) ;
assertOpenEventually ( "str" , responseLatch ) ;
assertOpenEventually ( "str" , responseLatch ) ;
return new PutBackupOperation ( name , dataKey , dataValue , replicationInfo , true , false ) ;
Class < ? > clazz = context . getBundle ( ) . loadClass ( "str" ) ;
logWithConfigHint ( log ) ;
public static final int F_ID = FactoryIdHelper . getFactoryId ( FactoryIdHelper . COLLECTION_DS_FACTORY , - 29 ) ;
return super . getEvictionConfig ( ) . getAsReadOnly ( ) ;
return super . getPredicateConfig ( ) . getAsReadOnly ( ) ;
return tryLock ( key , 0 , TimeUnit . MILLISECONDS ) ;
void interceptAfterGet ( String mapName , Object value ) ;
public String addItemListener ( ItemListener < E > listener , boolean includeValue ) {
@EncodeMethod ( id = 14 )
@EncodeMethod ( id = 15 )
@EncodeMethod ( id = 17 )
@EncodeMethod ( id = 18 )
@EncodeMethod ( id = 19 )
@EncodeMethod ( id = 20 )
@EncodeMethod ( id = 21 )
@EncodeMethod ( id = 22 )
@EncodeMethod ( id = 15 )
@EncodeMethod ( id = 16 )
@EncodeMethod ( id = 17 )
@EncodeMethod ( id = 18 )
@EncodeMethod ( id = 19 )
@EncodeMethod ( id = 20 )
@EncodeMethod ( id = 21 )
@EncodeMethod ( id = 22 )
public String waddItemListener ( ItemListener < E > listener , boolean includeValue ) {
@EncodeMethod ( id = 20 )
@EncodeMethod ( id = 21 )
@EncodeMethod ( id = 22 )
@EncodeMethod ( id = 23 )
@EncodeMethod ( id = 24 )
@EncodeMethod ( id = 25 )
@EncodeMethod ( id = 26 )
@EncodeMethod ( id = 27 )
@EncodeMethod ( id = 28 )
@EncodeMethod ( id = 29 )
@EncodeMethod ( id = 30 )
@EncodeMethod ( id = 31 )
@EncodeMethod ( id = 32 )
@EncodeMethod ( id = 33 )
@EncodeMethod ( id = 34 )
@EncodeMethod ( id = 35 )
@EncodeMethod ( id = 36 )
@EncodeMethod ( id = 37 )
@EncodeMethod ( id = 38 )
@EncodeMethod ( id = 39 )
@EncodeMethod ( id = 40 )
@EncodeMethod ( id = 41 )
@EncodeMethod ( id = 42 )
@EncodeMethod ( id = 43 )
@EncodeMethod ( id = 44 )
@EncodeMethod ( id = 45 )
@EncodeMethod ( id = 46 )
@EncodeMethod ( id = 47 )
@EncodeMethod ( id = 48 )
@EncodeMethod ( id = 49 )
@EncodeMethod ( id = 50 )
@EncodeMethod ( id = 51 )
@EncodeMethod ( id = 52 )
@EncodeMethod ( id = 53 )
@EncodeMethod ( id = 54 )
@EncodeMethod ( id = 2 )
@EncodeMethod ( id = 3 )
@EncodeMethod ( id = 4 )
@EncodeMethod ( id = 5 )
@EncodeMethod ( id = 6 )
@EncodeMethod ( id = 7 )
@EncodeMethod ( id = 8 )
@EncodeMethod ( id = 9 )
@EncodeMethod ( id = 10 )
@EncodeMethod ( id = 11 )
@EncodeMethod ( id = 12 )
@EncodeMethod ( id = 13 )
@EncodeMethod ( id = 14 )
@EncodeMethod ( id = 15 )
@EncodeMethod ( id = 16 )
@EncodeMethod ( id = 17 )
@EncodeMethod ( id = 18 )
@EncodeMethod ( id = 19 )
@EncodeMethod ( id = 20 )
logger . finest ( "str"
public final class BackPressureService {
cache . putRecord ( key , record ) ;
if ( ! success ) {
if ( ! success ) {
private static class CallbackImpl implements Callback < Object > {
if ( comparePartitionOwnership ( true , localMember , partition ) ) {
throw new ConfigMismatchException ( "str" + joinerType + "str" + found . joinerType ) ;
private final static long TERMINATE_TIMEOUT_SECONDS = 30 ;
boolean success = internalExecutor . awaitTermination ( TERMINATE_TIMEOUT_SECONDS , TimeUnit . SECONDS ) ;
+ TERMINATE_TIMEOUT_SECONDS + "str" ) ;
boolean success = executor . awaitTermination ( TERMINATE_TIMEOUT_SECONDS , TimeUnit . SECONDS ) ;
LOGGER . warning ( "str" + TERMINATE_TIMEOUT_SECONDS + "str" ) ;
private static final int LAST_INDEX = 8 ;
return config . getAccessKey ( ) + "str" + timestamp . substring ( 0 , LAST_INDEX ) + "str"
private SerializationService serializationService ;
return new LocalMemoryStatsImpl ( instance . getMemoryStats ( ) ) ;
failMap = processInternal ( delayedEntries ) ;
private Map < Integer , List < DelayedEntry > > doStoreUsingBatchSize ( List < DelayedEntry > sortedDelayedEntries ) {
while ( ( delayedEntryList = getBatchChunk ( sortedDelayedEntries , writeBatchSize , page + + ) ) ! = null ) {
if ( ! "str" . equals ( itemName ) & & ! itemName . startsWith ( "str" ) ) {
if ( ! "str" . equals ( itemName ) & & ! itemName . startsWith ( "str" ) ) {
responseThread . workQueue . add ( packet ) ;
BACKPRESSURE_SYNCWINDOW = new GroupProperty ( config , PROP_BACKPRESSURE_SYNCWINDOW , "str" ) ;
public void clientsConsume_withNodeShutdown ( ) throws InterruptedException {
cluster . shutdownRandomNode ( ) ;
public void shutdownRandomNode ( ) {
node . getLifecycleService ( ) . shutdown ( ) ;
if ( SamplingEntry . class . isInstance ( o ) ) {
if ( IterableSamplingEntry . class . isInstance ( o ) ) {
private static final int THREADS_PER_CLIENT = 4 ;
public static final int MAX_ITEMS = 100 ;
private final boolean selectorImbalanceWorkaroundEnabled ;
if ( selectorImbalanceWorkaroundEnabled ) {
if ( selectorImbalanceWorkaroundEnabled ) {
return ( ( 1f * cachePutTimeTakenNanos ) / cachePuts ) / NANOSECONDS_IN_A_MICROSECOND ;
return Runtime . getRuntime ( ) . freeMemory ( ) ;
return Runtime . getRuntime ( ) . maxMemory ( ) ;
if ( privateIp ! = null ) {
config . setInstanceName ( "str" ) ;
private int writeBehindQueueSize ( HazelcastInstance node , String mapName ) {
if ( recordStore = = null ) {
final MapStoreWithStoreCount mapStore = new MapStoreWithStoreCount ( expectedStoreCount , 300 , 50 ) ;
public void testGet_withSetBackedValueCollection ( ) throws Exception {
public void testGet_withSetBackedValueCollection_onEmptyMultiMap ( ) throws Exception {
public void testGet_withListBackedValueCollection ( ) throws Exception {
public void testGet_withListBackedValueCollection_onEmptyMultiMap ( ) throws Exception {
public void testRemove_withSetBackedValueCollection ( ) throws Exception {
public void testRemove_withSetBackedValueCollection_onEmptyMultiMap ( ) throws Exception {
public void testRemove_withListBackedValueCollection ( ) throws Exception {
public void testRemove_withListBackedValueCollection_onEmptyMultiMap ( ) throws Exception {
public void testGet_withSetBackedValueCollection ( ) throws Exception {
public void testGet_withSetBackedValueCollection_onEmptyMultiMap ( ) throws Exception {
public void testGet_withListBackedValueCollection ( ) throws Exception {
public void testGet_withListBackedValueCollection_onEmptyMultiMap ( ) throws Exception {
public void testRemove_withSetBackedValueCollection ( ) throws Exception {
public void testRemove_withSetBackedValueCollection_onEmptyMultiMap ( ) throws Exception {
public void testRemove_withListBackedValueCollection ( ) throws Exception {
public void testRemove_withListBackedValueCollection_onEmptyMultiMap ( ) throws Exception {
import com . hazelcast . map . mapstore . MapStoreTest ;
import com . hazelcast . map . mapstore . MapStoreTest ;
import static com . hazelcast . map . mapstore . MapStoreTest . newConfig ;
CLIENT_HEARTBEAT_TIMEOUT_SECONDS = new GroupProperty ( config , PROP_CLIENT_MAX_NO_HEARTBEAT_SECONDS , "str" ) ;
public static final int DEFAULT_POOL_SIZE = 16 ;
private static final class GcMetrics {
assertTrue ( "str" , networkConfig . isReuseAddress ( ) ) ;
assertOpenEventually ( latch1 ) ;
assertOpenEventually ( latch2 ) ;
if ( keySet . isEmpty ( ) ) {
if ( ! mapServiceContext . hasRegisteredListener ( mapName ) | | eventType = = NO_NEED_TO_FIRE_EVENT ) {
if ( ! mapServiceContext . hasRegisteredListener ( mapName ) | | eventType = = NO_NEED_TO_FIRE_EVENT ) {
String downloadId = "str" ;
final Enumeration < URL > resources = cl . getResources ( "str" ) ;
systemLogger . info ( "str" + version + "str"
systemLogger . info ( "str" + version + "str"
long max = Long . MIN_VALUE ;
downloadId = mainAttributes . getValue ( "str" ) ;
this . mapStoreManager = MapStoreManagers . newMapStoreManager ( mapService , storeWrapper , listeners ) ;
public static MapStoreManager newMapStoreManager ( MapService mapService ,
final InetAddress [ ] inetAddresses = InetAddress . getAllByName ( addressHolder . getAddress ( ) ) ;
return new Address ( inetAddress , addressHolder . getPort ( ) ) ;
return new Address ( addressHolder . getAddress ( ) , addressHolder . getPort ( ) ) ;
return new Address ( addressHolder . getAddress ( ) , addressHolder . getPort ( ) ) ;
final boolean portIsDefined = addressHolder . getPort ( ) ! = - 1 | | ! networkConfig . isPortAutoIncrement ( ) ;
final int port = addressHolder . getPort ( ) ! = - 1 ? addressHolder . getPort ( ) : networkConfig . getPort ( ) ;
addressMatcher = AddressUtil . getAddressMatcher ( addressHolder . getAddress ( ) ) ;
matchedAddresses = Collections . singleton ( addressHolder . getAddress ( ) ) ;
final String host = addressHolder . getAddress ( ) ;
final Address target = new Address ( addressHolder . getAddress ( ) , addressHolder . getPort ( ) ) ;
final String s = AddressUtil . getAddressHolder ( possibleAddress ) . getAddress ( ) ;
return new AddressDefinition ( holder . getAddress ( ) , holder . getPort ( ) , InetAddress . getByName ( holder . getAddress ( ) ) ) ;
out . writeObject ( value ) ;
constructors [ TXN_REMOVE_ALL_BACKUP ] = new ConstructorFunction < Integer , IdentifiedDataSerializable > ( ) {
lastDigits = Integer . valueOf ( host . substring ( host . lastIndexOf ( "str" ) + 1 ) ) ;
enumString = enumString . substring ( 1 + enumString . lastIndexOf ( "str" ) ) ;
private static final int RETRY_COUNT = 20 ;
endIndex = value . indexOf ( "str" , startIndex ) ;
int indexSlash = suffix . lastIndexOf ( "str" ) ;
return str . indexOf ( "str" , start ) ;
createDataIn ( clusterA , "str" , 0 , 10 ) ;
throw new HazelcastException ( member + "str" ) ;
config . getMapConfig ( mapName ) . setNearCacheConfig ( new NearCacheConfig ( ) . setInvalidateOnChange ( false ) ) ;
while ( numThreads . get ( ) > = MAX_THREADS ) {
client . getInvocationService ( ) . invokeOnRandomTarget ( request ) . get ( ) ;
@Test ( timeout = 60 * 1000 )
@Test ( timeout = 60 * 1000 )
final EntryCounter counter = new EntryCounter ( ) ;
private static final ConstructorCache CONSTRUCTOR_CACHE = new ConstructorCache ( ) ;
Constructor < T > constructor = CONSTRUCTOR_CACHE . get ( classLoader , className ) ;
CONSTRUCTOR_CACHE . put ( classLoader , className , constructor ) ;
urlString + = "str" + clusterId ;
latch . await ( 600 , TimeUnit . SECONDS ) ;
String keyManagerAlgorithm = properties . getProperty ( "str" , KeyManagerFactory . getDefaultAlgorithm ( ) ) ;
testMapStore . latchStoreOpCount = new CountDownLatch ( mapSize + 1 ) ;
private int maxIdleSeconds = DEFAULT_MAX_IDLE_SECONDS ;
throw new IOException ( "str" + getClass ( ) . getName ( ) + "str" ) ;
throw new IOException ( "str" + getClass ( ) . getName ( ) + "str" ) ;
idGenerator = maxId + 1 ;
inv . invoke ( ) . get ( ) ;
if ( ! list . isEmpty ( ) ) {
for ( String address : getClientConfig ( ) . getAddresses ( ) ) {
public List < String > getAddresses ( ) {
long timeoutMs = ( ( long ) connectionAttempts ) * connectionAttemptPeriodMs + 1000 ;
if ( nodeEngine . getClusterService ( ) . getThisAddress ( ) . equals ( nodeEngine . getPartitionService ( ) . getPartitionOwner ( i ) ) ) {
return maxSize < ( 100 d * used / total ) ;
assertEquals ( TestEventBasedMapStore . STORE_EVENTS . LOAD_ALL_KEYS , testMapStore . waitForEvent ( 30 ) ) ;
assertEquals ( TestEventBasedMapStore . STORE_EVENTS . LOAD , testMapStore . waitForEvent ( 30 ) ) ;
assertEquals ( TestEventBasedMapStore . STORE_EVENTS . STORE_ALL , testMapStore . waitForEvent ( 30 ) ) ;
assertEquals ( null , testMapStore . waitForEvent ( 30 ) ) ;
assertEquals ( TestEventBasedMapStore . STORE_EVENTS . LOAD , testMapStore . waitForEvent ( 30 ) ) ;
assertEquals ( TestEventBasedMapStore . STORE_EVENTS . STORE , testMapStore . waitForEvent ( 30 ) ) ;
assertEquals ( TestEventBasedMapStore . STORE_EVENTS . LOAD , testMapStore . waitForEvent ( 30 ) ) ;
assertEquals ( null , testMapStore . waitForEvent ( 30 ) ) ;
tx . removeTransactionLog ( new TransactionLogKey ( reservedOffer . getItemId ( ) , name ) ) ;
TxnMapRequest request = new TxnMapRequest ( getName ( ) , TxnMapRequest . TxnMapRequestType . REPLACE_IF_SAME , toData ( key ) , toData ( oldValue ) , toData ( newValue ) ) ;
REPLACE_IF_SAME ( 7 ) ,
maxSize = nearCacheConfig . getMaxSize ( ) < = 0 ? Integer . MAX_VALUE : nearCacheConfig . getMaxSize ( ) ;
assertTrue ( latch . await ( 5 , TimeUnit . MINUTES ) ) ;
assertFalse ( ( Boolean ) client . receive ( ) ) ;
active = false ;
Assert . assertTrue ( latch . await ( 10 , TimeUnit . SECONDS ) ) ;
Thread . sleep ( 1000 * 60 ) ;
return MapDataSerializerHook . MAP_STATS ;
if ( address = = null ) {
return value ! = null & & value . equals ( entryValue ) ;
value = value ! = null ? value : toObject ( dataValue ) ;
public ServiceProxy getProxy ( Object . . . params ) {
long diff = Clock . currentTimeMillis ( ) - client . getInRunnable ( ) . lastReceived ;
final boolean result = pm . runMigrationTasks ( tasks , partitionId , replicaIndex , from ) ;
addActiveMigration ( migrationRequestOp . createMigratingPartition ( ) ) ;
compareAndSetActiveMigratingPartition ( migrationRequestOp . createMigratingPartition ( ) , null ) ;
compareAndSetActiveMigratingPartition ( migrationRequestOp . createMigratingPartition ( ) , null ) ;
int size = factory . node . clientHandlerService . numberOfConnectedClients ( ) ;
logger . log ( Level . FINEST , "str" + migrationRequestTask ) ;
logger . log ( Level . FINEST , "str" + migrationRequestTask ) ;
Runnable t = new RunAfterTester (
Runnable t = new RunAfterTester (
Runnable t = new RunAfterTester (
handleSecurityPermissionEndpoints ( child , permConfig ) ;
handleSecurityPermissionActions ( child , permConfig ) ;
public void performanceWithLotsOfExecutingTasks ( ) throws InterruptedException , ExecutionException {
volatile boolean active = true ;
import java . io . FileInputStream ;
bundle . load ( new FileInputStream ( new File ( "str" ) ) ) ;
xml . append ( "str" ) . append ( m . isReadBackupData ( ) ) . append ( "str" ) ;
public ThreadInfo [ ] getAllThreads ( ) {
public ThreadInfo [ ] findDeadlockedThreads ( ) {
long [ ] tids = objectCall ( threadMxBean , ThreadMXBean_findDeadlockedThreads ) ;
public ThreadInfo [ ] getAllThreads ( ) {
public ThreadInfo [ ] findDeadlockedThreads ( ) {
node . factory . getExecutorService ( "str" ) . execute ( dt ) ;
if ( pairs ! = null & & pairs . getKeyValues ( ) ! = null ) {
registerBeanDefinitionParser ( "str" , new CacheProviderBeanDefinitionParser ( ) ) ;
@Test ( expected = IllegalStateException . class , timeout = 50000L )
@Test ( expected = NoMemberAvailableException . class , timeout = 50000L )
public void putWithTTL ( ) throws InterruptedException {
IMap < String , String > map = hClient . getMap ( "str" ) ;
Thread . sleep ( 200 ) ;
for ( int i = 0 ; i < 100 ; i + + ) {
for ( int i = 0 ; i < 100 ; i + + ) {
request . value = toData ( dataRecordEntry . getValue ( ) ) ;
maxSizePerJVM = ( qconfig . getMaxSizePerJVM ( ) = = 0 ) ? Integer . MAX_VALUE : qconfig . getMaxSizePerJVM ( ) ;
private final class AddListenerAtTarget extends TargetAwareOp {
if ( ! ( o instanceof Record ) ) return false ;
Thread . sleep ( 50 ) ;
assertTrue ( "str" , latch . await ( 25 , TimeUnit . SECONDS ) ) ;
@Test ( expected = NullPointerException . class )
inner . innerSetException ( new TimeoutException ( ) , false ) ;
inner . innerSetException ( ( Throwable ) result , true ) ;
record . setVersion ( + + version ) ;
removedValueCount = values . size ( ) ;
LocalQueueOperationStats localQueueOperationStats = memberQStat . getLocalQueueStats ( ) . getOperationStats ( ) ;
entryListeners . get ( name ) . put ( key , new CopyOnWriteArrayList < EntryListener < ? , ? > > ( ) ) ;
messageListeners . put ( name , new CopyOnWriteArrayList < MessageListener < Object > > ( ) ) ;
IMap < String , String > map = hClient . getMap ( "str" ) ;
return ( int ) ( diff * Math . random ( ) + from ) ;
public static final int STATS_SECONDS = 10 ;
protected static final Logger logger = Logger . getLogger ( JcaBase . class . getName ( ) ) ;
protected volatile Map . Entry lastMultiMapEntry ;
assertTrue ( latch . await ( 10000 , TimeUnit . MILLISECONDS ) ) ;
assertFalse ( latch . await ( 10000 , TimeUnit . MILLISECONDS ) ) ;
assertTrue ( latch . await ( 10000 , TimeUnit . MILLISECONDS ) ) ;
@Test ( timeout = 40000 )
public Data key = null ;
public Data value = null ;
result = toObjectWithConfigClassLoader ( data ) ;
public Set < K > localKeySet ( ) {
public Set < K > localKeySet ( Predicate predicate ) {
Set < K > keySet ( Predicate predicate ) ;
Set < Map . Entry < K , V > > entrySet ( Predicate predicate ) ;
Set < K > localKeySet ( ) ;
Set < K > localKeySet ( Predicate predicate ) ;
public Set < K > localKeySet ( ) {
public Set < K > localKeySet ( Predicate predicate ) {
final IMap < String , byte [ ] > map = hClient . getMap ( "str" ) ;
assertTrue ( entryAddLatch . await ( 10 , TimeUnit . SECONDS ) ) ;
import com . hazelcast . core . EntryEventType ;
void memberAdded ( MembershipEvent membershipEvent ) ;
void memberRemoved ( MembershipEvent membershipEvent ) ;
ItemListener l = ( ItemListener ) listener ;
l . itemAdded ( event . getKey ( ) ) ;
l . itemRemoved ( event . getKey ( ) ) ;
Map counter = new HashMap ( ) ;
counter . put ( integer , ( Integer ) counter . get ( integer ) - 1 ) ;
protected final Request request ;
getScheduledActions ( ) . add ( scheduledAction ) ;
return ( valueCount ( ) < = 0 & & ! hasListener ( ) & & ( getScheduledActions ( ) = = null | | getScheduledActions ( ) . size ( ) = = 0 ) & & ( getBackupOps ( ) = = null | | getBackupOps ( ) . size ( ) = = 0 ) ) ;
return ( lockCount = = 0 & & ! hasListener ( ) & & ( getScheduledActions ( ) = = null | | getScheduledActions ( ) . size ( ) = = 0 ) ) ;
public List < BaseManager . ScheduledAction > getScheduledActions ( ) {
public void setScheduledActions ( List < BaseManager . ScheduledAction > lsScheduledActions ) {
if ( deadAddress = = null | | deadAddress . equals ( thisAddress ) ) return ;
TransactionalMap txnMap = newTransactionalMapProxy ( "str" ) ;
TransactionalMap txnMap = newTransactionalMapProxy ( "str" ) ;
TransactionalMap txnMap = newTransactionalMapProxy ( "str" ) ;
TransactionalMap txnMap = newTransactionalMapProxy ( "str" ) ;
dos . writeUTF ( object . getClass ( ) . getName ( ) . replaceFirst ( "str" , "str" ) ) ;
DataSerializable data = ( DataSerializable ) Class . forName ( className . replaceFirst ( "str" , "str" ) ) . newInstance ( ) ;
private final long WAIT_MILLIS_BEFORE_JOIN = ConfigProperty . WAIT_SECONDS_BEFORE_JOIN . getInteger ( ) * 1000L ;
private final long MAX_NO_HEARTBEAT_MILLIS = ConfigProperty . MAX_NO_HEARTBEAT_SECONDS . getInteger ( ) * 1000L ;
if ( ( now - memberImpl . getLastRead ( ) ) > = ( MAX_NO_HEARTBEAT_MILLIS ) ) {
if ( ( now - masterMember . getLastRead ( ) ) > = ( MAX_NO_HEARTBEAT_MILLIS ) ) {
timeToStartJoin = System . currentTimeMillis ( ) + WAIT_MILLIS_BEFORE_JOIN ;
timeToStartJoin = System . currentTimeMillis ( ) + WAIT_MILLIS_BEFORE_JOIN ;
node . executorManager . executeLocally ( new Runnable ( ) {
node . executorManager . executeLocally ( new Runnable ( ) {
node . queryService . updateIndex ( name , null , record , Integer . MIN_VALUE ) ;
request . response = cmap . valueCount ( request . key ) ;
Block ownerBlock = getOrCreateBlock ( blockId ) ;
public interface ISet < E > extends ICollection < E > , Set < E > {
System . err . println ( String . format ( "str" , offsets . position ( ) ) ) ;
String s = inputText . getSubstring ( offset , offset + length ) ;
String s = inputText . getSubstring ( offset , offset + sublength ) ;
= new WordInfo ( s , ( short ) length ,
if ( ! beginLists . get ( size ) . get ( 0 ) . isConnectedToBOS ) {
( cinfo . isInvoke | | otherWordsLength . isEmpty ( ) ) ) {
if ( cinfo . isInvoke | | otherWordsLength . isEmpty ( ) ) {
if ( line . matches ( "str" ) ) {
String url = String . format ( "str" ,
return ! this . buildConfigs . isEmpty ( ) ;
return this . buildConfigs . isEmpty ( ) ;
return ! this . buildConfigs . isEmpty ( ) ;
if ( ! failedTestMessages . isEmpty ( ) ) {
if ( namedChildren . isEmpty ( ) )
if ( ! tempSlackNotificationList . isEmpty ( ) ) {
if ( ! statesList . isEmpty ( ) ) {
if ( ! typesList . isEmpty ( ) ) {
if ( ! templateList . isEmpty ( ) ) {
if ( ! this . enabledBuildTypesSet . isEmpty ( ) ) {
public static final String DEFAULT_ICONURL = "str" ;
if ( i > = bitsLength )
. create ( "str" )
if ( ( id ! = null ) & & ( STORE . containsKey ( id ) ) ) {
if ( sessions . size ( ) > = sessionlimit ) {
log . debug ( "str" , value ) ;
log . debug ( "str" + url + "str" + classLoader ) ;
import java . util . concurrent . ExecutorService ;
ExecutorService getExecutor ( ) ;
protected boolean removeEldestEntry (
boolean populateDefaults ) {
+ confFileName , this . props ) ;
this . props ) ;
this . props ) ;
. getContextClassLoader ( ) ;
this . defaultProps ) ;
this . defaultProps ) ;
+ confFileName ) ;
public String getBeliefSystemType ( ) {
public static final String TASK_USER_GROUP_CALLBACK = "str" ;
void setGlobal ( String identifier ,
Map < String , Channel > getChannels ( ) ;
Class < DroolsJaxbHelperProvider > cls = ( Class < DroolsJaxbHelperProvider > ) Class . forName ( "str" ) ;
throw new RuntimeException ( "str" ,
package org . drools . compiler ;
package org . drools . compiler ;
package org . drools . compiler ;
package org . drools . compiler ;
package org . drools . compiler ;
package org . drools . compiler ;
package org . drools . compiler ;
package org . drools . compiler ;
package org . drools . compiler ;
package org . drools . compiler ;
package org . drools . compiler ;
INSTANCE = ( KieServices ) Class . forName ( "str" ) . newInstance ( ) ;
Class < BatchExecutionHelperProvider > cls = ( Class < BatchExecutionHelperProvider > ) Class . forName ( "str" ) ;
throw new RuntimeException ( "str" ,
Class < DroolsJaxbHelperProvider > cls = ( Class < DroolsJaxbHelperProvider > ) Class . forName ( "str" ) ;
throw new RuntimeException ( "str" ,
Class < KnowledgeRuntimeLoggerFactoryService > cls = ( Class < KnowledgeRuntimeLoggerFactoryService > ) Class . forName ( "str" ) ;
throw new RuntimeException ( "str" ,
private static String providerClassName = "str" ;
Class < KnowledgeStoreService > cls = ( Class < KnowledgeStoreService > ) Class . forName ( "str" ) ;
throw new RuntimeException ( "str" ,
Class < CommandFactoryService > cls = ( Class < CommandFactoryService > ) Class . forName ( "str" ) ;
throw new RuntimeException ( "str" ,
this . severity = severity ! = null ? severity : ResultSeverity . INFO ;
public int getKnowledgeSessionId ( ) ;
Class < KnowledgeStoreService > cls = ( Class < KnowledgeStoreService > ) Class . forName ( "str" ) ;
throw new RuntimeException ( "str" ,
Object value ) ;
return "str" + ( ( dir = = null ) ? "str" : dir . toString ( ) ) + "str" ;
StatefulKnowledgeSession newStatefulKnowledgeSession ( KnowledgeSessionConfiguration conf ) ;
private static final String VERSION = "str" ;
data . putString ( KEY_NAME_VERSION , VERSION ) ;
int ans = 0 ;
edgeType ( v ) ;
int k = n > > 1 ;
return fib [ n ] = b * b + a * a ;
LOGGER . debug ( "str" ) ;
aptUtils . printError ( "str" ,
expectException . expectMessage ( format ( "str" +
Validator . validateTrue ( Tuple10 . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o ) ;
Validator . validateTrue ( TupleValue . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o , TupleValue . class . getCanonicalName ( ) ) ;
expectException . expectMessage ( format ( "str" +
Validator . validateTrue ( Tuple7 . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o ) ;
Validator . validateTrue ( TupleValue . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o , TupleValue . class . getCanonicalName ( ) ) ;
Validator . validateTrue ( Tuple9 . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o ) ;
Validator . validateTrue ( TupleValue . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o , TupleValue . class . getCanonicalName ( ) ) ;
trace . append ( format ( "str" , queryString ) ) ;
Validator . validateTrue ( Tuple4 . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o ) ;
Validator . validateTrue ( TupleValue . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o , TupleValue . class . getCanonicalName ( ) ) ;
Validator . validateTrue ( Tuple3 . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o ) ;
Validator . validateTrue ( TupleValue . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o , TupleValue . class . getCanonicalName ( ) ) ;
Validator . validateTrue ( Map . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o ) ;
Validator . validateTrue ( Map . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o ,
Validator . validateTrue ( Set . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o ) ;
Validator . validateTrue ( Set . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o , valueToClass . getCanonicalName ( ) ) ;
Validator . validateTrue ( valueClass . isAssignableFrom ( o . getClass ( ) ) , "str" , o , valueClass . getCanonicalName ( ) ) ;
Validator . validateTrue ( UDTValue . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o , UDTValue . class . getCanonicalName ( ) ) ;
validateNotNull ( keyspaceMetadata , "str" ,
validateNotNull ( tableMetadata , "str" ,
Validator . validateTrue ( List . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o ) ;
Validator . validateTrue ( List . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o , o ) ;
Validator . validateTrue ( Tuple5 . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o ) ;
Validator . validateTrue ( TupleValue . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o , TupleValue . class . getCanonicalName ( ) ) ;
Validator . validateTrue ( Tuple8 . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o ) ;
Validator . validateTrue ( TupleValue . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o , TupleValue . class . getCanonicalName ( ) ) ;
Validator . validateTrue ( valueFromTypeToken . getRawType ( ) . isAssignableFrom ( o . getClass ( ) ) , "str" , o , valueFromTypeToken ) ;
Validator . validateTrue ( valueToTypeToken . getRawType ( ) . isAssignableFrom ( o . getClass ( ) ) , "str" , o , valueToTypeToken ) ;
Validator . validateTrue ( Tuple6 . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o ) ;
Validator . validateTrue ( TupleValue . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o , TupleValue . class . getCanonicalName ( ) ) ;
Validator . validateTrue ( cqlClass . isAssignableFrom ( o . getClass ( ) ) , "str" , o , cqlClass . getCanonicalName ( ) ) ;
Validator . validateTrue ( Tuple2 . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o ) ;
Validator . validateTrue ( TupleValue . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o , TupleValue . class . getCanonicalName ( ) ) ;
Validator . validateTrue ( Tuple1 . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o ) ;
Validator . validateTrue ( TupleValue . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o , TupleValue . class . getCanonicalName ( ) ) ;
throw new AchillesException ( format ( "str" , cacheKey ) ) ;
Validator . validateTrue ( Optional . class . isAssignableFrom ( o . getClass ( ) ) , "str" , o ) ;
LOGGER . debug ( format ( "str" ,
trace . append ( format ( "str" , queryId . toString ( ) , executionInfo . getQueriedHost ( ) , executionInfo . getAchievedConsistencyLevel ( ) ) ) ;
manager . insert ( tweet1 ) . getImmediately ( ) ;
when ( flushContext . duplicateWithNoData ( ONE ) ) . thenReturn ( newFlushContext ) ;
when ( flushContext . duplicateWithNoData ( ONE ) ) . thenReturn ( newFlushContext ) ;
flushContext = flushContext . duplicateWithNoData ( defaultConsistencyLevel ) ;
flushContext = flushContext . duplicateWithNoData ( defaultConsistencyLevel ) ;
static final int DEFAULT_CACHE_SIZE = 10000 ;
assertThat ( ( Integer ) result . get ( "str" ) ) . isLessThanOrEqualTo ( 1000 ) ;
exception . expectMessage ( "str" ) ;
exception . expectMessage ( "str" ) ;
exception . expectMessage ( "str" ) ;
exception . expectMessage ( "str" ) ;
exception . expectMessage ( "str" ) ;
exception . expectMessage ( "str" ) ;
exception . expectMessage ( "str" ) ;
exception . expectMessage ( "str" ) ;
exception . expectMessage ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
if ( valueSerializer = = OBJECT_SRZ )
private int queueSize = 400 ;
jettyServer = new Server ( new QueuedThreadPool ( 450 ) ) ;
sentence = preprocessor . process ( language , sourceStr ) ;
File [ ] paths = modelPath . listFiles ( path - > path . isFile ( ) & & path . getName ( ) . endsWith ( "str" ) ) ;
private native long instantiate ( String modelFile , int threads ) ;
hasRightSpace = transformation . end < originalChars . length ;
hasRightSpace = transformation . end < nextTransformation . start ;
Option databasePort = Option . builder ( ) . longOpt ( "str" ) . hasArg ( ) . required ( false ) . build ( ) ;
String databasePort = cli . getOptionValue ( "str" ) ;
String msg = gpu < 0 ? "str" : ( "str" + gpu ) ;
lengthThreshold = cli . hasOption ( "str" ) ? Integer . parseInt ( cli . getOptionValue ( "str" ) ) : 0 ;
return getContextVector ( direction , new StringCorpus ( null , direction . source , query ) , limit ) ;
return getContextVector ( direction , new FileCorpus ( source , null , direction . source ) , limit ) ;
throw new ConfigException ( "str" ) ;
return match ( sourceLine , source ) > = threshold & & match ( targetLine , target ) > = threshold ;
String query = "str" ;
String query = "str" ;
String query = "str" ;
String query = "str" ;
return read ( result , "str" ) ;
return readAll ( result , "str" ) ;
config . setUser ( this . getStringAttribute ( "str" ) ) ;
config . setPassword ( this . getStringAttribute ( "str" ) ) ;
if ( properties . containsKey ( "str" ) )
if ( properties . containsKey ( "str" ) )
memory = new LuceneTranslationMemory ( languages , args . modelPath , 10 ) ;
super ( new LanguageIndex ( Arrays . asList ( languages ) ) , new RAMDirectory ( ) , 10 ) ;
public static final long TARGET_WORDS = 90000000 ;
double reduction = 1. ;
copy ( corpus , output , reduction ) ;
return start ( 0 ) ;
this . storage = new CorporaStorage ( new File ( indexPath , "str" ) , options , this . index ) ;
private void ensureDecoderSupportsNBest ( ) {
throw new IOException ( "str" + ( this . index + 1 ) ) ;
alignerConfig . setEnabled ( section . getBoolean ( "str" , true ) ) ;
json . add ( "str" , error ) ;
super ( "str" + cause . getMessage ( ) , cause ) ;
throw new XMLStreamException ( "str" + reader . getLocation ( ) . getLineNumber ( ) , e ) ;
private final int mColorStart ;
private final int mColorEnd ;
private final int mCount = 10 ;
private final EventType mType ;
private final long mSpinDuration ;
private final float mMinValue ;
private final float mMaxValue ;
private final float mInitialValue ;
private final boolean mInitialVisibility ;
private final boolean mSpinClockwise ;
private final boolean mRoundCap ;
private final boolean mDrawAsPoint ;
private final ChartStyle mChartStyle ;
private final Interpolator mInterpolator ;
private final boolean mShowPointWhenEmpty ;
private final RectF mSpinBounds = new RectF ( ) ;
private final ArcEventManagerListener mListener ;
private final String mLabel ;
private final int mColor ;
private final float mRatio ;
private final EdgeType mEdgeType ;
private int mRotateAngle ;
static private boolean mInitialized ;
private float mMinValue ;
private float mInitialValue ;
private boolean mDrawAsPoint ;
private View [ ] mLinkedViews ;
private boolean mInitialized ;
private boolean mIsPaused ;
float lineWidth = getSeriesItem ( ) . getLineWidth ( ) / 2 ;
mTextCenter = ( mPaintText . descent ( ) + mPaintText . ascent ( ) ) / 2 ;
final float remain = 1.0f - step ;
float rotateOffset = rotateAmount * percentComplete ;
float completed = ( percentComplete - 0.5f ) * 2 ;
final boolean ignore = event . getEventType ( ) = = DecoEvent . EventType . EVENT_MOVE ;
float percentFilled = ( currentPosition - seriesItem . getMinValue ( ) ) / ( seriesItem . getMaxValue ( ) - seriesItem . getMinValue ( ) ) ;
return start / max ;
Log . v ( TAG , "str" ) ;
return new Feedback ( configuration , "str" , warning , "str" , "str" , "str" , "str" , "str" ) ;
printGenerationInfo ( nbvcxz , Generator . generatePassphrase ( delimiter , words ) ) ;
public static String generatePassphrase ( final String delimiter , final int words )
return generatePassphrase ( delimiter , words , new Dictionary ( "str" , DictionaryUtil . loadUnrankedDictionary ( DictionaryUtil . eff_large ) , false ) ) ;
public static String generatePassphrase ( final String delimiter , final int words , final Dictionary dictionary )
String k = args [ i ] . toUpperCase ( ) ;
String jarName = "str" ;
labels . get ( DOCKER_TEMPLATE_LABEL ) . equals ( template . getId ( ) ) ) {
segmentFraction = 0.0 ;
if ( ! resultEP . isValid ( ) )
if ( ! resultEP . isValid ( ) )
if ( ! resultEP . isValid ( ) )
if ( ! resultEP . isValid ( ) )
if ( ! resultEP . isValid ( ) )
throw new InvalidShapefileException ( "str" ) ;
System . out . println ( "str" ) ;
if ( noRepeatedCoords . length < minLength ) {
if ( iter = = 0 ) System . out . println ( "str" ) ;
if ( ! ( hasAuths | | hasCredHelpers | | hasCredsStore ) ) {
@JsonProperty ( "str" ) final Map < String , String > credHelpers ,
credHelpers = = null
: ImmutableMap . copyOf ( credHelpers ) ,
. password ( AUTH_PASSWORD ) . build ( ) ;
compareVersion ( sut . version ( ) . apiVersion ( ) , "str" ) > = 0 ) ;
logs = stream . readFully ( ) ;
resource . request ( APPLICATION_JSON_TYPE ) ) ;
throws DockerException , InterruptedException {
public InputStream save ( final String image )
public InputStream save ( final String image , final AuthConfig authConfig )
. header ( "str" , authHeader ( ) ) ) ) {
String . valueOf ( true ) ) ;
throws DockerException , InterruptedException {
throws DockerException , InterruptedException {
throws DockerException , InterruptedException {
ObjectMapperProvider . objectMapper ( ) . writeValueAsString ( authRegistryConfig ) ;
. or ( defaultCertPath ( ) ) ) ;
. dockerCertPath ( dockerCertPath ) . build ( ) ;
void load ( String image , InputStream imagePayload )
void load ( String image , InputStream imagePayload , ProgressHandler handler )
void load ( String image , InputStream imagePayload , AuthConfig authConfig )
void load ( String image , InputStream imagePayload , AuthConfig authConfig ,
InputStream save ( String image , AuthConfig authConfig )
void pull ( String image , AuthConfig authConfig ) throws DockerException , InterruptedException ;
throws DockerException , InterruptedException , IOException ;
@JsonProperty ( "str" ) private List < List < String > > driverStatus ;
public List < List < String > > driverStatus ( ) {
. property ( ClientProperties . READ_TIMEOUT , ( int ) NO_TIMEOUT )
"str" ) ) ) ;
"str" ) ) ) ;
src1 , src2 , src3 ) ;
BiFunction < ? super A , ? super B , ? extends R > f ) {
TriFunction < ? super A , ? super B , ? super C , ? extends R > f ) {
TetraFunction < ? super A , ? super B , ? super C , ? super D , ? extends R > f ) {
PentaFunction < ? super A , ? super B , ? super C , ? super D , ? super E , ? extends R > f ) {
HexaFunction < ? super A , ? super B , ? super C , ? super D , ? super E , ? super F , ? extends R > f ) {
forEachObserver ( s - > {
userContentLength = Long . parseLong ( headerValue ) ;
clientRequest . content ( new InputStreamContentProvider ( iss ) {
if ( StrUtil . containsAnyIgnoreCase ( field , "str" , "str" , "str" , "str" ) ) {
hints . put ( EncodeHintType . CHARACTER_SET , charset . toString ( ) . toLowerCase ( ) ) ;
return CollectionUtil . addAll ( new ArrayList < > ( ) , networkInterfaces ) ;
long size = mNum * 1024 * 1024 * 8 ;
return readLines ( url , charset , new ArrayList < > ( ) ) ;
return readLines ( url , charset , new ArrayList < > ( ) ) ;
return readLines ( path , charset , new ArrayList < > ( ) ) ;
return readLines ( path , charset , new ArrayList < > ( ) ) ;
return readLines ( file , charset , new ArrayList < > ( ) ) ;
return readLines ( file , charset , new ArrayList < > ( ) ) ;
String url = "str" ;
Assert . assertEquals ( "str" , host . toString ( ) ) ;
return cookieManager . getCookieStore ( ) . get ( getURI ( conn ) ) ;
cookieHeader = cookieManager . get ( getURI ( conn ) , new HashMap < String , List < String > > ( 0 ) ) ;
this . yearMatchers . add ( new AlwaysTrueValueMatcher ( ) ) ;
return ( null = = set ) ? Collections . < K , V > emptyMap ( ) : set ;
return isOrder ? new LinkedHashMap < K , V > ( initialCapacity ) : new HashMap < K , V > ( initialCapacity ) ;
return builder ( new HashMap < K , V > ( ) ) ;
return CollectionUtil . addAll ( new ArrayList < NetworkInterface > ( ) , networkInterfaces ) ;
storage . add ( new HashMap < String , List < Long > > ( ) ) ;
return beanToMap ( bean , new LinkedHashMap < String , Object > ( ) , isToUnderlineCase , ignoreNullValue ) ;
return isSorted ? new LinkedHashSet < T > ( ) : new HashSet < T > ( ) ;
final HashSet < T > set = isSorted ? new LinkedHashSet < T > ( initialCapacity ) : new HashSet < T > ( initialCapacity ) ;
final HashSet < T > set = isSorted ? new LinkedHashSet < T > ( ) : new HashSet < T > ( ) ;
final HashSet < T > set = isSorted ? new LinkedHashSet < T > ( ) : new HashSet < T > ( ) ;
return isLinked ? new LinkedList < T > ( ) : new ArrayList < T > ( ) ;
final List < T > arrayList = isLinked ? new LinkedList < T > ( ) : new ArrayList < T > ( values . length ) ;
return ( null = = collection ) ? ( new CopyOnWriteArrayList < T > ( ) ) : ( new CopyOnWriteArrayList < T > ( collection ) ) ;
final List < T > list2 = ( list instanceof LinkedList ) ? new LinkedList < T > ( ) : new ArrayList < T > ( list . size ( ) ) ;
final List < T > list2 = ( list instanceof LinkedList ) ? new LinkedList < T > ( ) : new ArrayList < T > ( list . size ( ) ) ;
private static byte [ ] bigIntToFixedLengthBytes ( BigInteger rOrS ) {
pathToUse = pathToUse . replaceAll ( "str" , StrUtil . SLASH ) . trim ( ) ;
this . rowCellList = new ArrayList < > ( this . rowCellList . size ( ) ) ;
byte [ ] result ;
byte [ ] result ;
count + + ;
STEPFUNCTIONS ( "str" , 4585 ) ,
this ( "str" ) ;
. post ( RequestBody . create ( MediaType . parse ( "str" ) , objectMapper . writeValueAsBytes ( entity ) ) )
withEnv ( "str" , "str" + networkAlias + "str" + "str" + getBootstrapServers ( ) ) ;
throw new RuntimeException ( "str" ) ;
Uninterruptibles . sleepUninterruptibly ( 10 , TimeUnit . SECONDS ) ;
if ( dockerConfigPath ! = null & & ! dockerConfigPath . isEmpty ( ) ) {
LOGGER . info ( "str" + scriptPath ) ;
} catch ( IOException | UnsupportedOperationException e ) {
private final Set < Consumer < CreateContainerCmd > > createContainerCmdModifiers = new LinkedHashSet < > ( ) ;
createContainerCmdModifiers . forEach ( hook - > hook . accept ( createCommand ) ) ;
createContainerCmdModifiers . add ( modifier ) ;
this . prefix = "str" + prefix + "str" ;
this . followOutput ( new Slf4jLogConsumer ( logger ( ) ) ) ;
LOGGER . debug ( "str" , containerId , e . getMessage ( ) ) ;
protected String tag = "str" ;
LOGGER . debug ( "str" , containerId , e ) ;
@RequestParam ( value = "str" , required = false ) String clientId ,
public void outputFileImageTest ( ) throws IOException {
return this . ordinal ( ) ;
throw new IllegalStateException ( "str" ) ;
+ "str" ) ;
"str" + anInterface . getSimpleName ( )
. getGrapheneContext ( ) ;
GrapheneContext grapheneContext = ( ( GrapheneProxyInstance ) searchContext ) . getGrapheneContext ( ) ;
GrapheneContext grapheneContext = ( ( GrapheneProxyInstance ) root ) . getGrapheneContext ( ) ;
GrapheneContext grapheneContext = ( ( GrapheneProxyInstance ) searchContext ) . getGrapheneContext ( ) ;
GrapheneContext grapheneContext = ( ( GrapheneProxyInstance ) searchContext ) . getGrapheneContext ( ) ;
. getGrapheneContext ( ) ;
. getGrapheneContext ( ) ;
GrapheneContext grapheneContext = searchContext = = null ? null : ( ( GrapheneProxyInstance ) searchContext ) . getGrapheneContext ( ) ;
return ( ( GrapheneProxyInstance ) searchContext ) . getGrapheneContext ( ) ;
GrapheneContext getGrapheneContext ( ) ;
if ( method . equals ( GrapheneProxyInstance . class . getMethod ( "str" ) ) ) {
GrapheneContext grapheneContext = searchContext = = null ? null : ( ( GrapheneProxyInstance ) searchContext ) . getGrapheneContext ( ) ;
return new WebDriverWaitImpl < Void > ( null , driver , ( ( GrapheneProxyInstance ) driver ) . getGrapheneContext ( ) . getConfiguration ( ) . getWaitAjaxInterval ( ) ) ;
return new WebDriverWaitImpl < Void > ( null , driver , ( ( GrapheneProxyInstance ) driver ) . getGrapheneContext ( ) . getConfiguration ( ) . getWaitGuiInterval ( ) ) ;
return new WebDriverWaitImpl < Void > ( null , driver , ( ( GrapheneProxyInstance ) driver ) . getGrapheneContext ( ) . getConfiguration ( ) . getWaitModelInterval ( ) ) ;
context = ( ( GrapheneProxyInstance ) target ) . getGrapheneContext ( ) ;
return ( ( GrapheneProxyInstance ) object ) . getGrapheneContext ( ) ;
GrapheneContext grapheneContext = searchContext = = null ? null : ( ( GrapheneProxyInstance ) searchContext ) . getGrapheneContext ( ) ;
sb . append ( "str" + COUNTER + + ) ;
public static class SeleniumHubWithoutScheme {
public static class SeleniumHubWithScheme {
if ( ! file . exists ( ) ) {
browser . navigate ( ) . to ( "str" ) ;
GrapheneContext . getContextFor ( Default . class ) . getWebDriver ( ) . navigate ( ) . to ( "str" ) ;
String contextRoot = System . getProperty ( "str" , "str" ) ;
String contextPath = System . getProperty ( "str" , "str" ) ;
String browser = System . getProperty ( "str" , "str" ) ;
String seleniumPort = System . getProperty ( "str" , "str" ) ;
public void addSelection ( ElementLocator < ? > elementLocator , OptionLocator < ? > optionLocator ) {
public void removeSelection ( ElementLocator < ? > elementLocator , OptionLocator < ? > optionLocator ) {
void addSelection ( ElementLocator < ? > locator , OptionLocator < ? > optionLocator ) ;
void removeSelection ( ElementLocator < ? > locator , OptionLocator < ? > optionLocator ) ;
return commandProcessor . getString ( "str" , new String [ ] { locator , property } ) ;
logStatus ( result , true ) ;
logStatus ( result , false ) ;
logStatus ( result , false ) ;
logStatus ( result , false ) ;
logStatus ( result , false ) ;
private void logStatus ( ITestResult result , boolean isTestStart ) {
count + = isTestStart ? 1 : 0 ;
return index < count ;
return new JavaScript ( javaScript ) ;
invoke & = ! ( ( AfterMethod . class = = type ) & & ( ! testResult . isSuccess ( ) ) & & ( ! getMethodAlwaysRun ( annotation ) ) ) ;
return new JavaScript ( format ( "str" , elementLocator . getAsString ( ) , text ) ) ;
@Parameter ( property = "str" , defaultValue = "str" )
FilenameUtils . normalize ( file ) ) ;
@Parameter ( defaultValue = "str" )
@Parameter ( defaultValue = "str" )
@Parameter ( defaultValue = "str" )
@Parameter ( defaultValue = "str" )
RunJMeterMojo . copyFilesInTestDirectory ( sourceDirectory , destinationDirectory ) ;
is ( equalTo ( "str" + "str" + "str" + File . separator + "str" + "str" + testFile . getAbsolutePath ( ) ) ) ) ;
is ( equalTo ( "str" + "str" + File . separator + "str" + testArgs . getResultsLogFileName ( ) + "str" + testFilePath ) ) ) ;
assertThat ( testConfig . getFullConfig ( ) , is ( equalTo ( String . format ( "str" , System . lineSeparator ( ) ) ) ) ) ;
assertThat ( testConfig . getFullConfig ( ) , is ( equalTo ( String . format ( "str" , System . lineSeparator ( ) ) ) ) ) ;
getLog ( ) . debug ( "str" + artifactToCopy . getAbsolutePath ( ) + "str" ) ;
getLog ( ) . debug ( "str" + artifactToCopy . getAbsolutePath ( ) + "str" ) ;
@Parameter ( defaultValue = "str" )
protected boolean scanResultsForFailedRequests ;
protected boolean scanResultsForSuccessfulRequests ;
for ( int i = 0 ; i < trail . size ( ) ; i + + ) {
if ( dependency . contains ( "str" ) ) {
private boolean timestampResults = false ;
private boolean enableReports = false ;
private String start = null ;
if ( ! stopped & & 100 > t & & t > 0 ) {
} catch ( Exception e ) {
String VERSION = "str" ;
return this . validate ( solution , context , options . logger_detailed ? options . logger_appender : null ) ;
final double oldValue = tmpIndex > = 0 ? myStorage . doubleValueInternally ( tmpIndex ) : PrimitiveMath . NaN ;
final N oldValue = tmpIndex > = 0 ? myStorage . getInternally ( tmpIndex ) : null ;
while ( ( tmpUnits ! = 1L ) & & ( tmpSegmentSize > = tmpCacheDim ) & & ( ( retVal * tmpUnits ) < = tmpMaxNumberOfSegments ) ) {
while ( ( tmpUnits ! = 1L ) & & ( tmpSegmentSize > = tmpCacheDim ) & & ( ( retVal * tmpUnits ) < = tmpMaxNumberOfSegments ) ) {
public static final String DEFAULT_NAMESPACE = "str" ;
static final String ATTRIBUTE_PREFIX = "str" ;
private String namespace = DEFAULT_NAMESPACE + "str" ;
public static final String DEFAULT_NAMESPACE = "str" ;
private String namespace = DEFAULT_NAMESPACE + "str" ;
Assert . notNull ( cached , "str" ) ;
Assert . notNull ( delegate , "str" ) ;
servletContext . addServlet ( "str" , new WebServlet ( ) ) . addMapping ( "str" ) ;
public RedisSerializer < Object > springSessionDefaultRedisSerializer ( ) {
@Qualifier ( "str" )
assertThat ( strategy . encodeURL ( "str" , "str" ) ) . isEqualTo ( "str" ) ;
assertThat ( strategy . encodeURL ( "str" , "str" ) ) . isEqualTo ( "str" ) ;
assertThat ( strategy . encodeURL ( "str" , "str" ) ) . isEqualTo ( "str" ) ;
assertThat ( strategy . encodeURL ( "str" , "str" ) ) . isEqualTo ( "str" ) ;
assertThat ( strategy . encodeURL ( "str" , "str" ) ) . isEqualTo ( "str" ) ;
assertThat ( strategy . encodeURL ( "str" , "str" ) ) . isEqualTo ( "str" ) ;
assertThat ( strategy . encodeURL ( "str" , "str" ) ) . isEqualTo ( "str" ) ;
assertThat ( strategy . encodeURL ( "str" , "str" ) ) . isEqualTo ( "str" ) ;
assertThat ( strategy . encodeURL ( "str" , "str" ) ) . isEqualTo ( "str" ) ;
assertThat ( strategy . encodeURL ( "str" , "str" ) ) . doesNotContain ( "str" ) ;
assertThat ( strategy . encodeURL ( "str" , "str" ) ) . isEqualTo ( "str" ) ;
assertThat ( strategy . encodeURL ( "str" , "str" ) ) . isEqualTo ( "str" ) ;
static final String DEFAULT_SESSION_ALIAS_PARAM_NAME = "str" ;
. stroke ( 0xff000000 , 1 , true ) ) ;
public Badge stroke ( int color , float width , boolean isDpValue ) {
Badge stroke ( int color , float width , boolean isDpValue ) ;
if ( isCueDimensionSet ( cuePosition ) ) {
if ( isCueDimensionSet ( cueLine ) ) {
static boolean restrictLightLevel = true ;
comment = "str" ;
if ( enableSourceFall & & world . getBlockMetadata ( x , y , z ) = = 0 ) {
final String PATH_ARMOR = "str" + "str" ;
if ( matchRec . size ( ) > 0 & & matchRec . size ( ) > srcArg . size ( ) - 2 ) {
if ( compatible & & _arguments . size ( ) > 0 & & ! _name . equals ( other . _name ) & & ! MethodInv . _avoid . contains ( _name ) & & ! MethodInv . _avoid . contains ( other . _name ) & & _arguments . size ( ) > 0 ) {
if ( _parent = = null ) {
String logFile = Constant . PROJLOGBASEPATH + "str" + subject . getName ( ) + "str" + subject . getId ( ) + "str" ;
throw new EntryNotFoundException ( ErrorMessages . Credential . CERTIFICATE_ACCESS ) ;
public List < PermissionData > savePermissionsForUser ( @NotNull final List < PermissionEntry > permissionEntryList ) {
public void savePermissions ( @NotNull final List < PermissionEntry > permissionEntryList ) {
public PermissionData patchPermissions ( @NotNull final String guid , @NotNull final List < PermissionOperation > operations ) {
public PermissionData saveV2Permissions ( @NotNull final PermissionsV2Request permissionsRequest ) {
throw new EntryNotFoundException ( ErrorMessages . RESOURCE_NOT_FOUND ) ;
private boolean errorIsSomethingOtherThanTheKeyBeingIncorrect ( final Exception e ) {
throw new EntryNotFoundException ( "str" ) ;
throw new EntryNotFoundException ( "str" ) ;
assertThat ( errorMessage , is ( equalTo ( messageSource . getMessage ( "str" , null , null , Locale . ENGLISH ) ) ) ) ;
assertThat ( errorMessage , is ( equalTo ( messageSource . getMessage ( "str" , null , null , Locale . ENGLISH ) ) ) ) ;
assertThat ( errorMessage , is ( equalTo ( messageSource . getMessage ( "str" , null , null , Locale . ENGLISH ) ) ) ) ;
String expectedErrorMessage = "str" ;
String expectedErrorMessage = "str" ;
private static final String findMatchingNameQuery =
private static final String NON_EXISTENT_PASSWORD = "str" ;
map . put ( EXP , Long . valueOf ( intValue ) ) ;
return MTLS_ACTOR_PREFIX + "str" + parseAppIdentifier ( this . getClientId ( ) ) ;
new AccessControlEntry ( "str" ,
new AccessControlEntry ( "str" , asList ( READ ) ) )
new AccessControlEntry ( "str" ,
equalTo ( "str" ) ) ;
@Profile ( { "str" , "str" } )
. andExpect ( jsonPath ( "str" ) . value ( "str" ) ) ;
when ( passwordGenerator . generatePassword ( eq ( subject . DEFAULT_LENGTH ) , same ( characterRules ) ) ) . thenReturn ( "str" ) ;
when ( passwordGenerator . generatePassword ( eq ( subject . DEFAULT_LENGTH ) , anyList ( ) ) ) . thenReturn ( "str" ) ;
when ( passwordGenerator . generatePassword ( eq ( subject . DEFAULT_LENGTH ) , anyList ( ) ) ) . thenReturn ( "str" ) ;
public static final int DEFAULT_LENGTH = 30 ;
import io . pivotal . security . entity . NamedPasswordSecret ;
return new ResponseEntity < > ( secret . generateView ( saved ) , HttpStatus . OK ) ;
return new BigInteger ( NUM_BITS_IN_CERT_SERIAL_NUM , SecureRandom . getInstance ( "str" ) ) ;
String badResponseJson = "str" ;
String badResponseJson = "str" ;
String badResponseJson = "str" ;
return createErrorResponse ( "str" , HttpStatus . BAD_REQUEST ) ;
InputStream stream = Bukkit . class . getClassLoader ( ) . getResourceAsStream ( "str" ) ;
private static void ignoreRayTraceForSeatableBlocks ( ) {
mainThread = true ;
private HashIntObjMap < Set < Permission > > defaultPerms ;
io . akarin . server . core . AkarinAsyncScheduler . initalise ( ) ;
co . aikar . timings . TimingsManager . FULL_SERVER_TICK . startTiming ( ) ;
co . aikar . timings . TimingsManager . FULL_SERVER_TICK . stopTiming ( ) ;
if ( ! packet . canDispatchImmediately ( ) ) {
if ( ! ThreadAssertion . isMainThread ( ) & & Thread . currentThread ( ) ! = MinecraftServer . getServer ( ) . primaryThread ) {
public void sendPacket ( Packet < ? > packet , @Nullable GenericFutureListener < ? extends Future < ? super Void > > genericfuturelistener ) {
private void b ( Packet < ? > packet , @Nullable GenericFutureListener < ? extends Future < ? super Void > > genericfuturelistener ) {
ensuresTypeAndData ( iblockdata1 , iblockdata2 , generatoraccess , blockposition_pooledblockposition , i , blockposition ) ;
playerconnection . sendPackets (
entityplayer1 . playerConnection . sendPackets ( new PacketPlayOutSpawnPosition ( blockposition1 ) , new PacketPlayOutExperience ( entityplayer1 . exp , entityplayer1 . expTotal , entityplayer1 . expLevel ) ) ;
entityplayer . playerConnection . sendPackets (
entityplayer . playerConnection . sendPackets (
this . playerConnection . sendPackets ( new PacketPlayOutWindowItems ( container . windowId , nonnulllist ) , new PacketPlayOutSetSlot ( - 1 , - 1 , this . inventory . getCarried ( ) ) ) ;
public final void sendPackets ( Packet < ? > packet0 , Packet < ? > packet1 ) {
public final void sendPackets ( Packet < ? > packet0 , Packet < ? > packet1 , Packet < ? > packet2 ) {
public final void sendPackets ( Packet < ? > packet0 , Packet < ? > packet1 , Packet < ? > packet2 , Packet < ? > packet3 , Packet < ? > packet4 , Packet < ? > packet5 , Packet < ? > packet6 ) {
private final void dispatchOrQueuePacketUnsafe ( Packet < ? > packet , @Nullable GenericFutureListener < ? extends Future < ? super Void > > genericfuturelistener ) {
this . dispatchOrQueuePacketUnsafe ( packet , genericfuturelistener ) ;
( ( EntityPlayer ) entityhuman ) . playerConnection . sendPackets ( new PacketPlayOutSetSlot ( this . windowId , slot2 . rawSlotIndex , slot2 . getItem ( ) ) , new PacketPlayOutSetSlot ( this . windowId , 0 , this . getSlot ( 0 ) . getItem ( ) ) ) ;
public final void sendPacket ( Packet < ? > packet ) {
public final void sendPackets ( Packet < ? > packet0 , Packet < ? > packet1 ) {
this . networkManager . sendPackets ( packet0 , packet1 ) ;
public final void sendPackets ( Packet < ? > packet0 , Packet < ? > packet1 , Packet < ? > packet2 ) {
this . networkManager . sendPackets ( packet0 , packet1 , packet2 ) ;
public final void sendPackets ( Packet < ? > packet0 , Packet < ? > packet1 , Packet < ? > packet2 , Packet < ? > packet3 , Packet < ? > packet4 , Packet < ? > packet5 , Packet < ? > packet6 ) {
this . networkManager . sendPackets ( packet0 , packet1 , packet2 , packet3 , packet4 , packet5 , packet6 ) ;
public final boolean add ( E e ) {
public final boolean offer ( E e ) {
public final E poll ( Predicate < E > predicate , E signal ) {
this . b = com . koloboke . collect . map . hash . HashObjIntMaps . getDefaultFactory ( ) . withHashConfig ( com . koloboke . collect . hash . HashConfig . fromLoads ( 1. / 3. , 2. / 3. , 2. / 3. ) ) . withNullKeyAllowed ( true ) . withKeyEquivalence ( com . koloboke . collect . Equivalence . identity ( ) ) . newUpdatableMap ( ( int ) ( i * com . koloboke . collect . hash . HashConfig . getDefault ( ) . getTargetLoad ( ) ) ) ;
return String . format ( "str" ,
var baseName = repo . value ( ) . contains ( "str" ) ? repo . value ( ) . get ( "str" ) . asString ( ) : configuration . repositoryName ( repoName ) ;
if ( securityContext . isContinue ( ) ) {
if ( securityContext . isContinue ( ) ) {
if ( securityContext . isContinue ( ) ) {
if ( securityContext . isContinue ( ) ) {
if ( securityContext . isContinue ( ) ) {
response . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ;
response . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ;
response . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ;
public static final int VERSION_CODE = 46 ;
if ( classesCache . containsKey ( packageName + depth ) ) {
new JmsDefaultListenerContainerSpec ( ) . connectionFactory ( connectionFactory ) ) ;
for ( int ctx = tx ; ctx < tx + itw ; ctx + + )
for ( int cty = ty ; cty < ty + ith ; cty + + )
double curMin = getDistance ( x1 , y1 , x2 , y2 ) ;
drawRect ( viewer , origin , shape . getX ( ) , shape . getY ( ) + 1 , shape . getWidth ( ) - 1 , shape . getHeight ( ) - 1 , fill ) ;
g . drawRect ( tx , v - ty - 1 , 0 , 0 , false ) ;
g . drawRect ( x , y , w - 1 , h - 1 , false ) ;
final double viewY = viewer . getY ( ) + viewer . getScreenHeight ( ) ;
return getY ( ) + height - y ;
offY = ( int ) viewer . getY ( ) ;
assertEquals ( 1 , coord . getX ( ) ) ;
return ! hideMap | | tile ! = null & & tile . getNumber ( ) = = MapTileFog . NO_FOG ;
import static com . b3dgs . lionengine . UtilAssert . assertNull ;
assertNull ( featurables . get ( id ) ) ;
public void notifyStartMove ( Pathfindable pathfindable )
public void notifyMoving ( Pathfindable pathfindable )
public void notifyArrived ( Pathfindable pathfindable )
listeners . add ( services . get ( LayerableListener . class ) ) ;
if ( objectA ! = objectB & & done . get ( objectA ) ! = objectB )
public static final int MIN = 0 ;
next = state ;
final boolean glue = node . readBoolean ( true , ATT_GLUE ) ;
final Media surfaceMedia = Medias . create ( prefix + surfaceData . getImage ( ) ) ;
final Tile tile = map . getTileAt ( getPositionToSide ( ox , x ) , getPositionToSide ( oy , y ) ) ;
UtilAssert . assertEquals ( Math . floor ( 16.0 + speedX / 2.0 ) , res . getY ( ) . doubleValue ( ) ) ;
private Filter filter = FilterNone . INSTANCE ;
private Integer lastCode = NO_KEY_CODE ;
private char lastKeyName = EMPTY_KEY_NAME ;
private static String separator = File . separator ;
private static String resourcesDir = Constant . EMPTY_STRING ;
private static Optional < Class < ? > > loader = Optional . empty ( ) ;
public static synchronized String getResourcesDirectory ( )
public static synchronized Optional < Class < ? > > getResourcesLoader ( )
public static synchronized void setSeparator ( String separator )
public static synchronized String getSeparator ( )
private ImageBuffer surface ;
private ImageBuffer surface ;
private Integer lastCode = NO_KEY_CODE ;
private char lastKeyName = EMPTY_KEY_NAME ;
final double amplitude = data . getAmplitude ( ) ;
if ( ! ScreenFullAwt . ERROR_SWITCH . equals ( exception . getMessage ( ) ) )
import org . junit . jupiter . api . BeforeAll ;
public void testSetGraphic ( )
private void setResolution ( Resolution output )
transform = getTransform ( ) ;
final NodeList list = root . getChildNodes ( ) ;
private Optional < Applet < ? > > applet = Optional . empty ( ) ;
for ( final ImageBuffer tileBuffer : buffers )
else if ( action . hasCancel ( ) )
public boolean hasReverse ( )
public boolean hasRepeat ( )
if ( action . hasCancel ( ) )
public boolean hasCancel ( )
private final Collection < Object > servicesSet = new HashSet < > ( ) ;
servicesSet . add ( service ) ;
for ( final Object object : servicesSet )
private final Map < Class < ? extends Feature > , Feature > typeToFeature ;
typeToFeature = new HashMap < > ( ) ;
typeToFeature . put ( feature . getClass ( ) , feature ) ;
typeToFeature . put ( type . asSubclass ( Feature . class ) , feature ) ;
if ( typeToFeature . containsKey ( feature ) )
value = feature . cast ( typeToFeature . get ( feature ) ) ;
for ( final Feature current : typeToFeature . values ( ) )
if ( typeToFeature . containsKey ( feature ) )
for ( final Feature current : typeToFeature . values ( ) )
return typeToFeature . values ( ) ;
return typeToFeature . keySet ( ) ;
Assert . assertEquals ( map . getTile ( 0 , 2 ) , collided . get ( ) ) ;
Assert . assertEquals ( map . getTile ( 1 , 1 ) , collided . get ( ) ) ;
Assert . assertTrue ( String . valueOf ( extrapolation . get ( ) . doubleValue ( ) ) , extrapolation . get ( ) . doubleValue ( ) > 0.0 ) ;
Assert . assertTrue ( String . valueOf ( extrapolation . get ( ) ) , extrapolation . get ( ) . doubleValue ( ) > 0 ) ;
assetManager . open ( getPathAbsolute ( ) ) . close ( ) ;
if ( npoints > = xpoints . length )
lineHeight = ( int ) Math . floor ( surface . getHeight ( ) / ( double ) linesNumber * sy / 100.0 ) ;
Assert . assertTrue ( next . getName ( ) , next . equals ( feature . getClass ( ) ) | | Identifiable . class . isAssignableFrom ( next ) ) ;
Assert . assertTrue ( String . valueOf ( computed . get ( ) ) , computed . get ( ) . doubleValue ( ) > 1.0 ) ;
import com . b3dgs . lionengine . io . swt . Keyboard ;
import com . b3dgs . lionengine . io . swt . Mouse ;
import com . b3dgs . lionengine . io . swt . Mouse ;
import com . b3dgs . lionengine . io . swt . Mouse ;
Assert . assertTrue ( mouse . hasClicked ( Mouse . LEFT ) ) ;
Assert . assertTrue ( mouse . hasClicked ( Mouse . LEFT ) ) ;
Assert . assertTrue ( String . valueOf ( computed . get ( ) ) , computed . get ( ) . doubleValue ( ) > 0 ) ;
catch ( final LionEngineException exception )
Assert . assertEquals ( ClassCastException . class , exception . getCause ( ) . getClass ( ) ) ;
final double increased = current + increase * extrp ;
final double decreased = remain - decrease * extrp ;
private int volume = 100 ;
Thread . sleep ( Constant . DECADE ) ;
for ( int count = 0 ; count < = norm ; count + + )
classLoader = getClass ( ) . getClassLoader ( ) ;
return getImplementation ( getClass ( ) . getClassLoader ( ) , type , path ) ;
return getImplementation ( getClass ( ) . getClassLoader ( ) , type , paramsType , paramsValue , path ) ;
return source . getRate ( ) / ( double ) ONE_SECOND_IN_NANO * ( currentTime - lastTime ) ;
if ( actionsReleased . containsKey ( key ) )
if ( actionsReleased . containsKey ( key ) )
if ( actionsReleased . containsKey ( key ) )
Assert . assertTrue ( mapGroup . getGroups ( ) . containsAll ( Arrays . asList ( MapTileGroupModel . NO_GROUP_NAME ) ) ) ;
Assert . assertTrue ( mapGroup . getGroups ( ) . containsAll ( Arrays . asList ( "str" ) ) ) ;
Assert . assertTrue ( mapGroup . getGroups ( ) . containsAll ( Arrays . asList ( "str" ) ) ) ;
handler . changeState ( null ) ;
if ( TileGroupType . CIRCUIT = = groupType )
if ( isTileSame ( tile , current ) & & isTransitionGroup ( current ) )
public void testEquality ( )
public void testEqualityFail ( )
Check . equality ( Integer . MIN_VALUE , Integer . MAX_VALUE ) ;
public static void equality ( int a , int b )
public static final String OFFSET_X = "str" ;
public static final String OFFSET_Y = "str" ;
final String path = UtilFile . getPathSeparator ( "str" , UtilEclipse . ICON_FOLDER , root , icon ) ;
final int dv = ev - sv ;
for ( double v = sv , h = sh ; step < = stepMax ; v + = sy , h - = sx )
if ( tile ! = null & & collisions . contains ( tile . getCollision ( ) ) )
Thread . sleep ( 1000 ) ;
Thread . sleep ( 1000 ) ;
@Column ( name = "str" , length = 100000 )
@Column ( name = "str" , length = 100000 )
private static final String WIDGET_URL_PORTLET_PREFERENCE = "str" ;
& & WIDGET_URL_PORTLET_PREFERENCE . equals ( pref . getName ( ) ) ) {
+ "str" , group . getKey ( ) , member . getKey ( ) ,
+ "str" , name ) ;
private transient ApplicationContext applicationContext ;
log . warn ( "str" + addInfo + "str" ) ;
private final Logger log = LoggerFactory . getLogger ( this . getClass ( ) ) ;
this . offer ( e , - 1 , TimeUnit . MILLISECONDS ) ;
return this . poll ( - 1 , TimeUnit . MILLISECONDS ) ;
throw new RuntimeException ( t ) ;
if ( ( tester = = null ) | | ( ! tester . test ( person ) ) ) {
if ( ! StringUtils . isBlank ( params . get ( TARGET_PARAM ) . get ( 0 ) ) )
this . portletPreferenceReadOnly . put ( pref . getName ( ) , new BooleanAttribute ( pref . isReadOnly ( ) ) ) ;
usedPortalCache = cached ! = null ? cached : false ;
@Column ( name = "str" , length = 100000 )
@Column ( name = "str" , length = 100000 )
@Value ( "str" )
private static final String PROPERTY_ALLOW_EXPANDED_CONTENT = "str" ;
return this . < T > doWithExpression ( expression , null , callback ) ;
return this . < T > evaluate ( expression , null , item , returnType ) ;
if ( list . size ( ) > 10 ) {
private int timeout = 5000 ;
request . setAttribute ( REQUEST_ATTRIBUTE__CURRENT_FAILED_PORTLET_WINDOW_ID , failedPortletWindowId ) ;
String pName = rs2 . getString ( 1 ) ;
log . error ( e , e ) ;
log . error ( e , e ) ;
log . error ( e , e ) ;
log . error ( "str" + channelSubscribeId + "str" + person . getID ( ) + "str" + uPreferencesManager . getCurrentProfile ( ) . getLayoutId ( ) , e ) ;
} else if ( trimmedCacheScopeText . equals ( ICacheable . CHANNEL_CACHE_KEY_INSTANCE_SCOPE ) ) {
private String value = "str" ;
readOnly = Boolean . parseBoolean ( XML . getElementText ( ( Element ) readOnlyNodes . item ( 0 ) ) . trim ( ) ) ;
if ( DistributedLayoutManager . ContextHolder . getLabelPolicy ( ) = = null | | ! name . equals ( Constants . ATT_NAME ) )
if ( model ! = null ) {
pstmt . executeUpdate ( ) ;
public static final String MIN_CHAN_ID = "str" ;
. getPropertyAsBoolean ( SINGLE_THREAD_CFG_PROPERTY , false ) ;
final ChannelLayoutPortalEvent portalEvent = ( ChannelLayoutPortalEvent ) event ;
final ChannelLayoutPortalEvent portalEvent = ( ChannelLayoutPortalEvent ) event ;
final ChannelLayoutPortalEvent portalEvent = ( ChannelLayoutPortalEvent ) event ;
final ChannelLayoutPortalEvent portalEvent = ( ChannelLayoutPortalEvent ) event ;
final ChannelLayoutPortalEvent portalEvent = ( ChannelLayoutPortalEvent ) event ;
final ChannelLayoutPortalEvent portalEvent = ( ChannelLayoutPortalEvent ) event ;
final ChannelLayoutPortalEvent portalEvent = ( ChannelLayoutPortalEvent ) event ;
public static final String BASE_JNDI_CONTEXT = PropertiesManager . getProperty ( "str" , "str" ) ;
new PublicId ( "str" , "str" ) ,
public static final int EXISTS = 4 ;
queryMap . put ( queryAttr , "str" ) ;
assertEquals ( "str" , attribs . get ( "str" ) ) ;
assertEquals ( "str" , attribs . get ( "str" ) ) ;
Map attributes = dao . getUserAttributes ( "str" ) ;
assertEquals ( "str" , attributes . get ( "str" ) ) ;
private CheckResult nullBeanNameResult = CheckResult . createFailure ( "str" ,
if ( this . beanName = = null )
if ( parameters ! = null & & isChannel )
if ( overridableChanParams = = null | | overridableChanParams . isEmpty ( ) ) {
return PropertiesManager . getProperty ( GROUP_SERVICE_KEY + name , "str" ) ;
protected static final String COUNTUSERS = "str"
log . error ( "str" + sessionId + "str" , ne ) ;
LOG . debug ( sQuery ) ;
LOG . debug ( "str" ) ;
LOG . debug ( "str" ) ;
LOG . debug ( "str" ) ;
LOG . debug ( sQuery ) ;
this . targetStatsRecorder . recordChannelDefinitionModified ( person , channelDef ) ;
if ( this . flags . isRecordChannelTargeted ( ) ) {
log . error ( "str" + url + "str" , ioe ) ;
String value = pd . getExpirationCache ( ) ;
log . warn ( "str" + channelTarget + "str" ) ;
if ( log . isWarnEnabled ( ) ) {
log . warn ( "str" + XML . serializeNode ( doc ) ) ;
log . error ( e , e ) ;
protected static final boolean localeAware = PropertiesManager . getPropertyAsBoolean ( "str" , false ) ;
parameters . put ( name , new ChannelParameter ( name , value , override ) ) ;
new ChannelParameter ( pname , pvalue , povrd ) ;
boolean allowRefresh = true ;
boolean allowReinstantiation = true ;
PropertiesManager . getProperty ( "str" , null ) ;
multiServer = PropertiesManager . getPropertyAsBoolean ( "str" , false ) ;
PropertiesManager . getPropertyAsBoolean ( "str" , false ) ;
remediationAdvice = "str" + this . beanName + "str" + this . requiredBeanTypeClassName + "str" ;
import org . jasig . portal . channels . error . ErrorCode ;
ErrorCode . CHANNEL_MISSING_EXCEPTION . getCode ( ) ) ;
for ( Enumeration enum1 = restrictions . elements ( ) ; enum1 . hasMoreElements ( ) ; ) {
IUserLayoutRestriction restriction = ( IUserLayoutRestriction ) enum1 . nextElement ( ) ;
CookieProtocol enum1 = ( CookieProtocol )
for ( Enumeration enum1 = this . getParameterNames ( ) ; enum1 . hasMoreElements ( ) ; ) {
String pName = ( String ) enum1 . nextElement ( ) ;
for ( Enumeration enum1 = this . getParameterNames ( ) ; enum1 . hasMoreElements ( ) ; ) {
String pName = ( String ) enum1 . nextElement ( ) ;
value = ( String ) enum1 . nextElement ( ) ;
value = ( String ) enum1 . nextElement ( ) ;
StateChange enum1 = ( StateChange )
Element resourceRefE = doc . createElement ( "str" ) ;
String className = PropertiesManager . getProperty ( "str" , null ) ;
+ "str" , null ) ;
String className = PropertiesManager . getProperty ( "str" , null ) ;
String personManagerClass = PropertiesManager . getProperty ( "str" , null ) ;
String className = PropertiesManager . getProperty ( "str" , null ) ;
return ( lockArray . length > 0 ) ;
final String portletClassName = PropertiesManager . getProperty ( "str" , "str" ) ;
keys . add ( String . valueOf ( attrib . get ( ) ) . toLowerCase ( ) ) ;
readLock2 = EntityLockService . instance ( ) . newReadLock ( IPERSON_CLASS , key , testIds [ 0 ] ) ;
if ( attributeValue . indexOf ( "str" ) ! = - 1 & & attributeValue . indexOf ( "str" ) = = - 1 ) {
if ( channelAttributeValues . put ( channelSubscribeId , l ) ! = null & & log . isDebugEnabled ( ) )
if ( channelAttributeValues . remove ( channelSubscribeId ) = = null & & log . isDebugEnabled ( ) )
private final Log log = LogFactory . getLog ( getClass ( ) ) ;
handleRenderingError ( channelSubscribeId , contentHandler , null , renderingStatus , "str" , "str" , false ) ;
handleRenderingError ( channelSubscribeId , contentHandler , null , renderingStatus , "str" , "str" , false ) ;
LOG . debug ( "str" + name + "str" + waitTime + "str" ) ;
if ( isDefaultConn ) {
parameters . put ( parameter . getName ( ) , parameter ) ;
log . error ( "str" + this . person , e ) ;
log . error ( "str" + uri + "str" , se ) ;
log . error ( "str" , e ) ;
log . error ( "str" + dbName + "str" , ne ) ;
log . error ( "str" + dbName + "str" , sqle ) ;
log . info ( "str" , SQLe ) ;
log . error ( "str" , e ) ;
log . error ( "str" + ps + "str" , e ) ;
log . error ( "str" + ps + "str" , e ) ;
log . error ( "str" + rs + "str" , e ) ;
log . error ( "str" + st + "str" , e ) ;
log . error ( "str" , pe ) ;
log . error ( "str" , ioe ) ;
log . error ( "str" , e ) ;
log . error ( "str" + et + "str" , sqle ) ;
{ log . error ( "str" , ex ) ; }
log . error ( "str" + et , sqle ) ;
log . error ( "str" + et + "str" , sqle ) ;
log . error ( "str" + ch , e ) ;
log . error ( "str" + le + "str" + ch , e ) ;
log . error ( ioe , ioe ) ;
log . error ( "str" , e ) ;
log . error ( "str" , pe ) ;
log . error ( e , e ) ;
log . error ( "str" , sqle ) ;
log . error ( "str" , sqle ) ;
log . error ( "str" , sqle ) ;
log . error ( "str" + newValue , sqle ) ;
log . error ( "str" , e ) ;
log . error ( "str" , e ) ;
log . error ( "str" + perms , ex ) ;
log . error ( "str" + perm + "str" , ex ) ;
log . error ( "str" + perms , ex ) ;
log . error ( "str" + perm + "str" , ex ) ;
log . error ( "str" , e ) ;
log . error ( "str" , ep ) ;
log . error ( "str" , ep ) ;
log . error ( "str" + ctx , ep ) ;
log . error ( "str" + request , e ) ;
log . error ( e , e ) ;
log . error ( "str" , e ) ;
log . error ( "str" + sctx , ex ) ;
log . debug ( "str" + name , ep ) ;
log . error ( "str" + name , ep ) ;
log . error ( "str" + group , sqle ) ;
log . error ( "str" + group , sqle ) ;
log . error ( "str" + group , sqle ) ;
log . error ( "str" , sqle ) ;
log . error ( "str" , e ) ;
log . error ( "str" , e ) ;
log . error ( "str" , sqle ) ;
log . error ( "str" , sqle ) ;
log . error ( e , e ) ;
log . error ( e , e ) ;
log . error ( e , e ) ;
log . error ( "str" , e ) ;
log . error ( sqle , sqle ) ;
log . error ( sqle , sqle ) ;
log . error ( sqle , sqle ) ;
log . error ( sqle , sqle ) ;
log . error ( sqle , sqle ) ;
log . error ( sqle , sqle ) ;
log . error ( sqle , sqle ) ;
log . error ( sqle , sqle ) ;
log . error ( "str" , e ) ;
log . error ( "str" , e ) ;
log . error ( "str" , e ) ;
log . error ( "str" , e ) ;
log . error ( "str" , e ) ;
log . error ( "str" , pce ) ;
log . error ( "str" , pce ) ;
log . debug ( e , e ) ;
log . error ( "str" , e ) ;
log . error ( "str" , e ) ;
log . error ( e , e ) ;
log . error ( e , e ) ;
log . error ( e , e ) ;
log . error ( "str" , pce ) ;
private static final Log log = LogFactory . getLog ( ManageProfilesState . class ) ;
log . debug ( e , e ) ;
log . error ( e , e ) ;
log . error ( e , e ) ;
log . error ( e , e ) ;
log . debug ( e , e ) ;
log . error ( e , e ) ;
log . error ( e , e ) ;
log . debug ( e , e ) ;
log . error ( e , e ) ;
log . error ( e , e ) ;
log . debug ( e , e ) ;
private static final Log log = LogFactory . getLog ( CUserPreferences . class ) ;
log . error ( "str" + profile + "str" , e ) ;
log . error ( "str" + session , e ) ;
log . error ( e , e ) ;
log . error ( e , e ) ;
log . debug ( e , e ) ;
log . debug ( e , e ) ;
log . error ( "str" , e ) ;
log . error ( "str" + fname + "str" , e ) ;
log . error ( "str" , e ) ;
log . error ( "str" + channelSubscribeId + "str" , e ) ;
log . error ( "str" , e ) ;
log . error ( "str" , e ) ;
log . error ( "str" , e ) ;
log . error ( "str" + fname , e ) ;
log . error ( "str" , e ) ;
log . error ( "str" + channelSubscribeId , e ) ;
log . error ( e , e ) ;
log . error ( "str" , e ) ;
log . error ( "str" , e ) ;
log . error ( "str" , e ) ;
log . error ( "str" + fname , e ) ;
log . error ( "str" , e ) ;
log . error ( "str" + channelSubscribeId , e ) ;
log . error ( e , e ) ;
chObj = replaceWithErrorChannel ( channelTarget , CError . SET_RUNTIME_DATA_EXCEPTION , e , null , true ) ;
log . error (
log . error (
log . error (
log . error (
log . error (
log . error (
log . error (
log . error (
log . error (
"str" + ioe ) ;
public static boolean useAnchors = PropertiesManager . getPropertyAsBoolean ( "str" , false ) ;
if ( ! bPropsLoaded & & ! getDatasourceFromJndi ) {
super . add ( securityRole ) ;
Iterator iterator = iterator ( ) ;
super . add ( securityRoleRef ) ;
super . remove ( securityRoleRef ) ;
public static final String MAX_RECENT_ERRORS_PER_SPECIFIC_PROPERTY = "str" ;
public static final String OVERALL_RECENT_ERRORS_PROPERTY = "str" ;
System . out . print ( "str" ) ;
sqlFragment + = "str" + userId + "str" + ( ( pushFragmentIds ! = null ) ? "str" + pushFragmentIds + "str" : "str" ) ;
for ( final Iterator valueItr = pref . getValues ( ) ; valueItr . hasNext ( ) ; ) {
for ( final Iterator valueItr = pref . getValues ( ) ; valueItr . hasNext ( ) ; ) {
secprops . close ( ) ;
if ( ! LocaleManager . isLocaleAware ( ) | | locales = = null ) {
public static boolean isLocaleAware ( ) { return localeAware ; }
if ( locales [ i ] ! = null & & ! localeList . contains ( locales [ i ] ) )
fragmentId = ( fragments ! = null & & ! fragments . isEmpty ( ) ) ? ( String ) fragments . keySet ( ) . toArray ( ) [ 0 ] : "str" ;
NodeList errorPageNL = e . getElementsByTagName ( "str" ) ;
java . util . Iterator templateGroups = template . getContainingGroups ( ) ;
if ( "str" . equals ( action ) & & alm . isFragmentLoaded ( ) )
if ( ! PropertiesManager . getPropertyAsBoolean ( "str" ) ) {
for ( int i = 0 ; i < 1 ; parameters = statelessControlParameters , i + + ) {
throw new PortalException ( "str" + AggregatedLayout . class . getName ( ) + "str" ) ;
throw new PortalException ( "str" + userId + "str" + fragmentId ) ;
throw new PortalException ( "str" + portletHandle + "str" ) ;
throw new GeneralRenderingException ( "str" + state . fullxmlUri + "str" , e , false , true ) ;
static final boolean ALLOW_SYSTEM_BROWSER_MAPPING = PropertiesManager . getPropertyAsBoolean ( "str" ) ;
String SQLDelete = "str" + uPortalUID ;
SQLDelete = "str" + uPortalUID ;
SQLDelete = "str" + uPortalUID ;
SQLDelete = "str" + uPortalUID ;
SQLDelete = "str" + uPortalUID ;
SQLDelete = "str" + uPortalUID ;
SQLDelete = "str" + uPortalUID ;
SQLDelete = "str" + uPortalUID ;
SQLDelete = "str" + uPortalUID ;
XSLT xslt = XSLT . getTransformer ( this ) ;
public GuidGenerator ( ) throws Exception {
man . getUserLayout ( nodeId , new TransientUserLayoutManagerSAXFilter ( ch ) ) ;
trans . transform ( new DOMSource ( doc ) , new SAXResult ( new TransientUserLayoutManagerSAXFilter ( ch ) ) ) ;
state . person = person ;
if ( person ! = null )
LogService . log ( LogService . DEBUG , "str" ) ;
if ( attValue ! = null & & ( attValue . startsWith ( "str" ) | | attValue . startsWith ( "str" ) ) )
if ( attValue ! = null & & attValue . startsWith ( "str" ) )
? new ReferenceInvalidatingEntityCache ( type , maxSize , maxIdleTime , sweepInterval , clockToleranceMillis )
LogService . log ( LogService . DEBUG , "str"
LogService . log ( LogService . DEBUG , "str"
LogService . log ( LogService . DEBUG , "str" + sQuery ) ;
state . runtimeData . put ( "str" , String . valueOf ( state . runtimeData . isRenderingAsRoot ( ) ) ) ;
String sUpdate = "str" + nextId + "str" + counterName + "str" +
MultipartParser multi = new MultipartParser ( source , sizeLimit , true , true , "str" ) ;
if ( ! RDBMServices . supportsOuterJoins & & structParms . length ( ) > 0 ) {
sqlQuery . append ( OWNER_COLUMN ) ;
sqlQuery . append ( RDBMServices . sqlEscape ( owner ) ) ;
sqlQuery . append ( RDBMServices . sqlEscape ( OWNER_COLUMN ) ) ;
sqlQuery . append ( RDBMServices . sqlEscape ( activity ) ) ;
sqlQuery . append ( RDBMServices . sqlEscape ( target ) ) ;
if ( ! checkRestriction ( parentNode , RestrictionTypes . IMMUTABLE_RESTRICTION , "str" ) ) {
Element newNode = domLayout . createElement ( ( layoutNode . getNodeType ( ) = = IUserLayoutNodeDescription . FOLDER ) ? FOLDER : CHANNEL ) ;
if ( checkRestriction ( node , RestrictionTypes . IMMUTABLE_RESTRICTION , "str" ) )
person . setAttribute ( IPerson . USERNAME , "str" ) ;
if ( ulm . canUpdateNode ( ulm . getNode ( tabId ) ) ) {
public boolean canUpdateNode ( IUserLayoutNodeDescription node ) throws PortalException ;
eMsg = "str" + e ;
eMsg = "str" ;
eMsg = "str" + e ;
eMsg = "str" ;
eMsg = "str" + e ;
for ( int i = ( nl . getLength ( ) - 1 ) ; i > = 0 ; i - - ) {
sd . servantChannel . receiveEvent ( ev ) ;
( p . getEffective ( ) = = null | | ! p . getEffective ( ) . after ( now ) ) & &
LogService . log ( LogService . DEBUG , "str" ) ;
LogService . log ( LogService . DEBUG , "str" ) ;
serviceName = egi . getServiceName ( ) . toString ( ) ;
private final List getOverridableChannelParams ( String channelPublishId ) throws PortalException {
Element channel = ( Element ) channelRegistry . getElementById ( channelPublishId . startsWith ( "str" ) ? channelPublishId : "str" + channelPublishId ) ;
throw new PortalException ( "str" + channelPublishId + "str" ) ;
Element channel = ( Element ) channelRegistry . getElementById ( "str" + channelPublishId ) ;
paramOverride = "str" ;
public class TabColumnPrefsState extends BaseState
: service . findGroup ( ent . getLocalKey ( ) ) ;
CompositeEntityIdentifier cei = new CompositeEntityIdentifier ( ids [ i ] . getKey ( ) , ids [ i ] . getType ( ) ) ;
IIndividualGroupService service = ( IIndividualGroupService ) services . next ( ) ;
else if ( attValue . trim ( ) . startsWith ( "str" ) | | attValue . trim ( ) . startsWith ( "str" ) )
public void setStaticData ( ChannelStaticData sd , String uid )
throw new GeneralRenderingException ( "str" , e , false , true ) ;
LogService . instance ( ) . log ( LogService . DEBUG , "str"
LogService . instance ( ) . log ( LogService . DEBUG , "str" + e ) ;
LogService . instance ( ) . log ( LogService . DEBUG , "str"
LogService . instance ( ) . log ( LogService . DEBUG , e ) ;
IGroupMember entGrp = ( ! isPersistentGroup ( expandedElem ) ?
res . setContentType ( tsd . getMimeType ( ) + "str" ) ;
throw new SQLException ( "str" ) ;
if ( i = = - 1 | | ( i ! = - 1 & & attValue . substring ( 0 , i ) . indexOf ( "str" ) ! = - 1 ) )
add ( entity ) ;
private static String ENTITY_TYPE_COLUMN = "str" ;
if ( fname ! = null )
IPermission [ ] perms1 = iap . getPermissions ( ) ;
Object [ ] value_array = this . getObjectParameterValues ( pName ) ;
if ( this . credentialstring = = null & & credentials ! = null )
if ( channelManager ! = null ) channelManager . finishedSession ( ) ;
public static UserInstance getUserInstance ( HttpServletRequest request ) throws PortalException {
public void registerSession ( HttpServletRequest req ) throws PortalException {
if ( staticData . getPerson ( ) . getSecurityContext ( ) . isAuthenticated ( ) ) {
res . sendRedirect ( PortalSessionManager . DETACH_URL_ELEMENT + PortalSessionManager . PORTAL_URL_SEPARATOR + newDetachId + PortalSessionManager . PORTAL_URL_SEPARATOR + PortalSessionManager . PORTAL_URL_SUFFIX ) ;
uPElement = PortalSessionManager . DETACH_URL_ELEMENT + PortalSessionManager . PORTAL_URL_SEPARATOR + detachId ;
private String m_owner = null ;
LogService . instance ( ) . log ( LogService . ERROR , "str" +
String sessionId = bindingEvent . getSession ( ) . getId ( ) ;
Context layoutsContext = ( Context ) userIdContext . lookup ( "str" ) ;
boolean hasPermission = ap . canPublish ( ) ;
return doesPrincipalHavePermission ( principal , owner , CHANNEL_SUBSCRIBER_ACTIVITY , null ) ;
outputMessage ( "str" + svcItem . getName ( ) + "str" ) ;
outputMessage ( "str" + svcItem . getName ( ) + "str" ) ;
outputMessage ( "str" + svcItem . getName ( ) + "str" ) ;
this . chanEditable = chanEditable ;
"str" + newUID + "str" + templateUID ;
"str" + newUID + "str" + templateUID ;
"str" + newUID + "str" + templateUID ;
if ( ch ! = null ) {
String query = "str" + "str"
return new MyPreparedStatement ( con , "str" ) ;
String subSelectString = "str" + userId + "str" +
sql = "str" + userId + "str" + layoutId +
String query = "str" + userId + "str" + profileId ;
String sQuery = "str" + selectString ;
String sDelete = "str" + id ;
String sInsert = "str" + id +
String sQuery = "str" ;
String sQuery = "str"
String sQuery = "str"
String sQuery = "str" + userId + "str"
sQuery = "str" + profile . getThemeStylesheetId ( ) + "str" +
String sQuery = "str" + userId + "str"
sQuery = "str" + userId + "str"
LogService . instance ( ) . log ( LogService . ERROR , "str"
LogService . instance ( ) . log ( LogService . ERROR , "str"
String sQuery = "str" + userId + "str"
sQuery = "str" + userId + "str"
LogService . instance ( ) . log ( LogService . ERROR , "str"
String sQuery = "str" + userId + "str" + profileId
sQuery = "str" + ssup . getParameterValue ( pName ) + "str" + userId
sQuery = "str" + userId
String sQuery = "str" + userId + "str" + profileId
sQuery = "str" + pValue + "str" + userId + "str"
String sQuery = "str" + userId + "str" + profileId
sQuery = "str" + pValue + "str" + userId + "str"
String sQuery = "str" + userId + "str" + profileId
sQuery = "str" + tsup . getParameterValue ( pName ) + "str" + userId
sQuery = "str" + userId
String sQuery = "str" + userId + "str" + profileId
sQuery = "str" + pValue + "str" + userId + "str"
String sQuery = "str" + profile . getThemeStylesheetId ( ) + "str"
int id = getIncrementIntegerId ( "str" ) ;
String sQuery = "str"
String sQuery = "str" + userId + "str" + Integer . toString ( profileId ) ;
String sQuery = "str" ;
String sQuery = "str" + mimeType + "str" ;
String sQuery = "str" + structureStylesheetId ;
String sQuery = "str" + stylesheetId ;
sQuery = "str" + stylesheetId ;
sQuery = "str" + stylesheetId ;
String sQuery = "str" + stylesheetId ;
sQuery = "str" + stylesheetId ;
sQuery = "str" + stylesheetId + "str" ;
sQuery = "str" + stylesheetId + "str" ;
String sQuery = "str" + ssName + "str" ;
String sQuery = "str" + tsName + "str" ;
String sQuery = "str" + stylesheetId + "str" + pName
sQuery = "str" + stylesheetId + "str"
String sQuery = "str" + stylesheetId + "str" + pName
sQuery = "str" + stylesheetId + "str"
String sQuery = "str" + tsd . getStylesheetName ( ) + "str" + tsd . getStylesheetURI ( )
sQuery = "str" + stylesheetId ;
sQuery = "str" + tsd . getStylesheetParameterDefaultValue ( pName )
sQuery = "str" + tsd . getChannelAttributeDefaultValue ( pName ) +
sQuery = "str" + stylesheetId
sQuery = "str" + stylesheetId
String sQuery = "str" + stylesheetId + "str" + pName
sQuery = "str" + stylesheetId + "str"
String sQuery = "str" + stylesheetId + "str" + pName
sQuery = "str" + stylesheetId + "str"
String sQuery = "str" + stylesheetId + "str" + pName
sQuery = "str" + stylesheetId + "str"
String sQuery = "str" + ssd . getStylesheetName ( ) + "str" + ssd . getStylesheetURI ( )
sQuery = "str" + stylesheetId ;
sQuery = "str" + ssd . getStylesheetParameterDefaultValue ( pName )
sQuery = "str" + ssd . getFolderAttributeDefaultValue ( pName ) +
sQuery = "str" + ssd . getChannelAttributeDefaultValue ( pName ) +
sQuery = "str" +
sQuery = "str" +
sQuery = "str" +
int id = getIncrementIntegerId ( "str" ) ;
String sQuery = "str"
sQuery = "str" + id
sQuery = "str" + id
sQuery = "str" + id
sQuery + = "str" ;
sQuery = "str" + stylesheetId ;
sQuery + = "str" ;
sQuery = "str" + stylesheetId ;
int id = getIncrementIntegerId ( "str" ) ;
String sQuery = "str"
sQuery = "str" + id +
sQuery = "str" + id +
updateStatement . append ( "str" ) ;
queryString . append ( "str" ) ;
stmt = con . createStatement ( ResultSet . TYPE_SCROLL_INSENSITIVE , ResultSet . CONCUR_READ_ONLY ) ;
LogService . log ( LogService . DEBUG , "str" + query ) ;
LogService . log ( LogService . DEBUG , "str" + query ) ;
import org . jasig . portal . services . LogService ;
LogService . log ( LogService . DEBUG , ep ) ;
LogService . log ( LogService . ERROR , ep ) ;
thisUsersContext . rebind ( "str" , session . getId ( ) ) ;
nextContext . rebind ( subContextName , instanceid . getNodeValue ( ) ) ;
structure = createLayoutStructure ( rs , chanId , userId , con , doc ) ;
structure = createLayoutStructure ( rs , chanId , userId , con , doc ) ;
protected final Element createLayoutStructure ( ResultSet rs , int chanId , int userId , Connection con , DocumentImpl doc ) throws java . sql . SQLException {
if ( ! channelInUserRole ( chanId , userId , con ) ) {
returnNode = createChannelNode ( con , doc , chanId , channelPrefix + idTag ) ;
int first = base . indexOf ( "str" , i + 3 ) ;
Logger . log ( Logger . WARN , "str" + sJdbcDriver + "str" + SQLe . getMessage ( ) + "str" ) ;
pv . put ( new Integer ( upl . getProfileId ( ) ) , upl ) ;
+ "str" + profile . getThemeStylesheetId ( ) + "str" + profile . getProfileDescription ( ) + "str" ;
public static final String channelAddressingPathElement = "str" ;
protected static final void createChannelNodeHeaders ( DocumentImpl doc , int chanId , String idTag , ResultSet rs , Element channel ,
protected void createLayout ( Connection con , DocumentImpl doc , Statement stmt , Element root , int userId , int profileId ,
protected static final void createLayoutStructureParameter ( int chanId , ResultSet rs , Element structure , Element parameter ,
String subSelectString = "str" + userId + "str" +
Logger . log ( Logger . DEBUG , "str" + userId + "str" +
sInsert + = "str" + id + "str" + sqlTitle + "str" + sqlTitle + "str" + channel . getAttribute ( "str" ) +
sInsert = "str" + id +
sQuery + = "str" + "str" + role +
String sQuery = "str" + userId + "str" +
upl = new UserProfile ( profileId , rs . getString ( "str" ) , rs . getString ( "str" ) , rs . getInt ( "str" ) ,
UserProfile upl = new UserProfile ( rs . getInt ( "str" ) , rs . getString ( "str" ) , rs . getString ( "str" ) ,
sQuery = "str" + profile . getThemeStylesheetId ( ) + "str" +
+ stylesheetId + "str" + rsOld . getString ( "str" ) + "str" + rsOld . getInt ( "str" ) +
sQuery = "str" + tsd . getChannelAttributeDefaultValue ( pName ) +
+ stylesheetId + "str" + rsOld . getString ( "str" ) + "str" + rsOld . getInt ( "str" ) +
sQuery = "str" + ssd . getFolderAttributeDefaultValue ( pName ) +
sQuery = "str" + ssd . getChannelAttributeDefaultValue ( pName ) +
+ stylesheetId + "str" + rsOld . getString ( "str" ) + "str" + rsOld . getInt ( "str" ) +
sQuery = "str" +
sQuery = "str" +
sQuery = "str" +
sQuery = "str" + id +
sQuery = "str" + id +
if ( serializerName ! = null & & serializerName . equals ( "str" ) ) {
else if ( serializerName ! = null & & serializerName . equals ( "str" ) ) {
else if ( serializerName ! = null & & serializerName . equals ( "str" ) ) {
else if ( serializerName ! = null & & serializerName . equals ( "str" ) ) {
if ( servletPath . equals ( "str" + renderBase ) | | servletPath . startsWith ( "str" + detachBaseStart ) )
Logger . log ( Logger . DEBUG , "str" + sQuery ) ;
Logger . log ( Logger . DEBUG , "str" + sQuery ) ;
Logger . log ( Logger . DEBUG , "str" + sQuery ) ;
Logger . log ( Logger . DEBUG , "str" + sQuery ) ;
Logger . log ( Logger . DEBUG , "str" + sQuery ) ;
Logger . log ( Logger . DEBUG , "str" + sQuery ) ;
Logger . log ( Logger . DEBUG , "str" + sQuery ) ;
Logger . log ( Logger . INFO , "str" + chanId + "str" + userId ) ;
Logger . log ( Logger . DEBUG , "str" + subSelectString ) ;
Logger . log ( Logger . DEBUG , "str" + sQuery ) ;
Logger . log ( Logger . DEBUG , "str" + query ) ;
Logger . log ( Logger . DEBUG , "str" + sQuery ) ;
Logger . log ( Logger . DEBUG , "str" + sQuery ) ;
Logger . log ( Logger . DEBUG , "str" + sQuery ) ;
Logger . log ( Logger . DEBUG , "str" + sQuery ) ;
Logger . log ( Logger . DEBUG , "str" + sQuery ) ;
Logger . log ( Logger . DEBUG , "str" + sInsert ) ;
Logger . log ( Logger . DEBUG , "str" + query ) ;
Logger . log ( Logger . DEBUG , "str" + query ) ;
Logger . log ( Logger . DEBUG , "str" + sQuery ) ;
Logger . log ( Logger . DEBUG , "str" + sInsert ) ;
Logger . log ( Logger . DEBUG , "str" + sInsert ) ;
Logger . log ( Logger . DEBUG , "str" + sUpdate ) ;
fullxmlUri = buttonxmlUri ;
this . buttonxmlUri = this . helpUri ;
XSLT . transform ( xml , new URL ( UtilitiesBean . fixURI ( sslUri ) ) , out , runtimeData ) ;
XSLT . transform ( xml , new URL ( UtilitiesBean . fixURI ( sslUri ) ) , out , runtimeData , xslTitle , media ) ;
XSLT . transform ( xml , new URL ( UtilitiesBean . fixURI ( sslUri ) ) , out , runtimeData , media ) ;
private String getXmlString ( String uri )
if ( supportSetCookie2 )
processSetCookie2Header ( urlConnect . getHeaderField ( index ) , domain , path ) ;
token = cookieValue . nextToken ( ) ;
cookie . setDomain ( token . substring ( token . indexOf ( "str" ) + 1 ) . trim ( ) ) ;
cookie . setDomain ( domain ) ;
cookie . setPath ( path ) ;
if ( cookie . getName ( ) . equals ( old . getName ( ) ) )
public RemoveCookieTimerTask ( Cookie cookie )
cookies . removeElement ( cookie ) ;
return mediaProps . getValue ( req . getHeader ( "str" ) ) ;
return getSerializer ( mediaProps . getValue ( req . getHeader ( "str" ) ) , out ) ;
return getSerializer ( mediaProps . getValue ( req . getHeader ( "str" ) ) , out ) ;
return props . getValue ( req . getHeader ( "str" ) ) ;
String userAgent = req . getHeader ( "str" ) ;
uLayoutXML = uldb . getUserLayout ( this . person . getID ( ) , upl . getProfileId ( ) ) ;
uldb . setUserLayout ( person . getID ( ) , up . getProfile ( ) . getProfileId ( ) , uLayoutXML ) ;
private boolean DEBUG = false ;
Logger . log ( Logger . ERROR , "str" + ioe . getMessage ( ) ) ;
else if ( str . indexOf ( "str" ) = = - 1 & & str . indexOf ( "str" ) = = - 1 & & ch1 ! = "str" )
String profileName = null ;
profileName = rs . getString ( "str" ) ;
URL url = new URL ( fixURI ( uri ) ) ;
throw new GeneralRenderingException ( e . getMessage ( ) ) ;
String folderID = runtimeData . getParameter ( "str" ) ;
this . setThemeStylesheetUserPreferences ( userName , ssup ) ;
String r1 = "str" ;
public IXml getDefaultLayoutXml ( HttpServletRequest req )
String sQuery = "str" ;
String sLayoutXml = rs . getString ( "str" ) ;
public IXml getDefaultLayoutXml ( HttpServletRequest req ) ;
JSONAPI . dbug ( "str" + ( sender = = null ? null : String . valueOf ( sender . getName ( ) ) ) ) ;
URL whatismyip = new URL ( "str" ) ;
URL checkURL = new URL ( "str" ) ;
if ( ! isGET ) {
public boolean addPermission ( String playername , String key , Boolean value ) {
if ( ! resp . testLogin ( false ) . isAuthenticated ( ) ) {
EntityPlayer entity = new EntityPlayer ( server , server . getWorldServer ( 0 ) , exactPlayerName , new PlayerInteractManager ( server . getWorldServer ( 0 ) ) ) ;
if ( cmd . getName ( ) . equals ( "str" ) & & ( sender . hasPermission ( "str" ) | | sender instanceof ConsoleCommandSender ) ) {
public boolean setSignText ( String world , int x , int y , int z , String [ ] lines ) {
final String message = messager . length ( ) > 210 ? messager . substring ( 0 , 208 ) + "str" : messager ;
String [ ] a = new String [ ] { } ;
a = new String [ ] { "str" , "str" } ;
o . put ( "str" , p . getAddress ( ) ! = null ? p . getAddress ( ) . toString ( ) : "str" ) ;
} else if ( obj instanceof PlayerInventory ) {
} else if ( JSONAPI . instance . getServer ( ) . getPluginManager ( ) . getPlugin ( "str" ) ! = null & & obj instanceof EconomyResponse ) {
List < Map < String , Object > > locs = ( List < Map < String , Object > > ) config . getList ( "str" ) ;
subscribe ( s . get ( "str" ) . toString ( ) , s . get ( "str" ) . toString ( ) , false ) ;
log . severe ( "str" + s . get ( "str" ) ) ;
log . severe ( "str" + s . get ( "str" ) ) ;
} else if ( JSONAPI . instance . getServer ( ) . getPluginManager ( ) . getPlugin ( "str" ) ! = null & & obj instanceof PlayerInventory ) {
if ( rsp2 ! = null ) {
if ( ! ( settings . get ( "str" ) ! = null & & settings . get ( "str" ) ) ) {
throw new Exception ( "str" ) ;
if ( arg0 ! = null & & arg0 . getLevel ( ) . equals ( Level . SEVERE ) & & settings . get ( "str" ) ) {
public boolean doTrace = false ;
return return Runtime . getRuntime ( ) . totalMemory ( ) - Runtime . getRuntime ( ) . freeMemory ( ) ;
for ( int i = stack . size ( ) - count ; i < stack . size ( ) ; i + + ) {
for ( int i = stack . size ( ) - count ; i < stack . size ( ) ; i + + ) {
for ( int i = stack . size ( ) - count ; i < stack . size ( ) ; i + + ) {
r = jsonServer . new Response ( NanoHTTPD . HTTP_NOTFOUND , NanoHTTPD . MIME_JSON , jsonServer . returnAPIError ( "str" , "str" ) . toJSONString ( ) ) ;
return jsonRespone ( returnAPIError ( "str" , "str" ) , callback , HTTP_FORBIDDEN ) ;
return jsonRespone ( returnAPIError ( source , "str" ) , callback , HTTP_FORBIDDEN ) ;
return jsonRespone ( returnAPIError ( source , "str" + source + "str" ) , callback , HTTP_NOTFOUND ) ;
r = jsonServer . new Response ( NanoHTTPD . HTTP_NOTFOUND , NanoHTTPD . MIME_JSON , jsonServer . returnAPIError ( "str" , "str" ) . toJSONString ( ) ) ;
if ( ! uri . equals ( "str" ) & & ! uri . equals ( "str" ) ) {
public boolean setPlayerInventorySlot ( String playerName , int slot , int blockID , int quantity ) {
if ( ( val . getClass ( ) . equals ( Long . class ) | | val . getClass ( ) . equals ( Double . class ) | | val . getClass ( ) . equals ( String . class ) | | val . getClass ( ) . equals ( long . class ) | | val . getClass ( ) . equals ( double . class ) ) & & ( sig [ x ] . equals ( Integer . class ) | | sig [ x ] . equals ( int . class ) ) ) {
if ( ( val . getClass ( ) . equals ( Integer . class ) | | val . getClass ( ) . equals ( Long . class ) | | val . getClass ( ) . equals ( String . class ) | | val . getClass ( ) . equals ( long . class ) | | val . getClass ( ) . equals ( int . class ) ) & & ( sig [ x ] . equals ( Double . class ) | | sig [ x ] . equals ( double . class ) ) ) {
if ( ( val . getClass ( ) . equals ( Integer . class ) | | val . getClass ( ) . equals ( Double . class ) | | val . getClass ( ) . equals ( String . class ) | | val . getClass ( ) . equals ( int . class ) | | val . getClass ( ) . equals ( double . class ) ) & & ( sig [ x ] . equals ( Long . class ) | | sig [ x ] . equals ( long . class ) ) ) {
r . put ( "str" , "str" + pw . toString ( ) . replaceAll ( "str" , "str" ) . replaceAll ( "str" , "str" ) ) ;
throw new Exception ( "str" + params . length + "str" + Arrays . asList ( params ) . toString ( ) + "str" + c . getNumberOfExpectedArgs ( ) ) ;
caller . loadFile ( new File ( inst . getDataFolder ( ) + File . separator + "str" ) ) ;
File [ ] files = ( new File ( inst . getDataFolder ( ) + File . separator + "str" + File . separator ) ) . listFiles ( new FilenameFilter ( ) {
PropertiesFile options = new PropertiesFile ( new File ( getDataFolder ( ) . getAbsolutePath ( ) + File . separator + "str" ) . getAbsolutePath ( ) ) ;
File authfile = new File ( getDataFolder ( ) . getAbsolutePath ( ) + File . separator + "str" ) ;
private boolean debug = false ;
setSoftInputMode ( LayoutParams . SOFT_INPUT_ADJUST_RESIZE | LayoutParams . SOFT_INPUT_STATE_ALWAYS_VISIBLE ) ;
setHeight ( LayoutParams . MATCH_PARENT ) ;
popupView . getViewTreeObserver ( ) . addOnGlobalLayoutListener ( new OnGlobalLayoutListener ( ) {
FirebaseFunctions . getInstance ( ) . useFunctionsEmulator ( "str" ) ;
mockMvc . perform ( post ( "str" )
mockMvc . perform ( post ( "str" )
mockMvc . perform ( post ( "str" )
mockMvc . perform ( delete ( "str" , 1L ) )
mockMvc . perform ( delete ( "str" , 3L ) )
mockMvc . perform ( get ( "str" ) )
mockMvc . perform ( get ( "str" , 1L ) )
mockMvc . perform ( get ( "str" , 3L ) )
mockMvc . perform ( put ( "str" , 1L )
mockMvc . perform ( put ( "str" , 1L )
mockMvc . perform ( put ( "str" , 1L )
mockMvc . perform ( put ( "str" , 3L )
mockMvc . perform ( post ( "str" )
mockMvc . perform ( post ( "str" )
mockMvc . perform ( post ( "str" )
mockMvc . perform ( delete ( "str" , 1L ) )
mockMvc . perform ( delete ( "str" , 3L ) )
mockMvc . perform ( get ( "str" ) )
mockMvc . perform ( get ( "str" , 1L ) )
mockMvc . perform ( get ( "str" , 3L ) )
mockMvc . perform ( put ( "str" , 1L )
mockMvc . perform ( put ( "str" , 1L )
mockMvc . perform ( put ( "str" , 1L )
mockMvc . perform ( put ( "str" , 3L )
@RequestMapping ( value = "str" , method = RequestMethod . POST )
@RequestMapping ( value = "str" , method = RequestMethod . DELETE )
@RequestMapping ( value = "str" , method = RequestMethod . GET )
@RequestMapping ( value = "str" , method = RequestMethod . GET )
@RequestMapping ( value = "str" , method = RequestMethod . PUT )
public void showAddTodoForm ( ) {
public void showUpdateTodoForm ( ) throws TodoNotFoundException {
public void showUpdateTodoFormWhenToDoIsNotFound ( ) throws TodoNotFoundException {
public String showAddTodoForm ( Model model ) {
public String showUpdateTodoForm ( @PathVariable ( "str" ) Long id , Model model ) throws TodoNotFoundException {
String view = controller . showAddTodoForm ( model ) ;
String view = controller . showUpdateTodoForm ( TodoTestUtil . ID , model ) ;
controller . showUpdateTodoForm ( TodoTestUtil . ID , model ) ;
public void deleteByIdWhenToDoIsNotFound ( ) throws Exception {
Assert . assertTrue ( response . contains ( "str" ) ) ;
if ( ! ex . getMessage ( ) . contains ( "str" ) ) {
private transient volatile Map < Class < ? extends Annotation > , Annotation > declaredAnnotations ;
private transient volatile Map < Class < ? extends Annotation > , Annotation > declaredAnnotations ;
return fail ( text , "str" ) ;
return fail ( text , "str" ) ;
return fail ( text , "str" ) ;
return fail ( text , "str" ) ;
new UniMatcher < > ( "str" , ( s - > Integer . parseInt ( s ) ) ) ;
return fail ( text , "str" ) ;
return fail ( text , "str" ) ;
return fail ( text , "str" ) ;
return fail ( text , "str" ) ;
return fail ( text , "str" ) ;
return fail ( text , "str" ) ;
return fail ( text , "str" ) ;
return fail ( text , "str" ) ;
Logging . error ( "str" + text + "str" ) ;
private ASMVersion version = ASMVersion . V7 ;
for ( int i = 0 ; i < max ; i + = 2 ) {
if ( i + 2 < max ) {
public boolean topmost ;
private ASMVersion version = ASMVersion . V6 ;
Logging . info ( Lang . get ( "str" ) ) ;
add ( c , new JLabel ( Lang . get ( "str" ) ) , new ActionTextField ( value , n - > {
public static final int IDLE_TIME_BETWEEN_READS = 500 ;
private Instant getTimestampAndAdvance ( ) {
final Instant timestamp = ( record . getRecordTime ( ) = = null ) ? getTimestampAndAdvance ( ) : record . getRecordTime ( ) ;
streams . setUncaughtExceptionHandler ( ( t , e ) - > {
assertEquals ( 11 , buffer . remaining ( ) ) ;
log . info ( "str" , nextMetadata , node , t ) ;
private static final Field . Array OFFSETS = new Field . Array ( "str" , INT64 , "str" ) ;
log . warn ( "str" , url , CommonClientConfigs . BOOTSTRAP_SERVERS_CONFIG , resolvedCanonicalName , host ) ;
return new ConfigDef ( CONFIG ) ;
log . debug ( "str" , taskId ) ;
public static final String GROUP_INSTANCE_ID_DOC = "str" +
private boolean maskExitProcedures = true ;
. setGenerationId ( 1 )
. setMemberId ( this . generation . memberId )
. setGenerationId ( this . generation . generationId ) ) ;
. setGenerationId ( 1 )
final Map < UUID , ClientMetadata > clientMetadataMap = new HashMap < > ( ) ;
ClientMetadata clientMetadata = clientMetadataMap . get ( info . processId ( ) ) ;
clientMetadataMap . put ( info . processId ( ) , clientMetadata ) ;
log . debug ( "str" , clientMetadataMap ) ;
return errorAssignment ( clientMetadataMap , topic , Error . INCOMPLETE_SOURCE_TOPIC_METADATA . code ) ;
for ( final Map . Entry < UUID , ClientMetadata > entry : clientMetadataMap . entrySet ( ) ) {
for ( final Map . Entry < UUID , ClientMetadata > entry : clientMetadataMap . entrySet ( ) ) {
assignment = versionProbingAssignment ( clientMetadataMap , partitionsForTask , partitionsByHostState , futureConsumers , minReceivedMetadataVersion ) ;
assignment = computeNewAssignment ( clientMetadataMap , partitionsForTask , partitionsByHostState , minReceivedMetadataVersion ) ;
return "str" + fetchOffset +
for ( long i = 0 ; i < numRecords ; i + + ) {
topology . addStateStore ( storeBuilder , "str" ) ;
assertEquals ( "str" ,
builder . addStateStore ( storeBuilder , "str" ) ;
log . debug ( "str" ,
log . debug ( "str" , callbackHandler . getClass ( ) . getName ( ) ) ;
. setDefault ( - 1L )
log . warn ( "str" , node , e ) ;
public static final String ERRORS_TOLERANCE_CONFIG = "str" ;
9 * 60 * 1000L ,
5 * 60 * 1000L ,
10 * 60 * 1000L ,
24 * 60 * 60 * 1000L ,
factory . create ( Arrays . < KeyValue < String , Integer > > asList ( keyValuePairs ) ) ;
factory . create ( Arrays . < KeyValue < String , Integer > > asList ( keyValuePairs ) ) ;
factory . create ( Arrays . < KeyValue < String , Integer > > asList ( keyValuePairs ) , timestamp , 2L ) ;
String repartitionedSourceName = createRepartitionedSource ( builder , keySerde , valSerde , null , name ) ;
return KStreamImpl . createRepartitionedSource ( builder , keySerde , valSerde , queryableStoreName , name ) ;
return KStreamImpl . createRepartitionedSource ( builder , keySerde , valueSerde , queryableStoreName , name ) ;
INVALID_PARTITIONS ( 37 , "str" ,
INVALID_REPLICATION_FACTOR ( 38 , "str" ,
return new FetchResponse ( Errors . NONE , new LinkedHashMap < > ( partitions ) , throttleTime , INVALID_SESSION_ID ) ;
private KerberosTicket getTGT ( ) {
private void reLogin ( ) throws LoginException {
double jitter = 0.3 ;
jitter = 0.6 ;
stateManager . register ( store1 , stateRestoreCallback ) ;
< VR > KStream < K , VR > flatMapValues ( final ValueMapper < ? super V , ? extends Iterable < ? extends VR > > mapper ) ;
super ( "str" ) ;
assertEquals ( ConnectorType . UNKNOWN , unknownInfo . type ( ) ) ;
log . info ( "str" , logPrefix , partitionAssignor . standbyTasks ( ) ) ;
log . warn ( "str" , logPrefix , taskId , e ) ;
log . error ( "str" , logPrefix , e ) ;
log . error ( "str" , logPrefix , task . id ( ) , e ) ;
log . error ( "str" , logPrefix , e ) ;
log . error ( "str" , logPrefix , e ) ;
log . error ( "str" , logPrefix , e ) ;
log . error ( "str" , logPrefix , e ) ;
log . error ( "str" ,
log . error ( "str" , logPrefix , e ) ;
log . error ( "str" , logPrefix , next . getKey ( ) , e ) ;
log . error ( "str" , logPrefix , task . id ( ) , e ) ;
log . error ( "str" , logPrefix , taskId , e ) ;
log . error ( "str" , logPrefix , e ) ;
log . error ( "str" ,
log . warn ( "str" , logPrefix , consumedOffsetsAndMetadata , e ) ;
log . error ( "str" , logPrefix , e ) ;
log . error ( "str" , logPrefix , e ) ;
log . error ( "str" , logPrefix , entry . getKey ( ) , e ) ;
log . error ( "str" , logPrefix , e ) ;
log . warn ( "str" , new File ( baseDir , CHECKPOINT_FILE_NAME ) , e ) ;
log . debug ( "str" , logPrefix , currentState , target ) ;
final Bytes binarySessionId = Bytes . wrap ( serdes . rawKey ( key ) ) ;
final Bytes binaryKey = SessionKeySerde . toBinary ( key , serdes . keySerializer ( ) , topic ) ;
final Windowed < K > key = SessionKeySerde . from ( binaryKey . get ( ) , serdes . keyDeserializer ( ) , topic ) ;
bytesStore . put ( SessionKeySerde . toBinary ( sessionKey , serdes . keySerializer ( ) , topic ) , serdes . rawValue ( aggregate ) ) ;
return new AddOffsetsToTxnResponse ( ApiKeys . ADD_OFFSETS_TO_TXN . parseResponse ( version , buffer ) ) ;
final int oldQueueSize = partitionGroup . numBuffered ( partition ) ;
} , timeout , "str" + topic + "str" + partition + "str" ) ;
. parameter ( SCALE_FIELD , Integer . toString ( scale ) )
System . out . printf ( "str" ,
System . out . printf ( "str" ,
System . out . printf ( "str" , t . getMessage ( ) ) ;
megabytesPerSec ( latency , processedRecords , RECORD_SIZE ) ) ;
megabytesPerSec ( endTime - startTime , numRecords , KEY_SIZE + valueSizeBytes ) ) ;
megabytesPerSec ( endTime - startTime , consumedRecords , RECORD_SIZE ) ) ;
log . trace ( "str" , name ) ;
public < K1 , V1 > KStream < K1 , V1 > transform ( TransformerSupplier < ? super K , ? super V , KeyValue < K1 , V1 > > transformerSupplier , String . . . stateStoreNames ) {
< K1 , V1 > KStream < K1 , V1 > transform ( final TransformerSupplier < ? super K , ? super V , KeyValue < K1 , V1 > > transformerSupplier ,
log . error ( "str" , logPrefix , taskId , e ) ;
+ "str" + METADATA_FETCH_TIMEOUT_CONFIG + "str"
private static final String SESSION_TIMEOUT_MS_DOC = "str" +
public static final String SSL_CIPHER_SUITES_DOC = "str"
public static final String SSL_KEYSTORE_PASSWORD_DOC = "str"
props . put ( StreamsConfig . NUM_STREAM_THREADS_CONFIG , 1 ) ;
Aggregator < K , V , T > subtractor ,
Aggregator < K , V , T > subtractor ,
Aggregator < K , V , T > subtractor ,
return aggregate ( initializer , adder , subtractor , null , storeName ) ;
public Windows < W > until ( long durationMs ) {
protected Windows < W > segments ( int segments ) {
log . warn ( "str" +
throw new DataException ( "str" + value . getNodeType ( ) ) ;
throw new DataException ( "str" + value . getNodeType ( ) ) ;
log . warn ( "str" , logFilename ( ) ) ;
int lastPartition = partitions . size ( ) - 1 ;
64 * 1024 ,
if ( rawKey ! = null & & loggingEnabled ) {
if ( rawKey ! = null & & loggingEnabled ) {
consumedOffsetsAndMetadata . put ( entry . getKey ( ) , new OffsetAndMetadata ( entry . getValue ( ) + 1L ) ) ;
import org . apache . kafka . common . config . SslConfigs ;
long maxMessages = infinite ? Long . MAX_VALUE : producer . maxMessages ;
long maxMessages = infinite ? Long . MAX_VALUE : appender . maxMessages ;
log . warn ( "str" , key , this . originals . get ( key ) ) ;
client . schedule ( HeartbeatTask . this , time . milliseconds ( ) + retryBackoffMs ) ;
switch ( versionId ) {
switch ( versionId ) {
switch ( versionId ) {
switch ( versionId ) {
this . keyDeserializer . configure ( config . originals ( ) , true ) ;
. define ( RETRY_BACKOFF_MS_CONFIG , Type . LONG , 100L , atLeast ( 0 L ) , "str" ) ;
parameters . put ( "str" , BoxConfiguration . STANDARD_AUTHENTICATION ) ;
public final class ServiceNowMetadataRetrieval extends ComponentMetadataRetrieval {
operationNode . remove ( Arrays . asList ( "str" , "str" , "str" ) ) ;
if ( in . getBody ( ) instanceof List ) {
@ConditionalOnProperty ( prefix = "str" , name = "str" , matchIfMissing = true )
LOG . debug ( "str" , topic ) ;
LOG . error ( "str" , ex ) ;
throw SyndesisServerException . launderThrowable ( "str" , ex ) ;
String username = ( String ) parameters . get ( "str" ) ;
if ( ObjectHelper . isEmpty ( username ) & & ObjectHelper . isEmpty ( password ) ) {
if ( line . size ( ) > 1024 * 10 ) {
final String sName = openshiftName ( name ) ;
from ( "str" )
WebWindow webWindow = webClient . getWebWindowByName ( "str" ) ;
( ( ParenthesizedExpression ) parent ) . setExpression ( functionCall ) ;
( ( ReturnStatement ) parent ) . setReturnValue ( functionCall ) ;
( ( VariableInitializer ) parent ) . setInitializer ( functionCall ) ;
( ( SwitchStatement ) parent ) . setExpression ( functionCall ) ;
( ( WhileLoop ) parent ) . setCondition ( functionCall ) ;
( ( DoLoop ) parent ) . setCondition ( functionCall ) ;
( ( ForLoop ) parent ) . setCondition ( functionCall ) ;
( ( ElementGet ) parent ) . setElement ( functionCall ) ;
( ( ExpressionStatement ) parent ) . setExpression ( functionCall ) ;
if ( node . getLineno ( ) > 0 & & branchHelper . isBoolean ( node ) & & ! ( detectCoalesce & & branchHelper . isCoalesce ( node ) ) ) {
return pos - 1 ;
public void shouldSaveAndIncludeUnloadedJSWithTranslatedUris ( ) {
public void shouldShowHelpIfNoArgumentsProvided ( ) {
for ( int total = 0 , read = 0 ; total < length & & ( read = is . read ( buf , 0 , Math . min ( bufSize , length - total ) ) ) ! = - 1 ; total + = read ) {
public void saveJSONData ( File reportDir , String data , List < ScriptLinesAndSource > unloadJSData ) {
private int JSVersion = Context . VERSION_1_5 ;
assertThat ( configuration . getJSVersion ( ) , equalTo ( 150 ) ) ;
public final static boolean mboxed_eqeq_notag ( double x , double y ) {
new FormRenderCase ( "str" ) ;
if ( timeUsed > 400 ) {
protected String retrieveSessionCheckId ( boolean create ) {
private static final String SessionCheckIdKey = DefaultSessionAwareExpirableDataManager . class + "str" ;
if ( StringUtils . equals ( retrieveSessionCheckId ( false ) , holder . sessionId ) ) {
Object existing = dataMap . put ( dataId , new DataHolder ( data , expireMilliSeconds , retrieveSessionCheckId ( true ) ) ) ;
public void setUrlMappingRuleSetCls ( Class < ? extends UrlMappingRuleSet > urlMappingRuleSetCls ) {
form . cascadeJobFormStep3 . copyPropertiesTo ( this . confirmStepForm . cascadeJobForm ) ;
String key = this . getClass ( ) . getName ( ) + "str" ;
private final static String UniqAttrSufffix = "str" + IdGenerator . createId ( ) ;
public final static String EMBED_NODE_ATTR_BLOCK = "str" + UniqAttrSufffix ;
public final static String SNIPPET_NODE_ATTR_TYPE = "str" + UniqAttrSufffix ;
public final static String SNIPPET_NODE_ATTR_STATUS = "str" + UniqAttrSufffix ;
public final static String SNIPPET_NODE_ATTR_BLOCK = "str" + UniqAttrSufffix ;
public final static String GROUP_NODE_ATTR_TYPE = "str" + UniqAttrSufffix ;
protected CommonFormResult processValidation ( FormProcessData processData , Object form ) {
rewriteMap . put ( k , getMessage ( formatter , locale , v , v , rewriteMap ) ) ;
private int disableMissingSelectorWarningCounter = 0 ;
context . init ( ) ;
TypeUnMacthPolicy typeUnMatch ( ) default TypeUnMacthPolicy . EXCEPTION ;
TypeUnMacthPolicy typeUnMatch ( ) default TypeUnMacthPolicy . EXCEPTION ;
TypeUnMacthPolicy typeUnMatch ( ) default TypeUnMacthPolicy . EXCEPTION ;
TypeUnMacthPolicy typeUnMatch ( ) default TypeUnMacthPolicy . EXCEPTION ;
TypeUnMacthPolicy typeUnMatch ( ) default TypeUnMacthPolicy . EXCEPTION ;
TypeUnMacthPolicy typeUnMatch ( ) default TypeUnMacthPolicy . EXCEPTION ;
TypeUnMacthPolicy typeUnMatch ( ) default TypeUnMacthPolicy . EXCEPTION ;
final Context context = Context . getCurrentThreadContext ( ) . clone ( ) ;
return Context . with ( context , new Callable < T > ( ) {
public void addDefaultRequestHandler ( String attribute , Object . . . handlerList ) {
defaultHandlerList . add ( new RequestHandlerHolder ( attribute , handler ) ) ;
render . add ( "str" , "str" , ( Object ) null ) ;
render . add ( "str" , "str" , ( Object ) null ) ;
render . add ( "str" , "str" , ( Object ) null ) ;
renderer . add ( "str" , "str" , ( Object ) null ) ;
renderer . add ( "str" , "str" , ( Object ) null ) ;
renderer . add ( "str" , "str" , ( Object ) null ) ;
renderer . add ( "str" , "str" , ( Object ) null ) ;
public Renderer add ( String selector , Boolean value ) {
public Renderer add ( String selector , String attr , Long value ) {
public Renderer add ( String selector , String attr , Integer value ) {
public Renderer add ( String selector , String attr , Boolean value ) {
render . add ( "str" , "str" , ( Object ) null ) ;
WebApplicationContext asta4dContext = WebApplicationContext . getCurrentThreadContext ( ) ;
public final static String GROUP_NODE_ATTR_TYPE_EMBED_WRAPPER = "str" ;
Element wrappingNode = new GroupNode ( ExtNodeConstants . GROUP_NODE_ATTR_TYPE_EMBED_WRAPPER ) ;
public Renderer enableMissingSelectorWarning ( ) {
creationInfo = "str" + creationInfo + "str" ;
String cls = path . substring ( "str" . length ( ) ) ;
if ( path . startsWith ( "str" ) ) {
if ( path . startsWith ( "str" ) ) {
return Collections . unmodifiableMap ( rule . getExtraVarMap ( ) ) ;
render . addDebugger ( "str" ) ;
super ( CurrentNodeSelector + "str" + logMessage , new ElementSetterTransformer ( new ElementSetter ( ) {
public DebugRenderer ( final String logMessage ) {
render . addDebugger ( "str" ) ;
return ResourceBundle . getBundle ( resourceName , locale ) ;
return ResourceBundle . getBundle ( resourceName , currentLocale ) ;
WhatsAppDatabaseHelper . execSQL ( "str" , "str" + contact + "str" ) ;
checkBoxSeen . performClick ( ) ;
String safeName = ESAPI . validator ( ) . getValidInput ( "str" , strippedName , "str" , 50 , false ) ;
String safeName = ESAPI . validator ( ) . getValidInput ( "str" , strippedName , "str" , 50 , false ) ;
public class IntrusionException extends EnterpriseSecurityRuntimeException {
throw new EncryptionException ( "str" ,
public final void testAddandGetAttributes ( ) {
protected void loadConfiguration ( ) throws IOException {
this . trace ( org . owasp . esapi . Logger . EVENT_UNSPECIFIED , toLog ) ;
this . trace ( org . owasp . esapi . Logger . EVENT_UNSPECIFIED , toLog , throwable ) ;
this . debug ( org . owasp . esapi . Logger . EVENT_UNSPECIFIED , toLog ) ;
this . debug ( org . owasp . esapi . Logger . EVENT_UNSPECIFIED , toLog , throwable ) ;
this . info ( org . owasp . esapi . Logger . EVENT_UNSPECIFIED , toLog ) ;
this . info ( org . owasp . esapi . Logger . EVENT_UNSPECIFIED , toLog , throwable ) ;
this . warning ( org . owasp . esapi . Logger . EVENT_UNSPECIFIED , toLog ) ;
this . warning ( org . owasp . esapi . Logger . EVENT_UNSPECIFIED , toLog , throwable ) ;
this . error ( org . owasp . esapi . Logger . EVENT_UNSPECIFIED , toLog ) ;
this . error ( org . owasp . esapi . Logger . EVENT_UNSPECIFIED , toLog , throwable ) ;
this . fatal ( org . owasp . esapi . Logger . EVENT_UNSPECIFIED , toLog ) ;
this . fatal ( org . owasp . esapi . Logger . EVENT_UNSPECIFIED , toLog , throwable ) ;
public static final EventType EVENT_UNSPECIFIED = new EventType ( "str" , null ) ;
public static final String DEFAULT_ENCRYPTION_IMPLEMENTATION = "str" ;
private static String signatureAlgorithm = "str" ;
if ( keySize < 112 ) {
throw new ValidationException ( context + "str" + allowedExtensions + "str" , "str" + allowedExtensions + "str" + context + "str" + input , context ) ;
return properties . getProperty ( PREFERRED_JCE_PROVIDER ) ;
new File ( "str" ) . delete ( ) ;
new File ( "str" ) . delete ( ) ;
String filename = "str" ;
try { if ( bis ! = null ) bis . close ( ) ; } catch ( Exception e ) { }
throw new AccessControlException ( "str" + "str" , "str" , cex ) ;
protected boolean actionNecessary = true ;
throw new ValidationException ( this . encoder . encodeForJavaScript ( context ) + "str" + minLength + "str" , "str" + minLength + "str" + ( minLength - input . length ( ) ) + "str" + context + "str" + getTypeName ( ) + "str" + input + ( NullSafe . equals ( input , orig ) ? "str" : "str" + orig ) , context ) ;
assertEquals ( "str" , "str" , instance . encodeForSQL ( oracle , "str" ) ) ;
throw new EncodingException ( "str" , "str" , ex ) ;
throw new EncodingException ( "str" , "str" , ex ) ;
public File getUploadDirectory ( ) ;
finalDir = ESAPI . securityConfiguration ( ) . getUploadDirectory ( ) ;
public File getUploadDirectory ( ) {
if ( ch = = 0x1a ) return "str" ;
if ( value = = null ) return DEFAULT_ACCESS_CONTROL_IMPLEMENTATION ;
if ( ch < 256 ) {
return ( String [ ] ) newValues . toArray ( new String [ 0 ] ) ;
if ( ! ESAPI . accessController ( ) . isAuthorizedForURL ( request . getRequestURI ( ) ) ) {
throw new ValidationException ( context + "str" + input . length ( ) + "str" + maxLength + "str" , context + "str" + ( input . length ( ) - maxLength ) + "str" , context ) ;
return ( ValidatorErrorList ) validatorErrorList . getValidatorErrorList ( ) ;
String getValidSafeHTML ( String context , String input , int maxLength , boolean allowNull , ValidatorErrorList errorList ) throws IntrusionException ;
String getValidSafeHTML ( String context , String input , int maxLength , boolean allowNull ) throws ValidationException , IntrusionException ;
throw new ValidationException ( context + "str" , "str" + maxValue + "str" + minValue + "str" + context ) ;
if ( i < minValue | | i > maxValue ) throw new ValidationException ( context + "str" + minValue + "str" + maxValue , "str" + minValue + "str" + maxValue + "str" + context + "str" + input ) ;
throw new ValidationException ( context + "str" , "str" + context + "str" + type + "str" + p . pattern ( ) + "str" + input ) ;
logger . debug ( "str" ,
private static final long defaultCallTimeout = 30000 ;
public static final boolean IGNORE_CASE_DEFAULT = false ;
public static final int DEFAULT_TRANSACTION_CAPACITY = 10000 ;
s . stop ( ) ;
private int maxBatchSize = 1000 ;
Map < String , String > selectorConfig = context . getSubProperties ( "str" + "str" ) ;
} catch ( Throwable th ) {
Preconditions . checkNotNull ( pri , "str"
throw new IOException ( "str" ) ;
+ q . size ( ) + "str" ) ;
throw new IOException ( "str"
LOG . error ( "str" + t . getMessage ( ) , t ) ;
throw new IOException ( "str" + e ) ;
+ q . size ( ) + "str" ) ;
throw new IOException ( "str"
final String table ;
LOG . error ( "str" , e ) ;
Preconditions . checkNotNull ( p , "str" ) ;
throw new FlumeSpecException ( "str" + rel ) ;
throw new IOException ( "str" ) ;
Preconditions . checkNotNull ( p , "str" ) ;
throw new IOException ( "str" ) ;
LOG . error ( "str" ) ;
LOG . info ( "str" + cfg ) ;
"str" + maxArgs + "str"
FlumeBuilder . buildSink ( new Context ( ) , "str" ) ;
assertEquals ( "str" , e . getMessage ( ) ) ;
return get ( MASTER_ZK_LOGDIR , "str" ) ;
return get ( AGENT_LOG_DIR_NEW , "str" ) ;
return get ( COLLECTOR_DFS_DIR , "str" ) ;
properties . setProperty ( "str" , "str" ) ;
LOG . error ( "str" + nodeName + "str" + conn + "str"
private final LivenessManager liveMan ;
if ( ! oneshot ) {
String host = env . get ( "str" ) ;
url = host + "str" + req . getRequestURI ( ) ;
public InputStreamDownload downloadAttachment ( Long attachmentId ) throws IOException {
throw new IllegalArgumentException ( "str" ) ;
stack . next ( method , instance ) ;
cause . printStackTrace ( pw ) ;
. setSubject ( format ( bundle . getMessage ( "str" ) , bundle . getMessage ( "str" ) , action . getMainThread ( ) . getTitle ( ) ) ) ;
assertFalse ( urlValidator . isValid ( "str" ) ) ;
if ( ! q . getTagsAsString ( "str" ) . contains ( tag ) ) {
SessionFactoryCreator sessionFactoryCreator = new SessionFactoryCreator ( env , null ) ;
if ( "str" . equals ( env . get ( "str" , "str" ) ) )
if ( ! reputationEvent . equals ( ReputationEvent . IGNORED_EVENT ) ) {
String hack = env . get ( "str" , "str" ) ;
homePath = env . get ( "str" , "str" ) ;
if ( photoUri = = null ) {
p . put ( "str" , url ( ) ) ;
public void should_pend_if_cant_update ( ) {
assertEquals ( User . GHOST , shouldILiveForever . getLastTouchedBy ( ) ) ;
public List < TagUsage > getRecentTagsUsageSince ( DateTime since ) {
List < TagUsage > recentTagsUsage = tags . getRecentTagsUsageSince ( new DateTime ( ) . minusMonths ( 2 ) ) ;
public abstract class TestCase {
@Post ( "str" )
intent . setClassName ( FoldingActivitys . this , "str" + testValues [ arg2 ]
"str" , PackageManager . GET_ACTIVITIES ) ;
CalligraphyConfig . initDefault ( "str" , R . attr . fontPath ) ;
void shouldPutFlowIdToMdc ( ) {
void shouldUseBaggageKey ( ) {
return newScheduledThreadPool ( Runtime . getRuntime ( ) . availableProcessors ( ) ) ;
public String getDatabaseNameBase ( NamedElement element ) {
relObj . setDatabaseTable ( getDatabaseNameBase ( relObj ) ) ;
assertTrue ( SculptorGeneratorRunner . run ( "str" ) ) ;
assertFalse ( SculptorGeneratorRunner . run ( "str" ) ) ;
private String guiceModule ;
public String getDefaultForeignKeyNameBase ( Reference ref ) {
return getDefaultForeignKeyNameBase ( ref . getOpposite ( ) ) ;
values . put ( "str" , position . getAccuracy ( ) ) ;
if ( location ! = null & & location . getTime ( ) - lastUpdateTime > = period ) {
. appendQueryParameter ( "str" , String . valueOf ( position . getSpeed ( ) ) )
return - 1 ;
enable ? PackageManager . COMPONENT_ENABLED_STATE_ENABLED : PackageManager . COMPONENT_ENABLED_STATE_DISABLED ,
ExposedBridge . initOnce ( context , data . appInfo , originClassLoader , getUserId ( vuid ) ) ;
File oldXposedInstallerApk = getFileStreamPath ( "str" ) ;
File xposedInstallerApk = getFileStreamPath ( "str" ) ;
public static native void disableJit ( int apiLevel ) ;
NativeEngine . disableJit ( Build . VERSION . SDK_INT ) ;
intent . setType ( "str" ) ;
VLog . w ( TAG , String . format ( "str" , callingPid ) ) ;
VLog . e ( TAG , "str" , e ) ;
VLog . e ( "str" , "str" , intent ) ;
config . enable = false ;
callUiCallback ( intent , false ) ;
callUiCallback ( intent , false ) ;
callUiCallback ( intent , false ) ;
callUiCallback ( intent , true ) ;
private void callUiCallback ( Intent intent , boolean success ) {
"str" + ( mInitialApplication = = null ? "str" : mInitialApplication . getClass ( ) . getName ( ) )
"str" + ( mInitialApplication = = null ? "str" : mInitialApplication . getClass ( ) . getName ( )
root = LayoutInflater . from ( context ) . inflate ( R . layout . item_task_manage , parent , false ) ;
Drawable icon = getResources ( ) . getDrawable ( android . R . drawable . sym_def_app_icon ) ;
showVersionDialog ( url , getResources ( ) . getString ( R . string . new_version_detected ) , updateMessage ) ;
if ( BuildCompat . isOreo ( ) | | ClipboardManager . getService = = null ) {
if ( Build . VERSION . SDK_INT > Build . VERSION_CODES . KITKAT ) {
startInstallingAnimation ( holder . iconView , data ) ;
startLoadingAnimation ( holder . iconView , data ) ;
private void startInstallingAnimation ( LauncherIconView iconView , AppData data ) {
AlertDialog alertDialog = new AlertDialog . Builder ( this )
if ( currentVersion < versionCode ) {
. build ( VApp . this , "str" ) ;
String userLibPath = new File ( VEnvironment . getUserSystemDirectory ( userId ) , info . packageName + "str" ) . getAbsolutePath ( ) ;
GmsSupport . installGApps ( 0 ) ;
intent . setData ( Uri . parse ( "str" + packageName ) ) ;
intent . setData ( Uri . parse ( "str" + packageName ) ) ;
public abstract static class PackageObserver extends IPackageObserver . Stub { }
scheduleFinishMarkedActivityLocked ( ) ;
private void scheduleFinishMarkedActivityLocked ( ) {
setContentView ( R . layout . activity_splash ) ;
if ( sFetcher = = null ) {
throw e . getCause ( ) = = null ? e : e . getCause ( ) ;
public Intent startActivityLocked ( int userId , Intent intent , ActivityInfo info , IBinder resultTo , boolean fromHost , Bundle options ) {
Intent resultIntent = VActivityManager . get ( ) . startActivity ( targetIntent , targetActInfo , resultTo , options , ! isAppProcess ( ) , userId ) ;
public Intent startActivity ( Intent intent , ActivityInfo info , IBinder resultTo , Bundle options , boolean fromHost , int userId ) {
return mMainStack . startActivityLocked ( userId , intent , info , resultTo , fromHost , options ) ;
task . rootAffinity = ComponentUtils . getTaskAffinity ( targetActInfo , VBinder . getCallingUid ( ) ) ;
public Intent startActivity ( Intent intent , ActivityInfo info , IBinder resultTo , Bundle options , boolean fromHost , int userId ) {
return getService ( ) . startActivity ( intent , info , resultTo , options , fromHost , userId ) ;
mActivities . removeActivity ( a , "str" ) ;
public int negative = - 1 ;
if ( ! DimenUtils . isPxVal ( array . peekValue ( index ) ) ) continue ;
return myServer ! = null & & myServer . getCluster ( ) ! = null ;
if ( ( node . isLocal ( ) & & ! Boolean . getBoolean ( USE_NODE_HOST_FOR_LOCAL_NODE_SYSTEM_PROPERTY ) )
public List < ClusterInstanceInfo > internalClusterInstanceInfo (
@Min ( value = 0 , message = "str" )
@Min ( value = 0 , message = "str" )
@Min ( value = 0 , message = "str" )
@Min ( value = 0 , message = "str" )
boolean HTTP2_PUSH_ENABLED = false ;
@Attribute ( defaultValue = "str"
if ( appName ! = null & & ! isApplicationEnabled ( appName ) ) {
preBootCommands . add ( new BootCommand ( "str" , "str" + minHttpThreads ) ) ;
private final static String DEFAULT_TEMPLATE_RELATIVE_PATH = "str" + File . separator + "str" + File . separator + "str" ;
+ DEFAULT_TEMPLATE_RELATIVE_PATH + File . separator + defaultTemplateName ;
extraPropsMap . put ( "str" , DEFAULT_STUCK_THREAD_NAME ) ;
} else if ( extraPropsMap . containsValue ( DEFAULT_STUCK_THREAD_NAME ) ) {
final String DEFAULT_STUCK_THREAD_NAME = "str" ;
this . buffer = new byte [ this . bufSize ] ;
private final static String RESOURCE_PACKAGE = "str" ;
return ResourceBundle . getBundle ( RestMonitoringAdapter . class . getPackage ( ) . getName ( ) + "str" , locale ) ;
public CountStatistic getMessageCount ( ) {
@Attribute ( dataType = Integer . class , defaultValue = "str" )
cmd = ASADMIN + "str" +
cmd = ASADMIN + "str" ;
cmd1 = ASADMIN + "str" ;
cmd = ASADMIN + "str" ;
jndiProps . put ( "str" , "str" ) ;
jndiProps . setProperty ( "str" , "str" ) ;
"str" , cname , "str" , "str" , "str" ,
"str" , cname , "str" , "str" , "str" ,
HttpURLConnection connection = getConnection ( "str" ) ;
HttpURLConnection connection = getConnection ( "str" ) ;
HttpURLConnection connection = getConnection ( "str" ) ;
HttpURLConnection connection = getConnection ( "str" ) ;
HttpURLConnection connection = getConnection ( "str" ) ;
cmd = ASADMIN + "str" + cwd + File . separator + batchFile1 ;
cmd = ASADMIN + "str" + cwd + File . separator + mdbAppDir
cmd = APPCLIENT + "str" + "str" + "str" + cwd + File . separator + mdbAppDir + mdbApp + "str"
cmd = ASADMIN + "str" + mdbApp ;
cmd = ASADMIN + "str" + cwd + File . separator + batchFile2 ;
if ( connection . getResponseCode ( ) < 200 | | connection . getResponseCode ( ) > = 300 ) {
Map responseMap = RestUtil . restRequest ( endpoint , null , "str" , handlerCtx , false , false ) ;
DOLUtils . getDefaultLogger ( ) . severe ( "str" + type + "str" + i ) ;
throw new IllegalStateException ( "str" + ejb . getType ( ) ) ;
executionOptions . setPort ( Integer . parseInt ( notifierConfiguration . getPort ( ) ) ) ;
executionOptions . setPort ( Integer . parseInt ( notifierConfiguration . getPort ( ) ) ) ;
executionOptions . setSecurityDisabled ( Boolean . valueOf ( notifierConfiguration . getSecurityDisabled ( ) ) ) ;
String getPort ( ) ;
String getSecurityDisabled ( ) ;
return context . addJspFile ( servletName , jspFile ) ;
return context . addJspFile ( servletName , jspFile ) ;
String msg = MessageFormat . format ( rb . getString ( LogFacade . ERROR_REGISTERING ) , e . toString ( ) ) ;
logger . log ( Level . WARNING , LogFacade . FIND_CLASS_INTERNAL_SECURITY_EXCEPTION , new Object [ ] { name , ace . getMessage ( ) } ) ;
String msg = MessageFormat . format ( rb . getString ( LogFacade . EXCEPTION_CLOSING_WAR ) , base . getName ( ) ) ;
throw new IOException ( MessageFormat . format ( rb . getString ( LogFacade . READ_FILE_EXCEPTION ) , f . getAbsolutePath ( ) ) ) ;
MessageFormat . format ( rb . getString ( LogFacade . BLOCK_EXTERNAL_ENTITY ) , publicId , systemId ) ) ;
MessageFormat . format ( rb . getString ( LogFacade . BLOCK_EXTERNAL_SUBSET ) , name , baseURI ) ) ;
MessageFormat . format ( rb . getString ( LogFacade . BLOCK_EXTERNAL_ENTITY2 ) ,
String msg = MessageFormat . format ( rb . getString ( LogFacade . MAX_DISPATCH_DEPTH_REACHED ) ,
( MessageFormat . format ( rb . getString ( LogFacade . RESOURCES_NOT_FOUND ) , name ) ) ;
( MessageFormat . format ( rb . getString ( LogFacade . RESOURCES_NOT_FOUND ) , name ) ) ;
( MessageFormat . format ( rb . getString ( LogFacade . RESOURCES_NOT_FOUND ) , name ) ) ;
( MessageFormat . format ( rb . getString ( LogFacade . RESOURCES_NOT_FOUND ) , name ) ) ;
report . setMessage ( MessageFormat . format ( rb . getString ( LogFacade . CREATE_HTTP_FAIL_PROTOCOL_NOT_FOUND ) , protocol ) ) ;
assert ( cname . charAt ( 0 ) = = "str" ) ;
@Param ( name = "str" , optional = true ,
@Param ( name = "str" , optional = true )
@Param ( name = "str" , optional = true )
@Param ( name = "str" , optional = true , acceptableValues = "str" )
@Param ( name = "str" )
@Param ( name = "str" )
@Param ( name = "str" , optional = true )
@Param ( name = "str" , optional = true )
@Param ( name = "str" , optional = true )
@Param ( name = "str" , optional = true )
@Param ( name = "str" , optional = true )
@Param ( name = "str" , optional = true )
@Param ( name = "str" , optional = true )
params . add ( "str" , enabled . toString ( ) ) ;
if ( Boolean . valueOf ( app . getEnabled ( ) ) | | loadAppOnDAS ( app . getName ( ) ) ) {
if ( http2Element ! = null & & http2Element . getEnabled ( ) ) {
final boolean ENABLED = false ;
gfproperties . setConfigFileURI ( "str" + alternateDomainXML . getAbsolutePath ( ) . replace ( "str" , "str" ) ) ;
alternateDomainXML = new File ( args [ i + 1 ] ) ;
String [ ] localDirs = envs . get ( "str" ) . split ( "str" ) ;
String [ ] logsDirs = envs . get ( "str" ) . split ( "str" ) ;
updateBlacklist . invoke ( amrmAsync , blackHosts , null ) ;
TreeMap < String , ClassGroup > mapGroupNameToClassGroup = createMapGroupNameToClassGroup ( cModels , sourceDirectory ) ;
fm . createDoc ( mapGroupNameToClassGroup , cModels , projectDetail , homeContents , hostedSourceURL , monitor ) ;
private static TreeMap < String , ClassGroup > createMapGroupNameToClassGroup ( ArrayList < ClassModel > cModels ,
private boolean createHTML ( TreeMap < String , String > mapFNameToContent , IProgressMonitor monitor ) {
mapFNameToContent . put ( cg . getContentFilename ( ) , strHtml ) ;
rgstrScope [ 2 ] = "str" ;
if ( nestedCurlyBraceDepth = = 1 & & openCurlies ! = closeCurlies & & cModels . size ( ) > 1 & & cModel ! = null ) {
mModel . setReturns ( comment . substring ( idxStart + 7 ) . trim ( ) ) ;
String strGoTo = "str" ;
links + = "str" ;
return "str" + hostedSourceURL + strClassName + "str" + model . getInameLine ( ) + "str" ;
escapeHTML ( cModel . getNameLine ( ) ) + "str" +
contents + = "str" + escapeHTML ( prop . getNameLine ( ) ) + "str" ;
escapeHTML ( method . getNameLine ( ) ) + "str" +
( method . getReturns ( ) ! = "str" ? "str" + escapeHTML ( method . getReturns ( ) ) + "str" : "str" ) +
escapeHTML ( cg . getName ( ) ) + "str" + cgContent + "str" ;
assertTrue ( BytesInternal . equalBytesAny ( storeOfThirtyTwoBytes , longerBuffer , 32 ) ) ;
Jvm . setAccessible ( field ) ;
Jvm . setAccessible ( field ) ;
Jvm . setAccessible ( field ) ;
Jvm . setAccessible ( method ) ;
assert value > = 0 : "str" + value ;
@NotNull String [ ] words = new String [ ] { "str" , "str" , "str" , "str" } ;
assertEquals ( 26 , bytes . readPosition ( ) ) ;
assertEquals ( null , bytes . readUtf8 ( ) ) ;
return BytesInternal . readUtf8 ( this ) ;
MappedBytes bytes = MappedBytes . mappedBytes ( File . createTempFile ( "str" , "str" ) , 64 < < 10 ) ;
if ( endOfBuffer < = realCapacity ) {
if ( ( ( char2 & 0xC0 ) ! = 0x80 ) )
if ( bytesStore ( ) instanceof NativeBytesStore & & bytes . bytesStore ( ) instanceof NativeBytesStore & & length > = 64 ) {
for ( ; i < chars . length - 3 ; i + = 4 ) {
final int h = hash ( bytes , bytes . readPosition ( ) , bytes . readLimit ( ) , stopByte ) & mask ;
final char [ ] chars = new char [ ( int ) bytes . readRemaining ( ) ] ;
return interner [ h ] = StringUtils . newString ( chars ) ;
private static int hash ( Bytes cs , long position , long limit , final byte delimitor ) {
private static long longHash ( Bytes cs , long position , long limit , byte delimitor ) {
BytesUtil . append ( ( StreamingDataOutput ) this , f ) ;
BytesUtil . append ( ( StreamingDataOutput ) this , d ) ;
return new NativeBytesStore < > ( address , capacity , deallocator , false ) ;
if ( offset2 < 0 | | offset2 > capacity ( ) )
return pumpFrom ( source , 1_000_000 ) ;
return pumpTo ( destination , 1_000_000 ) ;
throw new IllegalArgumentException ( "str" + name ) ;
throw new IllegalArgumentException ( "str" + name ) ;
params . put ( "str" , rs . getInt ( "str" ) ) ;
return rs . getInt ( "str" ) ;
if ( rs . getObject ( "str" ) = = null ) {
return rs . getInt ( "str" ) ;
. query ( "str" ,
pet . setId ( rs . getInt ( "str" ) ) ;
import org . joda . time . LocalDate ;
visit . setDate ( new LocalDate ( visitDate ) ) ;
import org . joda . time . LocalDate ;
@Type ( type = "str" )
private LocalDate date ;
this . date = new LocalDate ( ) ;
public LocalDate getDate ( ) {
public void setDate ( LocalDate date ) {
@RequestMapping ( value = { "str" , "str" } )
return this . em . createQuery ( "str" ) . getResultList ( ) ;
params . put ( "str" , lastName + "str" ) ;
public String initCreationForm ( @PathVariable ( "str" ) int ownerId , Model model ) {
bindService ( intent , myServiceConnection , Context . BIND_AUTO_CREATE ) ;
sendMessage ( ) ;
unbindService ( myServiceConnection ) ;
void sendMessage ( ) {
private ServiceConnection myServiceConnection = new ServiceConnection ( ) {
this . offlineFallbackTimeout = TimeUnit . MILLISECONDS . convert ( offlineFallbackTimeout , unit ) ;
public Query ( CharSequence query ) {
public @NonNull Query setQuery ( CharSequence query ) {
public PlacesQuery ( CharSequence query ) {
PlacesQuery setQuery ( CharSequence query ) {
public JSONObject addObject ( JSONObject obj , @Nullable RequestOptions requestOptions ) throws AlgoliaException {
public static final int defaultExpirationTimeout = 120 ;
client . deleteIndexAsync ( index . getRawIndexName ( ) , new AssertCompletionHandler ( ) {
localIndex = new LocalIndex ( getClient ( ) . getRootDataDir ( ) . getAbsolutePath ( ) , getClient ( ) . getApplicationID ( ) , getRawIndexName ( ) ) ;
return new File ( new File ( getClient ( ) . getRootDataDir ( ) , getClient ( ) . getApplicationID ( ) ) , getRawIndexName ( ) ) ;
return new MultipleQueryEmulator ( this . getRawIndexName ( ) ) {
this . indexName = index . getRawIndexName ( ) ;
protected Index ( @NonNull Client client , @NonNull String rawIndexName ) {
return String . format ( "str" , this . getClass ( ) . getSimpleName ( ) , getRawIndexName ( ) ) ;
request . put ( "str" , this . rawIndexName ) ;
return client . postRequest ( "str" + encodedIndexName + "str" , query . getParameters ( ) , new JSONObject ( ) . put ( "str" , query . build ( ) ) . toString ( ) , false , null ) ;
return getRequest ( "str" + objectID , null , false , null ) ;
return getSettings ( 2 ) ;
JSONObject settingsJSON = this . getSettings ( 1 ) ;
if ( encoding ! = null & & encoding . equals ( "str" ) ) {
String paramsString = indexQuery . getQueryString ( ) ;
this . hostsArray . add ( 0 , applicationID + "str" ) ;
errors . put ( host , String . format ( "str" , e . getClass ( ) . getName ( ) , e . getMessage ( ) ) ) ;
queries . add ( new APIClient . IndexQuery ( indexName , new Query ( "str" ) ) ) ;
protected String facetFilters ;
public Query setFacetFilters ( List < String > facets ) {
this . facetFilters = obj . toString ( ) ;
public Query setTagFilters ( String tags ) {
public Query setNumericFilters ( String numerics ) {
public Query setNumericFilters ( List < String > numerics ) {
stringBuilder . append ( "str" ) ;
stringBuilder . append ( "str" ) ;
if ( facetFilters ! = null ) {
stringBuilder . append ( "str" ) ;
stringBuilder . append ( "str" ) ;
Assert . assertNotNull ( outputZipFile . getEntry ( "str" + File . separator ) ) ;
Assert . assertNull ( outputZipFile . getEntry ( "str" + File . separator ) ) ;
Validate . notNull ( session , "str" ) ;
includedFiles [ i ] = "str" + includedFiles [ i ] . replace ( File . separator , "str" ) ;
assertEquals ( true , config . isResolveNotReadyAddresses ( ) ) ;
this . resolveNotReadyAddresses = getOrDefault ( properties , KUBERNETES_SYSTEM_PREFIX , RESOLVE_NOT_READY_ADDRESSES , true ) ;
SSLContext context = SSLContext . getInstance ( "str" ) ;
Type type = new TypeToken < Pagination < Album > > ( ) { } . getType ( ) ;
BufferedImage maxImg = max = = - 1 ? img : ImageUtil . getScaledInstance ( img , max , max , RenderingHints . VALUE_INTERPOLATION_BILINEAR , true ) ;
BBC . SELECTOR_EXPANDED . send ( player , pos , region . getArea ( ) ) ;
player . printError ( "str" + filename + "str" + f + "str" ) ;
player . printError ( "str" + filename + "str" + f . exists ( ) + "str" + f + "str" + ( ! MainUtil . isInSubDirectory ( working , f ) ) + "str" ) ;
public boolean removeSectionLighting ( ExtendedBlockStorage section , int layer , boolean sky ) {
public boolean removeSectionLighting ( ExtendedBlockStorage section , int layer , boolean sky ) {
public boolean removeSectionLighting ( ExtendedBlockStorage section , int layer , boolean sky ) {
public boolean removeSectionLighting ( ExtendedBlockStorage section , int layer , boolean sky ) {
public boolean removeSectionLighting ( ExtendedBlockStorage section , int layer , boolean sky ) {
public boolean removeSectionLighting ( ExtendedBlockStorage section , int layer , boolean sky ) {
usage = "str" ,
BRUSH_LINE_SECONDARY ( "str" , "str" ) ,
File [ ] files = folder . listFiles ( new FilenameFilter ( ) {
public void hcyl ( FawePlayer fp , Player player , LocalSession session , EditSession editSession , Pattern pattern , Vector2D radius , @Optional ( "str" ) int height , @Range ( min = 1 ) @Optional ( "str" ) int thickness , CommandContext context ) throws WorldEditException , ParameterException {
int affected = editSession . makeHollowCylinder ( pos , pattern , radius . getBlockX ( ) , radius . getBlockZ ( ) , height , thickness - 1 ) ;
worldEdit . checkMaxRadius ( max ) ;
worldEdit . checkMaxRadius ( max ) ;
return getExtent ( ) . getNearestSurfaceTerrainBlock ( x , z , y , 0 , maxY ) ;
m . newline ( ) . text ( BBC . SCHEMATIC_LIST_ELEM , fileName , fileFormat ) ;
help = "str" +
Field fieldBits = BlockStateContainer . class . getDeclaredField ( "str" ) ;
Field fieldPalette = BlockStateContainer . class . getDeclaredField ( "str" ) ;
Field fieldSize = BlockStateContainer . class . getDeclaredField ( "str" ) ;
Field fieldBits = BlockStateContainer . class . getDeclaredField ( "str" ) ;
Field fieldPalette = BlockStateContainer . class . getDeclaredField ( "str" ) ;
Field fieldSize = BlockStateContainer . class . getDeclaredField ( "str" ) ;
Field fieldBits = BlockStateContainer . class . getDeclaredField ( "str" ) ;
Field fieldPalette = BlockStateContainer . class . getDeclaredField ( "str" ) ;
Field fieldSize = BlockStateContainer . class . getDeclaredField ( "str" ) ;
} , ( HasFaweQueue ) ( null ) ) ;
customMasks . put ( id . toLowerCase ( ) , clazz ) ;
usage = "str" ,
URL worldEditUrl = new URL ( "str" ) ;
return getBiome ( lastChunk , x , z ) & 0xFF ;
public static final String BIN_URL = "str" , USER_AGENT = "str" ;
return "str" + matcher . group ( 1 ) ;
public static int COMPRESSION_LEVEL = 3 ;
public static int ITEMS = 128 ;
player . setMeta ( "str" , mask ) ;
super ( "str" ) ;
dis . readFully ( buf ) ;
public int MAX_HISTORY_MB = 200 ;
debug ( "str" + plugin . getClass ( ) . getSimpleName ( ) . split ( "str" ) [ 1 ] ) ;
if ( ! parallel ) {
World world = Sponge . getServer ( ) . getWorld ( getParent ( ) . getWorldName ( ) ) . get ( ) ;
return Sponge . getServer ( ) . getWorld ( super . getWorldName ( ) ) . get ( ) ;
return new File ( "str" ) ;
public static final boolean DEBUG = false ;
public static final boolean DEBUG = false ;
boolean COPY_TO_CLIPBOARD_DEFAULT = false ;
boolean SHOW_CODE_NOTIFICATION_DEFAULT = true ;
boolean ENABLE_AUTO_INPUT_CODE_DEFAULT = true ;
String regex = "str" ;
boolean needBlank = false ;
needBlank = true ;
final Object extra = XposedHelpers . getObjectField ( pkg , "str" ) ;
refreshEnableAutoInputPreference ( mAutoInputPreference . isChecked ( ) ) ;
refreshEnableAutoInputPreference ( ( Boolean ) newValue ) ;
XLog . d ( "str" , serviceList . toString ( ) ) ;
XLog . e ( getResult . getStderr ( ) ) ;
private static boolean setEnabledAccessibilityServices ( List < String > enabledServices ) {
if ( this . response . getConnectionInfo ( ) . responseCode < 400 & & this . response . getConnectionInfo ( ) . responseCode > 100 )
this . response . onFinish ( this . response . getConnectionInfo ( ) . responseCode > = 400 | | this . response . getConnectionInfo ( ) . responseCode = = 0 ) ;
public static final String BASEURL = "str" ;
String url = Constants . BASEURL + botToken + "str" + SetWebhook . PATH ;
setWebhook ( extrenalUrl = = null ? "str" : extrenalUrl , botToken , pathToCertificate , publicCertificateName ) ;
if ( botToken = = null ) {
if ( getText ( ) ! = null | | getTextOff ( ) ! = null | | getTextOff ( ) ! = null )
protected int mCounterTextColor ;
this . counterLabel . setTextColor ( this . mCounterTextColor ) ;
setmCounterTextColor ( this . mCounterTextColor ) ;
public void setmCounterTextColor ( int colorRes ) {
protected boolean isManualValidateError = false ;
if ( isManualValidateError ) {
validateError ( ) ;
this . isManualValidateError = styledAttrs . getBoolean ( R . styleable . TextFieldBoxes_manualValidateError , false ) ;
public boolean validateError ( ) {
updateCounterText ( ! isManualValidateError ) ;
updateCounterText ( ! isManualValidateError ) ;
updateCounterText ( ! isManualValidateError ) ;
updateCounterText ( ! isManualValidateError ) ;
updateCounterText ( ! isManualValidateError ) ;
updateCounterText ( ! isManualValidateError ) ;
( ( RelativeLayout . LayoutParams ) this . inputLayout . getLayoutParams ( ) )
( ( RelativeLayout . LayoutParams ) this . inputLayout . getLayoutParams ( ) )
( ( TextFieldBoxes ) findViewById ( R . id . tfb1 ) ) . setError ( "str" ) ;
if ( nextTokenIsFast ( builder , tokens ) ) {
static final Parser attr_recover_parser_ = new Parser ( ) {
static final Parser grammar_element_parser_ = new Parser ( ) {
static final Parser grammar_element_recover_parser_ = new Parser ( ) {
static final Parser list_entry_recover_parser_ = new Parser ( ) {
static final Parser sequence_recover_parser_ = new Parser ( ) {
static final Parser Foo__recovery_parser_ = new Parser ( ) {
static final Parser nested_meta_pin_1_1_0_0_parser_ = new Parser ( ) {
static final Parser nested_meta_pin_1_1_0_1_parser_ = new Parser ( ) {
static final Parser nested_meta_pin_1_1_1_0_parser_ = new Parser ( ) {
static final Parser nested_meta_pin_1_1_1_1_parser_ = new Parser ( ) {
static final Parser some_parser_ = new Parser ( ) {
static final Parser item_auto_recover_ = new Parser ( ) {
static final Parser PERC_RE_parser_ = new Parser ( ) {
static final Parser SOME_parser_ = new Parser ( ) {
static final Parser item_recover_parser_ = new Parser ( ) {
static final Parser meta_mixed_list_paren_0_0_parser_ = new Parser ( ) {
static final Parser meta_seq_0_1_parser_ = new Parser ( ) {
static final Parser meta_seq_of_lists_0_1_parser_ = new Parser ( ) {
static final Parser meta_seq_of_lists_opt_0_0_1_parser_ = new Parser ( ) {
static final Parser one_parser_ = new Parser ( ) {
static final Parser param_choice_1_0_parser_ = new Parser ( ) {
static final Parser param_choice_alt_1_0_parser_ = new Parser ( ) {
static final Parser param_opt_1_0_parser_ = new Parser ( ) {
static final Parser param_seq_alt_1_0_parser_ = new Parser ( ) {
static final Parser param_seq_alt_1_1_parser_ = new Parser ( ) {
static final Parser param_seq_alt_params_ext_1_1_parser_ = new Parser ( ) {
static final Parser perc_parser_ = new Parser ( ) {
static final Parser two_parser_ = new Parser ( ) {
static final Parser one_list_par_0_0_parser_ = new Parser ( ) {
static final Parser grammar_element_parser_ = new Parser ( ) {
static final Parser include_section_recover__parser_ = new Parser ( ) {
static final Parser identifier_parser_ = new Parser ( ) {
static final Parser declaration_recover_parser_ = new Parser ( ) {
static final Parser macro_definition_recover_parser_ = new Parser ( ) {
static final Parser opt_code1_parser_ = new Parser ( ) {
static final Parser opt_code2_parser_ = new Parser ( ) {
static final Parser opt_eof1_parser_ = new Parser ( ) {
static final Parser opt_eof2_parser_ = new Parser ( ) {
static final Parser opt_eofthrow1_parser_ = new Parser ( ) {
static final Parser opt_eofthrow2_parser_ = new Parser ( ) {
static final Parser opt_eofval1_parser_ = new Parser ( ) {
static final Parser opt_eofval2_parser_ = new Parser ( ) {
static final Parser opt_init1_parser_ = new Parser ( ) {
static final Parser opt_init2_parser_ = new Parser ( ) {
static final Parser opt_initthrow1_parser_ = new Parser ( ) {
static final Parser opt_initthrow2_parser_ = new Parser ( ) {
static final Parser opt_yylexthrow1_parser_ = new Parser ( ) {
static final Parser opt_yylexthrow2_parser_ = new Parser ( ) {
static final Parser rule_recover_parser_ = new Parser ( ) {
static final Parser section_recover_parser_ = new Parser ( ) {
static final Parser user_value_0_0_parser_ = new Parser ( ) {
out ( "str" + name + "str" + call + "str" ) ;
static final Parser element_recover_parser_ = new Parser ( ) {
static final Parser statement_parser_ = new Parser ( ) {
if ( type = = BINARY ) {
if ( type = = ELEMENT ) {
if ( type = = ELEMENT_1 ) {
if ( type = = A_STATEMENT ) {
if ( type = = ITEM ) {
out ( ( ! first1 ? "str" : "str" ) + "str" + elementType + "str" ) ;
g . out ( "str" , g . N . pos , g . N . builder ) ;
int [ ] result = new int [ 36261 ] ;
public class InterfaceTypeImpl extends TypeImpl implements InterfaceType {
public class StructTypeImpl extends TypeImpl implements StructType {
marker_ = enter_section_ ( builder , level , modifiers , isPrivate ? null : elementType , frameName ) ;
exit_section_ ( builder , level , marker_ , alwaysTrue | | result_ , pinned_ , recoverPredicate ) ;
public static < T > T getGenerateOption ( @NotNull PsiElement node , @NotNull KnownAttribute < T > attribute , @Nullable String currentValue ) {
public static < T > T getRootAttribute ( @NotNull PsiElement node , @NotNull KnownAttribute < T > attribute ) {
public static < T > T getRootAttribute ( @NotNull PsiElement node , @NotNull KnownAttribute < T > attribute , @Nullable String match ) {
public static < T > T getAttribute ( @NotNull BnfRule rule , @NotNull KnownAttribute < T > attribute ) {
public static < T > BnfAttr findAttribute ( @NotNull BnfRule rule , @NotNull KnownAttribute < T > attribute ) {
public static < T > T getAttribute ( @NotNull BnfRule rule , @NotNull KnownAttribute < T > attribute , @Nullable String match ) {
String mixinClass = rule = = null ? null : getAttribute ( rule , KnownAttribute . MIXIN ) ;
addWarning ( info . rule . getProject ( ) , "str" + info . operator . getText ( ) + "str" + result ) ;
BnfRule arg2 = substRule ( childExpressions2 , index3 , rootRule ) ;
project . registerService ( DumbService . class , new DumbServiceImpl ( project ) ) ;
} , FileDocumentManagerImpl . HARD_REF_TO_DOCUMENT_KEY )
import com . intellij . openapi . vfs . newvfs . impl . VfsRootAccess ;
VfsRootAccess . allowRootAccess ( new File ( getTestDataPath ( ) ) . getAbsolutePath ( ) ) ;
VfsRootAccess . disallowRootAccess ( new File ( "str" ) . getAbsolutePath ( ) ) ;
VfsRootAccess . allowRootAccess ( absolutePath ) ;
VfsRootAccess . disallowRootAccess ( absolutePath ) ;
while ( i < 1326 ) {
holder . createInfoAnnotation ( element , null ) . setTextAttributes ( JFlexSyntaxHighlighterFactory . STATE ) ;
ErrorState . get ( builder ) . braces = braces . isEmpty ( ) ? null : braces . toArray ( new BracePair [ braces . size ( ) ] ) ;
public interface GeneratedTypes {
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
public interface GeneratedTypes {
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
public class GeneratedParser implements PsiParser {
public static Logger LOG_ = Logger . getInstance ( "str" ) ;
import static generated . GeneratedTypes . * ;
public interface GeneratedTypes {
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
public class GeneratedParser implements PsiParser {
public static Logger LOG_ = Logger . getInstance ( "str" ) ;
import static generated . GeneratedTypes . * ;
public static final KnownAttribute < String > PARSER_CLASS = create ( true , String . class , "str" , "str" ) ;
public static final KnownAttribute < String > ELEMENT_TYPE_HOLDER_CLASS = create ( true , String . class , "str" , "str" ) ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
import static generated . GeneratedTypes . * ;
IElementType ID = new IElementType ( "str" , null ) ;
result = psiMap ( new LeafPsiElement ( EXTERNAL_TYPE , "str" + ruleRef . getText ( ) ) , REQUIRED ) ;
IElementType BLOCK_OF = new IElementType ( "str" ) ;
IElementType SPECIAL_REF = new IElementType ( "str" ) ;
if ( type = = BLOCK_OF ) {
else if ( type = = LEFT_SHADOW ) {
else if ( type = = LEFT_SHADOW_TEST ) {
else if ( type = = SPECIAL_REF ) {
return super . toString ( ) + "str" + getText ( ) ;
return super . toString ( ) + "str" + getText ( ) ;
public static boolean shouldGeneratePsi ( BnfRule rule , boolean psiClasses ) {
if ( ! psiClasses ) return elementType = = null ;
if ( RuleGraphHelper . shouldGeneratePsi ( rule , true ) ) {
if ( isPrivate & & ! isLeftInner & & recoverRoot = = null ) {
while ( result_ & & ! builder_ . eof ( ) ) {
while ( result_ & & ! builder_ . eof ( ) ) {
while ( result_ & & ! builder_ . eof ( ) ) {
while ( result_ & & ! builder_ . eof ( ) ) {
while ( result_ & & ! builder_ . eof ( ) ) {
while ( result_ & & ! builder_ . eof ( ) ) {
while ( result_ & & ! builder_ . eof ( ) ) {
while ( result_ & & ! builder_ . eof ( ) ) {
out ( "str" ) ;
while ( result_ & & ! builder_ . eof ( ) ) {
while ( result_ & & ! builder_ . eof ( ) ) {
while ( result_ & & ! builder_ . eof ( ) ) {
while ( result_ & & ! builder_ . eof ( ) ) {
while ( result_ & & ! builder_ . eof ( ) ) {
while ( true ) {
final boolean result = eatMoreCondition . parse ( builder ) & & parser . parse ( builder ) ;
& & Sets . symmetricDifference ( wrapped ( a . getParameters ( ) ) , wrapped ( b . getParameters ( ) ) ) . isEmpty ( ) ;
result = result . replaceAll ( "str" , "str" ) ;
return CaseFormat . LOWER_CAMEL . to ( CaseFormat . UPPER_CAMEL , stringValue ) ;
definition . name ( apiKey . getKeyname ( ) ) . in ( In . forValue ( apiKey . getPassAs ( ) ) ) ;
LOG . debug ( "str" , e ) ;
allowableValueString = allowableValueString . trim ( ) ;
List < String > singleVal = Collections . singletonList ( allowableValueString ) ;
result = result . replaceAll ( "str" , "str" ) ;
LOG . debug ( "str" , handlerMethod . getMethod ( ) . getName ( ) , authorizations . size ( ) ) ;
consumesList . add ( MediaType . APPLICATION_JSON_VALUE ) ;
new ResponseMessage ( NO_CONTENT . value ( ) , NO_CONTENT . getReasonPhrase ( ) , toOption ( null ) ) ,
new ResponseMessage ( NO_CONTENT . value ( ) , NO_CONTENT . getReasonPhrase ( ) , toOption ( null ) ) ,
new ResponseMessage ( NO_CONTENT . value ( ) , NO_CONTENT . getReasonPhrase ( ) , toOption ( null ) ) ,
new ResponseMessage ( NO_CONTENT . value ( ) , NO_CONTENT . getReasonPhrase ( ) , toOption ( null ) ) ,
new ResponseMessage ( NO_CONTENT . value ( ) , NO_CONTENT . getReasonPhrase ( ) , toOption ( null ) ) ,
this . modelProvider = modelProvider ;
private Map < String , ResourceListing > swaggerApiResourceListingMap = newLinkedHashMap ( ) ;
private Map < String , ApiListing > swaggerApiListingMap = newHashMap ( ) ;
public static final String DOCUMENTATION_BASE_PATH = "str" ;
private SwaggerCache swaggerCache ;
LOG . debug ( format ( "str" ,
log . info ( "str" , annotatedElement ) ;
protected static class DefinitionBuild {
protected ChannelHandler buildHandler ( DefinitionBuild definitionBuild ) throws Exception {
protected Registry buildServerRegistry ( ServerConfig serverConfig , Function < ? super Registry , ? extends Registry > userRegistryFactory ) {
protected Handler decorateHandler ( Handler rootHandler , Registry serverRegistry ) throws Exception {
protected Handler buildRatpackHandler ( Registry serverRegistry , Function < ? super Registry , ? extends Handler > handlerFactory ) throws Exception {
public class DefaultDurationRetryPolicyBuilder implements DurationRetryPolicyBuilder {
if ( path . startsWith ( "str" ) ) {
cookieSessionId = ( match = = null | | match . value ( ) . isEmpty ( ) ) ? Optional . empty ( ) : Optional . of ( AsciiString . of ( match . value ( ) ) ) ;
pathBinding = new DefaultPathBinding ( boundTo , ImmutableMap . copyOf ( pathTokens ) , new RootPathBinding ( boundTo + "str" + pastBinding ) , description ) ;
throw new IllegalArgumentException ( "str" ) ;
return streamMap ( input , ( subscription , downstream ) - > {
return left . isSubtypeOf ( right ) ;
boolean assignableFrom = left . isSupertypeOf ( right ) ;
} catch ( Throwable e ) {
while ( true ) {
ClassLoader parent = Thread . currentThread ( ) . getContextClassLoader ( ) ;
default GroovyChain notFound ( ) {
return post ( getRegistry ( ) . get ( handler ) ) ;
private Duration maxInactivityInterval = Duration . ofHours ( 24 ) ;
public boolean isError ( ) {
result . set ( new ResultBackedExecResult < > ( Result . < T > error ( throwable ) , Execution . execution ( ) ) ) ;
return "str" + getThrowable ( ) + "str" + getValue ( ) + "str" ;
fire ( Result . < T > error ( new IllegalStateException ( "str" ) ) ) ;
fire ( Result . < T > error ( t ) ) ;
return Result . < T > error ( e ) ;
consumer . accept ( Result . < List < T > > error ( t ) ) ;
. onError ( throwable - > requestAction . setResult ( Result . < ReceivedResponse > error ( throwable ) ) )
boolean isError ( ) ;
if ( isError ( ) ) {
} else if ( result . isError ( ) ) {
if ( result . isError ( ) ) {
reference . set ( new ResultBackedExecResult < > ( Result . < T > error ( throwable ) , exec ) ) ;
onError ( t - > resultHandler . execute ( Result . < T > error ( t ) ) ) . then ( v - > resultHandler . execute ( Result . success ( v ) ) ) ;
private final Throwable error ;
this . error = null ;
return error = = null ;
return "str" + error + "str" + value + "str" ;
ctx . writeAndFlush ( response ) . addListener ( ChannelFutureListener . CLOSE ) ;
int longCache = 60 * 60 * 24 * 365 ;
int cacheFor = ctx . getRequest ( ) . getQuery ( ) . isEmpty ( ) ? shortCache : longCache ;
LOGGER . warn ( "str" , definitionBuild . error ) ;
this . secret = Long . toString ( System . currentTimeMillis ( ) / 10000 ) ;
STYLE = CharStreams . toString ( reader ) ;
private final static String DEFAULT_INTERVAL = "str" ;
requestConstants . context . error ( throwable instanceof HandlerException ? throwable . getCause ( ) : throwable ) ;
void execute ( T t ) throws Exception ;
e . getContext ( ) . error ( ExceptionUtils . toException ( e . getCause ( ) ) ) ;
context . error ( new NoSuchRendererException ( object ) ) ;
this . registry = registry ( type , object ) ;
private int size ;
return ! Files . getLastModifiedTime ( file ) . equals ( lastModifiedHolder . get ( ) ) | | ! isBytesAreSame ( ) ;
public < T > void bind ( final Class < ? super T > publicType , final T instance ) {
< T > void bind ( Class < ? super T > publicType , T instance ) ;
import static org . ratpackframework . handling . Handlers . chain ;
private int cacheSize ;
private int cacheSize = 0 ;
this . handler = new ErrorCatchingHandler ( handler ) ;
handler . handle ( exchange ) ;
exchange . clientError ( METHOD_NOT_ALLOWED . code ( ) ) ;
exchange . clientError ( FORBIDDEN . code ( ) ) ;
private int cacheSize = 100 ;
public RatpackServer create ( Class < ? extends Handler < Routing > > appHandler , Module . . . modules ) {
public RatpackServer create ( Class < ? extends Handler < Routing > > appHandler , File staticAssetsDir , Module . . . modules ) {
public RatpackServer create ( Class < ? extends Handler < Routing > > appHandler , StaticAssetsConfig staticAssetsConfig , Module . . . modules ) {
public static AppRoutingModule create ( final Class < ? extends Handler < Routing > > routingHandlerClass ) {
end ( HttpResponseStatus . FOUND . getCode ( ) ) ;
boolean ret = isAccessAllowed ( user , userGroups , null , null , accessType ) & & isMatch ( resources , null ) ;
boolean ret = isAccessAllowed ( user , userGroups , roles , null , accessType ) & & isMatch ( policy , null ) ;
if ( StringUtils . isBlank ( service . getTagService ( ) ) & & xxServiceDef ! = null & & ! StringUtils . equals ( EmbeddedServiceDefsUtil . EMBEDDED_SERVICEDEF_TAG_NAME , xxServiceDef . getName ( ) ) ) {
if ( fileSpooler . isSpoolingSuccessful ( ) ) {
throw restErrorUtil . createRESTException ( "str" , MessageEnums . INVALID_INPUT_DATA , null , null , pwdChange . getLoginId ( ) ) ;
throw restErrorUtil . createRESTException ( "str" , MessageEnums . INVALID_INPUT_DATA , gjUser . getId ( ) , "str" , gjUser . toString ( ) ) ;
String errMsg = "str" + policyId + "str" + eventTime ;
public boolean optimizeTrieForRetrieval = false ;
optimizeTrieForRetrieval = conf . getBoolean ( propertyPrefix + "str" , false ) ;
LOG . debug ( "str" + name + "str" + ret ) ;
vXResponse . setMsgDesc ( "str" ) ;
vXResponse . setMsgDesc ( "str" ) ;
vXResponse . setMsgDesc ( "str" ) ;
vXResponse . setMsgDesc ( "str" ) ;
public static final String DEFAULT_CONFIG_FILE = "str" ;
isMatched = matchType ! = RangerPolicyResourceMatcher . MatchType . NONE ;
+ "str" + vObj . getService ( ) , MessageEnums . INVALID_INPUT_DATA ) ;
throw new IOException ( "str" ) ;
LOG . error ( "str" , he ) ;
isAccessAllowed = rangerResult ! = null & & rangerResult . getIsAllowed ( ) ;
return ! StringUtils . isEmpty ( _baseUrl ) & & _baseUrl . toLowerCase ( ) . startsWith ( "str" ) ;
private static String UNAUTHENTICATED_MSG = "str" ;
throw new IllegalArgumentException ( "str" + "str" + dfsNameservices + "str" ) ;
. any ( ) ) ) . thenReturn ( rangerServiceDef ) ;
. any ( ) ) ) . thenReturn ( rangerServiceDef ) ;
private static final Log LOG = LogFactory . getLog ( ValuePrinter . class ) ;
. getLog ( Log4JAuditDestination . class ) ;
LOG . debug ( "str" + jsonString ) ;
LOG . debug ( "str" + request + "str" ) ;
LOG . debug ( "str" + request + "str" ) ;
LOG . debug ( "str" + request + "str" ) ;
LOG . debug ( "str" + request + "str" ) ;
LOG . debug ( "str" + rangerServiceName + "str" + applicationId + "str" + propertyPrefix + "str" ) ;
LOG . debug ( "str" + rangerServiceName + "str" + applicationId + "str" + propertyPrefix + "str" + policySourceImpl + "str" + ret ) ;
private static final String DEFAULT_BOOTSTRAP_SERVICEDEF_LIST = "str" ;
LOG . debug ( "str" + policyReorderIntervalMs + "str" ) ;
logger . error ( "str" + query
throw restErrorUtil . createRESTException ( "str" ,
if ( "str" . equals ( fieldName ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( vObj = = null | | action = = null | | ( "str" . equalsIgnoreCase ( action ) & & mObj = = null ) ) {
if ( "str" . equalsIgnoreCase ( action ) ) {
} else if ( "str" . equalsIgnoreCase ( action ) ) {
} else if ( "str" . equalsIgnoreCase ( action ) ) {
if ( ! StringUtils . isEmpty ( forceDeleteStr ) & & "str" . equalsIgnoreCase ( forceDeleteStr ) ) {
if ( session . isKeyAdmin ( ) & & ! EmbeddedServiceDefsUtil . KMS_IMPL_CLASS_NAME . equals ( xxServiceDef . getImplclassname ( ) ) ) {
if ( ( ! session . isKeyAdmin ( ) & & ! session . isUserAdmin ( ) ) & & EmbeddedServiceDefsUtil . KMS_IMPL_CLASS_NAME . equals ( xxServiceDef . getImplclassname ( ) ) ) {
if ( EmbeddedServiceDefsUtil . KMS_IMPL_CLASS_NAME . equals ( xServiceDef . getImplclassname ( ) ) ) {
if ( ! EmbeddedServiceDefsUtil . KMS_IMPL_CLASS_NAME . equals ( xServiceDef . getImplclassname ( ) ) ) {
if ( "str" . equalsIgnoreCase ( headerName ) & & value . startsWith ( "str" ) ) {
if ( "str" . equalsIgnoreCase ( field . getName ( ) ) ) {
} else if ( POLICY_RESOURCE_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( POLICY_ITEM_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( DENYPOLICY_ITEM_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( POLICY_NAME_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( ALLOW_EXCEPTIONS_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( DENY_EXCEPTIONS_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( DATAMASK_POLICY_ITEM_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( ROWFILTER_POLICY_ITEM_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( IS_ENABLED_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
if ( POLICY_RESOURCE_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( POLICY_ITEM_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( DENYPOLICY_ITEM_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( POLICY_NAME_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( POLICY_DESCRIPTION_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( ALLOW_EXCEPTIONS_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( DENY_EXCEPTIONS_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( DATAMASK_POLICY_ITEM_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( ROWFILTER_POLICY_ITEM_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( IS_ENABLED_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( POLICY_RESOURCE_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( POLICY_ITEM_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( POLICY_NAME_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( DENYPOLICY_ITEM_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( ALLOW_EXCEPTIONS_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( DENY_EXCEPTIONS_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( POLICY_DESCRIPTION_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( DATAMASK_POLICY_ITEM_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( ROWFILTER_POLICY_ITEM_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( IS_ENABLED_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( IS_AUDIT_ENABLED_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( IS_ENABLED_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
} else if ( IS_AUDIT_ENABLED_CLASS_FIELD_NAME . equalsIgnoreCase ( fieldName ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( className ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( sortType ! = null & & "str" . equalsIgnoreCase ( sortType ) ) {
if ( ! ( "str" . equalsIgnoreCase ( args [ 0 ] ) ) | | ! ( "str" . equalsIgnoreCase ( args [ 1 ] ) | | "str" . equalsIgnoreCase ( args [ 1 ] ) | | "str" . equalsIgnoreCase ( args [ 1 ] ) | | "str" . equalsIgnoreCase ( args [ 1 ] ) | | "str" . equalsIgnoreCase ( args [ 1 ] ) | | "str" . equalsIgnoreCase ( args [ 1 ] ) | | "str" . equalsIgnoreCase ( args [ 1 ] ) ) ) {
if ( ! "str" . equalsIgnoreCase ( serviceName ) ) {
if ( vObj = = null | | action = = null | | ( "str" . equalsIgnoreCase ( action ) & & mObj = = null ) ) {
if ( "str" . equalsIgnoreCase ( fieldName ) ) {
if ( "str" . equalsIgnoreCase ( action ) ) {
| | ( "str" . equalsIgnoreCase ( fieldName ) & & ! stringUtil
} else if ( "str" . equalsIgnoreCase ( action ) ) {
if ( "str" . equalsIgnoreCase ( mFieldName ) ) {
if ( "str" . equalsIgnoreCase ( fieldName ) ) {
return isEmpty ( str ) | | WILDCARD_ASTERISK . equals ( str ) ;
if ( vObj = = null | | action = = null | | ( "str" . equalsIgnoreCase ( action ) & & mObj = = null ) ) {
if ( "str" . equals ( fieldName ) )
else if ( value = = null | | "str" . equalsIgnoreCase ( value ) | | stringUtil . isEmpty ( value ) ) {
if ( "str" . equalsIgnoreCase ( action ) ) {
} else if ( "str" . equalsIgnoreCase ( action ) ) {
} else if ( "str" . equalsIgnoreCase ( action ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( "str" . equalsIgnoreCase ( action ) ) {
} else if ( "str" . equalsIgnoreCase ( action ) ) {
} else if ( "str" . equalsIgnoreCase ( action ) ) {
if ( httpRequest . getServletContext ( ) . getAttribute ( httpRequest . getRequestedSessionId ( ) ) ! = null & & "str" . equals ( httpRequest . getServletContext ( ) . getAttribute ( httpRequest . getRequestedSessionId ( ) ) . toString ( ) ) ) {
| | ! "str" . equals ( response . getMediaType ( ) . getType ( ) ) ) {
if ( "str" . equalsIgnoreCase ( contentType ) | | contentType . endsWith ( "str" ) ) {
if ( isKeyAdmin & & EmbeddedServiceDefsUtil . KMS_IMPL_CLASS_NAME . equals ( implClass ) ) {
} else if ( ( isSysAdmin | | isUser ) & & ! EmbeddedServiceDefsUtil . KMS_IMPL_CLASS_NAME . equals ( implClass ) ) {
if ( isKeyAdmin & & EmbeddedServiceDefsUtil . KMS_IMPL_CLASS_NAME . equals ( implClass ) ) {
} else if ( isUser & & ! EmbeddedServiceDefsUtil . KMS_IMPL_CLASS_NAME . equals ( implClass ) ) {
if ( session . isKeyAdmin ( ) & & ! EmbeddedServiceDefsUtil . KMS_IMPL_CLASS_NAME . equals ( implClassName ) ) {
if ( "str" . equalsIgnoreCase ( objType ) & & session . isUserAdmin ( ) & & EmbeddedServiceDefsUtil . KMS_IMPL_CLASS_NAME . equals ( implClassName ) ) {
if ( "str" . equals ( u ) | | ( user ! = null & & u . equalsIgnoreCase ( user ) ) ) {
if ( "str" . equals ( u ) | | ( userName ! = null & & u . equalsIgnoreCase ( userName ) ) ) {
if ( "str" . equalsIgnoreCase ( field . getName ( ) ) ) {
if ( "str" . equalsIgnoreCase ( key )
if ( ! stringUtil . isEmpty ( pwd ) & & ServiceDBStore . HIDDEN_PASSWORD_STR . equalsIgnoreCase ( pwd ) ) {
if ( "str" . equalsIgnoreCase ( fileType ) ) {
if ( epoch ! = null & & ! epoch . trim ( ) . isEmpty ( ) & & ! "str" . equalsIgnoreCase ( epoch ) ) {
if ( "str" . equalsIgnoreCase ( rdn . getType ( ) ) ) {
} else if ( ! "str" . equalsIgnoreCase ( searchCriteria . getSortType ( ) ) & & ! "str" . equalsIgnoreCase ( searchCriteria . getSortType ( ) ) ) {
if ( RangerBizUtil . AUDIT_STORE_SOLR . equalsIgnoreCase ( xaBizUtil . getAuditDBType ( ) ) ) {
if ( vXTrxLog . getPreviousValue ( ) = = null | | "str" . equalsIgnoreCase ( vXTrxLog . getPreviousValue ( ) ) ) {
if ( vXTrxLog . getAttributeName ( ) ! = null & & "str" . equalsIgnoreCase ( vXTrxLog . getAttributeName ( ) ) ) {
if ( vXTrxLog . getAttributeName ( ) ! = null & & "str" . equalsIgnoreCase ( vXTrxLog . getAttributeName ( ) ) ) {
if ( vObj = = null | | action = = null | | ( "str" . equalsIgnoreCase ( action ) & & xObj = = null ) ) {
if ( "str" . equalsIgnoreCase ( action ) ) {
} else if ( "str" . equalsIgnoreCase ( action ) ) {
} else if ( "str" . equalsIgnoreCase ( action ) ) {
if ( "str" . equalsIgnoreCase ( fieldName ) ) {
if ( "str" . equalsIgnoreCase ( persistenceContextUnit ) ) {
if ( ! StringUtils . isEmpty ( authType ) & & KERBEROS_TYPE . equalsIgnoreCase ( authType . trim ( ) ) & & SecureClientLogin . isKerberosCredentialExists ( lookupPrincipal , lookupKeytab ) ) {
if ( ! StringUtils . isEmpty ( authType ) & & KERBEROS_TYPE . equalsIgnoreCase ( authType . trim ( ) ) & & SecureClientLogin . isKerberosCredentialExists ( rangerPrincipal , rangerkeytab ) ) {
if ( ! StringUtils . isEmpty ( authType ) & & KERBEROS_TYPE . equalsIgnoreCase ( authType . trim ( ) ) & & SecureClientLogin . isKerberosCredentialExists ( lookupPrincipal , lookupKeytab ) ) {
if ( ! StringUtils . isEmpty ( authType ) & & KERBEROS_TYPE . equalsIgnoreCase ( authType . trim ( ) ) & & SecureClientLogin . isKerberosCredentialExists ( rangerPrincipal , rangerkeytab ) ) {
if ( pluginJarPath ! = null & & "str" . equals ( pluginJarPath . getProtocol ( ) ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( CONDITION . AND . equals ( condition ) ) {
if ( CONDITION . AND . equals ( condition ) ) {
if ( "str" . equalsIgnoreCase ( msg ) ) {
} else if ( "str" . equalsIgnoreCase ( msg ) ) {
if ( ajaxRequestHeader ! = null & & "str" . equalsIgnoreCase ( ajaxRequestHeader ) ) {
if ( tmp = = null | | ! EmbeddedServiceDefsUtil . EMBEDDED_SERVICEDEF_TAG_NAME . equals ( tmp . getType ( ) ) ) {
if ( EmbeddedServiceDefsUtil . EMBEDDED_SERVICEDEF_TAG_NAME . equals ( service . getType ( ) ) ) {
if ( ( ! rangerService . getConfigs ( ) . containsKey ( ServiceREST . Allowed_User_List_For_Grant_Revoke ) ) & & ( "str" . equalsIgnoreCase ( rangerService . getType ( ) ) | | "str" . equalsIgnoreCase ( rangerService . getType ( ) ) ) ) {
if ( "str" . equalsIgnoreCase ( rangerAuthenticationMethod ) ) {
if ( "str" . equalsIgnoreCase ( rangerAuthenticationMethod ) ) {
if ( "str" . equalsIgnoreCase ( rangerAuthenticationMethod ) ) {
if ( "str" . equalsIgnoreCase ( rangerAuthenticationMethod ) ) {
if ( vObj = = null | | action = = null | | ( "str" . equalsIgnoreCase ( action ) & & mObj = = null ) ) {
if ( "str" . equalsIgnoreCase ( action ) ) {
} else if ( "str" . equalsIgnoreCase ( action ) ) {
} else if ( "str" . equalsIgnoreCase ( action ) ) {
if ( "str" . equalsIgnoreCase ( fieldName ) ) {
if ( "str" . equalsIgnoreCase ( key ) & & entry
if ( isEncryptedEntry = = null | | ! "str" . equalsIgnoreCase ( isEncryptedEntry . getValue ( ) ) | | isForced = = true ) {
if ( timeOffsetCookieName . equals ( cookie . getName ( ) ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( vObj = = null | | action = = null | | ( "str" . equalsIgnoreCase ( action ) & & mObj = = null ) ) {
if ( "str" . equalsIgnoreCase ( action ) ) {
} else if ( "str" . equalsIgnoreCase ( action ) ) {
} else if ( "str" . equalsIgnoreCase ( action ) ) {
if ( vObj = = null | | action = = null | | ( "str" . equalsIgnoreCase ( action ) & & mObj = = null ) ) {
if ( enumName = = null & & "str" . equals ( fieldName ) ) {
if ( value = = null | | "str" . equalsIgnoreCase ( value ) ) {
if ( "str" . equalsIgnoreCase ( action ) ) {
} else if ( "str" . equalsIgnoreCase ( action ) ) {
} else if ( "str" . equalsIgnoreCase ( action ) ) {
if ( enumName = = null & & "str" . equals ( mFieldName ) ) {
if ( value . equalsIgnoreCase ( oldValue ) & & ! "str" . equals ( fieldName ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( "str" . equals ( fieldName ) ) {
! "str" . equalsIgnoreCase ( xaDBPassword . trim ( ) ) ) {
! "str" . equalsIgnoreCase ( auditDBPassword . trim ( ) ) ) {
if ( authenticationMethod ! = null & & ( "str" . equalsIgnoreCase ( authenticationMethod ) | | "str" . equalsIgnoreCase ( authenticationMethod ) ) ) {
! "str" . equalsIgnoreCase ( bindDNPassword . trim ( ) ) ) {
if ( authenticationMethod ! = null & & ( "str" . equalsIgnoreCase ( authenticationMethod ) ) ) {
! "str" . equalsIgnoreCase ( bindDNPassword . trim ( ) ) ) {
if ( auditStore ! = null & & ( "str" . equalsIgnoreCase ( auditStore ) ) ) {
! "str" . equalsIgnoreCase ( solrAuditPassword . trim ( ) ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( ! StringUtils . isEmpty ( sessionUserName ) & & "str" . equalsIgnoreCase ( sessionUserName ) & & ! StringUtils . isEmpty ( pathInfo ) & & pathInfo . contains ( "str" ) ) {
if ( cname ! = null & & "str" . equalsIgnoreCase ( cname ) )
} else if ( cname ! = null & & AUTH_COOKIE_NAME . equalsIgnoreCase ( cname ) ) {
return ( ( ! StringUtils . isEmpty ( authType ) ) & & KERBEROS_TYPE . equalsIgnoreCase ( authType ) & & SecureClientLogin . isKerberosCredentialExists ( principal , keytabPath ) ) ;
if ( ajaxRequestHeader ! = null & & "str" . equalsIgnoreCase ( ajaxRequestHeader ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( SearchField . SEARCH_TYPE . LESS_THAN . equals ( searchField . getSearchType ( ) ) ) {
} else if ( SearchField . SEARCH_TYPE . LESS_EQUAL_THAN . equals ( searchField . getSearchType ( ) ) ) {
} else if ( SearchField . SEARCH_TYPE . GREATER_THAN . equals ( searchField . getSearchType ( ) ) ) {
} else if ( SearchField . SEARCH_TYPE . GREATER_EQUAL_THAN . equals ( searchField . getSearchType ( ) ) ) {
if ( "str" . equalsIgnoreCase ( sortType ) | | "str" . equalsIgnoreCase ( sortType ) ) {
& & "str" . equalsIgnoreCase ( ajaxRequestHeader ) ) {
| | "str" . equalsIgnoreCase ( collectionName ) ) {
| | "str" . equalsIgnoreCase ( solrURL ) ) {
if ( "str" . equalsIgnoreCase ( rangerBizUtil . getAuditDBType ( ) ) ) {
if ( "str" . equalsIgnoreCase ( rangerBizUtil . getAuditDBType ( ) ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( "str" . equals ( fieldName ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( label ) ) {
if ( "str" . equalsIgnoreCase ( resType ) ) {
} else if ( "str" . equalsIgnoreCase ( resType ) ) {
} else if ( "str" . equalsIgnoreCase ( resType ) ) {
} else if ( "str" . equalsIgnoreCase ( resType ) ) {
} else if ( "str" . equalsIgnoreCase ( resType ) ) {
} else if ( "str" . equalsIgnoreCase ( resType ) ) {
} else if ( "str" . equalsIgnoreCase ( resType ) ) {
} else if ( "str" . equalsIgnoreCase ( resType ) ) {
if ( "str" . equalsIgnoreCase ( resType ) ) {
} else if ( "str" . equalsIgnoreCase ( resType ) ) {
} else if ( "str" . equalsIgnoreCase ( resType ) ) {
} else if ( "str" . equalsIgnoreCase ( resType ) ) {
} else if ( "str" . equalsIgnoreCase ( resType ) ) {
} else if ( "str" . equalsIgnoreCase ( resType ) ) {
} else if ( "str" . equalsIgnoreCase ( resType ) ) {
} else if ( "str" . equalsIgnoreCase ( resType ) ) {
if ( "str" . equalsIgnoreCase ( perm ) ) {
if ( "str" . equalsIgnoreCase ( perm ) ) {
if ( "str" . equalsIgnoreCase ( rdn . getType ( ) ) ) {
if ( KERBEROS_TYPE . equalsIgnoreCase ( PropertiesUtil . getProperty ( RANGER_AUTH_TYPE , "str" ) ) ) {
if ( "str" . equalsIgnoreCase ( rangerBizUtil . getAuditDBType ( ) ) ) {
| | "str" . equalsIgnoreCase ( collectionName ) ) {
| | "str" . equalsIgnoreCase ( solrURL ) ) {
} else if ( strRoleList . size ( ) = = 1 & & RangerConstants . ROLE_USER . equals ( strRoleList . get ( 0 ) ) ) {
System . out . println ( "str" + cb . getClass ( ) . getName ( ) + "str" ) ;
LOG . error ( "str" + serviceName , new Throwable ( ) ) ;
logger . fatal ( "str"
throw new IllegalArgumentException ( "str" ) ;
FileStatus [ ] fileStatus = fs . listStatus ( basePath ) ;
LOG . debug ( "str" + fileStatus . length + "str" + pathList ) ;
for ( FileStatus stat : fileStatus ) {
LOG . debug ( "str" ) ;
LOG . warn ( "str" + keytabPath + "str" ) ;
System . out . println ( "str" + alias + "str" ) ;
LOG . error ( "str" + serviceName + "str" + lastKnownVersion + "str" , snfe ) ;
if ( groupUserInfo ! = null & & groupUserInfo . getXuserInfo ( ) ! = null ) {
LOG . error ( "str" + className + "str" , t ) ;
package org . apache . ranger . unixusersync . config ;
private static final Logger LOG = Logger . getLogger ( UserGroupSyncConfig . class ) ;
public static final String DEFAULT_UGSYNC_MIN_GROUPID = "str" ;
private static final String DEFAULT_AUTHENTICATION_MECHANISM = "str" ;
private static final String LGSYNC_SEARCH_BASE = "str" ;
private static final String LGSYNC_USER_SEARCH_BASE = "str" ;
private static final String LGSYNC_USER_SEARCH_SCOPE = "str" ;
private static final String DEFAULT_UGSYNC_USERNAME_CASE_CONVERSION_VALUE = UGSYNC_NONE_CASE_CONVERSION_VALUE ;
private static final String LGSYNC_GROUP_SEARCH_BASE = "str" ;
private static final String LGSYNC_GROUP_SEARCH_SCOPE = "str" ;
private static final String LGSYNC_GROUP_SEARCH_FILTER = "str" ;
public static final String SYNC_MAPPING_GROUPNAME = "str" ;
. create403RESTException ( "str"
throw restErrorUtil . create403RESTException ( "str" + "str" + ( sess ! = null ? sess . getXXPortalUser ( ) . getId ( ) : "str" ) ) ;
LOG . error ( "str" , e ) ;
LOG . error ( "str" , e ) ;
LOG . error ( "str" , e ) ;
LOG . debug ( "str" + serviceType + "str" ) ;
LOG . error ( "str" , e ) ;
LOG . error ( "str" , e ) ;
LOG . error ( "str" , e ) ;
String stormTopologyName = null ;
stormTopologyName = userInput ;
stormTopologyName = userInput ;
resultList = getStormResources ( url , username , password , lookupPrincipal , lookupKeytab , nameRules , stormTopologyName , StormTopologyList ) ;
String StormTopologyName = null ;
StormTopologyName = userInput ;
StormTopologyName = userInput ;
resultList = getStormResources ( url , username , password , lookupPrincipal , lookupKeytab , nameRules , StormTopologyName , StormTopologyList ) ;
if ( userName ! = null & & userPassword ! = null & & ! userName . trim ( ) . isEmpty ( ) & & ! userPassword . trim ( ) . isEmpty ( ) ) {
final UserDetails principal = new User ( userName , userPassword , grantedAuths ) ;
+ "str" + knoxUrl
+ "str" + knoxUrl
logger . debug ( "str" ) ;
Object entry = keyEntries . get ( convertAlias ( alias ) ) ;
deltaEntries . put ( convertAlias ( alias ) , entry ) ;
keyEntries . put ( convertAlias ( alias ) , entry ) ;
Log . info ( "str" ) ;
Log . info ( "str" ) ;
+ config . toString ( ) + "str" + t . getMessage ( ) ) ;
LOG . debug ( String . format ( "str" , propertyName , RangerAdminRESTClient . class . getName ( ) ) ) ;
throw restErrorUtil . createRESTException ( "str" + serviceName + "str" ,
throw restErrorUtil . createRESTException ( "str" + serviceName + "str" ,
LOG . warn ( "str" + ( cacheFile = = null ? null : cacheFile . getAbsolutePath ( ) ) + "str" ) ;
LOG . warn ( "str" + ( cacheFile = = null ? null : cacheFile . getAbsolutePath ( ) ) + "str" ) ;
private static final int DEFAULT_TAGSYNC_TAGADMIN_CONNECTION_CHECK_INTERVAL = 15000 ;
dataMasks . put ( dataMaskDefId , ret ) ;
policyItem . setDelegateAdmin ( Boolean . FALSE ) ;
ret = serviceDefService . getPopulatedViewObject ( xServiceDef ) ;
LOG . debug ( "str" + aStormUIUrl + "str" + aUserName + "str" + "str" + "str" ) ;
LOG . info ( "str" + userName + "str" ) ;
String hdfsDestinationDirectory = properties . get ( "str" ) ;
String localFileBufferDirectory = properties . get ( "str" ) ;
String localFileBufferArchiveDirectory = properties . get ( "str" ) ;
mNextRolloverTime = MiscUtil . getNextRolloverTime ( mNextRolloverTime , ( mRolloverIntervalSeconds * 1000L ) ) ;
long startTime = MiscUtil . getRolloverStartTime ( mNextRolloverTime , ( mRolloverIntervalSeconds * 1000L ) ) ;
mNextFlushTime = System . currentTimeMillis ( ) + ( mFlushIntervalSeconds * 1000L ) ;
if ( now > ( mLastOpenFailedTime + ( mOpenRetryIntervalSeconds * 1000L ) ) ) {
mNextFlushTime = now + ( mFlushIntervalSeconds * 1000L ) ;
mNextRolloverTime = MiscUtil . getNextRolloverTime ( mNextRolloverTime , ( mRolloverIntervalSeconds * 1000L ) ) ;
long startTime = MiscUtil . getRolloverStartTime ( mNextRolloverTime , ( mRolloverIntervalSeconds * 1000L ) ) ;
mNextFlushTime = System . currentTimeMillis ( ) + ( mFlushIntervalSeconds * 1000L ) ;
mNextFlushTime = now + ( mFlushIntervalSeconds * 1000L ) ;
long pollIntervalInMs = 1000L ;
long destinationPollIntervalInMs = 1000L ;
private void sleep ( long sleepTimeInMs , String onFailMsg ) {
@Produces ( { "str" , "str" } )
@Produces ( { "str" , "str" } )
@Produces ( { "str" , "str" } )
@Produces ( { "str" , "str" } )
@Produces ( { "str" , "str" } )
@Produces ( { "str" , "str" } )
@Produces ( { "str" , "str" } )
@Produces ( { "str" , "str" } )
@Produces ( { "str" , "str" } )
private long mLastCommitTime = System . currentTimeMillis ( ) ;
if ( ! addPermission ( permissionsList , Manifest . permission . WRITE_EXTERNAL_STORAGE ) )
perms . put ( Manifest . permission . WRITE_EXTERNAL_STORAGE , PackageManager . PERMISSION_GRANTED ) ;
& & perms . get ( Manifest . permission . WRITE_EXTERNAL_STORAGE ) = = PackageManager . PERMISSION_GRANTED ) {
return this . advertiseSocketAddress . getHostName ( ) ;
contextPath = contextPath . trim ( ) ;
this . add ( proxy . getRemoteAddress ( ) , proxy . getLocalAddress ( ) ) ;
myBalancers ( "str" , "str" , null , "str" , "str" , null , true ) ;
private void myBalancers ( String balancer , String loadBalancingGroup , String app , String balancer2 , String loadBalancingGroup2 , String app2 , boolean testAlias ) {
private boolean stickySessionForce = false ;
fail ( "str" ) ;
while ( ( ! Maintest . checkProxyInfo ( lifecycle , nodes ) ) & & countinfo < 40 ) {
if ( countinfo = = 40 ) {
Maintest . waitn ( ) ;
System . out . println ( "str" ) ;
cluster = Maintest . createClusterListener ( "str" , 23364 , false ) ;
cluster = Maintest . createClusterListener ( "str" , 23364 , false , null , true , true , false ) ;
cluster = Maintest . createClusterListener ( "str" , 23364 , false ) ;
lifecycle = Maintest . createClusterListener ( "str" , 23364 , false ) ;
LifecycleListener cluster = Maintest . createClusterListener ( "str" , 23364 , false , domain ) ;
cluster = Maintest . createClusterListener ( "str" , 23364 , false , "str" ) ;
LifecycleListener cluster = Maintest . createClusterListener ( "str" , 23364 , false ) ;
cluster = Maintest . createClusterListener ( "str" , 23364 , false ) ;
cluster = Maintest . createClusterListener ( "str" , 23364 , false , "str" ) ;
when ( zoneService . listCitizenZones ( ) ) . thenReturn ( asList ( zoneInfo , another ) ) ;
when ( zoneService . listCitizenZones ( ) ) . thenReturn (
if ( sessionVersion > = 3 & & parameters . getTheirOneTimePreKey ( ) . isPresent ( ) ) {
return ! _executor . isShutdown ( ) ;
this . sourceInclusionPattern = "str" ;
buf . append ( "str" ) ;
assertCoverage ( pkg . getLineCoverage ( ) , 393 , 196 ) ;
assertCoverage ( r . getLineCoverage ( ) , 513 , 361 ) ;
assertCoverage ( pkg . getLineCoverage ( ) , 34 , 41 ) ;
assertCoverage ( pkg . getLineCoverage ( ) , 68 , 1 ) ;
assertCoverage ( pkg . getLineCoverage ( ) , 34 , 41 ) ;
Build < ? , ? > b = start ;
public final Project < ? , ? > project ;
for ( Build < ? , ? > b = project . getLastBuild ( ) ; b ! = null ; b = b . getPreviousBuild ( ) ) {
SELF prev = ( SELF ) p . getChildren ( ) . get ( name ) ;
SELF extends CoverageObject < SELF > > extends CoverageObject < SELF > implements ModelObject {
import javafx . css . converter . EnumConverter ;
lStartDateTime = layoutHelp . roundTimeToNearestMinutes ( lStartDateTime , ( int ) ( ( AgendaSkinTimeScale24HourAbstract < ? > ) layoutHelp . skin ) . getSnapToMinutes ( ) ) ;
lEndDateTime = layoutHelp . roundTimeToNearestMinutes ( lEndDateTime , ( int ) ( ( AgendaSkinTimeScale24HourAbstract < ? > ) layoutHelp . skin ) . getSnapToMinutes ( ) ) ;
endLocalDateTime = layoutHelp . roundTimeToNearestMinutes ( endLocalDateTime , ( int ) ( ( AgendaSkinTimeScale24HourAbstract < ? > ) layoutHelp . skin ) . getSnapToMinutes ( ) ) ;
getStyleClass ( ) . add ( appointment . getAppointmentGroup ( ) ! = null ? appointment . getAppointmentGroup ( ) . getStyleClass ( ) : "str" ) ;
setDateFormat ( getShowTime ( ) ? SimpleDateFormat . getDateTimeInstance ( DateFormat . MEDIUM , DateFormat . LONG , value ) : SimpleDateFormat . getDateInstance ( DateFormat . LONG , value ) ) ;
return getValueAsLong ( 0 L ) ;
return new EnumMapSerializer ( _valueType , _staticTyping , _keyEnums , vts , _property , _valueSerializer ) ) ;
return _fromBooleanCreator . call1 ( Boolean . valueOf ( value ) ) ;
assertEquals ( "str" , ( ( Child2 ) deserializedContent . get ( 1 ) ) . parentContent ) ;
throw ctxt . instantiationException ( getBeanClass ( ) , "str" ) ;
throw ctxt . instantiationException ( getBeanClass ( ) , "str" ) ;
_reportMismatchedEndMarker ( i , "str" ) ;
_reportMismatchedEndMarker ( i , "str" ) ;
_reportMismatchedEndMarker ( i , "str" ) ;
_reportMismatchedEndMarker ( i , "str" ) ;
assertEquals ( JsonToken . END_OBJECT , jp . getCurrentToken ( ) ) ;
protected final String _name ;
protected final Method _accessorMethod ;
protected final boolean _cfgWriteIfNull ;
protected final JsonSerializer < Object > _serializer ;
if ( _anySetter ! = null & & ! _anySetter . hasValueDeserializer ( ) ) {
this . rule . getFileSystem ( ) . provider ( ) . getPath ( uri ) ;
assertEquals ( 1 , createdFile . toRealPath ( ) . getFileName ( ) . toString ( ) . length ( ) ) ;
assertThat ( aPath , equalTo ( nPath ) ) ;
assertThat ( aPath , equalTo ( nPath ) ) ;
this . collator = MemoryFileSystemProperties . caseSensitiveCollator ( this . getLocale ( ) , false ) ;
. setCollator ( MemoryFileSystemProperties . caseSensitiveCollator ( builder . getLocale ( ) , true ) )
. setCollator ( MemoryFileSystemProperties . caseSensitiveCollator ( builder . getLocale ( ) , false ) )
static Collator caseSensitiveCollator ( Locale locale , boolean decomposition ) {
return MemoryFileSystemProperties . caseSensitiveCollator ( Locale . getDefault ( ) , false ) ;
assertEquals ( "str" , e . getMessage ( ) ) ;
mConfiguration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
mConfiguration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
Configuration configuration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
Configuration configuration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
mConfigurationWithUnionPay = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
. configuration ( Configuration . fromJson ( stringFromFixture ( "str" ) ) )
. configuration ( Configuration . fromJson ( stringFromFixture ( "str" ) ) )
stringFromFixture ( "str" ) ) ;
Configuration configuration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
stringFromFixture ( "str" ) ) ;
stringFromFixture ( "str" ) ) ;
stringFromFixture ( "str" ) ) ;
stringFromFixture ( "str" ) ) ;
stringFromFixture ( "str" ) ) ;
stringFromFixture ( "str" ) ) ;
JSONObject json = new JSONObject ( stringFromFixture ( "str" ) )
Configuration configuration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
Configuration configuration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
Configuration configuration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
Configuration configuration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
Configuration configuration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
Configuration configuration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
Configuration configuration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
Configuration configuration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
Configuration configuration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
Configuration configuration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
Configuration configuration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
Configuration configuration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
stubConfigurationFromGateway ( stringFromFixture ( "str" ) ) ;
Configuration configuration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
Configuration configuration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
Configuration configuration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
stringFromFixture ( "str" ) ) ;
JSONObject configuration = new JSONObject ( stringFromFixture ( "str" ) ) ;
stringFromFixture ( "str" ) ) ;
Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
stringFromFixture ( "str" ) ) ;
Configuration configuration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
final Configuration configuration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
final Configuration configuration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
final Configuration configuration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
Configuration configuration = Configuration . fromJson ( stringFromFixture ( "str" ) ) ;
JSONObject json = new JSONObject ( stringFromFixture ( "str" ) )
@Test ( timeout = 10000 )
DropInRequest dropInRequest = new DropInRequest ( )
dropInRequest . paypalAdditionalScopes ( Collections . singletonList ( PayPal . SCOPE_ADDRESS ) ) ;
showDialog ( ( ( Exception ) data . getSerializableExtra ( DropInActivity . EXTRA_ERROR ) ) . getMessage ( ) ) ;
. successResponse ( stringFromFixture ( "str" ) )
. successResponse ( stringFromFixture ( "str" ) )
public static final String UNIONPAY_NOT_ACCEPTED = "str" ;
return getPreferences ( context ) . getBoolean ( "str" , false ) ;
throw new RateLimitException ( "str" ) ;
HttpClient httpClient = clientWithExpectedResponse ( 429 , "str" ) ;
assertExceptionIsPosted ( httpClient , RateLimitException . class , "str" ) ;
assertEquals ( "str" ,
assertEquals ( "str" ,
. findViewById ( com . braintreepayments . api . dropin . R . id . bt_payment_method_view_switcher ) ;
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_paypal_button ) . getVisibility ( ) ) ;
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_venmo_button ) . getVisibility ( ) ) ;
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_android_pay_button ) . getVisibility ( ) ) ;
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_payment_button_divider )
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_payment_button_divider_2 )
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_venmo_button ) . getVisibility ( ) ) ;
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_paypal_button ) . getVisibility ( ) ) ;
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_android_pay_button ) . getVisibility ( ) ) ;
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_payment_button_divider )
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_payment_button_divider_2 )
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_android_pay_button ) . getVisibility ( ) ) ;
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_paypal_button ) . getVisibility ( ) ) ;
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_venmo_button ) . getVisibility ( ) ) ;
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_payment_button_divider )
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_payment_button_divider_2 )
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_android_pay_button ) . getVisibility ( ) ) ;
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_paypal_button ) . getVisibility ( ) ) ;
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_venmo_button ) . getVisibility ( ) ) ;
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_payment_button_divider )
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_payment_button_divider_2 )
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_android_pay_button ) . getVisibility ( ) ) ;
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_paypal_button ) . getVisibility ( ) ) ;
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_venmo_button ) . getVisibility ( ) ) ;
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_payment_button_divider )
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_payment_button_divider_2 )
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_android_pay_button ) . getVisibility ( ) ) ;
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_paypal_button ) . getVisibility ( ) ) ;
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_venmo_button ) . getVisibility ( ) ) ;
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_payment_button_divider )
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_payment_button_divider_2 )
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_android_pay_button ) . getVisibility ( ) ) ;
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_venmo_button ) . getVisibility ( ) ) ;
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_paypal_button ) . getVisibility ( ) ) ;
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_payment_button_divider )
mPaymentButton . getView ( ) . findViewById ( com . braintreepayments . api . dropin . R . id . bt_payment_button_divider_2 )
clickButton ( com . braintreepayments . api . dropin . R . id . bt_paypal_button ) ;
clickButton ( com . braintreepayments . api . dropin . R . id . bt_paypal_button ) ;
clickButton ( com . braintreepayments . api . dropin . R . id . bt_venmo_button ) ;
clickButton ( com . braintreepayments . api . dropin . R . id . bt_android_pay_button ) ;
assertEquals ( "str" ,
assertEquals ( "str" ,
when ( fragment . getApplicationContext ( ) ) . thenReturn ( context ) ;
when ( fragment . getApplicationContext ( ) ) . thenReturn ( context ) ;
BraintreeBroadcastManager . getInstance ( fragment . getApplicationContext ( ) )
BraintreeBroadcastManager . getInstance ( fragment . getApplicationContext ( ) )
PayPal . buildPayPalCheckoutConfiguration ( null , fragment . getApplicationContext ( ) , configuration ) ;
getBuilderFromResponse ( fragment . getApplicationContext ( ) , resultCode , data ) ;
deviceData . put ( CORRELATION_ID_KEY , PayPalOneTouchCore . getClientMetadataId ( fragment . getApplicationContext ( ) ) ) ;
when ( fragment . getApplicationContext ( ) ) . thenReturn ( getTargetContext ( ) ) ;
JSONObject fullMetaData = generateRequestBody ( fragment . getApplicationContext ( ) ,
Intent intent = new Intent ( fragment . getApplicationContext ( ) ,
protected Context getApplicationContext ( ) {
assertEquals ( mActivity . getApplicationContext ( ) , fragment . getApplicationContext ( ) ) ;
when ( fragment . getApplicationContext ( ) ) . thenReturn ( getTargetContext ( ) ) ;
when ( fragment . getApplicationContext ( ) ) . thenReturn ( getTargetContext ( ) ) ;
if ( isAvailable ( fragment . getApplicationContext ( ) , configuration ) ) {
Object [ ] paddingSpans = editable . getSpans ( 0 , editable . length ( ) , AppendSlashSpan . class ) ;
mPaymentButton = ( PaymentButton ) findViewById ( R . id . payment_button ) ;
public static final int REQUEST_CODE = 11876 ;
static final double version = 3.065 ;
this . autoImportProxyHistory = getBooleanSetting ( "str" , false ) ;
if ( view = = null ) view = LoggerPreferences . View . HORIZONTAL ;
Matcher compoundMatcher = compoundPattern . matcher ( regexStripped ) ;
Matcher operationMatcher = operation . matcher ( regexStripped ) ;
return ! this . getTableHeaderColumnsDetails ( ) . getAllColumnsDefinitionList ( ) . get ( columnIndex ) . isReadonly ( ) ;
return ( String ) this . getTableHeaderColumnsDetails ( ) . getAllColumnsDefinitionList ( ) . get ( columnIndex ) . getVisibleName ( ) ;
private final double version = 2.1 ;
private final JLabel lblNewLabel_1 = new JLabel ( "str" ) ;
if ( ! ( isAsciiAlpha ( chars [ i ] ) | | isDigital ( chars [ i ] ) ) ) {
public static final long MAX_SLEEP_TIME_IN_MILLS = 24 * 60 * 60 * 60 * 1000L ;
public static String ACTION_OUT_OF_MEMORY_ERROR_NAME = "str" ;
if ( actionSpec = = null ) {
if ( ( this . rawJsonObject = = null ) & & ( this . getLastResponse ( ) ! = null ) ) {
private static final String MOCK_MINIMUM_VERSION = "str" ;
boolean signatureFound = false ;
return String . format ( "str" , classURL ( ApplicationFee . class ) , this . getFee ( ) ,
return String . format ( "str" , classURL ( Transfer . class ) , this . getTransfer ( ) ,
public void setNet ( Long net ) {
if ( method . getDeclaringClass ( ) ! = model ) {
Method mostSpecificMethod = model . getDeclaredMethod ( method . getName ( ) ,
APIResource . class . getSimpleName ( ) , model . getSimpleName ( ) , method . getName ( ) ,
return staticRequest ( method , url , params , clazz , type , options ) ;
public < T > T oauthRequest (
return staticOAuthRequest ( method , url , params , clazz , type , options ) ;
String responseBody = new Scanner ( responseStream , APIResource . CHARSET )
responseBody = getResponseBody ( conn . getErrorStream ( ) ) ;
return new StripeResponse ( responseCode , responseBody , headers ) ;
private static StripeResponse rawRequest (
private static < T > T staticRequest (
StripeResponse response = rawRequest ( method , url , params , type , options ) ;
T resource = APIResource . GSON . fromJson ( responseBody , clazz ) ;
private static < T > T staticOAuthRequest (
StripeResponse response = rawRequest ( method , url , params , type , options ) ;
T resource = APIResource . GSON . fromJson ( responseBody , clazz ) ;
responseBody = getResponseBody ( conn . getErrorStream ( ) ) ;
return new StripeResponse ( responseCode , responseBody , headers ) ;
private static void handleAPIError ( String responseBody , int responseCode , String requestId )
LiveStripeResponseGetter . Error error = APIResource . GSON . fromJson ( responseBody ,
switch ( responseCode ) {
throw new AuthenticationException ( error . message , requestId , error . code , responseCode ) ;
error . declineCode , error . charge , responseCode , null ) ;
throw new PermissionException ( error . message , requestId , error . code , responseCode ) ;
throw new APIException ( error . message , requestId , error . code , responseCode , null ) ;
private static void handleOAuthError ( String responseBody , int responseCode , String requestId )
LiveStripeResponseGetter . OAuthError error = APIResource . GSON . fromJson ( responseBody ,
String description = ( error . errorDescription ! = null ) ? error . errorDescription : code ;
throw new InvalidClientException ( code , description , requestId , responseCode , null ) ;
throw new InvalidGrantException ( code , description , requestId , responseCode , null ) ;
responseCode , null ) ;
throw new InvalidScopeException ( code , description , requestId , responseCode , null ) ;
throw new UnsupportedGrantTypeException ( code , description , requestId , responseCode , null ) ;
when ( networkMock . oauthRequest (
< T > T oauthRequest (
return OAuth . stripeResponseGetter . oauthRequest ( APIResource . RequestMethod . POST , url , params ,
return OAuth . stripeResponseGetter . oauthRequest ( APIResource . RequestMethod . POST , url , params ,
if ( id ! = null & & ! id . isEmpty ( ) ) {
if ( id ! = null & & ! id . isEmpty ( ) ) {
public Long getAmount ( ) {
public void setAmount ( Long amount ) {
public Long getAmount ( ) {
public void setAmount ( Long amount ) {
public Long getAmountRefunded ( ) {
public void setAmountRefunded ( Long amountRefunded ) {
public Long getAmount ( ) {
public void setAmount ( Long amount ) {
final Long REFUND_AMOUNT = 50l ;
public Long getAmount ( ) {
public void setAmount ( Long amount ) {
public Long getAmount ( ) {
public void setAmount ( Long amount ) {
public Long getAmount ( ) {
public void setAmount ( Long amount ) {
final Long REFUND_AMOUNT = 50l ;
public Long getAmount ( ) {
public void setAmount ( Long amount ) {
public Long getAmount ( ) {
public void setAmount ( Long amount ) {
public Long getAmount ( ) {
public void setAmount ( Long amount ) {
public Long getAmount ( ) {
public void setAmount ( Long amount ) {
public Long getAmountReceived ( ) {
public void setAmountReceived ( Long amountReceived ) {
public Long getBitcoinAmount ( ) {
public void setBitcoinAmount ( Long bitcoinAmount ) {
public Long getBitcoinAmountReceived ( ) {
public void setBitcoinAmountReceived ( Long bitcoinAmountReceived ) {
public Long getAmount ( ) {
public void setAmount ( Long amount ) {
public Long getAmountReceived ( ) {
public void setAmountReceived ( Long amountReceived ) {
public Long getAmountReturned ( ) {
public void setAmountReturned ( Long amountReturned ) {
public Long getAmountCharged ( ) {
public void setAmountCharged ( Long amountCharged ) {
public Long getAmountOff ( ) {
public void setAmountOff ( Long amountOff ) {
public Long getPaymentAmount ( ) {
public void setPaymentAmount ( Long paymentAmount ) {
public Long getAmount ( ) {
public void setAmount ( Long amount ) {
public Long getAccountBalance ( ) {
public void setAccountBalance ( Long accountBalance ) {
public Long getAmount ( ) {
public Long getAmount ( ) {
public void setAmount ( Long amount ) {
public Long getAmountReversed ( ) {
public void setAmountReversed ( Long amountReversed ) {
public Long getAmount ( ) {
public void setAmount ( Long amount ) {
public Long getAmount ( ) {
public void setAmount ( Long amount ) {
assertEquals ( 0 , Long . parseLong ( created . getTypeData ( ) . get ( "str" ) ) ) ;
public Long getAmount ( ) {
public void setAmount ( Long amount ) {
public Long getAmountRefunded ( ) {
public void setAmountRefunded ( Long amountRefunded ) {
public Long getAmount ( ) {
public void setAmount ( Long amount ) {
public Long getBitcoinAmount ( ) {
public void setBitcoinAmount ( Long bitcoinAmount ) {
public Long getAdjustmentGross ( ) {
public void setAdjustmentGross ( Long adjustmentGross ) {
public Long getChargeFees ( ) {
public void setChargeFees ( Long chargeFees ) {
public Long getChargeGross ( ) {
public void setChargeGross ( Long chargeGross ) {
public Long getNet ( ) {
public void set ( Long net ) {
public Long getRefundFees ( ) {
public void setRefundFees ( Long refundFees ) {
public Long getRefundGross ( ) {
public void setRefundGross ( Long refundGross ) {
public Long getValidationFees ( ) {
public void setValidationFees ( Long validationFees ) {
public Long getAmount ( ) {
public void setAmount ( Long amount ) {
public Long getFee ( ) {
public void setFee ( Long fee ) {
public Long getAmount ( ) {
public void setAmount ( Long amount ) {
public Long getAmountDue ( ) {
public void setAmountDue ( Long amountDue ) {
public Long getEndingBalance ( ) {
public void setEndingBalance ( Long endingBalance ) {
public Long getStartingBalance ( ) {
public void setStartingBalance ( Long startingBalance ) {
public Long getSubtotal ( ) {
public void setSubtotal ( Long subtotal ) {
public Long getTax ( ) {
public void setTax ( Long tax ) {
public Long getTotal ( ) {
public void setTotal ( Long total ) {
public Long getAmount ( ) {
public void setAmount ( Long amount ) {
public Long getAmount ( ) {
public void setAmount ( Long amount ) {
String json = resource ( "str" ) ;
String json = resource ( "str" ) ;
String json = resource ( "str" ) ;
String json = resource ( "str" ) ;
String json = resource ( "str" ) ;
Stripe . getApiBase ( ) , e . getMessage ( ) ) , e ) ;
public Long getRedeemBy ( ) {
public void setRedeemBy ( Long redeemBy ) {
private Integer rate = 10 ;
import java . util . LinkedHashMap ;
Map < String , Collection < String > > headers = new LinkedHashMap < > ( request . headers ( ) ) ;
public Mono < Long > continueSpanInTraceContext ( ) {
public Mono < Long > newSpanInTraceContext ( ) {
public Mono < Long > newSpanInSubscriberContext ( ) {
@ConditionalOnProperty ( value = "str" , havingValue = "str" )
private static final boolean ribbonPresent ;
@Target ( value = { ElementType . METHOD } )
@Target ( value = { ElementType . METHOD } )
log . trace ( String . format (
@ConditionalOnBean ( Tracer . class )
this ( - 1 , - 1 , "str" , 0 , Collections . < Long > emptyList ( ) , 0 , false , false , null ) ;
@Value ( "str" ) protected int timeout ;
binaryAnn . setAnnotation_type ( AnnotationType . STRING ) ;
String stem = "str" + binder + "str" ;
map . put ( stem + "str" + i + "str" , headers [ i ] ) ;
String . format ( Lang . ALERT_TREEREDUCEBONEMEAL . get ( ) ,
String . format ( Lang . ALERT_TREEREDUCE . get ( ) ,
SeaLevelRise seaLevelRise = new SeaLevelRise ( world . getChunkAt ( player . getLocation ( ) ) . getChunkSnapshot ( ) ) ;
import net . porillo . objects . GPlayer ;
GPlayer player = new GPlayer ( event . getPlayer ( ) . getUniqueId ( ) , System . currentTimeMillis ( ) , 0 ) ;
updateStrings ( "str" ) ;
updateStrings ( "str" ) ;
new GitSource ( mLastSelectedRepo . settings . getSource ( ) , "str" ) , false ) . start ( ) ;
new GitSource ( repo . settings . getSource ( ) , "str" ) , true ) . start ( ) ;
return String . format ( GITHUB_REPO_URL_TEMPLATE , owner , repository ) ;
stream = new FileOutputStream ( imageFile ) ;
return readCloseTextStream ( stream , true ) . get ( 0 ) ;
final String scheme = UriParser . extractScheme ( getSchemes ( ) , uri ) ;
public void ignore_testAddRemove ( ) throws Exception {
public void ignore_testStartStop ( ) throws Exception {
Assert . assertTrue ( "str" , file . setExecutable ( true , true ) ) ;
Assert . assertTrue ( "str" , file . setExecutable ( true , false ) ) ;
Assert . assertTrue ( "str" , file . setExecutable ( false , true ) ) ;
Assert . assertTrue ( "str" , file . setWritable ( true , true ) ) ;
Assert . assertTrue ( "str" , file . setWritable ( true , false ) ) ;
Assert . assertTrue ( "str" , file . setWritable ( false , true ) ) ;
Assert . assertTrue ( "str" , file . setReadable ( true , true ) ) ;
Assert . assertTrue ( "str" , file . setReadable ( true , false ) ) ;
Assert . assertTrue ( "str" , file . setReadable ( false , true ) ) ;
public class DefaultFileSystemManager implements FileSystemManager , AutoCloseable {
private SftpFileSystem fileSystem ;
this . fileSystem = ( SftpFileSystem ) fileObject . getFileSystem ( ) ;
Assert . fail ( String . format ( "str" , message , Long . valueOf ( expected ) , Long . valueOf ( actual ) , Long . valueOf ( delta ) ) ) ;
if ( ( ( iterFileNames + 1 ) % getChecksPerRun ( ) ) = = 0 )
return getBoolean ( opts , name , Boolean . valueOf ( defaultValue ) ) . booleanValue ( ) ;
throw new FileSystemException ( "str" , getName ( ) , e ) ;
throw new FileSystemException ( "str" , e , getName ( ) , attrName ) ;
throw new FileSystemException ( "str" , new Object [ ] { hostname } , exc ) ;
assertTrue ( "str" + schemes [ i ] + "str" , fsm . hasProvider ( schemes [ i ] ) ) ;
if ( ! attributes . containsKey ( property . getName ( ) . getName ( ) ) )
System . err . println ( "str" + client . getSystemType ( ) ) ;
if ( files . size ( ) < 1 )
final Class < ? > className )
final Class < ? > [ ] classNames )
void collectOperations ( final Collection < ? > operationsList , final FileObject file )
FileOperation getOperation ( final FileObject file , final Class < ? > operationClass )
public Class < ? > [ ] getOperations ( ) throws FileSystemException
public FileOperation getOperation ( Class < ? > operationClass )
public boolean hasOperation ( Class < ? > operationClass ) throws FileSystemException
Class < ? > [ ] operations = getOperations ( ) ;
Class < ? > operation = operations [ i ] ;
Class < ? > [ ] getOperations ( ) throws FileSystemException ;
FileOperation getOperation ( Class < ? > operationClass ) throws FileSystemException ;
boolean hasOperation ( Class < ? > operationClass ) throws FileSystemException ;
public final void collectOperations ( final Collection < ? > operationsList ,
final Collection < ? > availableOperations , final Collection < ? > resultList ,
public final FileOperation getOperation ( FileObject file , Class < ? > operationClass )
final Class < ? > operationClass ) throws FileSystemException ;
protected final Class < ? > lookupOperation ( final Class < ? > operationClass )
protected final void addOperation ( final Class < ? > operationClass )
private volatile boolean requestEnd ;
private volatile boolean shouldRun = true ;
return System . getProperty ( "str" , "str" ) ;
throw new FileSystemException ( "str" , new Object [ ] { hostname , UserAuthenticatorUtils . toString ( username ) } , null ) ;
final AbstractFileObject file = FileObjectUtils . getAbstractFileObject ( ( FileObject ) files . get ( i ) ) ;
( FileObjectUtils . getAbstractFileObject ( destFile ) ) . handleCreate ( getType ( ) ) ;
protected void doRename ( final FileObject newfile ) throws Exception
UserAuthenticatorUtils . getData ( authData , UserAuthenticationData . PASSWORD , UserAuthenticatorUtils . toChar ( rootName . getPassword ( ) ) ) ,
UserAuthenticatorUtils . toString ( UserAuthenticatorUtils . getData ( authData , UserAuthenticationData . PASSWORD , UserAuthenticatorUtils . toChar ( rootName . getPassword ( ) ) ) ) ,
UserAuthenticationData . PASSWORD ,
public static char [ ] getData ( UserAuthenticationData data , UserAuthenticationData . Type type , char [ ] overwriddenValue )
throw new FileSystemException ( "str" , fileObject = = null ? "str" : fileObject . getClass ( ) . getName ( ) ) ;
synchronized ( fs )
synchronized ( fs )
synchronized ( fs )
synchronized ( fs )
synchronized ( fs )
synchronized ( fs )
synchronized ( fs )
synchronized ( fs )
synchronized ( fs )
final FileListener fileListener = fileListeners [ i ] ;
event . notify ( fileListener ) ;
parent = fs . getFileFromCache ( parentName ) ;
if ( children . add ( baseName . getBaseName ( ) ) )
return new URL ( UriParser . extractScheme ( name . getURI ( ) , buf ) , "str" , - 1 ,
setURL ( u , protocolPart , "str" , - 1 , null , null , filePart . toString ( ) , null , null ) ;
final class FileContentOutputStream extends MonitorOutputStream
private final class FileContentOutputStream extends MonitorOutputStream
if ( absPath . length ( ) > 1 & & absPath . endsWith ( "str" ) )
public final char SEPARATOR_CHAR = "str" ;
public final String SEPARATOR = "str" ;
public final String ROOT_PATH = "str" ;
public String getBaseName ( ) ;
public String getPath ( ) ;
public String getPathDecoded ( ) throws FileSystemException ;
public String getExtension ( ) ;
public int getDepth ( ) ;
public String getScheme ( ) ;
public String getURI ( ) ;
public String getRootURI ( ) ;
public FileName getParent ( ) ;
public String getRelativeName ( FileName name ) throws FileSystemException ;
public FileName getName ( ) ;
public URL getURL ( ) throws FileSystemException ;
public boolean exists ( ) throws FileSystemException ;
public boolean isHidden ( ) throws FileSystemException ;
public boolean isReadable ( ) throws FileSystemException ;
public boolean isWriteable ( ) throws FileSystemException ;
public FileType getType ( ) throws FileSystemException ;
public FileObject getParent ( ) throws FileSystemException ;
public FileSystem getFileSystem ( ) ;
public FileObject [ ] getChildren ( ) throws FileSystemException ;
public FileObject getChild ( String name ) throws FileSystemException ;
public FileObject resolveFile ( String name , NameScope scope )
public FileObject resolveFile ( String path ) throws FileSystemException ;
public FileObject [ ] findFiles ( FileSelector selector ) throws FileSystemException ;
public void findFiles ( FileSelector selector ,
public boolean delete ( ) throws FileSystemException ;
public int delete ( FileSelector selector ) throws FileSystemException ;
public void createFolder ( ) throws FileSystemException ;
public void createFile ( ) throws FileSystemException ;
public void copyFrom ( FileObject srcFile , FileSelector selector )
public void moveTo ( FileObject destFile )
public FileContent getContent ( ) throws FileSystemException ;
public void close ( ) throws FileSystemException ;
throw new FileSystemException ( "str" , "str" ) ;
FileName [ ] names = new FileName [ objects . length ] ;
FileObject [ ] objects = new FileObject [ children . length ] ;
throw new FileSystemException ( "str" , getName ( ) ) ;
throw new FileSystemException ( "str" , destFile . getName ( ) ) ;
public static void reset ( ) {
RandomRegistry . reset ( ) ;
public KnapsackFunction ( final Item [ ] items , double size ) {
private static KnapsackFunction FF ( int n , double size ) {
return new KnapsackFunction ( items , size ) ;
KnapsackFunction ff = FF ( 15 , 100 ) ;
shuffle ( array , RandomRegistry . getRandom ( ) ) ;
shuffle ( array , RandomRegistry . getRandom ( ) ) ;
shuffle ( list , RandomRegistry . getRandom ( ) ) ;
return subset ( n , k , RandomRegistry . getRandom ( ) ) ;
subset ( n , sub , RandomRegistry . getRandom ( ) ) ;
permutation ( p , RandomRegistry . getRandom ( ) ) ;
assert ( false ) : "str" ;
set = new CharSet ( "str" ) ;
public double getQuantile ( ) {
xml . getAttribute ( TYPE , "str" )
final String value = xml . getAttribute ( VALUE , "str" ) ;
_min = genes [ 0 ] . _min ;
_min = genes [ 0 ] . _min ;
balance = balance . add ( transaction . getBalance ( getUID ( ) ) ) ;
int color = accountBalance . isNegative ( ) ? R . color . debit_red : R . color . credit_green ;
mSelectedColor = String . format ( "str" , 0xFFFFFF & color ) ;
TextView balanceTextView = ( TextView ) view . findViewById ( R . id . account_balance ) ;
int rowMax = ( rowNumber + 1 ) * mNumColumns ;
return getQuarter ( end ) - getQuarter ( start ) + y * 4 ;
return ( date . getMonthOfYear ( ) - 1 ) / 3 + 1 ;
String targetCurrency = mAccountsDbAdapter . getCurrencyCode ( mAccountsDbAdapter . getUID ( id ) ) ;
mMoveTransactionsRadioButton = ( RadioButton ) transactionOptionsView . findViewById ( R . id . radio_move ) ;
synchronized ( getReplaceStatement ( ) ) {
synchronized ( getUpdateStatement ( ) ) {
synchronized ( getInsertStatement ( ) ) {
synchronized ( getReplaceStatement ( ) ) {
nRow = doAddModels ( modelList , updateMethod ) ;
splitUidTextView . setText ( UUID . randomUUID ( ) . toString ( ) . replaceAll ( "str" , "str" ) ) ;
onView ( withId ( R . id . fab_create_transaction ) ) . perform ( click ( ) ) ;
onView ( withId ( R . id . fab_create_transaction ) ) . perform ( click ( ) ) ;
onView ( withId ( R . id . fab_create_transaction ) ) . perform ( click ( ) ) ;
onView ( withId ( R . id . fab_create_transaction ) ) . perform ( click ( ) ) ;
onView ( withId ( R . id . fab_create_transaction ) ) . perform ( click ( ) ) ;
onView ( withId ( R . id . fab_create_transaction ) ) . perform ( click ( ) ) ;
ActionBar actionBar = ( ( AppCompatPreferenceActivity ) getActivity ( ) ) . getSupportActionBar ( ) ;
ActionBar actionBar = ( ( AppCompatPreferenceActivity ) getActivity ( ) ) . getSupportActionBar ( ) ;
ActionBar actionBar = ( ( AppCompatPreferenceActivity ) getActivity ( ) ) . getSupportActionBar ( ) ;
ActionBar actionBar = ( ( AppCompatPreferenceActivity ) getActivity ( ) ) . getSupportActionBar ( ) ;
ActionBar actionBar = ( ( AppCompatPreferenceActivity ) getActivity ( ) ) . getSupportActionBar ( ) ;
ActionBar actionBar = ( ( AppCompatPreferenceActivity ) getActivity ( ) ) . getSupportActionBar ( ) ;
shareIntent . setType ( "str" ) ;
if ( ! key . equals ( resolvedBinding . provideKey ) & & ! key . equals ( resolvedBinding . membersKey ) ) {
JavaFileObjects . forSourceString ( "str" , Joiner . on ( "str" ) . join (
int destination = 1 ;
static boolean IS_PRE_ORDER_SUPPORTED ( ) {
if ( ! IS_PRE_ORDER_SUPPORTED ( ) & & settings . usePreOrder ) {
GradientWrtParameterProvider . TOLERANCE ) ;
GradientWrtParameterProvider . TOLERANCE ) ;
CheckGradientNumerically ( GradientWrtParameterProvider provider ,
if ( doubleCounted | | intervalCount = = 1 ) {
final double currentIncrease = tree . getNodeHeight ( tree . getNode ( nodeNumbers [ 1 ] ) ) - tree . getNodeHeight ( tree . getNode ( nodeNumbers [ 0 ] ) ) ;
private List < Epoch > epochs = new ArrayList < Epoch > ( ) ;
return codonFrequencies . getParameterName ( ) + "str" + dataType . getTriplet ( dim ) ;
stepSize * = runtimeOptions . checkStepSizeReductionFactor ;
final double differential = branchRateModel . getBranchRateDifferential ( tree , node ) ;
return new HamiltonianMonteCarloOperator ( coercionMode , weight , derivative , parameter , transform , null ,
differentialMassMatrix [ i ] [ j ] * = ( 1.0 - Math . exp ( ( eigenValues [ j ] - eigenValues [ i ] ) * time ) ) / ( eigenValues [ i ] - eigenValues [ j ] ) ;
double [ ] updatedGradient = transform . updateGradient ( gradient ,
double updateGradient ( double gradient , double value ) ;
double [ ] updateGradient ( double [ ] gradient , double [ ] value , int from , int to ) ;
return updateGradient ( gradient , transform ( value ) ) + getGradientLogJacobianInverse ( transform ( value ) ) ;
public double updateGradient ( double gradient , double value ) {
return gradient * gradient ( value ) ;
public double [ ] updateGradient ( double [ ] gradient , double [ ] value , int from , int to ) {
result [ i ] = updateGradient ( gradient [ i ] , value [ i ] ) ;
public double updateGradient ( double gradient , double value ) {
double [ ] updatedGradient = updateGradient ( gradient , transformedValues , from , to ) ;
public double [ ] updateGradient ( double [ ] gradient , double [ ] value , int from , int to ) {
public double [ ] updateGradient ( double [ ] gradient , double [ ] value , int from , int to ) {
public double updateGradient ( double gradient , double value ) {
public double [ ] updateGradient ( double [ ] gradient , double [ ] value , int from , int to ) {
public double [ ] updateGradient ( double [ ] gradient , double [ ] values , int from , int to ) {
result [ i ] = array . get ( i ) . updateGradient ( gradient [ i ] , values [ i ] ) ;
public double [ ] updateGradient ( double [ ] gradient , double [ ] values , int from , int to ) {
result [ i ] = segment . transform . updateGradient ( gradient [ i ] , values [ i ] ) ;
if ( Math . abs ( x ) < SQRT_EPSILON * 1.2 ) {
if ( variable = = location . getFixedEffectsParameter ( ) | | variable = = scale ) {
BranchSpecificFixedEffects locationParameter = null ;
locationParameter = ( BranchSpecificFixedEffects ) locationObject ;
locationParameter = new BranchSpecificFixedEffects . None ( ( Parameter ) locationObject ) ;
Default ( "str" ) {
return super . computeInverseMass ( covariance , gradientProvider , PDTransformMatrix . Default ) ;
this . drawDistribution = new ArrayList < NormalDistribution > ( ) ;
x0 = transform . transform ( x0 , 0 , x0 . length ) ;
private final static boolean DEBUG = false ;
return matrixBufferHelper . getBufferCount ( ) + getEigenIndex ( 0 ) ;
return matrixBufferHelper . getBufferCount ( ) + getEigenBufferCount ( ) + getEigenIndex ( 0 ) ;
if ( raw > 0.0 ) {
summedArray [ v ] + = patternArray [ v * patternCount + pattern ] * patternWeights [ pattern ] ;
+ "str" + oldScore + "str" + logr [ 0 ] + "str" ) ;
public static final String MVN_OPERATOR = "str" ;
private static final boolean RESCALING_OFF = false ;
double functionalStepSize = stepSize ;
momentum [ i ] = momentum [ i ] - functionalStepSize / 2 * derivative [ i ] ;
public static String POWER_LAW_GROWTH_MODEL = "str" ;
public synchronized EigenDecomposition getEigenDecomposition ( ) {
public synchronized EigenDecomposition getEigenDecomposition ( ) {
addModel ( internalSubstModel ) ;
private double pathParameter = 1.0 ;
LogColumn [ ] columns = new LogColumn [ outbreak . infectedSize ( ) ] ;
boolean scaleData = xo . getAttribute ( SCALE_DATA , true ) ;
"str" ) } ) ;
virusDrift = ( Parameter ) xo . getElementFirstChild ( VIRUS_DRIFT ) ;
serumDrift = ( Parameter ) xo . getElementFirstChild ( SERUM_DRIFT ) ;
"str" , OperatorType . SKY_GRID_GIBBS_OPERATOR , 1.0 , 2 ) ;
PriorScaleType . NONE , 0.1 , 0.001 , 1000 , true ) ;
createScaleOperator ( "str" , "str" , 0.75 , 1.0 ) ;
new Attribute . Default < String > ( "str" , options . fileNameStem + "str" + partition . getName ( ) + STATE_LOG_SUFFIX ) } ) ;
new Attribute . Default < String > ( "str" , options . fileNameStem + "str" + partition . getName ( ) + DNDS_LOG_SUFFIX ) } ) ;
writer . write ( "str" + options . fileNameStem + "str" + partition . getName ( ) + DNDS_LOG_SUFFIX + "str" ) ;
errorLogger . addHandler ( messageHandler ) ;
operator = new Operator . Builder ( "str" + taxon . getId ( ) + "str" , description , parameter , OperatorType . RANDOM_WALK_REFLECTING , 1.0 , 1.0 ) . build ( ) ;
private final JCheckBox renumberOutput = new JCheckBox ( "str" ) ;
public static XMLObjectParser PRODUCT_OF_EXPONENTIALS_POSTERIOR_MEANS_LOESS_PARSER = new AbstractXMLObjectParser ( ) {
final double normalisation = 1 - Math . exp ( - Binomial . choose2 ( lineageCount ) * fullIntegral ) ;
answer = LoadMat . product ( colPrec ) . product ( LoadMat . transpose ( ) ) . add ( idMat ) ;
answer = getPrecision ( ) . inverse ( ) . product ( new Matrix ( LFM . getLoadings ( ) . getParameterAsMatrix ( ) ) ) . product ( new Matrix ( LFM . getColumnPrecision ( ) . getParameterAsMatrix ( ) ) ) . product ( LFM . getScaledData ( ) ) ;
throw new IllegalDimension ( "str"
factors = new Matrix ( LFM . getFactors ( ) . getParameterAsMatrix ( ) ) ;
answer = Matrix . buildIdentityTimesElementMatrix ( size , 1 / ( prior . getSD ( ) * prior . getSD ( ) ) ) . add ( factors . productWithTransposed ( factors ) . product ( LFM . getColumnPrecision ( ) . getParameterValue ( i , i ) ) ) ;
+ "str" ) ;
addVariable ( latentStateProportionParameter ) ;
( ( ThreadAwareLikelihood ) likelihood ) . isLikelihoodKnown ( ) ) ;
logLikelihood = treeLogProb + geographyLogProb + transLogProb - normalisation ;
} else if ( trunkClock . tipList . contains ( node . getNumber ( ) ) ) {
Logger . getLogger ( "str" ) . severe ( "str" + currentState + "str" +
Logger . getLogger ( "str" ) . severe ( "str" + currentState + "str" ) ;
logger . severe ( "str" + currentState + "str"
boolean option = xo . getAttribute ( BOOLEAN_DIS_OPTION , true ) ;
public int mleChainLength = 1000000 ;
double total = 0.0 ;
public final static boolean DEBUG = false ;
private static final PartialsRescalingScheme DEFAULT_RESCALING_SCHEME = PartialsRescalingScheme . DYNAMIC ;
public interface Model extends Identifiable {
createZeroOneParameterUniformPrior ( "str" , "str" , 0.1 ) ;
Logger . getLogger ( "str" ) . severe ( "str" + Double . toString ( lnL ) ) ;
includePatterns = new int [ includeTo - includeFrom ] ;
for ( int i = includeFrom ; i < includeTo ; i + = every ) {
excludePatterns = new int [ excludeTo - excludeFrom ] ;
for ( int i = excludeFrom ; i < excludeTo ; i + = every ) {
stopInclude = xoc . getIntegerAttribute ( TO ) ;
Logger . getLogger ( "str" ) . info ( "str" + ( startInclude + 1 ) + "str" + ( stopInclude ) + "str" ) ;
stopExclude = xoc . getIntegerAttribute ( TO ) ;
Logger . getLogger ( "str" ) . info ( "str" + ( startExclude + 1 ) + "str" + ( stopExclude ) + "str" ) ;
boolean checkConditioning = xo . getAttribute ( CHECK_CONDITIONING , true ) ;
if ( ! checkConditioning ) {
if ( ! checkConditioning ) {
columnLabels . add ( values [ SERUM_ISOLATE ] ) ;
final int I = getRowDimension ( ) ;
System . err . println ( "str" + e . getMessage ( ) + "str" ) ;
for ( int i = 0 ; i < dataList . get ( row ) . frequencyParameterIndices [ index ] . length ; i + + ) {
int k = dataList . get ( row ) . frequencyParameterIndices [ index ] [ i ] ;
double pathParameter = 1.0 - ( double ) step / ( double ) ( pathSteps ) ;
S2 = ( SymmetricMatrix ) S2 . product ( pathWeight ) ;
logLikelihood + = evaluateLikelihoods ( lateLikelihoods ) ;
throw new RuntimeException ( "str" + paramName ) ;
new Attribute . Default < String > ( MutationDeathTypeParser . CODE , "str" ) , true ) ;
if ( threads < 0 | | threads > 1000 ) {
threads = 0 ;
new ElementRule ( Likelihood . class , 0 , Integer . MAX_VALUE )
createZeroOneParameterUniformPrior ( "str" , "str" , 0.9 ) ;
PriorScaleType . NONE , 0.5 , 1.0 , 1.0 , false ) ;
createZeroOneParameterUniformPrior ( "str" , "str" , 0.5 ) ;
boolean mergeColumnStrains = xo . getAttribute ( MERGE_COLUMNS , false ) ;
AttributeRule . newBooleanRule ( MERGE_COLUMNS , true , "str" ) ,
throw new IllegalArgumentException ( "str" + sum ) ;
if ( trait . getTraitName ( ) . startsWith ( match ) ) {
if ( step > pathSteps ) {
} else if ( ancestralStatesOptions . isCountingStates ( partition ) ) {
new Attribute . Default < String > ( XMLParser . ID , idString ) ,
if ( ! includeRoot ) {
System . out . println ( "str" ) ;
this . rescalingScheme = PartialsRescalingScheme . DYNAMIC ;
this . rescalingScheme = PartialsRescalingScheme . DYNAMIC ;
} else if ( this . rescalingScheme = = PartialsRescalingScheme . DELAYED & & everUnderflowed ) {
likelihoodTester ( tree , birthRate , deathRate , origin , - 29.529647743897872 ) ;
if ( HIERARCHICAL_ENABLED & & ! isDefaultOnly ) {
if ( options . hasIdenticalTaxa ( ) & & options . getPartitionPattern ( ) . size ( ) < 1 ) {
beagle . updateTransitionMatrices ( eigenIndices [ j ] ,
JLabel label = new JLabel ( "str" +
label = new JLabel ( "str" +
return reconstructAtNodes ( partition ) | | reconstructAtMRCA ( partition ) | | dNdSRobustCounting ( partition ) ;
| | ( para . priorType = = PriorType . UNIFORM_PRIOR & & para . uniformLower > 0 & & para . uniformUpper < Double . POSITIVE_INFINITY )
throw new IllegalArgumentException ( "str" ) ;
throw new IllegalArgumentException ( "str" ) ;
throw new XMLParseException ( "str" ) ;
throw new IllegalArgumentException ( "str" ) ;
throw new IllegalArgumentException ( "str" ) ;
double lower = Double . NEGATIVE_INFINITY ;
double upper = Double . POSITIVE_INFINITY ;
public boolean operatorAnalysis = true ;
loadProperties ( this . getClass ( ) , parsers + PARSER_PROPERTIES_SUFFIX , verbose , this . parserWarnings , verbose ) ;
loadProperties ( this . getClass ( ) , addParsers + PARSER_PROPERTIES_SUFFIX , verbose , this . parserWarnings , verbose ) ;
if ( ! constantPopulation & & nc = = 0 ) {
double logLikelihood = ( 0.5 * Math . log ( precision ) * pointObservationCount ) - ( 0.5 * precision * sumOfSquaredResiduals ) ;
if ( tipPartialsModel ! = null & & tipPartialsModel . getPatternList ( ) ! = null ) {
sb . append ( String . format ( FORMAT , bf ) + "str" + bf + "str" ) ;
+ BirthDeathSerialSamplingModelParser . SAMPLE_BECOMES_NON_INFECTIOUS , writer ) ;
+ BirthDeathSerialSamplingModelParser . SAMPLE_BECOMES_NON_INFECTIOUS ,
+ BirthDeathSerialSamplingModelParser . SAMPLE_BECOMES_NON_INFECTIOUS , demoTuning , 1 ) ;
+ BirthDeathSerialSamplingModelParser . SAMPLE_BECOMES_NON_INFECTIOUS ) ) ;
+ BirthDeathSerialSamplingModelParser . SAMPLE_BECOMES_NON_INFECTIOUS ) ) ;
static final String inputFileName = path + curD + "str" ;
public static final String SAMPLED_REMAIN_INFECTIOUS = "str" ;
rootHeight = - 1 ;
private static final boolean DEBUG = false ;
if ( comp . errorModelType = = SequenceErrorType . NO_ERROR | | options . dataPartitions . size ( ) ! = 1 ) {
assertExpectation ( HKYParser . KAPPA , kappaStats , 18.06518 ) ;
assertExpectation ( LogNormalDistributionModelParser . MEAN , ucldStats , 8.0591451486E-4 ) ;
assertExpectation ( "str" , covarianceStats , - 0.0260333026 ) ;
assertExpectation ( RateStatisticParser . COEFFICIENT_OF_VARIATION , coefficientOfVariationStats , 0.773609960455 ) ;
citation = "str" ;
writePatternList ( partition , 0 , 1 , "str" , writer ) ;
return options . taxonList . getTaxon ( i ) . getAttribute ( getName ( ) ) . toString ( ) . trim ( ) . length ( ) > 0 ;
throw new RuntimeException ( "str" ) ;
boolean cacheBranches = xo . getAttribute ( CACHE_BRANCHES , false ) ;
boolean cacheBranches = xo . getAttribute ( CACHE_BRANCHES , true ) ;
boolean summaryOnly = true ;
assertExpectation ( LogNormalDistributionModelParser . MEAN , ucldStats , 8.18686E-4 ) ;
assertExpectation ( LogNormalDistributionModelParser . STDEV , ucldStats , 0.16846023066431434 ) ;
assertExpectation ( HKYParser . KAPPA , kappaStats , 18.38065 ) ;
ArrayList < Double > heights = new ArrayList < Double > ( ) ;
heights . add ( tree . getNodeHeight ( tree . getInternalNode ( i ) ) ) ;
intervals [ intervals . length - 1 ] = heights . get ( intervals . length - 1 ) ;
doubleValues [ i ] = ( Double ) values [ i ] ;
public static final String [ ] falseTrue = { "str" , "str" } ;
final double newHeightFather = minHeightFather + ( ran * ( heightGrandfather - minHeightFather ) ) ;
limitText . setValue ( 0.0 ) ;
trees . add ( binaryTree ) ;
taxa = binaryTree ;
final String name = RandomWalkIntegerOperatorParser . RANDOM_WALK_INTEGER_OPERATOR ;
private static final boolean TEST_NODE_BOUNDS = false ;
return "str" + df . toString ( ) + "str" ;
private BeautiOptions options = null ;
super ( ) ;
updateShareSameTreePriorChanged ( ) ;
updateTreePriorBorder ( ) ;
treePriorBorder . setTitle ( "str" + currentTreeModel . getPartitionTreePrior ( ) . getName ( ) ) ;
if ( currentTreeModel . getPartitionTreePrior ( ) ! = null ) treePriorPanelParent . removeAll ( ) ;
public final String CATEGORY_COUNT = "str" ;
likelihoodTester ( tree , birthRate , deathRate , - 4.633233508436623 ) ;
SpeciationModel speciationModel = new BirthDeathSerialSamplingModel ( b , d , psi , p , false , true , 0.0 , Units . Type . YEARS ) ;
double finalTimeInterval = 0.0 ;
return ( finalTimeInterval = = 0.0 ) & & sampledIndividualsRemainInfectious ;
if ( partitionData . getTraitType ( ) ! = null & & ( ! partitionData . getName ( ) . equalsIgnoreCase ( TraitData . Traits . TRAIT_SPECIES . toString ( ) ) ) )
return new Trace < Double > ( name , initialSize , ( double ) 0 ) ;
return new Trace < Integer > ( name , initialSize , 0 ) ;
done = true ;
sSeq + = c ;
public static final String REPLICATIONS = "str" ;
if ( this . rescalingScheme = = PartialsRescalingScheme . DEFAULT ) {
addTrait ( newTrait ) ;
public void addTrait ( TraitData newTrait ) {
traitsPanel . addTrait ( newTrait ) ;
private static boolean DEBUG = false ;
public static final String JEFFREYS_PRIOR = "str" ;
return new String [ ] { getParserName ( ) , JEFFREYS_PRIOR } ;
return CovarionHKY . class ;
return GeneralSubstitutionModel . class ;
return GeneralSubstitutionModel . class ;
return BinaryCovarionModel . class ;
if ( taxa_sequence . length > 2 ) {
private Double logDet = null ;
if ( logDet = = null ) {
sequenceNodes . addFirst ( parent ) ;
sequenceNodes . addFirst ( currentNode ) ;
sequenceNodes . addFirst ( child ) ;
final double oldValue = parameter . getParameterValue ( newRootNodeNumber ) ;
parameter . setParameterValue ( end , oldValue ) ;
final double oldValue = parameter . getParameterValue ( end ) ;
parameter . setParameterValue ( rootNodeNumber , oldValue ) ;
throw new RuntimeException ( "str" ) ;
assertEquals ( mypdf , gamma . pdf ( value ) , 1e-8 ) ;
public void selectOperators ( List < Operator > ops ) {
throw new IllegalArgumentException ( "str" ) ;
throw new IllegalArgumentException ( "str" + label + "str" + seperator + "str" ) ;
throw new IllegalArgumentException ( "str" ) ;
throw new IllegalArgumentException ( "str" + label + "str" + seperator + "str" ) ;
fireModelChanged ( null , index ) ;
public void writeBranchRatesModel ( PartitionClockModel model , XMLWriter writer ) {
if ( options . getPartitionClockModels ( ) . size ( ) > 1 ) {
static int DEBUG = 0 ;
if ( xo . getName ( ) . equalsIgnoreCase ( "str" ) & & System . getProperty ( "str" ) ! = null ) {
if ( parameter . priorType ! = PriorType . JEFFREYS_PRIOR ) optionsPanels . get ( parameter . priorType ) . setParameterPrior ( parameter ) ;
super ( "str" , microsatellite , freqModel , null ) ;
beagle . calculateRootLogLikelihoods ( rootBufferIndicies , categoryProportions , frequencies , new int [ 0 ] , new int [ 0 ] , patternLogLikelihoods ) ;
case LABELED : return ( taxonCount - 1 ) * Math . log ( 2.0 ) - logGamma ( taxonCount ) ;
final String s = xo . getAttribute ( TREE_TYPE , BirthDeathGernhard08Model . TreeType . UNSCALED . toString ( ) ) ;
case UNSCALED : break ;
SpeciationModel speciationModel = new BirthDeathGernhard08Model ( b , d , null , BirthDeathGernhard08Model . TreeType . TIMESONLY ,
return new BirthDeathGernhard08Model ( brParameter , deathParameter , null , BirthDeathGernhard08Model . TreeType . UNSCALED , units ) ;
SpeciationModel speciationModel = new BirthDeathGernhard08Model ( b , d , null , BirthDeathGernhard08Model . TreeType . TIMESONLY ,
createScaleParameter ( TraitGuesser . Traits . TRAIT_SPECIES + "str" + POP_MEAN , "str" ,
createScaleParameter ( SpeciesTreeModel . SPECIES_TREE + "str" + Generator . SPLIT_POPS , "str" ,
createParameter ( TraitGuesser . Traits . TRAIT_SPECIES + "str" + TreeNodeSlide . TREE_NODE_REHEIGHT , "str" ) ;
return convert ( endValue [ 0 ] - startValue [ 0 ] , endValue [ 1 ] - startValue [ 1 ] , startTime - endTime ) ;
public static String nextNonCommentLine ( BufferedReader reader ) throws IOException {
assert tree . getNodeHeight ( i ) < = tree . getNodeHeight ( iGrandParent ) ;
throw new IllegalArgumentException ( "str" + minimumTaxa + "str" ) ;
return new LogNormalDistributionModel ( meanParam , precParam , offset , meanInRealSpace , false ) ;
if ( pdf = = 0 | | Double . isNaN ( pdf ) ) {
return NormalDistribution . logPdf ( ( 1.0 / ( x - offset ) ) , getM ( ) , getStDev ( ) ) - ( Math . log ( x - offset ) ) ;
writer . flush ( ) ;
sb . append ( "str" + ( scaleByTime ? ( useTreeLength ? "str" : "str" ) : "str" ) + "str" ) ;
CoercionMode . COERCION_ON , internalHeights , allInternalNodeHeights , rates , 0.9 , null , - 1 ) ;
double offset = xo . getAttribute ( OFFSET , 0.0 ) ;
AttributeRule . newDoubleRule ( OFFSET , true ) ,
makeDirty ( ) ;
Logger . getLogger ( "str" ) . info ( "str" + type ) ;
model = importer . parseMrBayesBlock ( beautiOptions , charSets ) ;
model = importer . parseMrBayesBlock ( beautiOptions , charSets ) ;
public static String SAMPLE_NONACTIVE_GIBBS_OPERATOR = "str" ;
int t = to + 1 ;
int to = - 1 ;
if ( to = = - 1 ) t = alignment . getSiteCount ( ) ;
throw new XMLParseException ( "str" ) ;
throw new XMLParseException ( "str" + name + "str" ) ;
hashMap . put ( s , 1 ) ;
Double [ ] array = ( Double [ ] ) value ;
valuesArray [ k ] [ j ] = array [ k ] ;
} , 0 , Integer . MAX_VALUE ) ,
public interface Statistic extends Attribute < double [ ] > , Identifiable , Loggable {
public final double [ ] getAttributeValue ( ) {
double logDet = Math . log ( determinatePrecisionMatrix ) ;
final double det = W . determinant ( ) ;
public static final String GIBBS_OPERATOR = "str" ;
public double doOperation ( ) throws OperatorFailedException {
double [ ] [ ] precision = precisionMatrixParameter . getParameterAsMatrix ( ) ;
NodeRef node = treeModel . getRoot ( ) ;
NodeRef parent = treeModel . getParent ( node ) ;
double [ ] weightedAverage = new double [ dim ] ;
public static dr . xml . XMLObjectParser PARSER = new dr . xml . AbstractXMLObjectParser ( ) {
public Object parseXMLObject ( XMLObject xo ) throws XMLParseException {
double weight = xo . getIntegerAttribute ( WEIGHT ) ;
TreeModel treeModel = ( TreeModel ) xo . getChild ( TreeModel . class ) ;
MultivariateDiffusionModel diffusionModel = ( MultivariateDiffusionModel ) xo . getChild ( MultivariateDiffusionModel . class ) ;
writer . writeOpenTag ( "str" , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } ) ;
writer . writeTag ( "str" , new Attribute [ ] { new Attribute . Default < String > ( "str" , taxon . getId ( ) ) } , ! hasDate ) ;
new Attribute . Default < String > ( "str" , taxa . getId ( ) )
writer . writeTag ( "str" , new Attribute [ ] { new Attribute . Default < String > ( "str" , taxon . getId ( ) ) } , true ) ;
writer . writeTag ( "str" , new Attribute [ ] { new Attribute . Default < String > ( "str" , taxon . getId ( ) ) } , true ) ;
new Attribute . Default < String > ( "str" , initialPopSize ) ,
new Attribute . Default < String > ( "str" , "str" ) ,
writer . writeTag ( "str" , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( TreeModel . TREE_MODEL , new Attribute . Default < String > ( "str" , "str" ) , false ) ;
writer . writeTag ( "str" , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( CoalescentSimulator . COALESCENT_TREE , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) }
new Attribute . Default < String > ( "str" , alignment . getDataType ( ) . getDescription ( ) )
new Attribute [ ] { new Attribute . Default < String > ( "str" , id ) }
new Attribute . Default < String > ( "str" , alignment . getDataType ( ) . getDescription ( ) )
writer . writeTag ( "str" , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } , true ) ;
new Attribute [ ] { new Attribute . Default < String > ( "str" , id ) }
new Attribute . Default < String > ( "str" , alignment . getDataType ( ) . getDescription ( ) )
writer . writeTag ( "str" , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } , true ) ;
writer . writeOpenTag ( CompoundParameter . COMPOUND_PARAMETER , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } ) ;
new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" + i + "str" ) } , true ) ;
writer . writeOpenTag ( GammaSiteModel . SITE_MODEL , new Attribute [ ] { new Attribute . Default < String > ( "str" , id ) } ) ;
writer . writeTag ( dr . evomodel . substmodel . HKY . HKY_MODEL , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( dr . evomodel . substmodel . HKY . HKY_MODEL , new Attribute . Default < String > ( "str" , "str" + num ) , true ) ;
writer . writeTag ( dr . evomodel . substmodel . GTR . GTR_MODEL , new Attribute . Default < String > ( "str" , "str" + num ) , true ) ;
writer . writeTag ( dr . evomodel . substmodel . HKY . HKY_MODEL , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( dr . evomodel . substmodel . HKY . HKY_MODEL , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( dr . evomodel . substmodel . GTR . GTR_MODEL , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeOpenTag ( GammaSiteModel . GAMMA_SHAPE , new Attribute . Default < String > ( GammaSiteModel . GAMMA_CATEGORIES , "str" + gammaCategories ) ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
new Attribute . Default < String > ( "str" , "str" ) } ) ;
new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeOpenTag ( GammaSiteModel . GAMMA_SHAPE , new Attribute . Default < String > ( GammaSiteModel . GAMMA_CATEGORIES , "str" + gammaCategories ) ) ;
new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) }
writer . writeTag ( TreeModel . TREE_MODEL , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( "str" , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( "str" , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( "str" , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) }
writer . writeTag ( TreeModel . TREE_MODEL , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeOpenTag ( "str" , new Attribute . Default < String > ( LogNormalDistributionModel . MEAN_IN_REAL_SPACE , "str" ) ) ;
new Attribute . Default < String > ( "str" , "str" )
writer . writeTag ( TreeModel . TREE_MODEL , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( TreeModel . TREE_MODEL , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) }
writer . writeTag ( TreeModel . TREE_MODEL , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) }
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" + num ) }
writer . writeTag ( SitePatternsParser . PATTERNS , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } , true ) ;
writer . writeTag ( SitePatternsParser . PATTERNS , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } , true ) ;
writer . writeTag ( SitePatternsParser . PATTERNS , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" + num ) } , true ) ;
new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) }
writer . writeTag ( StrictClockBranchRates . STRICT_CLOCK_BRANCH_RATES , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } , true ) ;
writer . writeTag ( DiscretizedBranchRates . DISCRETIZED_BRANCH_RATES , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } , true ) ;
new Attribute . Default < String > ( "str" , "str" + taxa . getId ( ) + "str" ) ,
writer . writeTag ( TaxaParser . TAXA , new Attribute [ ] { new Attribute . Default < String > ( "str" , taxa . getId ( ) ) } , true ) ;
writer . writeTag ( TreeModel . TREE_MODEL , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } , true ) ;
new Attribute . Default < String > ( "str" , "str" + taxa . getId ( ) + "str" ) ,
writer . writeTag ( TaxaParser . TAXA , new Attribute [ ] { new Attribute . Default < String > ( "str" , taxa . getId ( ) ) } , true ) ;
writer . writeTag ( TreeModel . TREE_MODEL , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } , true ) ;
new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) }
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , operator . parameter1 . getName ( ) ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , operator . parameter1 . getName ( ) ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute [ ] { new Attribute . Default < String > ( "str" , operator . parameter1 . getName ( ) ) } , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute [ ] { new Attribute . Default < String > ( "str" , operator . parameter2 . getName ( ) ) } , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute [ ] { new Attribute . Default < String > ( "str" , operator . parameter1 . getName ( ) ) } , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute [ ] { new Attribute . Default < String > ( "str" , operator . parameter1 . getName ( ) ) } , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute [ ] { new Attribute . Default < String > ( "str" , operator . parameter1 . getName ( ) ) } , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute [ ] { new Attribute . Default < String > ( "str" , operator . parameter1 . getName ( ) ) } , true ) ;
new Attribute . Default < Double > ( "str" , operator . weight ) ,
writer . writeTag ( ParameterParser . PARAMETER , new Attribute [ ] { new Attribute . Default < String > ( "str" , operator . parameter1 . getName ( ) ) } , true ) ;
writer . writeTag ( TreeModel . TREE_MODEL , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } , true ) ;
new Attribute . Default < String > ( "str" , logFileName )
writer . writeOpenTag ( CompoundLikelihood . POSTERIOR , new Attribute . Default < String > ( "str" , "str" ) ) ;
writer . writeOpenTag ( CompoundLikelihood . PRIOR , new Attribute . Default < String > ( "str" , "str" ) ) ;
writer . writeTag ( SpeciationLikelihood . SPECIATION_LIKELIHOOD , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( BayesianSkylineLikelihood . SKYLINE_LIKELIHOOD , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( CoalescentLikelihood . COALESCENT_LIKELIHOOD , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( BooleanLikelihood . BOOLEAN_LIKELIHOOD , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ExponentialMarkovModel . EXPONENTIAL_MARKOV_MODEL , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeOpenTag ( CompoundLikelihood . LIKELIHOOD , new Attribute . Default < String > ( "str" , "str" ) ) ;
writer . writeTag ( TreeLikelihood . TREE_LIKELIHOOD , new Attribute . Default < String > ( "str" , "str" + i ) , true ) ;
writer . writeTag ( TreeLikelihood . TREE_LIKELIHOOD , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( SimpleOperatorSchedule . OPERATOR_SCHEDULE , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( TreeModel . TREE_MODEL , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( DiscretizedBranchRates . DISCRETIZED_BRANCH_RATES , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } , true ) ;
writer . writeTag ( "str" , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( TreeModel . TREE_MODEL , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( StrictClockBranchRates . STRICT_CLOCK_BRANCH_RATES , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } , true ) ;
writer . writeTag ( DiscretizedBranchRates . DISCRETIZED_BRANCH_RATES , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } , true ) ;
final Attribute . Default attr = new Attribute . Default < String > ( "str" , taxaRef ) ;
new Attribute . Default < String > ( DistributionLikelihood . MEAN_IN_REAL_SPACE , "str" )
writer . writeTag ( "str" , new Attribute [ ] { new Attribute . Default < String > ( "str" , parameter . getName ( ) ) } , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute [ ] { new Attribute . Default < String > ( "str" , parameter . getName ( ) ) } , true ) ;
writer . writeTag ( CompoundLikelihood . POSTERIOR , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( CompoundLikelihood . PRIOR , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( CompoundLikelihood . LIKELIHOOD , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( RateStatistic . RATE_STATISTIC , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( "str" , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( CompoundLikelihood . POSTERIOR , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( CompoundLikelihood . PRIOR , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( CompoundLikelihood . LIKELIHOOD , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( RateStatistic . RATE_STATISTIC , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( "str" , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" + taxa . getId ( ) + "str" ) } , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
new Attribute . Default < String > ( "str" , "str" + i + "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" + i + "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
new Attribute . Default < String > ( "str" , "str" + i + "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
new Attribute . Default < String > ( "str" , "str" + i + "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( ParameterParser . PARAMETER , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( "str" , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( TreeLikelihood . TREE_LIKELIHOOD , new Attribute . Default < String > ( "str" , "str" + i ) , true ) ;
writer . writeTag ( TreeLikelihood . TREE_LIKELIHOOD , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( SpeciationLikelihood . SPECIATION_LIKELIHOOD , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( BayesianSkylineLikelihood . SKYLINE_LIKELIHOOD , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
writer . writeTag ( CoalescentLikelihood . COALESCENT_LIKELIHOOD , new Attribute . Default < String > ( "str" , "str" ) , true ) ;
attributes . add ( new Attribute . Default < String > ( "str" , id ) ) ;
attributes . add ( new Attribute . Default < String > ( "str" , dimension + "str" ) ) ;
attributes . add ( new Attribute . Default < String > ( "str" , value + "str" ) ) ;
attributes . add ( new Attribute . Default < String > ( "str" , lower + "str" ) ) ;
attributes . add ( new Attribute . Default < String > ( "str" , upper + "str" ) ) ;
new Attribute . Default < String > ( "str" , "str" )
new Attribute . Default < String > ( DistanceMatrixParser . CORRECTION , "str" )
writer . writeTag ( AlignmentParser . ALIGNMENT , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } , true ) ;
new Attribute . Default < String > ( "str" , "str" )
Attribute [ ] taxaAttribute = new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } ;
Attribute mono = new Attribute . Default < Boolean > ( CoalescentSimulator . IS_MONOPHYLETIC , taxonSetsMono . get ( taxonSet ) ) ;
new Attribute [ ] { new Attribute . Default < String > ( "str" , taxonSet . getId ( ) ) } , true ) ;
writer . writeTag ( ConstantPopulationModel . CONSTANT_POPULATION_MODEL , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } , true ) ;
writer . writeTag ( ExponentialGrowthModel . EXPONENTIAL_GROWTH_MODEL , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } , true ) ;
writer . writeTag ( ConstantPopulationModel . CONSTANT_POPULATION_MODEL , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } , true ) ;
writer . writeTag ( ConstantPopulationModel . CONSTANT_POPULATION_MODEL , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } , true ) ;
writer . writeTag ( ExponentialGrowthModel . EXPONENTIAL_GROWTH_MODEL , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } , true ) ;
writer . writeTag ( LogisticGrowthModel . LOGISTIC_GROWTH_MODEL , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } , true ) ;
writer . writeTag ( ExpansionModel . EXPANSION_MODEL , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } , true ) ;
writer . writeTag ( BayesianSkylineLikelihood . SKYLINE_LIKELIHOOD , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } , true ) ;
writer . writeTag ( YuleModel . YULE_MODEL , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } , true ) ;
writer . writeTag ( BirthDeathModel . BIRTH_DEATH_MODEL , new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" ) } , true ) ;
new Attribute [ ] { new Attribute . Default < String > ( "str" , "str" + tree . getNodeHeight ( node ) ) }
writer . writeTag ( "str" , new Attribute [ ] { new Attribute . Default < String > ( "str" , tree . getNodeTaxon ( node ) . getId ( ) ) } , true ) ;
boolean sortTranslationTable = true ;
double x0 = ( shape * scale + Math . sqrt ( 4 * scale / bias + shape * shape * scale * scale ) ) / 2.0 ;
buffer . append ( popSizes [ 0 ] ) ;
buffer . append ( "str" ) . append ( popSizes [ i ] ) ;
Logger . getLogger ( "str" ) . info ( "str" + ( ratesAreMultipliers ? "str" : "str" ) ) ;
final TreeLikelihood treeLikelihood = new TreeLikelihood ( patternList , treeModel , siteModel , null , false , true , false ) ;
new ElementRule ( DISTRIBUTION ,
class Epoch implements Comparable {
distribution = new ExponentialDistribution ( 1.0 / exponentialMean ) ;
public void close ( ) {
public void close ( ) {
import com . wizzardo . tools . misc . Pair ;
import com . wizzardo . tools . misc . Pair ;
Assert . assertEquals ( "str" , makeRequest ( "str" ) . get ( ) . asString ( ) . trim ( ) ) ;
checkResponse ( 400 , "str" , makeRequest ( "str" ) . get ( ) ) ;
"str" + port + "str" +
Response handle ( Request < HttpConnection > request , Response response ) throws IOException ;
if ( response . header ( Header . KEY_CONTENT_ENCODING ) ! = null )
if ( ! file . exists ( ) | | ! file . isFile ( ) )
public static void checkException ( Runnable runnable , Class < ? extends Exception > exceptionClass , String message ) {
throw new IllegalArgumentException ( "str" + controllerName + "str" + actionName + "str" , e ) ;
ExpressionHolder checked = asExpression ( ch , false ) ;
if ( limit > = 0 & & length > limit )
if ( length < limit )
return authFilter . filter ( request , response ) ;
return authFilter . filter ( request , response ) ;
return authFilter . filter ( request , response ) ;
checkResponse ( 400 , "str" , makeRequest ( "str" ) . get ( ) ) ;
checkResponse ( 400 , "str" , makeRequest ( "str" ) . get ( ) ) ;
checkResponse ( 400 , "str" , makeRequest ( "str" ) . get ( ) ) ;
checkResponse ( 400 , "str" , makeRequest ( "str" ) . get ( ) ) ;
checkResponse ( 400 , "str" , makeRequest ( "str" ) . get ( ) ) ;
checkResponse ( 400 , "str" , makeRequest ( "str" ) . get ( ) ) ;
if ( type = = Long . class )
if ( type = = Float . class )
if ( type = = Double . class )
if ( type = = Boolean . class )
if ( type = = Short . class )
if ( type = = Byte . class )
if ( type = = Character . class )
config . merge ( subConfig ) ;
File outDir = new File ( Unchecked . call ( ( ) - > File . createTempFile ( "str" , null ) ) . getParentFile ( ) , jarFile . getName ( ) + "str" ) ;
protected RangeResponseHelper rangeResponseHelper = new RangeResponseHelper ( ) ;
return pool . holder ( ) . get ( ) ;
handler = ( request , response ) - > new RangeResponseHelper ( 0 , 0 , 0 , false ) . makeRangeResponse ( request , response , file ) ;
Config resourcesCache = resources . config ( "str" ) ;
UrlTemplate template = urlMapping . getUrlTemplate ( "str" ) ;
throw new IllegalStateException ( "str" ) ;
loadSystemProperties ( config ) ;
protected void loadSystemProperties ( Config config ) {
protected static final Pattern END = Pattern . compile ( "str" ) ;
Assert . assertEquals ( "str" , makeRequest ( "str" ) . get ( ) . header ( "str" ) ) ;
Assert . assertEquals ( "str" , makeRequest ( "str" ) . post ( ) . header ( "str" ) ) ;
public void test_allowNothing_butOptions ( ) throws IOException {
Assert . assertEquals ( "str" , makeRequest ( "str" ) . get ( ) . header ( "str" ) ) ;
return application ! = null ? application . getEnvironment ( ) : null ;
return application ! = null ? application . getConfig ( ) : null ;
AuthFilter auth = new BasicAuthFilter ( ) ;
if ( ( r = = - 1 & & read = = 0 ) | | ( read = = 4 & & b [ 0 ] = = "str" & & b [ 1 ] = = "str" & & b [ 2 ] = = "str" & & b [ 3 ] = = "str" ) )
if ( html . children ( ) . size ( ) = = 1 & & "str" . equals ( ( page = html . children ( ) . get ( 0 ) ) . name ( ) ) & & page . hasAttr ( "str" ) ) {
process ( connection , this ) ;
private void process ( T connection , ByteBufferProvider bufferProvider ) {
} else if ( checkData ( connection , bufferProvider ) )
HpackReader . encode ( 10 , bytes , 3 ) ;
return 4 + ( masked ? 4 : 0 ) ;
private static Pattern p = Pattern . compile ( "str" ) ;
if ( bytes ! = null )
return init ( node . attributes ( ) , new Body ( node , getBodyOffset ( offset ) , dir , imports ) , offset ) ;
params = new Parameters ( ) ;
headers = new LinkedHashMap < > ( 16 ) ;
Boolean absolute = ( Boolean ) attrs . remove ( "str" ) ;
} else if ( absolute ! = null & & absolute )
n = Node . parse ( "str" , true ) ;
if ( name . length ( ) < 7 | | ! name . endsWith ( "str" ) )
} catch ( ClassNotFoundException | NoClassDefFoundError ignored ) {
Assert . assertEquals ( "str" , new Link ( ) . init ( new LinkedHashMap < > ( attrs ) ) . get ( model ) . toString ( ) ) ;
Assert . assertEquals ( "str" , new Link ( ) . init ( new LinkedHashMap < > ( attrs ) ) . get ( model ) . toString ( ) ) ;
Assert . assertEquals ( "str" , new Link ( ) . init ( new LinkedHashMap < > ( attrs ) ) . get ( model ) . toString ( ) ) ;
Assert . assertEquals ( "str" , new Link ( ) . init ( new LinkedHashMap < > ( attrs ) ) . get ( model ) . toString ( ) ) ;
Assert . assertEquals ( "str" , new Link ( ) . init ( new LinkedHashMap < > ( attrs ) ) . get ( model ) . toString ( ) ) ;
Assert . assertEquals ( "str" , new Link ( ) . init ( new LinkedHashMap < > ( attrs ) ) . get ( model ) . toString ( ) ) ;
Assert . assertEquals ( "str" , new Link ( ) . init ( new LinkedHashMap < > ( attrs ) ) . get ( model ) . toString ( ) ) ;
Assert . assertEquals ( "str" , new Link ( ) . init ( new LinkedHashMap < > ( attrs ) ) . get ( model ) . toString ( ) ) ;
Assert . assertEquals ( "str" , new Link ( ) . init ( new LinkedHashMap < > ( attrs ) ) . get ( model ) . toString ( ) ) ;
Assert . assertEquals ( "str" , new Link ( ) . init ( new LinkedHashMap < > ( attrs ) ) . get ( model ) . toString ( ) ) ;
this ( host , port , context , workersCount , null ) ;
while ( ( b = connection . read ( connection . getBufferSize ( ) , this ) ) . limit ( ) > 0 ) {
protected void processConnection ( T connection ) {
public RenderResult render ( ) {
public RenderResult render ( ) {
public abstract RenderResult render ( ) ;
public static void prepare ( List < Node > n , RenderableList l , String dir , String offset ) {
public static void prepare ( Node n , RenderableList l , String dir , String offset ) {
UrlMappingWithVariables ( UrlMapping < T > parent , String part , int partNumber ) {
protected UrlMappingEndsWith ( UrlMapping < T > parent ) {
protected UrlMappingHolder ( UrlMapping < T > parent ) {
protected UrlMappingMatcherAny ( UrlMapping < T > parent ) {
protected UrlMappingMatcherAnyVariable ( UrlMapping < T > parent , String part , int partNumber ) {
protected UrlMappingMatcherPattern ( UrlMapping < T > parent , String pattern ) {
protected UrlMappingMatcher ( UrlMapping < T > parent ) {
String md5 = MD5 . create ( ) . update ( big ) . asString ( ) ;
Assert . assertEquals ( md5 , MD5 . create ( ) . update ( makeRequest ( "str" ) . get ( ) . asStream ( ) ) . asString ( ) ) ;
final String md5 = MD5 . create ( ) . update ( data ) . asString ( ) ;
return response . setBody ( MD5 . create ( ) . update ( request . getInputStream ( ) ) . asString ( ) ) ;
return response . setBody ( MD5 . create ( ) . update ( out . toByteArray ( ) ) . asString ( ) ) ;
sb . append ( MD5 . create ( ) . update ( String . valueOf ( random . nextInt ( ) ) ) . asString ( ) ) ;
sb . append ( MD5 . create ( ) . update ( String . valueOf ( random . nextInt ( ) ) ) . asString ( ) ) ;
public void attrs ( ) {
private byte [ ] serverName = "str" . getBytes ( ) ;
text = "str" + HttpDateFormatterHolder . get ( ) . format ( new Date ( time ) ) + "str" ;
frames . get ( frames . size ( ) - 1 ) . setIsFinalFrame ( false ) ;
public void testIgnoreCase ( ) {
public UrlMapping < T > append ( String url , T handler ) {
return new Tag ( "str" + level ) ;
Assert . assertEquals ( "str" , hhr . headers . get ( "str" ) . getValue ( ) ) ;
if ( handler ! = null )
Assert . assertEquals ( "str" , request . path ( ) . toString ( ) ) ;
Assert . assertEquals ( "str" , request . path ( ) . toString ( ) ) ;
Assert . assertEquals ( "str" , request . path ( ) . toString ( ) ) ;
int h = "str" ;
to = parseLong ( temp [ 1 ] ) ;
from = parseLong ( temp [ 0 ] ) ;
private long parseLong ( String s ) {
return Long . parseLong ( s ) ;
throw new IllegalArgumentException ( "str" + s + "str" ) ;
SimpleDateFormat format = new SimpleDateFormat ( "str" , Locale . US ) ;
sb . append ( "str" ) . append ( dateFormatThreadLocal . get ( ) . format ( date ) ) ;
sb . append ( "str" ) . append ( path ) ;
sb . append ( "str" ) . append ( domain ) ;
String cookieRaw = header ( Header . KEY_COOKIE ) ;
for ( String kvRaw : cookieRaw . split ( "str" ) ) {
cookies . put ( kv [ 0 ] . trim ( ) , kv [ 1 ] . trim ( ) ) ;
while ( ( r = connection . read ( buffer , read , buffer . length - read ) ) > 0 ) {
byteArrayOutputStream . write ( b , 2 , rnrn - 2 ) ;
return position = = partsCount - 1 & & parts [ position ] . isComplete ( ) ;
Long userId = Long . valueOf ( req . params ( "str" ) ) ;
Boolean nsfw = ( community ! = null & & community . getNsfw ( ) ) ? true : d . getBoolean ( "str" ) ;
if ( ! userObj . equals ( creator ) & & ! getPrivateUsers ( ) . contains ( userObj ) ) {
int [ ] windowLengths = getWindowLengths ( samples , mean ) ;
public ValueLabel ( double key , Double label ) {
this . label = label ! = null ? label : 0 ;
TimeSeries . NORM = false ;
TimeSeries . NORM = true ;
int min = 4 ;
short [ ] [ ] wordsQuery = sfa . transformWindowing ( test [ q ] ) ;
final int l = getPrefix ( words , prefixLength ) ;
return searchKNN ( dftQuery , wordQuery , query , k ) ;
LOGGER . debug ( "str" , result . getCertPath ( ) ) ;
logger . debug ( "str" , context . getOwnerNode ( ) . getBrowseName ( ) . getName ( ) ) ;
LOGGER . debug ( "str" , fsm . getId ( ) ) ;
LOGGER . debug ( "str" , fsm . getId ( ) , delaySeconds ) ;
RefRow ( BrowsePath browsePath , NodeId nodeId , RefTarget target ) {
if ( queue . size ( ) < queue . maxSize ( ) ) {
Thread thread = new Thread ( r , "str" + threadNumber . getAndIncrement ( ) ) ;
Thread thread = new Thread ( r , "str" + threadNumber . getAndIncrement ( ) ) ;
Thread thread = new Thread ( r , "str" + threadNumber . getAndIncrement ( ) ) ;
Thread thread = new Thread ( r , "str" ) ;
throw new UaException ( StatusCodes . Bad_IndexRangeNoData ) ;
includeServer ? new DateTime ( ) : null
includeServer ? new DateTime ( ) : null
faultListeners . forEach ( h - > h . onServiceFault ( serviceFault ) ) ) ;
faultListeners . forEach ( h - > h . onServiceFault ( serviceFault ) ) ) ;
long statusCode = UaException . extract ( ex )
public static final int DEFAULT_MAX_CHUNK_SIZE = 65535 ;
public interface Out < T > {
public interface InvocationContext {
private static final DataChangeFilter DEFAULT_FILTER = new DataChangeFilter (
this . filter = DEFAULT_FILTER ;
public ClientExampleRunner ( ClientExample clientExample ) throws Exception {
public static void main ( String [ ] args ) throws Exception {
public void shouldIgnoreCase ( )
private MTable < SpatialEvent > table ;
String contentType = getContentType ( ) . getExtension ( ) = = null ? MediaType . _bin . getExtension ( ) : getContentType ( ) . getMIME ( ) ;
this . CONTENT_TYPE = HEADER . get ( "str" ) = = null ? "str" : HEADER . get ( "str" ) . get ( 0 ) ;
result . append ( m_Data . attribute ( j ) . name ( ) + "str" +
"str" , 1 , "str" ) ) ;
"str" , 1 , "str" ) ) ;
"str" , 1 , "str" ) ) ;
"str" , 1 , "str" ) ) ;
} else if ( m_loss = = EPSILON_INSENSITIVE ) {
throw new IllegalArgumentException ( "str" ) ;
( testFileName . length ( ) > 0 ) | | ( classificationOutput ! = null & & noCrossValidation & & splitPercentage = = - 1 ) ) {
if ( thresholdFile . length ( ) ! = 0 ) {
m_prefLab . setText ( "str" ) ;
p . println ( "str"
p . println ( "str"
if ( ( i = = 0 ) & & ( data . instance ( j ) . value ( m_attIndex ) < = m_splitPoint ) ) {
& & ( data . instance ( j ) . value ( m_attIndex ) > m_splitPoint ) ) {
if ( ( inst . value ( attIndex ) < = splitPoint ) ) {
color = Color . lightGray ;
color = Color . lightGray ;
return processInstance ( instance ) ;
protected Environment m_env = new Environment ( ) ;
if ( m_NumEpochsPerformed > = getNumEpochs ( ) | | m_zeroR ! = null ) {
+ PROPERTY_FILE , DefaultModelsPanel . class . getClassLoader ( ) ) ;
displayOrder = 2 )
displayOrder = 3 )
displayOrder = 4 )
displayOrder = 5 )
displayOrder = 6 )
displayOrder = 7 )
displayOrder = 8 )
displayOrder = 9 )
displayOrder = 10 )
displayOrder = 11 )
displayOrder = 12 )
displayOrder = 13 )
displayOrder = 14 )
displayOrder = 15 )
displayOrder = 16 )
displayOrder = 17 )
displayOrder = 18 )
displayOrder = 19 )
displayOrder = 20 )
displayOrder = 21 )
displayOrder = 22 )
displayOrder = 23 )
displayOrder = 24 )
displayOrder = 25 )
displayOrder = 26 )
displayOrder = 27 )
displayOrder = 28 )
displayOrder = 29 )
displayOrder = 30 )
displayOrder = 31 )
displayOrder = 32 )
( MainMenuExtension ) WekaPackageClassLoaderManager . objectForName ( classname ) ;
if ( ! checkForUnsetEnvVar ( p ) ) {
double allWords = 0 ;
while ( m_Objs . containsKey ( nameCopy ) ) {
public boolean stepMustRunSingleThreaded ( ) {
setDoNotPrintModels ( Utils . getFlag ( "str" , options ) ) ;
( m_fileName = = null | | isEmpty ( m_fileName . toString ( ) ) ) ) {
String title = "str" ;
String title = "str" ;
freq * = ( m_norm / iNorm ) ;
freq * = ( m_norm / iNorm ) ;
freq * = ( m_norm / iNorm ) ;
mode = "str" ;
m_runningJob = null ;
. append ( "str"
"str" ) ) ;
p . setBorder ( BorderFactory . createTitledBorder ( "str" ) ) ;
protected transient Map < String , BufferedImage > m_images =
550 , 100 ) ;
if ( m_ClassIndex > position ) {
m_ibk . buildClassifier ( m_dtInstances ) ;
while ( i < sStr . length ( ) & & ( c = = "str" | | Character . isDigit ( c ) ) | | c = = "str" ) {
evaluateDouble ( "str" , value )
editorPan . add ( editorScroller , BorderLayout . CENTER ) ;
DataSetEvent d = new DataSetEvent ( this , m_matches . getOutputStructure ( ) ) ;
public void instancesToPythonAsScikitLearn ( Instances instances ,
Option . setOptionsForHierarchy ( options , this , AbstractClusterer . class ) ;
session . assign ( requester , cleanse ( "str" + att . name ( ) ) , d ) ;
if ( summaryAttOrig . isNominal ( ) ) {
m_bagger . setCalcOutOfBag ( ! getDontCalculateOutOfBagError ( ) ) ;
protected boolean m_Debug = false ;
for ( int i = position + 1 ; i < m_Attributes . size ( ) ; i + + ) {
protected boolean m_Debug = false ;
if ( ( weightNonMissing [ j ] > 0 ) & & members . attribute ( j ) . isNumeric ( ) ) {
if ( m_Predictions = = null | | m_Predictions . size ( ) = = 0 | | retain = = 1 ) {
m_Instances = new Instances ( data , 0 ) ;
if ( ( ! m_SuitableData ) | | ( m_Classifiers . size ( ) > = m_NumIterations ) | |
result . add ( "str" ) ;
result . add ( "str" ) ;
protected int m_numTrees = 100 ;
newVector . addElement ( new Option ( "str" , "str" , 1 ,
"str" , "str" , 1 ,
m_numTrees = 100 ;
m_KValue = ( int ) Utils . log2 ( data . numAttributes ( ) - 1 ) + 1 ;
setStepSize ( 1 ) ;
downSampled . add ( ( Prediction ) m_Predictions . get ( index ) ) ;
& & src . value ( ( int ) instance . value ( instIndex ) ) . equals ( Attribute . DUMMY_STRING_VAL ) ) {
classStatistics = ! Utils . getFlag ( "str" , options ) ;
result . add ( getAttributeIndices ( ) ) ;
Instances withSummary , boolean deleteClassIfSet ) throws Exception {
false , deleteClassIfSet ) ;
checkAgainstUtilsCorr ( matrix , orig , withSummary , true ) ;
checkAgainstUtilsCorr ( matrix , orig , withSummary , false ) ;
checkAgainstUtilsCorr ( matrix , orig , withSummary , true ) ;
for ( int i = 0 ; i < nodesLevel . length ; i + + ) {
loadPackages ( verbose , false , true ) ;
result . setValue ( Field . PAGES , "str" ) ;
m_setAutoCommit = PROPERTIES . getProperty ( "str" , "str" ) . equals (
} else if ( inst . attribute ( i ) . isNominal ( ) & & i ! = inst . classIndex ( ) ) {
"str" , 0 , "str" ) ) ;
setDebug ( Utils . getFlag ( "str" , options ) ) ;
options [ current + + ] = "str" ;
| | m_types [ i ] = = TYPE . UNDETERMINED ) {
+ m_current . size ( ) + "str" + m_structure . numAttributes ( ) ) ;
super ( cause . getMessage ( ) ) ;
if ( m_sourceReader = = null ) {
if ( m_sourceReader = = null ) {
if ( m_sourceReader = = null ) {
options [ current + + ] = "str" ;
int index = n . m_neighbors . numInstances ( ) ;
dateformat = ( String ) att . getChild ( DATEFORMAT ) . getValue ( "str" ) ;
if ( data . attribute ( index ) . isNumeric ( ) & & ! data . attribute ( index ) . isDate ( ) ) {
text . append ( String . format ( "str" , recall ( i ) ) ) ;
text . append ( String . format ( "str" , fMeasure ( i ) ) ) ;
0 , ( int ) Math . ceil ( Utils . log2 ( data . numInstances ( ) ) ) ) ;
return 2 * ( Math . log ( n - 1 ) + 0.5772156649 ) - ( 2 * ( n - 1 ) / n ) ;
double [ ] [ ] predictions = ( ( BatchPredictor ) current )
} else if ( saveVis & & plotInstances ! = null
public String minLogLikelihoodImprovementCVTipText ( ) {
public String minLogLikelihoodImprovementIteratingTipText ( ) {
result . add ( "str" + getNumExecutionSlots ( ) ) ;
double [ ] [ ] predictions = ( ( BatchPredictor ) current )
& & contents [ i ] . getPath ( ) . endsWith ( "str" ) ) {
if ( m_log ! = null & & ! e . isStructureOnly ( ) ) {
if ( m_log ! = null & & ! e . isStructureOnly ( ) ) {
if ( e . getMaxSetNumber ( ) ! = 1 ) {
+ "str" , "str" , 1 , "str" ) ) ;
if ( ! ( h . containsKey ( word ) ) )
buildTree ( data , m_subtreeRaising | | ! m_cleanup ) ;
newTree . buildTree ( ( Instances ) data , m_subtreeRaising | | ! m_cleanup ) ;
data . testCV ( numSets , numSets - 1 ) , ! m_cleanup ) ;
newTree . buildTree ( train , test , ! m_cleanup ) ;
if ( m_Decimals > - 1 & & ! result . isMissing ( i ) ) {
private String m_ParamChar ;
updatedPackagesBuff . append ( localPackage + "str" + repoVersion + "str" ) ;
( att . numValues ( ) > 2 | | m_TransformAll | | m_Numeric ) ) {
setOutputFormat ( new Instances ( getInputFormat ( ) ) ) ;
if ( att . isNominal ( ) & & ( att . numValues ( ) > 2 | | m_Numeric | | m_TransformAll ) ) {
setOutputFormat ( new Instances ( getInputFormat ( ) ) ) ;
( att . numValues ( ) > 2 | | m_TransformAll | | m_Numeric ) ) {
setOutputFormat ( new Instances ( getInputFormat ( ) ) ) ;
return RevisionUtils . extract ( "str" ) ;
if ( ( retrieveFile ( ) = = null ) & & ( outW = = null ) ) {
if ( ( retrieveFile ( ) = = null ) & & ( outW = = null ) )
if ( ( retrieveFile ( ) = = null ) & & ( outW = = null ) ) {
if ( ( retrieveFile ( ) = = null ) & & ( outW = = null ) ) {
if ( retrieveFile ( ) = = null & & outW = = null )
if ( retrieveFile ( ) = = null & & outW = = null )
if ( retrieveFile ( ) = = null & & outW = = null ) {
if ( retrieveFile ( ) = = null & & outW = = null )
if ( message . indexOf ( "str" ) > = 0 ) {
+ ArffLoader . FILE_EXTENSION_COMPRESSED
+ ArffLoader . FILE_EXTENSION + "str"
} else if ( PropertyDialog . getParentFrame ( this ) ! = null ) {
Object rendererO = PluginManager . getPluginInstance ( "str" ,
Object rendererO = PluginManager . getPluginInstance ( "str" ,
tipText = tipText . replace ( "str" , "str" ) ;
Object r = PluginManager . getPluginInstance ( "str" ,
PluginManager . getPluginNamesOfType ( "str" ) ;
if ( m_CanMeasureCpuTime & & ! m_ThreadMonitor . isThreadCpuTimeEnabled ( ) )
if ( canMeasureCPUTime & & ! thMonitor . isThreadCpuTimeEnabled ( ) )
if ( canMeasureCPUTime & & ! thMonitor . isThreadCpuTimeEnabled ( ) )
if ( canMeasureCPUTime & & ! thMonitor . isThreadCpuTimeEnabled ( ) )
tester . setDatasetKeyColumns (
m_trainingSet = new Instances ( m_train , 0 ) ;
protected class HotSpotHashKey implements Serializable {
m_modifyListener . setModifiedStatus ( ClassValuePickerCustomizer . this , m_modified ) ;
m_modifyListener . setModifiedStatus ( ClassAssignerCustomizer . this , true ) ;
public String initializeUsingKMeansPlusPlusMethodTipText ( ) {
if ( Utils . gr ( vals [ m_Attribute ] , 0 ) & & ( count > 1 ) ) {
String type = "str" + Attribute . typeToStringShort ( m_trainingInstances . attribute ( i ) ) + "str" ;
"str" , 1 , "str" ) ) ;
tester . setDatasettKeyColumns (
tester . setResultsetKeyColumns (
if ( partsum > = r | | ( i = = m_popSize - 1 ) ) {
repURL = "str" ;
System . err . println ( "str" + repURL ) ;
conn . setConnectTimeout ( 30000 ) ;
for ( int i = 0 ; i < inst . numValues ( ) ; i + + ) {
if ( true ) {
int indS = - 1 ;
if ( m_useDefaultModel ) {
return TAGS_SELECTION [ m_metricType . ordinal ( ) ] . getReadable ( ) ;
if ( TAGS_SELECTION [ m . ordinal ( ) ] . getReadable ( ) . equals ( metricName ) ) {
metricNames [ i ] = TAGS_SELECTION [ i ] . getReadable ( ) ;
values [ i ] = getNamedMetricValue ( TAGS_SELECTION [ i ] . getReadable ( ) ) ;
while ( ( r = m_random . nextInt ( m_numAttribs ) ) = = m_classIndex ) ;
r = m_random . nextInt ( m_numAttribs ) ;
if ( getResultMatrix ( ) instanceof ResultMatrixLatex )
if ( getResultMatrix ( ) instanceof ResultMatrixCSV )
if ( getResultMatrix ( ) instanceof ResultMatrixHTML )
if ( getResultMatrix ( ) instanceof ResultMatrixSignificance )
m_dsSaver . setSaverTemplate ( m_dsSaver . getSaverTemplate ( ) ) ;
m_dbaseURLText . setText ( ( ( DatabaseConverter ) m_dsSaver . getSaverTemplate ( ) ) . getUrl ( ) ) ;
m_userNameText . setText ( ( ( DatabaseConverter ) m_dsSaver . getSaverTemplate ( ) ) . getUser ( ) ) ;
m_tabBox . setSelected ( ( ( DatabaseSaver ) m_dsSaver . getSaverTemplate ( ) ) . getRelationForTableName ( ) ) ;
m_idBox . setSelected ( ( ( DatabaseSaver ) m_dsSaver . getSaverTemplate ( ) ) . getAutoKeyGeneration ( ) ) ;
( ( DatabaseSaver ) m_dsSaver . getSaverTemplate ( ) ) . setTableName ( m_tableText . getText ( ) ) ;
m_prefixText . setText ( m_dsSaver . getSaverTemplate ( ) . filePrefix ( ) ) ;
m_directoryText . setText ( m_dsSaver . getSaverTemplate ( ) . retrieveDir ( ) ) ;
setSelected ( ( ( FileSourcedConverter ) m_dsSaver . getSaverTemplate ( ) ) . getUseRelativePath ( ) ) ;
( ( FileSourcedConverter ) m_dsSaver . getSaverTemplate ( ) ) .
if ( m_dsSaver . getSaverTemplate ( ) instanceof FileSourcedConverter ) {
part = part . replace ( "str" , "str" ) ;
if ( ! ( m_ClassifierTemplate instanceof weka . core . Drawable ) ) {
public String thresholdTipText ( ) {
public double getThreshold ( ) {
setThreshold ( Double . parseDouble ( optionString ) ) ;
options [ current + + ] = "str" + getThreshold ( ) ;
+ Utils . doubleToString ( Math . abs ( getThreshold ( ) ) , 8 , 3 ) + "str" ) ;
if ( ClassDiscovery . hasInterface ( Comparable . class , getColumnClass ( mSortColumn ) ) )
protected JTextField m_cost_aa = new JTextField ( "str" , 5 ) ;
protected JTextField m_cost_bb = new JTextField ( "str" , 5 ) ;
double fpCost = 0.0 ;
double fnCost = 0.0 ;
double fpCost = 0.0 ;
double fnCost = 0.0 ;
newVector . addElement ( new Option ( "str"
setMissingSeparate ( Utils . getFlag ( "str" , options ) ) ;
public String missingSeparateTipText ( ) {
if ( getMissingSeparate ( ) ) {
if ( ! m_missingSeparate & &
int nx = ( ! m_missingSeparate )
if ( ! m_missingSeparate ) {
if ( ! m_missingSeparate ) {
int nx = ( ! m_missingSeparate )
int ny = ( ! m_missingSeparate )
if ( ! m_missingSeparate ) {
if ( ! m_missingSeparate ) {
if ( ! m_missingSeparate ) {
if ( ! m_missingSeparate ) {
if ( ! m_missingSeparate ) {
m_missingSeparate = false ;
protected String m_Find = "str" ;
protected String m_Replace = "str" ;
setFind ( "str" ) ;
setReplace ( "str" ) ;
pred [ j ] = m_Shrinkage * m_Classifiers [ j ] [ i ] . classifyInstance ( instance ) ;
if ( ! Instance . isMissingValue ( x ) & & ! Instance . isMissingValue ( y ) ) {
if ( ! Instance . isMissingValue ( tempAUC ) ) {
if ( Instance . isMissingValue ( value ) ) {
if ( m_Type = = DATE | | Instance . isMissingValue ( value ) ) return true ;
for ( int j = 0 ; j < files . length ; j + + ) {
+ files [ j ] . getName ( ) . replaceAll ( "str" , "str" )
return RevisionUtils . extract ( "str" ) ;
return RevisionUtils . extract ( "str" ) ;
protected int m_plotAreaWidth = 384 ;
protected int m_plotAreaHeight = 384 ;
m_CoverageStatisticsAvailable = false ;
m_ComplexityStatisticsAvailable = false ;
return RevisionUtils . extract ( "str" ) ;
example = new Instance ( 1.0 , attributes ) ;
return RevisionUtils . extract ( "str" ) ;
result . enableAll ( ) ;
String [ ] options = Utils . splitOptions ( get ( "str" , ResultMatrix . class . getName ( ) + "str" ) ) ;
return RevisionUtils . extract ( "str" ) ;
for ( int i = selected . length - 1 ; i > = 0 ; i - - ) {
setAttributeName ( Utils . unbackQuoteChars ( Utils . getOption ( "str" , options ) ) ) ;
result . add ( Utils . backQuoteChars ( getAttributeName ( ) ) ) ;
if ( outliers . length ( ) > 0 & & m_outlierTreatmentMethod = = Outlier . ASEXTREMEVALUES ) {
return "str" + ( m_ClassIndex + 1 ) + "str" + ( dataset . m_ClassIndex + 1 ) ;
return "str" + m_Attributes . size ( ) + "str" + dataset . m_Attributes . size ( ) ;
throw new Exception ( "str" + name ) ;
if ( m_BatchBuffer = = null )
if ( m_BatchBuffer = = null )
gx . setFont ( new Font ( null , Font . PLAIN , 9 ) ) ;
gx . setFont ( new Font ( null , Font . PLAIN , 9 ) ) ;
temp . getGraphics ( ) . setFont ( new Font ( null , Font . PLAIN , 9 ) ) ;
tempL . setFont ( new Font ( null , Font . PLAIN , 9 ) ) ;
temp . setFont ( new Font ( null , Font . PLAIN , 9 ) ) ;
BrowserHelper . openURL ( m_Self , "str" ) ;
if ( node . m_Capabilities ! = null & & m_CapabilitiesFilter ! = null ) {
short sh = rs . getShort ( i ) ;
short sh = rs . getShort ( i ) ;
return RevisionUtils . extract ( "str" ) ;
short sh = rs . getShort ( i ) ;
return RevisionUtils . extract ( "str" ) ;
repwidth + 2 , fm . getAscent ( ) + vpad ) ;
super ( owner , pe . getClass ( ) . getName ( ) , true ) ;
return RevisionUtils . extract ( "str" ) ;
return RevisionUtils . extract ( "str" ) ;
return RevisionUtils . extract ( "str" ) ;
return RevisionUtils . extract ( "str" ) ;
setFilter ( new weka . filters . supervised . instance . SpreadSubsample ( ) ) ;
return RevisionUtils . extract ( "str" ) ;
return RevisionUtils . extract ( "str" ) ;
return RevisionUtils . extract ( "str" ) ;
public double [ ] [ ] coefficients ( ) {
setDesignatedClass ( new SelectedTag ( OPTIMIZE_POS_NAME , TAGS_OPTIMIZE ) ) ;
options [ current + + ] = "str" ; options [ current + + ] = "str" + ( m_ClassMode + 1 ) ;
System . out . println ( "str" ) ;
System . out . println ( "str" + anyJars [ j ] . getPath ( )
System . err . println ( "str"
System . out . println ( "str" ) ;
System . err . println ( "str" + tempBeanCompName ) ;
System . out . println ( "str" ) ;
System . err . println ( "str" + tempBeanCompName
System . err . println ( "str" + algName ) ;
System . err . println ( "str" + tempBeanCompName
System . err . println ( "str" + tempBeanCompName
println ( "str" ) ;
System . err . println ( "str" ) ;
System . err . println ( "str" ) ;
System . err . println ( "str" ) ;
System . out . println ( "str" ) ;
System . err . println ( "str"
System . err . println ( "str" ) ;
System . err . println ( "str" + fileName + "str" ) ;
System . err . println ( "str" ) ;
"str" , null ) ;
current . addElement ( "str" ) ;
for ( int i = 0 ; i < getInstance ( ) . numValues ( ) ; i + + ) {
for ( int i = 0 ; i < getInstance ( ) . numValues ( ) ; i + + ) {
for ( int i = 0 ; i < getInstance ( ) . numValues ( ) ; i + + ) {
for ( int i = 0 ; i < getInstance ( ) . numValues ( ) ; i + + ) {
private boolean m_dontReplaceMissing = false ;
if ( ! m_dontReplaceMissing ) {
+ "str" ) ;
+ "str" ) ;
private double m_PeriodicPruningRate = - 1 ;
result . m_Capabilities . add ( cap ) ;
result . m_Capabilities . add ( cap ) ;
result . m_Capabilities . add ( cap ) ;
if ( Utils . sm ( currDistance , distance ) ) {
if ( Utils . sm ( currDistance , distance ) ) {
if ( Utils . eq ( distance , 0 ) )
if ( Utils . eq ( distance , 0 ) )
if ( ( k < 1 ) | | ( k > j + 1 ) ) {
private static final long serialVersionUID = - 5687069451420259135L ;
if ( inBag [ j ] [ i ] )
if ( hasImmediateOutputFormat ( ) | | isFirstBatchDone ( ) ) {
"str" , 1 , "str" ) ) ;
protected double [ ] [ ] m_probOfWordGivenClass ;
protected double [ ] m_probOfClass ;
protected int m_numAttributes ;
protected int m_numClasses ;
protected double [ ] m_lnFactorialCache = new double [ ] { 0.0 , 0.0 } ;
for ( int c = 0 ; c < m_numClasses ; c + + )
m_probOfWordGivenClass [ c ] [ att ] = 1 ;
m_probOfWordGivenClass [ classIndex ] [ instance . index ( a ) ] + = numOccurences ;
double [ ] probOfClassGivenDoc = new double [ m_numClasses ] ;
for ( int i = 0 ; i < m_numClasses ; i + + )
probOfClassGivenDoc [ i ] = Math . exp ( logDocGivenClass [ i ] - max ) * m_probOfClass [ i ] ;
answer + = ( freqOfWordInDoc * m_probOfWordGivenClass [ classIndex ] [ inst . index ( i ) ]
if ( m_lnFactorialCache . length < = n ) {
m_lnFactorialCache = tmp ;
return m_lnFactorialCache [ n ] ;
for ( int w = 0 ; w < m_numAttributes ; w + + )
for ( m = 0 ; m < inst . numValues ( ) ; m + + ) {
String filename = System . getProperty ( "str" ) + File . separator + "str" ;
String filename = System . getProperty ( "str" ) + File . separator + "str" ;
setClusterer ( new SimpleKMeans ( ) ) ;
result = new TechnicalInformation ( Type . MASTERSTHESIS ) ;
result = new TechnicalInformation ( Type . MASTERSTHESIS ) ;
popup = popup & & ( getInstances ( ) ! = null ) ;
inst = new Instances ( inst ,
/ 100 D * inst . numInstances ( ) )
+ source . getDataSet ( ) . numInstances ( ) + "str" ) ;
outBuff . append ( "str" + source . getDataSet ( ) . numInstances ( ) + "str" ) ;
result = cap . test ( data . attribute ( 1 ) . relation ( 0 ) ) ;
if ( ! getUseProb ( ) ) {
throw new Exception ( "str" ) ;
setKNN ( - 1 ) ;
double H = Math . min ( C2 , - gamma + C1 ) ;
double H = Math . min ( C2 , C1 + gamma ) ;
import weka . core . CheckScheme . PostProcessor ;
import weka . core . CheckScheme . PostProcessor ;
m_Instances = new Instances ( data ) ;
m_numFolds = m_Instances . numInstances ( ) ;
m_Instances . randomize ( random ) ;
bestSubset = hillclimbRace ( m_Instances , random ) ;
bestSubset = schemataRace ( m_Instances , random ) ;
bestSubset = rankRace ( m_Instances , random ) ;
result . add ( "str" ) ;
m_correlation [ j ] [ i ] = corr ;
delimiters = newDelimiters . replaceAll ( "str" , "str" ) . replaceAll ( "str" , "str" ) ;
if ( varActual * varPredicted < = 0 ) {
System . err . println ( "str" + name + "str" ) ;
current * = - 11 ;
double fract = Math . abs ( current - Math . rint ( current ) ) ;
if ( data . instance ( i ) . isMissing ( n ) ) {
options [ current + + ] = "str" ; options [ current + + ] = "str" + getStepSize ( ) ;
options [ current + + ] = "str" ; options [ current + + ] = "str" + getStartPoint ( ) ;
m_globalStdDev ) , 1 , 3 )
result . setValue ( Field . PS , "str" ) ;
result . setValue ( Field . PS , "str" ) ;
result . setValue ( Field . PS , "str" ) ;
m_globalDeviation ) , 1 , 3 )
INPROCEEDINGS ( "str" , "str" ) ,
c = c . add ( r ) ;
if ( ( m_NumIterationsPerformed + 1 ) % subCmtySize = = 0 ) {
System . err . println ( m_NumIterationsPerformed + "str" + subCmtySize ) ;
if ( m_Hashtable . containsKey ( store ) ) {
DataGenerator . makeData ( new LED24 ( ) , args ) ;
newVector . addElement ( new Option ( "str"
setLocallyPredictive ( ! Utils . getFlag ( "str" , options ) ) ;
if ( ! getLocallyPredictive ( ) ) {
m_locallyPredictive = true ;
line + = padString ( "str" + Utils . doubleToString ( getCount ( getDisplayRow ( i - 1 ) ) , 0 ) + "str" ,
if ( Utils . getFlag ( "str" , options ) )
if ( Utils . getFlag ( "str" , options ) )
if ( Utils . getFlag ( "str" , options ) )
return super . getOptions ( ) ;
return super . getOptions ( ) ;
throw new Exception ( "str" ) ;
newVector . addElement ( new Option ( "str" , "str" , 1 , "str" ) ) ;
if ( m_bGenerateNet ) {
member = method . invoke ( o , ( Object [ ] ) null ) ;
optionsText . append ( "str" ) ;
hidden = Boolean . getBoolean ( tok . nextToken ( ) ) ;
return m_Ignored . containsKey ( displayName ) ;
if ( m_Ignored . containsKey ( c ) )
( ( MetaBean ) bc ) . restoreBeans ( ) ;
group . shiftBeans ( bi , true ) ;
( ( MetaBean ) getBean ( ) ) . shiftBeans ( this , false ) ;
protected long [ ] m_keys ;
return m_Helper . getColumnCount ( ) + 1 ;
instances . numAttributes ( ) , true ) ;
result . append ( "str" + cells [ 0 ] [ 1 ] ) ;
result . append ( "str" + cells [ 0 ] [ 1 ] + "str" ) ;
result . append ( "str" + cells [ 0 ] [ j ] + "str" ) ;
result . append ( "str" + cells [ 0 ] [ j ] + "str" ) ;
( double ) premiseCount * ( double ) ( m_totalTransactions - consequenceCount ) /
attributes . addElement ( m_BaseFormat . classAttribute ( ) . copy ( ) ) ;
m_Class = "str" ;
newVector . addElement ( new Option ( "str" , "str" , 0 , "str" ) ) ;
setUseProb ( ! Utils . getFlag ( "str" , options ) ) ;
m_LNorm = newLNorm ;
Filter . batchFilterFile ( new Normalize ( ) , argv ) ;
Filter . filterFile ( new Normalize ( ) , argv ) ;
if ( m_sparseIndices [ i ] ! = ( int ) m_classIndex ) {
if ( m_sparseIndices [ i ] ! = ( int ) m_classIndex ) {
setNominalIndices ( "str" ) ;
res = "str" + res ;
"str" , 1 , "str" ) ) ;
add ( new javax . swing . JLabel ( "str" ) ,
result . append ( Double . toString ( Math . exp ( probOfWordGivenClass [ c ] [ w ] ) ) ) . append ( "str" ) ;
if ( m_Instances . attribute ( i ) . name ( ) . toLowerCase ( ) . equals ( "str" ) ) {
} else if ( m_Instances . attribute ( i ) . name ( ) . toLowerCase ( ) . equals ( "str" ) ) {
m_Discretizer . setAttributeIndices ( "str" + ( instances . classIndex ( ) + 1 ) ) ;
public double [ ] distributionForInstance ( Instance instance ) throws Exception {
return m_Classifier . distributionForInstance ( instance ) ;
addF . setAttributeIndex ( "str" ) ;
addF . setAttributeIndex ( "str" ) ;
addF . setAttributeIndex ( "str" ) ;
Instances train = trainCV ( numFolds , numFold ) ;
( m_CompareCombo . getSelectedIndex ( ) < 0 ) ) {
m_SelectCols . setInvert ( false ) ;
if ( bSubstract ) {
m_ClassPriors [ 0 ] = m_ClassPriorsSum = 0 ;
if ( ! m_kNNValid & & ( m_CrossValidate ) & & ( m_kNNUpper > = 1 ) ) {
+ "str" ) ;
String [ ] options = new String [ classifierOptions . length + 8 ] ;
while ( ! ( ( alam > = upper ) | | ( m_f > fold + m_ALF * alam * m_Slope ) ) ) {
public HierarchyPropertyParser ( String p , String delim ) throws Exception {
public void build ( String p , String delim ) throws Exception {
public synchronized void goToChild ( int pos ) throws Exception {
static final int MIN_RECORD_SIZE = 5 ;
public void buildDecList ( Instances data , boolean leaf ) throws Exception {
boolean leaf ) throws Exception {
public abstract boolean covers ( Instance datum ) ;
public abstract void grow ( Instances data ) throws Exception ;
public abstract boolean hasAntds ( ) ;
public abstract double getConsequent ( ) ;
public abstract double size ( ) ;
public void performRequest ( String request ) {
public static final int FORMAT_AVAILABLE = 1 ;
public static final int INSTANCE_AVAILABLE = 2 ;
public static final int BATCH_FINISHED = 3 ;
public abstract void buildClassifier ( Instances instances ) throws Exception ;
public abstract String leftSide ( Instances data ) ;
public abstract String rightSide ( int index , Instances data ) ;
public abstract double [ ] weights ( Instance instance ) ;
public abstract int whichSubset ( Instance instance ) throws Exception ;
public Operator ( char opp ) {
private int infixPriority ( char opp ) {
private int stackPriority ( char opp ) {
protected static final String NO_SOURCE = "str" ;
public void setOptions ( String [ ] options ) throws Exception {
public static double log2Binomial ( double a , double b ) {
public static final int NUMERIC = 0 ;
public static final int NOMINAL = 1 ;
public static final int STRING = 2 ;
public static final int DATE = 3 ;
public static final int ORDERING_SYMBOLIC = 0 ;
public static final int ORDERING_ORDERED = 1 ;
public static final int ORDERING_MODULO = 2 ;
private static final int STRING_COMPRESS_THRESHOLD = 200 ;
public void performRequest ( String request ) {
public void findRules ( Instances [ ] dataByClass , int lvl ) throws Exception {
public void buildClassifier ( Instances instances ) throws Exception {
public void buildClassifier ( Instances instances ) throws Exception {
public void setOptions ( String [ ] options ) throws Exception {
double getMeasure ( String measureName ) ;
public void buildClassifier ( Instances data ) throws Exception {
public void buildTree ( Instances data , boolean keepData ) throws Exception {
protected ClassifierTree getNewTree ( Instances data ) throws Exception {
public void buildClassifier ( Instances instances ) throws Exception {
public void performRequest ( String request ) {
public void setOptions ( String [ ] options ) throws Exception {
public void grow ( Instances data ) throws Exception {
public void buildClassifier ( Instances instances ) throws Exception {
protected static final String NO_SOURCE = "str" ;
private static String [ ] FOR_JFC_1_1_DCBM_BUG = { "str" } ;
protected static final String NOT_RUNNING = "str" ;
protected static final double stdDev ( int attr , Instances inst ) {
protected static final double absDev ( int attr , Instances inst ) {
public void buildClassifier ( Instances instances ) throws Exception {
public abstract Filter getFilter ( ) ;
public static final int GRID = 0 ;
public static final int SINE = 1 ;
public static final int RANDOM = 2 ;
public static final int ORDERED = 0 ;
public static final int RANDOMIZED = 1 ;
private static void println ( Object obj ) {
protected void insertHoldOutSet ( Instances data ) throws Exception {
public void setOptions ( String [ ] options ) throws Exception {
double pc ) throws Exception {
private void getIndex ( StreamTokenizer tokenizer ) throws IOException {
protected Object m_Backup ;
protected PropertyChangeSupport m_Support = new PropertyChangeSupport ( this ) ;
public void setAsText ( String text ) {
void performRequest ( String requestName ) ;
protected static final double MIN_VALUE = 0.05 ;
public void setOptions ( String [ ] options ) throws Exception {
public void performRequest ( String request ) {
public void setOptions ( String [ ] options ) throws Exception {
private static final String [ ] CATEGORY_NAMES = { "str" , "str" } ;
public void setOptions ( String [ ] options ) throws Exception {
public void buildClassifier ( Instances instances ) throws Exception {
public double [ ] distributionForInstance ( Instance instance ) throws Exception {
public void performRequest ( String request ) {
public void buildClassifier ( Instances data ) throws Exception {
public void performRequest ( String request ) {
public static double chiSquaredProbability ( double x , double v ) {
public static double normalInverse ( double y0 ) {
public static double lnGamma ( double x ) {
static double p1evl ( double x , double coef [ ] , int N ) {
static double polevl ( double x , double coef [ ] , int N ) {
static double incompleteGammaComplement ( double a , double x ) {
static double gamma ( double x ) {
static double stirlingFormula ( double x ) {
public static double incompleteBeta ( double aa , double bb , double xx ) {
static double incompleteBetaFraction1 ( double a , double b , double x ) {
static double incompleteBetaFraction2 ( double a , double b , double x ) {
static double powerSeries ( double a , double b , double x ) {
protected static final String NO_SOURCE = "str" ;
public void buildClassifier ( Instances data ) throws Exception {
protected ClassifierTree getNewTree ( Instances data ) throws Exception {
void setWrappedAlgorithm ( Object algorithm ) ;
public void performRequest ( String request ) {
protected static final double MISSING_VALUE = Double . NaN ;
public void setOptions ( String [ ] options ) throws Exception {
public void setAsText ( String text ) {
public static final String RELATION_NAME = "str" ;
public static final String THRESHOLD_NAME = "str" ;
public static String typeName ( int type ) {
private Instances defineDataset ( Random random ) throws Exception {
public int [ ] LUDecomposition ( ) throws Exception {
public void solve ( double [ ] bb ) throws Exception {
public static final String RELATION_NAME = "str" ;
public void setOptions ( String [ ] options ) throws Exception {
public void performRequest ( String request ) {
public static final int UNCONNECTED = 0 ;
public static final int PURE_INPUT = 1 ;
public static final int PURE_OUTPUT = 2 ;
public static final int INPUT = 4 ;
public static final int OUTPUT = 8 ;
public static final int CONNECTED = 16 ;
public static final double correlation ( double y1 [ ] , double y2 [ ] , int n ) {
newVector . addElement ( new Option ( "str" ,
m_kernelEvals = 0 ;
if ( ! att . isNominal ( ) | | ( j = = getInputFormat ( ) . classIndex ( ) ) ) {
String [ ] options = new String [ 15 ] ;
if ( m_Universe = = null ) m_Universe = m_Ranges ;
protected int m_maxChunkSize = 8000 ;
JMenuItem runGC = new JMenuItem ( "str" ) ;
protected Filter m_Filter = new weka . filters . supervised . attribute . AttributeSelection ( ) ;
this ( new weka . classifiers . rules . ZeroR ( ) , new weka . filters . supervised . attribute . AttributeSelection ( ) ) ;
protected Remove m_attributeFilter = new Remove ( ) ;
new weka . classifiers . functions . Logistic ( ) ;
m_attScores = new double [ data . numAttributes ( ) ] ;
setComplexityParameter ( ( new Double ( optionString ) ) . doubleValue ( ) ) ;
options [ current + + ] = "str" + getComplexityParameter ( ) ;
public String complexityParameterTipText ( ) {
public void setComplexityParameter ( double svmC ) {
public double getComplexityParameter ( ) {
double [ ] newVals = null ;
newVals [ m_numAttribs ] = inst . value ( inst . numAttributes ( ) - 1 ) ;
for ( int i = 0 ; i < m_eTranspose [ 0 ] . length ; i + + ) {
for ( int j = 1 ; j < m_eTranspose . length ; j + + ) {
inst . value ( j - 1 ) ) ;
newVals [ i ] = tempval ;
for ( int i = index + 1 ; i < m_Indices . length ; i + + ) {
int del = 0 ;
setDecay ( true ) ;
setDecay ( false ) ;
if ( options [ i ] . length ( ) ! = 2 ) {
public Range ( String rangeList ) {
public void setRanges ( String rangeList ) {
public boolean isInRange ( int index ) {
throw new RuntimeException ( "str" ) ;
public int [ ] getSelection ( ) {
throw new RuntimeException ( "str" ) ;
for ( j = 0 ; j < instances . numAttributes ( ) ; j + + ) {
for ( j = 0 ; j < instances . numAttributes ( ) ; j + + ) {
int bagSize = data . numInstances ( ) * m_BagSizePercent / 100 ;
int bagSize = data . numInstances ( ) * m_BagSizePercent / 100 ;
+ "str" + PROPERTY_FILE + "str"
m_ColourCombo . setSelectedIndex ( prefC ) ;
return new Instances ( "str" , fv , 100 ) ;
return new Instances ( "str" , fv , 100 ) ;
plotSize . addElement ( new Integer ( Plot2D . DEFAULT_SHAPE_SIZE ) ) ;
plotSize . setElementAt ( new Integer ( 1 ) , i ) ;
plotSize . setElementAt ( new Integer ( 1 ) , i ) ;
plotSize . addElement ( new Double ( Plot2D . DEFAULT_SHAPE_SIZE ) ) ;
public static final double DEFAULT_SHAPE_SIZE = 2 ;
protected int m_NumFolds = 3 ;
protected int m_Mode = ThresholdSelector . TUNING_DATA ;
setNumFolds ( 3 ) ;
m_Mode = ThresholdSelector . TUNING_DATA ;
protected int m_NumFolds = 3 ;
protected int m_Mode = ThresholdSelector . TUNING_DATA ;
setNumFolds ( 3 ) ;
m_Mode = ThresholdSelector . TUNING_DATA ;
if ( sumj [ nj - 1 ] > 0.0 ) {
if ( counts [ ni - 1 ] [ nj - 1 ] > 0.0 & & total_missing ! = sum ) {
if ( m_attributeRanking [ i ] [ 1 ] > m_threshold ) {
append ( Utils . doubleToString ( m_attributeRanking [ i ] [ 1 ] ,
if ( m_attributeRanking [ i ] [ 1 ] > m_threshold ) {
if ( m_attributeRanking [ i ] [ 1 ] > m_threshold ) {
if ( m_attributeRanking [ i ] [ 1 ] > m_threshold ) {
if ( m_attributeRanking [ i ] [ 1 ] > m_threshold ) {
if ( m_attributeRanking [ i + 1 ] [ 1 ] > m_threshold ) {
protected Classifier m_Classifier = new weka . classifiers . DecisionStump ( ) ;
protected Classifier m_Classifier = new weka . classifiers . DecisionStump ( ) ;
text . append ( "str" + m_sons [ i ] . m_train + "str" ) ;
text . append ( "str" + m_sons [ i ] . m_train + "str" ) ;
text . append ( "str" + m_sons [ i ] . m_train + "str" ) ;
text . append ( "str" + m_sons [ i ] . m_train + "str" ) ;
String [ ] resultNames = new String [ RESULT_SIZE + addm ] ;
Object [ ] result = new Object [ RESULT_SIZE + addm ] ;
m_Discretizer . setFindNumBins ( true ) ;
m_Discretizer . setFindNumBins ( true ) ;
protected JTextArea m_LogText = new JTextArea ( 4 , 20 ) ;
text . append ( "str" ) ;
for ( int i = 0 ; i < m_Instances . attribute ( index ) . numValues ( ) ; i + + ) {
for ( int i = 0 ; i < m_Instances . attribute ( index ) . numValues ( ) ; i + + ) {
protected JFileChooser m_FileChooser = new JFileChooser ( new File ( System . getProperty ( "str" ) ) ) ;
protected JFileChooser m_FileChooser = new JFileChooser ( new File ( System . getProperty ( "str" ) ) ) ;
JFileChooser fileChooser = new JFileChooser ( new File ( System . getProperty ( "str" ) ) ) ;
JFileChooser fileChooser = new JFileChooser ( new File ( System . getProperty ( "str" ) ) ) ;
JFileChooser fileChooser = new JFileChooser ( new File ( System . getProperty ( "str" ) ) ) ;
protected JFileChooser m_FileChooser = new JFileChooser ( new File ( System . getProperty ( "str" ) ) ) ;
JFileChooser fileChooser = new JFileChooser ( new File ( System . getProperty ( "str" ) ) ) ;
protected boolean m_ShowStdDevs = false ;
if ( attributeValues = = null ) {
xpturb = ( int ) ( ( double ) m_JitterVal * ( xj / 2.0 ) ) ;
ypturb = ( int ) ( ( double ) m_JitterVal * ( yj / 2.0 ) ) ;
if ( selected ! = - 1 ) {
oh . setOptions ( ( String [ ] ) defaultOptions . clone ( ) ) ;
throw new Exception ( "str" ) ;
Runnable r = new Runnable ( ) {
"str" . length ( ) ) ;
+ Utils . padLeft ( "str" , width ) + "str" ;
( m_Classifier instanceof WeightedInstancesHandler ) ) {
( m_Classifier instanceof WeightedInstancesHandler ) ) {
if ( optionArray [ i ] . indexOf ( "str" ) ! = - 1 ) {
if ( ( m_unpruned ) & & ( ! m_subtreeRaising ) ) {
if ( ( m_unpruned ) & & ( ! m_subtreeRaising ) ) {
if ( m_ClassifierExample = = null ) {
if ( m_ClassifierExample = = null ) {
if ( cardId ! = null & & cardId . length ( ) > 0 ) {
if ( cache . getExpires ( ) < 0 l ) {
private long order ;
public long getOrder ( ) {
public void setOrder ( long order ) {
public final static String VERSION = "str" ;
public final static String VERSION = "str" ;
String . format ( "str" , tagId ) ) ;
_payPackage . remove ( "str" ) ;
} else if ( event = = XMLStreamConstants . CHARACTERS | | event = = XMLStreamConstants . CDATA ) {
MpArticle article ) throws WeixinException {
obj . put ( "str" , article ) ;
public JsonResult updateMaterialArticle ( String mediaId , int index , MpArticle article )
return mediaApi . updateMaterialArticle ( mediaId , index , article ) ;
private int expireSeconds ;
public static QRParameter createTemporary ( int expireSeconds , long sceneValue ) {
qr . sceneValue = Long . toString ( sceneValue ) ;
} else if ( "str" . contains ( suffixName ) ) {
public void run ( SampleConfiguration configuration , Environment environment ) {
@Then ( "str" )
@Then ( "str" )
String value = key . split ( PROPERTIES_PREFIX ) [ 1 ] ;
boolean enableGC = a . getBoolean ( "str" , true ) ;
public native CompletableFuture < String > generateVideoThumbnail ( AsyncReader imageBlob , int fileSize , String fileName , String mimeType ) ;
public static Optional < byte [ ] > generateThumbnail ( byte [ ] imageBlob ) {
return Optional . of ( baos . toByteArray ( ) ) ;
return Optional . empty ( ) ;
fut . complete ( generateThumbnail ( bytes ) ) ;
public static Mp3CoverImage extractCoverArt ( byte [ ] rawMp3 ) throws NoSuchTagException , UnsupportedTagException , InvalidDataException {
public static class NoSuchTagException extends Exception {
public static class UnsupportedTagException extends Exception {
public static class InvalidDataException extends Exception {
if ( oldIndex < newIndex )
{ "str" , new Random ( 0 ) }
byte [ ] data = new byte [ 2 * 1024 * 1024 - 6 * 1024 ] ;
e . printStackTrace ( ) ;
if ( ( b & 0xff ) < 0x20 & & b ! = ( byte ) 0xA & & b ! = ( byte ) 0xD )
Start . LOCAL . main ( args ) ;
boolean hasMime = thumbnailSrcImageSize > = MimeTypes . HEADER_BYTES_TO_IDENTIFY_MIME_TYPE ;
if ( fileSize > MimeTypes . HEADER_BYTES_TO_IDENTIFY_MIME_TYPE ) {
httpExchange . getResponseHeaders ( ) . set ( "str" , "str" ) ;
UserPublicKeyLink . UsernameClaim node = UserPublicKeyLink . UsernameClaim . create ( username , user . secretSigningKey , LocalDate . now ( ) . plusMonths ( 2 ) ) ;
UserPublicKeyLink . UsernameClaim node2 = UserPublicKeyLink . UsernameClaim . create ( username , user . secretSigningKey , LocalDate . now ( ) . plusMonths ( 3 ) ) ;
UserPublicKeyLink . UsernameClaim node3 = UserPublicKeyLink . UsernameClaim . create ( username , user3 . secretSigningKey , LocalDate . now ( ) . plusMonths ( 2 ) ) ;
throw new IllegalStateException ( "str" + claimed + "str" + computed ) ;
. thenApply ( multihash1 - > new TreeNode ( this , multihash1 ) ) ;
int FRAGMENTs_PER_QUERY = 1 ;
dout . writeLong ( modified . toEpochSecond ( ZoneOffset . UTC ) ) ;
long modified = din . readLong ( ) ;
return new FileProperties ( name , size , LocalDateTime . ofEpochSecond ( modified , 0 , ZoneOffset . UTC ) , isHidden , thumbnail ) ;
FileTreeNode userRoot2 = context2 . getUserRoot ( ) . get ( ) ;
if ( root . hash . isPresent ( ) & & ! root . hash . equals ( newRoot . hash ) )
OPTIONS . put ( "str" , "str" ) ;
native public byte [ ] post ( String url , byte [ ] payload , boolean unzip ) throws IOException ;
try ( DataOutputStream dout = new DataOutputStream ( bout ) ) {
DataInputStream din = new DataInputStream ( new ByteArrayInputStream ( res ) ) ;
staticData . put ( entry . pointer . writer , entry ) ;
int corenodePort = Args . getInt ( "str" , HTTPCoreNodeServer . PORT ) ;
long size = ( long ) din . readDouble ( ) ;
root = new TreeNode ( newRoot . keys , storage . put ( newRoot . serialize ( ) ) ) ;
root = new TreeNode ( newRoot . keys , storage . put ( newRoot . serialize ( ) ) ) ;
System . out . println ( "str" + new ByteArrayWrapper ( mapKey ) + "str" + new ByteArrayWrapper ( value ) ) ;
Args . parse ( new String [ ] { "str" , "str" , "str" , Args . getArg ( "str" , "str" ) } ) ;
public boolean removeFollowRequest ( UserPublicKey owner , byte [ ] data )
Args . parse ( new String [ ] { "str" , "str" } ) ;
Start . main ( new String [ ] { "str" , "str" , "str" , "str" , "str" , domain , "str" } ) ;
List < Future < Object > > futures = new ArrayList < > ( ) ;
public static final int THREADS = 200 ;
private static final String CREATE_STORAGE_TABLE = "str" ;
stmt = conn . prepareStatement ( "str" ) ;
HTTPCoreNodeServer server = new HTTPCoreNodeServer ( AbstractCoreNode . getDefault ( ) , new InetSocketAddress ( "str" , port ) ) ;
if ( Args . hasParameter ( "str" ) )
public final String username ;
int frags = 60 * 2 ;
System . out . println ( "str" + quota / 1024 + "str" ) ;
Assert . assertEquals ( 5111111_000_000L , Utils . toNano ( "str" , "str" ) ) ;
protected boolean showLimitNotification = true ;
public static final Icon ICON = IconLoader . getIcon ( "str" ) ;
protected String getContentType ( @NotNull RunnerLayoutUi runnerLayoutUi ) {
Disposer . register ( tab , newConsole ) ;
return form ! = null & & form . isSettingsModified ( settings ) ;
GrepHighlightFilter grepHighlightFilter = weakHashMap . get ( console ) ;
sb . append ( "str" ) . append ( System . identityHashCode ( console ) ) . append ( "str" ) . append (
sb . append ( System . identityHashCode ( console ) ) . append ( "str" ) . append ( consoleViewGrepHighlightFilterEntry . getKey ( ) ) ;
if ( grepExpressionGroups . isEmpty ( ) & & grepExpressionItems ! = null & & ! grepExpressionItems . isEmpty ( ) ) {
public int getMaxProgress ( ) {
public void setOnValueChangedListener ( OnValueChangedListener listener ) {
httpRequest . setUri ( url . getFile ( ) ) ;
public void beforeCatch ( Channel clientChannel , Throwable cause ) throws Exception {
cause . printStackTrace ( ) ;
public void afterCatch ( Channel clientChannel , Channel proxyChannel , Throwable cause ) throws Exception {
cause . printStackTrace ( ) ;
return new PaginationInterceptor ( ) . setLimit ( - 1 ) ;
gmlreader . load ( "str" , graph ) ;
hyperreader . load ( "str" , graph ) ;
private boolean hybridized = true ;
ACTIVE_SWITCHES . put ( SynchronizedBlocks . class , SynchronizedBlocks . WITH_SYNCHRONIZED ) ;
data . _set ( rId , r ) ;
BaseDummyMinMaxTransformer . denormalizeX ( data , minColumnValues , maxColumnValues ) ;
BaseDummyMinMaxTransformer . denormalizeX ( data , minColumnValues , maxColumnValues ) ;
public static final long RANDOM_SEED = 42L ;
protected String dbName ;
private int connectionTimeoutMillis = ( int ) TimeUnit . SECONDS . toMillis ( 30 ) ;
assertEquals ( TimeUnit . SECONDS . toMillis ( 30 ) , defaultConfig . connectionTimeoutMillis ( ) ) ;
private final int constraintsRemoved ;
int constraintsAdded , int constraintsRemoved )
this . constraintsRemoved = constraintsRemoved ;
| | isPositive ( constraintsRemoved ) ;
& & constraintsRemoved = = that . constraintsRemoved ;
result = 31 * result + constraintsRemoved ;
assertByteBufContains ( tailSlice , INT_64 , time . toLocalTime ( ) . toNanoOfDay ( ) , INT_32 , time . getOffset ( ) . getTotalSeconds ( ) ) ;
exception . expectMessage ( "str" ) ;
private static final int READ_REPLICA_COUNT = 2 ;
private static final int READ_REPLICA_COUNT = 1 ;
return readServers . hop ( ) ;
return writeServers . hop ( ) ;
StubServer server = StubServer . start ( "str" , 9001 ) ;
. updateWith ( Neo4jSettings . DATA_DIR , tempDir . getRoot ( ) . getAbsolutePath ( ) . replace ( "str" , "str" ) ) ) ;
assertThat ( session . run ( "str" ) . summarize ( ) . plan ( ) . toString ( ) , equalTo ( "str" ) ) ;
if ( pkg ! = null & & pkg . getImplementationVersion ( ) ! = null )
return pkg . getImplementationVersion ( ) ;
Element cachedElement = this . getCache ( ) . get ( key . hashCode ( ) ) ;
this . getCache ( ) . put ( new Element ( key . hashCode ( ) , value ) ) ;
this . getCache ( ) . remove ( key . hashCode ( ) ) ;
public static final String GENERATE_CONVERTER_FROM_METHOD = "str" ;
public static final String GENERATE_SETTER_METHOD = "str" ;
questionslist = pc . findQuery ( type , qf + "str" + tag , itemcount ) ;
boolean sameSpace = ( showUser . getSpaces ( ) . isEmpty ( ) & & utils . canAccessSpace ( authUser , "str" ) ) | |
if ( isAdmin & & selectedUsers ! = null ) {
settings . put ( "str" , Config . getConfigBoolean ( "str" , ! Config . IN_PRODUCTION ) ) ;
String baseurl = ScooldServer . getServerURL ( ) ;
String host = Config . getConfigParam ( "str" , defaultHost ) ;
return Config . getConfigBoolean ( "str" , ! Config . getConfigParam ( "str" , "str" ) . isEmpty ( ) ) ;
model . addAttribute ( "str" , utils . isNearMeFeatureEnabled ( ) ) ;
String body = Utils . markdownToHtml ( comment . getComment ( ) ) ;
authUser . getVotes ( ) < Config . getConfigInt ( "str" , ENTHUSIAST_IFHAS ) & &
public static final String SPRING_RESOURCE_LOADER_CLASS = "str" ;
public static final String SPRING_RESOURCE_LOADER_CACHE = "str" ;
String body = Utils . markdownToHtml ( question . getBody ( ) ) ;
@GetMapping ( { "str" , "str" } )
if ( ! StringUtils . isBlank ( space ) & & pc . read ( utils . getSpaceId ( space ) ) = = null ) {
String likeTxt = Utils . abbreviate ( Utils . stripAndTrim ( ( showPost . getTitle ( ) + "str" + showPost . getBody ( ) ) ) , 1000 ) ;
velocityEngine . setProperty ( RuntimeConstants . RESOURCE_LOADERS , "str" ) ;
RuntimeConstants . RESOURCE_LOADERS , SpringResourceLoader . NAME ) ;
Set < String > emails = getNotificationSubscribers ( EMAIL_ALERTS_PREFIX + "str" ) ;
emailer . sendEmail ( new ArrayList < String > ( emails ) ,
String baseurl = Config . getConfigParam ( "str" , "str" ) ;
sb . append ( "str" ) ;
logger . error ( "str" , emails , body , ex . getMessage ( ) ) ;
model . addAttribute ( "str" , Config . getConfigBoolean ( "str" , true ) ) ;
String cookieLoc = getCookieValue ( req , LOCALE_COOKIE ) ;
Object tool = toolClass . getDeclaredConstructor ( ) . newInstance ( ) ;
settings . put ( "str" , Config . getConfigParam ( "str" , "str" ) ) ;
velocityProperties . put ( "str" , "str" ) ;
vc . setPreferFileSystemAccess ( ! Config . IN_PRODUCTION ) ;
if ( email = = null ) {
return NumberUtils . toInt ( System . getProperty ( "str" ) , Config . getConfigInt ( "str" , 8000 ) ) ;
Config . getConfigParam ( "str" , getDefaultContentSecurityPolicy ( request . isSecure ( ) ) ) ) ;
response . addHeader ( "str" , "str" ) ;
response . addHeader ( "str" , "str" ) ;
response . addHeader ( "str" , "str" ) ;
response . addHeader ( "str" , "str" ) ;
List < Tag > tagslist = utils . getParaClient ( ) . findTags ( "str" , itemcount ) ;
ALL_LOCALES . putIfAbsent ( locstr , Locale . forLanguageTag ( locstr ) ) ;
object . getClass ( ) . getName ( ) , object . getId ( ) ) ;
@RequestParam ( required = false , defaultValue = "str" ) String q , HttpServletRequest req , Model model ) {
String qs = qf . isEmpty ( ) ? "str" : "str" . equals ( qf ) ? queryString : qf + "str" + queryString ;
boolean spaceFiltered = ! StringUtils . isBlank ( currentSpace ) ;
showPost . setCloserid ( "str" ) ;
return ! StringUtils . isBlank ( this . closerid ) ;
if ( ! StringUtils . isBlank ( firstValue ) ) {
import static com . erudika . scoold . ScooldServer . CSRF_COOKIE ;
String csrfInCookie = HttpUtils . getStateParam ( CSRF_COOKIE , request ) ;
return "str" + ( noid ? "str" : "str" + p . getParentid ( ) ) ;
authUser . setPicture ( u . getPicture ( ) ) ;
if ( ! StringUtils . isBlank ( picture ) ) {
new String [ ] { "str" , "str" , "str" } , Utils . stripAndTrim ( likeTxt , "str" ) , new Pager ( 10 ) ) ;
itemcount . setSortby ( "str" . equals ( sortby ) ? "str" : "str" ) ;
@PostMapping ( "str" )
public String forceDelete ( @RequestParam Boolean confirmdelete , @RequestParam String id , HttpServletRequest req ) {
@GetMapping ( path = { "str" , "str" } )
addModel ( "str" , Config . getConfigParam ( "str" , imageslink + "str" ) ) ;
logger . warning ( e . toString ( ) ) ;
logger . warning ( e . toString ( ) ) ;
logger . warning ( e . toString ( ) ) ;
logger . warning ( e . toString ( ) ) ;
logger . warning ( e . toString ( ) ) ;
logger . warning ( e . toString ( ) ) ;
logger . warning ( e . toString ( ) ) ;
logger . warning ( e . toString ( ) ) ;
logger . warning ( e . toString ( ) ) ;
. put ( "str" , "str" )
return name + "str" + width + "str" + height + "str" + depth + "str" ;
private boolean debugMode = false ;
debugMode = ! debugMode ;
if ( debugMode )
text = managerState . getElements ( ) . toString ( ) ;
creator . setSidebar ( ModelCreator . uvSidebar ) ;
element . setDepth ( Parser . parseDouble ( zSizeField . getText ( ) , element . getDepth ( ) ) ) ;
element . setDepth ( Parser . parseDouble ( zSizeField . getText ( ) , element . getDepth ( ) ) ) ;
if ( animation = = null ? other . animation ! = null : ! animation . equals ( other . animation ) ) {
Marker displayedMarker = cluster . getDisplayedMarker ( ) ;
Marker getDisplayedMarker ( ) {
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 52.199 , 20.620 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 52.179 , 20.799 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 50.479 , 20.719 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 50.299 , 16.639 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 50.320 , 19.129 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 54.360 , 18.639 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 54.040 , 21.759 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 50.320 , 17.370 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 50.700 , 17.370 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 50.710 , 22.410 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 50.650 , 20.299 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 51.200 , 20.399 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 51.750 , 19.319 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 52.090 , 16.639 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 52.060 , 15.100 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 50.429 , 16.229 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 54.549 , 17.750 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 52.339 , 16.870 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 50.360 , 20.019 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 50.439 , 21.759 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 51.809 , 15.709 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 52.310 , 16.120 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 50.940 , 17.299 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 51.209 , 17.379 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 51.969 , 19.290 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 54.069 , 19.659 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 51.409 , 19.700 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 53.770 , 16.100 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 49.790 , 22.780 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 50.039 , 18.400 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 50.390 , 18.889 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 52.750 , 16.979 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 50.299 , 18.880 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 50.049 , 21.999 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 53.449 , 17.530 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 50.330 , 19.049 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 49.800 , 18.799 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 54.069 , 15.260 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 49.719 , 18.799 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 52.259 , 21.200 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 51.329 , 16.629 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 51.110 , 17.030 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 52.320 , 17.579 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 51.609 , 18.940 ) ) ) ;
map . addMarker ( options . title ( "str" ) . position ( new LatLng ( 50.599 , 17.050 ) ) ) ;
map . addMarker ( options . position ( new LatLng ( 41.333333333333336 , 19.816666666666666 ) ) . title ( "str" ) . snippet ( "str" ) ) ;
map . addMarker ( options . position ( new LatLng ( 47.86666666666667 , - 4.233333333333333 ) ) . title ( "str" ) . snippet ( "str" ) ) ;
map . addMarker ( options . position ( new LatLng ( 50.88333333333333 , 7.0 ) ) . title ( "str" ) . snippet ( "str" ) ) ;
map . addMarker ( options . position ( new LatLng ( 48.13333333333333 , 11.583333333333334 ) ) . title ( "str" ) . snippet ( "str" ) ) ;
map . addMarker ( options . position ( new LatLng ( 48.78333333333333 , 9.2 ) ) . title ( "str" ) . snippet ( "str" ) ) ;
map . addMarker ( options . position ( new LatLng ( 69.7 , 19.0 ) ) . title ( "str" ) . snippet ( "str" ) ) ;
map . addMarker ( options . position ( new LatLng ( 41.15 , - 8.616666666666667 ) ) . title ( "str" ) . snippet ( "str" ) ) ;
map . addMarker ( options . position ( new LatLng ( 55.583333333333336 , 13.0 ) ) . title ( "str" ) . snippet ( "str" ) ) ;
map . addMarker ( options . position ( new LatLng ( 47.38333333333333 , 8.55 ) ) . title ( "str" ) . snippet ( "str" ) ) ;
String scriptDomain = subFolder . getFileName ( ) . toString ( ) . replace ( "str" , "str" ) ;
if ( behaviour . canConnect ( facing , oTile ) & & flow . canConnect ( facing , oTile ) ) {
AxisAlignedBB aabb = tile . getWorld ( ) . getBlockState ( pos ) . getBoundingBox ( tile . getWorld ( ) , pos ) ;
if ( loadedDomains . remove ( module . getModId ( ) ) ) {
super . postReadFromNbt ( ) ;
dependencies = "str" )
import buildcraft . transport . client . model . PipeModelCacheBase . PipeBaseTranslucentKey ;
public List < BakedQuad > generateTranslucent ( PipeBaseTranslucentKey key ) {
import buildcraft . transport . client . model . PipeModelCacheBase . PipeBaseTranslucentKey ;
List < BakedQuad > generateTranslucent ( PipeBaseTranslucentKey key ) ;
import buildcraft . transport . client . model . PipeModelCacheBase . PipeBaseTranslucentKey ;
private final PipeBaseTranslucentKey translucent ;
translucent = new PipeBaseTranslucentKey ( tile . getPipe ( ) . getModel ( ) ) ;
public PipeBaseTranslucentKey getBaseTranslucent ( ) {
static final IModelCache < PipeBaseTranslucentKey > cacheTranslucent ;
private static List < BakedQuad > generateTranslucent ( PipeBaseTranslucentKey key ) {
public static final class PipeBaseTranslucentKey {
public PipeBaseTranslucentKey ( PipeModelKey key ) {
import buildcraft . transport . client . model . PipeModelCacheBase . PipeBaseTranslucentKey ;
public List < BakedQuad > generateTranslucent ( PipeBaseTranslucentKey key ) {
public static void renderItemStack ( double x , double y , double z , ItemStack stack , int lightc , EnumFacing dir , VertexBuffer vb ) {
q . lighti ( lightc ) ;
stack , lightc , item . getRenderDirection ( now , partialTicks ) , vb ) ;
left . add ( "str" + MjAPI . formatMj ( clamp ( e + esum / 20 , MIN_OUTPUT , MAX_OUTPUT ) ) + "str" ) ;
FluidRenderer . renderFluid ( FluidSpriteType . STILL , forRender , amounts [ face . getIndex ( ) ] / flow . capacity , 1 , min , max , fluidBuffer , sides ) ;
FluidRenderer . renderFluid ( FluidSpriteType . STILL , forRender , amount / flow . capacity , 1 , min , max , fluidBuffer , sides ) ;
import buildcraft . lib . path . task . TaskMiniChunkManager ;
tempData . put ( pos , data ) ;
WorkerThreadUtil . executeWorkTask ( new TaskMiniChunkManager ( world , pos ) ) ;
if ( item = = null | | item . getContainer ( ) ! = pipe . container ) {
super ( Material . iron , BCCreativeTab . get ( "str" ) , FACING_PROP ) ;
final int powerBase = 40 ;
if ( ( heatExchange . getInputHeatable ( ) ! = null & & heatExchange . getInputHeatable ( ) . amount > 0 ) | | crafted ) inHeatableTicks = 20 ;
if ( ib . onItemUse ( stack , player , world , pos , direction , 0.5f , 0.5f , 0.5f ) ) {
recursiveBuilder = new RecursiveBlueprintBuilder ( bpt , worldObj , pos , face . getOpposite ( ) ) ;
if ( ingredients [ 1 ] instanceof ItemPipe & & clas ! = PipeStructureCobblestone . class ) {
renderData . flags , pipe . container . getWorldObj ( ) ) ;
if ( renderData . amount [ 6 ] > 0 ) {
renderData . flags , pipe . container . getWorldObj ( ) ) ;
int pos = ( y * sizeX + z ) * sizeZ + x ;
public static Chunk getChunk ( World world , int x , int z ) {
Object tile = getEnergyProvider ( o ) ;
private void drawToolTips ( Collection < ? > objects , int mouseX , int mouseY , int offsetX , int offsetY ) {
drawToolTips ( tips , mouseX + offsetX , mouseY + offsetY ) ;
stack . setTagCompound ( new NBTTagCompound ( ) ) ;
initClient = 6 ;
for ( int j = 0 ; j < 3 ; + + j ) {
slots . add ( new RecipeSlot ( 116 + 18 * j , 36 + 18 * i ) ) ;
drawTexturedModalRect ( guiLeft + 86 , guiTop + 36 + 70 - h , 176 , 18 , 4 , h ) ;
private final Map < Integer , TravelingItem > itemCache = new MapMaker ( ) . weakValues ( ) . makeMap ( ) ;
itemCache . put ( item . id , item ) ;
return itemCache . get ( id ) ;
| | ! recipe . hasKey ( "str" , 3 ) ) {
GameRegistry . addShapelessRecipe ( new ItemStack ( pipeWaterproof , 1 ) , new ItemStack ( Items . slime_ball ) ) ;
if ( from . ordinal ( ) < 6 & & container . getNeighborTile ( from ) instanceof IRedstoneEngine ) {
} while ( ! ( ( TileGenericPipe ) source . getTile ( ) ) . isPipeConnected ( direction ) ) ;
this . motionY = 0.001D ;
if ( slot = = 0 ) {
} else if ( "str" . equals ( c ) ) {
} else if ( "str" . equals ( c ) ) {
} else if ( "str" . equals ( c ) ) {
return states = = null ? renderAsHollow : states [ 0 ] . hollow ;
if ( end = = null ) {
return ( ( ( index ! = null ? index . hashCode ( ) : 0 ) * 37 ) + ( side ! = null ? side . ordinal ( ) : 0 ) * 37 ) + localId ;
int status = meta & 8 ;
public void updateHeat ( ) {
fontRendererObj . drawString ( String . format ( "str" , engine . getCurrentHeatValue ( ) ) , x + 22 , y + 80 , textColour ) ;
if ( item ! = null & & item . getItem ( ) instanceof ItemMapLocation ) {
int stackSize = ( int ) Math . floor ( battery . useEnergy ( 10 , stack . stackSize * 10 , false ) / 10 ) ;
return slots ! = null ? index < slots . length : false ;
return slots ! = null ? new InvSlot ( slots [ index + + ] ) : null ;
return type = = PipeType . ITEM ? ConnectOverride . CONNECT : ConnectOverride . DEFAULT ;
tool . setToolTip ( new ToolTip ( new ToolTipLine ( StringUtils . localize ( "str" ) ) ) ) ;
byte [ ] dBytes = BitSetUtils . toByteArray ( delta , 2 ) ;
if ( ( bytes [ i / 8 ] & ( 1 < < ( i % 8 ) ) ) ! = 0 ) {
ItemStack output = inputA ;
if ( parameters ! = null & & parameters . length > = 1 & & parameters [ 0 ] ! = null & & parameters [ 0 ] . getItemStack ( ) ! = null ) {
if ( parameters ! = null & & parameters . length > = 1 & & parameters [ 0 ] ! = null ) {
if ( parameters ! = null & & parameters . length > = 1 & & parameters [ 0 ] ! = null & & parameters [ 0 ] . getItemStack ( ) ! = null ) {
world . setBlock ( wellX , y , wellZ , BuildCraftEnergy . blockOil , 0 , 3 ) ;
} else if ( pipeStack ! = null & & ( isBleach | | ( dye ! = null & & pipeStack . stackSize = = 8 ) ) & & ! hasDifferentPipes ) {
int stackSize = ( int ) Math . floor ( battery . useEnergy ( 10 , 10 * stack . stackSize , false ) / 10 ) ;
public static HashMap < Integer , RobotRegistry > registries = new HashMap < Integer , RobotRegistry > ( ) ;
return limit . maxPower + "str" ;
mapping . remap ( Item . getItemFromBlock ( laserBlock ) ) ;
if ( sources = = 0 ) {
int powerConsumed = ( int ) ( ( double ) internalPower [ in ] * ( double ) totalPowerConsumed / totalPowerContained ) ;
int powerConsumed = internalPower [ in ] * totalPowerConsumed / totalPowerContained ;
iEnergy = ( int ) Math . round ( energy ) ;
private ModelBase model = new ModelBase ( ) {
data . writeByte ( ( byte ) ( ( Enum ) actual ) . ordinal ( ) ) ;
return PipeIconProvider . TYPE . TransparentFacade . getIcon ( ) ;
NBTTagCompound [ ] gatesNBT = new NBTTagCompound [ 6 ] ;
} else if ( ( ( AIRobotFetchItem ) ai ) . target ! = null ) {
if ( isTriggerActive ( side , pipe . getAdjacentTile ( side ) , p ) ) {
slots [ position ] = new TriggerParameterSlot ( 71 , 26 + 18 * k , pipe , 0 , ( TriggerSlot ) slots [ k ] ) ;
slots [ position ] = new TriggerParameterSlot ( 26 , 26 + 18 * k , pipe , 0 ,
slots [ position ] = new TriggerParameterSlot ( 116 , 26 + 18 * k , pipe , 0 ,
itemAngle1 = ( float ) Math . atan2 ( z - Math . floor ( posZ ) ,
itemAngle2 = 0 ;
public void cleanRegistries ( WorldEvent . Unload unload ) {
resultF = tanks [ tankid ] . getFluid ( ) ;
if ( cpt . hasKey ( "str" ) & & ! "str" . equals ( cpt . getString ( "str" ) ) ) {
if ( cpt . hasKey ( "str" ) & & ! "str" . equals ( cpt . getString ( "str" ) ) ) {
} else if ( "str" . equals ( cpt . getString ( "str" ) ) ) {
checkBlockAndMeta = new GuiButton ( 0 , xscreen + 5 , yscreen + 30 , 120 , 20 , "str" ) ;
checkTileMethod = new GuiButton ( 1 , xscreen + 5 , yscreen + 55 , 120 , 20 , "str" ) ;
checkTestCommand = new GuiButton ( 2 , xscreen + 5 , yscreen + 80 , 120 , 20 , "str" ) ;
cancel = new GuiButton ( 2 , xscreen + 5 , yscreen + 105 , 120 , 20 , "str" ) ;
private float x , y , z ;
if ( ! BuildCraftAPI . isSoftBlock ( anchorTile . getWorldObj ( ) , x , y , z ) ) {
private static final String REMOTE_VERSION_FILE = "str" ;
if ( NEXTGEN_PREALPHA ) {
return pipe ! = null & & pipe . transport ! = null & & pipe . container ! = null ;
public static final double BUILD_ENERGY = 20 ;
@MjBattery ( maxReceivedPerCycle = 100 , maxCapacity = 10000 , minimumConsumption = 1 )
context . world ( ) . setBlock ( x2 , y , z2 , block , meta + 8 , 3 ) ;
maxLifetime = c * 2 ;
for ( int i = 0 ; i < size ; + + i ) {
public double minimumConsumption ( ) {
battery . addEnergy ( extractEnergy ( 0 , battery . minimumConsumption ( ) ,
import net . minecraft . block . ITileEntityProvider ;
if ( block instanceof ITileEntityProvider ) {
double dx = to . x - from . x ;
for ( int dir = 0 ; dir < = 5 ; + + dir ) {
BuildCraftCore . bcLog . warning ( "str" + key + "str" ) ;
return pipe1 ! = null ? pipe1 . isPipeConnected ( with , side . getOpposite ( ) ) : false ;
GL11 . glTranslatef ( - 0.5F , - 0.5F , - 0.5F ) ;
public boolean canConnectRedstone ( IBlockAccess world , int x , int y , int z , int side ) {
return BuildCraftTransport . pipeDurability ;
public static float pipeDurability ;
worldObj . markBlockNeedsUpdate ( xCoord , yCoord , zCoord ) ;
worldObj . markBlockNeedsUpdate ( xCoord , yCoord , zCoord ) ;
worldObj . markBlockNeedsUpdate ( xCoord , yCoord , zCoord ) ;
worldObj . markBlockNeedsUpdate ( xCoord , yCoord , zCoord ) ;
worldObj . markBlockNeedsUpdate ( xCoord , yCoord , zCoord ) ;
worldObj . markBlockNeedsUpdate ( xCoord , yCoord , zCoord ) ;
@SidedProxy ( clientSide = "str" , serverSide = "str" )
System . err . printf ( "str" + key + "str" ) ;
System . err . printf ( "str" + key + "str" ) ;
int iconIndex = itemstack . getItem ( ) . getIconFromDamageForRenderPass ( itemstack . getItemDamage ( ) , i ) ;
public class BlockAutoWorkbench extends BlockBuildCraft {
} catch ( Exception e ) {
Application . getInstance ( ) . getBus ( ) . post ( SyncEvent . COMPLETE ) ;
new ServerCredentials ( this ) ) ;
new ServerCredentials ( this ) ) ;
protected void onPrepareDialog ( int id , Dialog dialog ) {
protected void onPrepareDialog ( int id , Dialog dialog ) {
private boolean jobLabelProviderEnabled = false ;
private boolean scattering = true ;
. help ( "str" )
. validation ( "str" )
private String applicationWorkingDir = "str" ;
return configurationService . getConfiguration ( configurationName ) ;
private String full = "str" ;
private String base = "str" ;
private String build = "str" ;
private String commit = "str" ;
private String source = "str" ;
@RequestMapping ( value = "str" , method = RequestMethod . GET )
@RequestMapping ( value = "str" , method = RequestMethod . GET )
@RequestMapping ( value = "str" , method = RequestMethod . GET )
@RequestMapping ( value = "str" , method = RequestMethod . GET )
import static net . nemerosa . ontrack . model . form . Form . defaultNameField ;
. with ( defaultNameField ( ) )
. with ( defaultNameField ( ) . readOnly ( ) . value ( name ) )
import static net . nemerosa . ontrack . model . form . Form . defaultNameField ;
. with ( defaultNameField ( ) )
. with ( defaultNameField ( ) . readOnly ( ) . value ( name ) )
import static net . nemerosa . ontrack . model . form . Form . defaultNameField ;
. with ( defaultNameField ( ) )
. with ( defaultNameField ( ) . readOnly ( ) . value ( name ) )
public static Text defaultNameField ( ) {
. label ( "str" )
if ( depths [ i ] < depths [ i + 1 ] ) {
item . drawPath . rewind ( ) ;
writeLock . unlock ( ) ;
writeLock . unlock ( ) ;
final class Base64 {
static String encode ( byte [ ] data ) {
static byte [ ] decode ( String data ) {
private static final String MIRRORED_XOR_MESSAGE = "str" ;
private void addAddress ( TestAddress address ) {
value . addAddress ( persistable ) ;
private boolean clearFlag ;
clearFlag = true ;
String key = getKeyFromFileName ( fileName ) ;
String key = getKeyFromFileName ( fileName ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new UnsupportedOperationException ( "str" ) ;
void putString ( String key , String defValue ) ;
void putStringSet ( String key , Set < String > defValue ) ;
void putInt ( String key , int defValue ) ;
void putLong ( String key , long defValue ) ;
void putFloat ( String key , float defValue ) ;
void putBoolean ( String key , boolean defValue ) ;
void putBoolean ( String key , boolean value ) ;
public void shouldReturnModifiedKeysMapWithNonUniqueMapperAndMergedValues ( ) {
public void shouldNotEvaluateNPlusOneWhenTakeN ( ) {
public void shouldConcatNestedConcatIterators ( ) {
public void shouldReturnTheSameInstanceWhenInsertingAnAlreadyContainedElement ( ) {
public void shouldComputeAverageAndCompensateErrors ( ) {
return Stream . rangeClosed ( 3 , 2_540_160 )
public void shouldFlatMapChars ( ) {
public void shouldInsertAllIntoNil ( ) {
public void shouldRemoveAllIterableContainingNull ( ) {
assertThat ( denominatorBelow1000WithTheLongetsRecurringCycleOfDecimalFractions ( ) ) . isEqualTo ( 983 ) ;
private static int denominatorBelow1000WithTheLongetsRecurringCycleOfDecimalFractions ( ) {
. drop ( 1 ) ;
assertThat ( lexicographicPermutation ( List . of ( "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" ) , 1_000_000 ) ) . isEqualTo ( "str" ) ;
private static String lexicographicPermutationNaive ( List < String > stringsToPermutate , int ordinal ) {
private static String lexicographicPermutation ( List < String > stringsToPermutate , int ordinal ) {
return List . of ( sx . get ( headCharPosition - 1 ) ) . mkString ( ) + lexicographicPermutation ( sx . removeAt ( headCharPosition - 1 ) , ordinalRest ) ;
public void shouldCompareTwoIntegersUsingNaturalOrder ( ) {
assertThat ( largest1To9PandigitalMultiple ( ) . mkString ( ) ) . isEqualTo ( "str" ) ;
private static CharSeq largest1To9PandigitalMultiple ( ) {
default CompletableFuture < T > toCompletableFuture ( ) {
default CompletableFuture < T > toCompletableFuture ( ) {
return foldLeft ( Vector . empty ( ) , ( acc , entry ) - > acc . append ( mapper . apply ( entry . _1 , entry . _2 ) ) ) ;
return foldLeft ( Vector . empty ( ) , ( acc , entry ) - > acc . append ( mapper . apply ( entry . _1 , entry . _2 ) ) ) ;
return map ( t - > t . _2 ) ;
throw new UnsupportedOperationException ( "str" ) ;
throw new IndexOutOfBoundsException ( "str" + index + "str" + length ( ) ) ;
static NonFatalException of ( Throwable exception ) {
if ( Objects . equals ( head , element ) ) {
return containsKey ( currentElement . _1 ) ? remove ( currentElement . _1 ) . put ( newElement ) : this ;
return containsKey ( currentElement . _1 ) ? remove ( currentElement . _1 ) . put ( newElement ) : this ;
return IntMap . of ( original . replace ( currentEntry , Tuple . of ( original . size ( ) + 1 , newElement ) ) ) ;
Tuple2 < ? extends Seq < T > , ? extends Seq < T > > splitAt ( int n ) ;
final Function0 < Object > lambda = ( ) - > null ;
final Function0 < Object > lambda = ( ) - > null ;
final Function0 < Object > lambda = ( ) - > null ;
final Function1 < Object , Object > lambda = o - > o ;
final Function1 < Object , Object > lambda = o - > o ;
final Function1 < Object , Object > lambda = o - > o ;
final Function2 < Object , Object , Object > lambda = ( o1 , o2 ) - > o1 ;
final Function2 < Object , Object , Object > lambda = ( o1 , o2 ) - > o1 ;
final Function2 < Object , Object , Object > lambda = ( o1 , o2 ) - > o1 ;
final Function3 < Object , Object , Object , Object > lambda = ( o1 , o2 , o3 ) - > o1 ;
final Function3 < Object , Object , Object , Object > lambda = ( o1 , o2 , o3 ) - > o1 ;
final Function3 < Object , Object , Object , Object > lambda = ( o1 , o2 , o3 ) - > o1 ;
final Function4 < Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 ) - > o1 ;
final Function4 < Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 ) - > o1 ;
final Function4 < Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 ) - > o1 ;
final Function5 < Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 ) - > o1 ;
final Function5 < Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 ) - > o1 ;
final Function5 < Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 ) - > o1 ;
final Function6 < Object , Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 , o6 ) - > o1 ;
final Function6 < Object , Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 , o6 ) - > o1 ;
final Function6 < Object , Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 , o6 ) - > o1 ;
final Function7 < Object , Object , Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 , o6 , o7 ) - > o1 ;
final Function7 < Object , Object , Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 , o6 , o7 ) - > o1 ;
final Function7 < Object , Object , Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 , o6 , o7 ) - > o1 ;
final Function8 < Object , Object , Object , Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 , o6 , o7 , o8 ) - > o1 ;
final Function8 < Object , Object , Object , Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 , o6 , o7 , o8 ) - > o1 ;
final Function8 < Object , Object , Object , Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 , o6 , o7 , o8 ) - > o1 ;
final Function9 < Object , Object , Object , Object , Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 , o6 , o7 , o8 , o9 ) - > o1 ;
final Function9 < Object , Object , Object , Object , Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 , o6 , o7 , o8 , o9 ) - > o1 ;
final Function9 < Object , Object , Object , Object , Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 , o6 , o7 , o8 , o9 ) - > o1 ;
final Function10 < Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 , o6 , o7 , o8 , o9 , o10 ) - > o1 ;
final Function10 < Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 , o6 , o7 , o8 , o9 , o10 ) - > o1 ;
final Function10 < Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 , o6 , o7 , o8 , o9 , o10 ) - > o1 ;
final Function11 < Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 , o6 , o7 , o8 , o9 , o10 , o11 ) - > o1 ;
final Function11 < Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 , o6 , o7 , o8 , o9 , o10 , o11 ) - > o1 ;
final Function11 < Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 , o6 , o7 , o8 , o9 , o10 , o11 ) - > o1 ;
final Function12 < Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 , o6 , o7 , o8 , o9 , o10 , o11 , o12 ) - > o1 ;
final Function12 < Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 , o6 , o7 , o8 , o9 , o10 , o11 , o12 ) - > o1 ;
final Function12 < Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 , o6 , o7 , o8 , o9 , o10 , o11 , o12 ) - > o1 ;
final Function13 < Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 , o6 , o7 , o8 , o9 , o10 , o11 ,
final Function13 < Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 , o6 , o7 , o8 , o9 , o10 , o11 ,
final Function13 < Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object , Object > lambda = ( o1 , o2 , o3 , o4 , o5 , o6 , o7 , o8 , o9 , o10 , o11 ,
final 0 < Integer > x0 = ( ) - > 1 ;
final 1 < Integer , Integer > x1 = i - > i + 1 ;
assertThat ( Try . of ( ( ) - > 1. identity ( ) . apply ( 1 ) ) . get ( ) ) . isEqualTo ( 1 ) ;
final MethodType expected = MethodType . fromMethodDescriptorString ( "str" ,
final 2 < Integer , Integer , Integer > x2 = ( i , j ) - > i + j ;
assertThat ( x2 . curried ( ) . getType ( ) . toString ( ) ) . isEqualTo ( "str" ) ;
final MethodType expected = MethodType . fromMethodDescriptorString ( "str" ,
final 3 < Integer , Integer , Integer , Integer > x3 = ( i1 , i2 , i3 ) - > i1 + i2 + i3 ;
assertThat ( x3 . curried ( ) . getType ( ) . toString ( ) ) . isEqualTo ( "str" ) ;
final MethodType expected = MethodType . fromMethodDescriptorString ( "str" ,
final 4 < Integer , Integer , Integer , Integer , Integer > x = ( i1 , i2 , i3 , i4 ) - > i1 + i2 + i3 + i4 ;
assertThat ( x . curried ( ) . getType ( ) . toString ( ) ) . isEqualTo ( "str" ) ;
final MethodType expected = MethodType . fromMethodDescriptorString ( "str" ,
final 5 < Integer , Integer , Integer , Integer , Integer , Integer > x = ( i1 , i2 , i3 , i4 , i5 ) - > i1 + i2 + i3 + i4 + i5 ;
assertThat ( x . curried ( ) . getType ( ) . toString ( ) ) . isEqualTo ( "str" ) ;
final MethodType expected = MethodType . fromMethodDescriptorString ( "str" ,
final 6 < Integer , Integer , Integer , Integer , Integer , Integer , Integer > x = ( i1 , i2 , i3 , i4 , i5 , i6 ) - > i1 + i2 + i3 + i4 + i5 + i6 ;
assertThat ( x . curried ( ) . getType ( ) . toString ( ) ) . isEqualTo ( "str" ) ;
final MethodType expected = MethodType . fromMethodDescriptorString ( "str" ,
final 7 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer > x =
assertThat ( x . curried ( ) . getType ( ) . toString ( ) ) . isEqualTo ( "str" ) ;
final MethodType expected = MethodType . fromMethodDescriptorString ( "str" ,
final 8 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer > x =
assertThat ( x . curried ( ) . getType ( ) . toString ( ) ) . isEqualTo ( "str" ) ;
final MethodType expected = MethodType . fromMethodDescriptorString ( "str" ,
final 9 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer > x =
assertThat ( x . curried ( ) . getType ( ) . toString ( ) ) . isEqualTo ( "str" ) ;
final MethodType expected = MethodType . fromMethodDescriptorString ( "str" ,
final 10 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer > x =
assertThat ( x . curried ( ) . getType ( ) . toString ( ) ) . isEqualTo ( "str" ) ;
final MethodType expected = MethodType . fromMethodDescriptorString ( "str" ,
final 11 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer > x =
assertThat ( x . curried ( ) . getType ( ) . toString ( ) ) . isEqualTo ( "str" ) ;
final MethodType expected = MethodType . fromMethodDescriptorString ( "str" ,
final 12 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer > x =
assertThat ( x . curried ( ) . getType ( ) . toString ( ) ) . isEqualTo ( "str" ) ;
final MethodType expected = MethodType . fromMethodDescriptorString ( "str" ,
final 13 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer > x =
assertThat ( x . curried ( ) . getType ( ) . toString ( ) ) . isEqualTo ( "str" ) ;
public interface CheckedBiFunction < T , U , R > extends CheckedLambda2 < T , U , R > {
public interface CheckedFunction < T , R > extends CheckedLambda1 < T , R > {
public interface CheckedUnaryOperator < T > extends CheckedLambda1 < T , T > {
public boolean suchThat ( Lambda1 < T1 , Boolean > predicate ) {
public boolean suchThat ( Lambda2 < T1 , T2 , Boolean > predicate ) {
final Stream < E > distinct = Stream . of ( elements ) . distinct ( ) ;
return rule ( "str" , seq ( ref ( AheadOfTimeSnakeGrammar : : eat ) , str ( "str" ) ) , EOF ) ;
return rule ( "str" , seq ( str ( "str" ) , ref ( HungrySnakeGrammar : : eat ) ) , EOF ) ;
public void shouldNotBeInstantiable ( ) {
public void shouldNotBeInstantiable ( ) {
public void shouldNotBeInstantiable ( ) {
public void shouldNotBeInstantiable ( ) {
public void shouldNotBeInstantiable ( ) {
public void shouldNotBeInstantiable ( ) {
public void shouldNotBeInstantiable ( ) {
public void shouldNotBeInstantiable ( ) {
public void shouldNotBeInstantiable ( ) {
public void shouldNotBeInstantiable ( ) {
this ( parent , value , List . of ( children ) , TreeTransformer : : keepParent , TreeTransformer : : updateChildren ) ;
Tree ( Tree < T > parent , T value , List < Tree < T > > children , TreeTransformer < T > updateParent ,
this . children = children . replaceAll ( updateChildren . apply ( this ) ) ;
if ( Boolean . TRUE . equals ( isLocked . get ( ) ) ) {
private final String TEST_URL = "str" ;
assertEquals ( "str" , buildFile . getProperty ( "str" ) ) ;
assertThat ( jsonb ) . extracting ( "str" ) . isEqualTo ( "str" ) ;
assertThat ( jsonp ) . extracting ( "str" ) . isEqualTo ( "str" ) ;
assertThat ( resteasy ) . extracting ( "str" ) . isEqualTo ( "str" ) ;
return handleProvider ( 0 , ( List ) providers , request , new AsyncAuthenticationRequestContext ( ) ) ;
private class AsyncAuthenticationRequestContext implements AuthenticationRequestContext {
private final Set < Class < ? extends Annotation > > securityAnnotations = new HashSet < > (
if ( hasSecurityAnnotations ( resourceInfo ) & & shouldNonAnnotatedMethodsBeDenied ( ) ) {
annotation = getSecurityAnnotation ( resourceInfo . getResourceMethod ( ) . getDeclaringClass ( ) . getDeclaredAnnotations ( ) ,
private Annotation getSecurityAnnotation ( Annotation [ ] declaredAnnotations ,
. filter ( annotation - > securityAnnotations . contains ( annotation . annotationType ( ) ) )
. anyMatch ( annotation - > securityAnnotations . contains ( annotation . annotationType ( ) ) ) ;
private boolean shouldNonAnnotatedMethodsBeDenied ( ) {
"str" + frameworkClassesPath ) ;
try ( FileSystem fs = FileSystems . newFileSystem ( p , ( ClassLoader ) null ) ) {
try ( FileSystem fs = FileSystems . newFileSystem ( appJar , ( ClassLoader ) null ) ) {
try ( FileSystem fs = FileSystems . newFileSystem ( appJar , ( ClassLoader ) null ) ) {
try ( FileSystem fs = FileSystems . newFileSystem ( appJar , ( ClassLoader ) null ) ) {
return FileSystems . newFileSystem ( path , ( ClassLoader ) null ) ;
MetricRegistry registry = MetricRegistries . get ( MetricRegistry . Type . VENDOR ) ;
public static final VirtualAddress ANY = new VirtualAddress ( "str" ) ;
if ( ! ( o instanceof VirtualAddress ) ) {
@Timeout ( 2 )
final ExecutorService executorService = Executors . newFixedThreadPool ( 4 ) ;
@Timeout ( 2 )
final ExecutorService executorService = Executors . newFixedThreadPool ( 4 ) ;
if ( configuration = = null ) {
LOGGER . warnf ( e , "str" , name ) ;
if ( path . equals ( "str" ) | | path . isEmpty ( ) ) {
public void build ( List < CapabilityBuildItem > capabilities ) throws Exception {
final String output = baos . toString ( "str" ) ;
final String output = baos . toString ( "str" ) ;
. addAttachment ( "str" , payload . getBytes ( "str" ) , TEXT_CONTENT_TYPE ) ) . toCompletableFuture ( ) . join ( ) ;
Scanner s = new Scanner ( is , "str" ) . useDelimiter ( "str" ) ;
new InputStreamReader ( new FileInputStream ( new File ( testDir , "str" + file ) ) , "str" ) ) ) {
private static List < File > classesRoots ;
& & qualifiers . contains ( BuiltinQualifier . ANY . getInstance ( ) ) ;
public void addServletInitParameter ( RuntimeValue < DeploymentInfo > info , String name , String value ) {
template . addServletInitParameter ( deployment , i . getKey ( ) , i . getValue ( ) ) ;
@Option ( shortName = "str" , defaultValue = "str" )
final Path quarkusDescr = quarkusDir . resolve ( BootstrapConstants . DESCRIPTOR_FILE_NAME ) ;
getLog ( ) . error ( "str" , e ) ;
. < Bean < ? > > map ( manager : : resolve )
String importFile = hibernateConfig . sqlLoadScript . orElse ( "str" ) ;
projectVersion = prompter . promptWithDefaultValue ( "str" ,
@ConfigItem ( defaultValue = "str" )
public static final String SMALLRYE_REACTIVE_MESSAGING_KAFKA = "str" ;
diagnostic . getSource ( ) = = null ? "str" : diagnostic . getSource ( ) . getName ( ) ) ;
throw new RuntimeException ( "str" + set ) ;
throw new RuntimeException ( "str" + url . getProtocol ( ) ) ;
throw new RestClientDefinitionException ( "str" + typeDef ) ;
@ConfigItem ( defaultValue = "str" )
@ConfigRoot ( name = "str" )
package io . quarkus . resteasy . common . runtime . graal ;
package io . quarkus . resteasy . common . runtime . graal ;
if ( j = = stackTrace . length ) {
public static final String BEAN_VALIDATION = "str" ;
args . add ( "str" ) ;
private static ByteBuffer DRAIN_BUFFER = null ;
private static volatile long bootStartTime ;
static boolean trueColor = false ;
private static String sourceId ;
private static String propertiesFile ;
private static String buildId ;
private final Map < Class < ? > , NonDefaultConstructorHolder > nonDefaultConstructors = new HashMap < > ( ) ;
nonDefaultConstructors . put ( constructor . getDeclaringClass ( ) , new NonDefaultConstructorHolder ( constructor , ( Function < Object , List < Object > > ) parameters ) ) ;
if ( color & & System . console ( ) ! = null ) {
if ( ! file . isDirectory ( ) & & file . getName ( ) . endsWith ( "str" ) ) {
getLog ( ) . info ( "str" + servletRes . getAbsolutePath ( ) ) ;
classPath . append ( wiringClassesDirectory . getAbsolutePath ( ) ) . append ( "str" ) ;
ShamrockInjectorFactory . PROXY_UNWRAPPER = new Function < Object , Object > ( ) {
static volatile Function < Object , Object > PROXY_UNWRAPPER ;
return delegate . inject ( PROXY_UNWRAPPER . apply ( target ) , unwrapAsync ) ;
return delegate . inject ( request , response , PROXY_UNWRAPPER . apply ( target ) , unwrapAsync ) ;
ResultHandle [ ] resolve ( ResultHandle . . . handle ) {
public RestClientBuilder register ( Class < ? > aClass , Class < ? > . . . classes ) {
public RestClientBuilder register ( Object o , Class < ? > . . . classes ) {
return name . substring ( 0 , name . lastIndexOf ( BeanGenerator . BEAN_SUFFIX ) ) ;
@ConfigProperty ( name = "str" , defaultValue = "str" )
formatter = consoleBranchResult . mergeBranches ( noConsole , yesConsole , Formatter . class ) ;
throw new IllegalStateException ( errorPrefix + "str" + DEBUG_HELPERS_PROPERTY ) ;
log . debugf ( "str" , ( isAppClass ? "str" : "str" ) , resource . getFullyQualifiedName ( ) ) ;
log . debugf ( "str" , beanClass ) ;
log . debugf ( "str" , annotationName ) ;
private static final String JAX_RS_SERVLET_NAME = "str" ;
log . debugf ( "str" , constructor ) ;
log . debugf ( "str" , constructor . getConstructor ( ) ) ;
command . add ( "str" ) ;
private boolean fakereplace = false ;
private static final CoreMessageLogger log = CoreLogging . messageLogger ( FlatClassLoaderService . class ) ;
log . errorf ( "str" , className , getClassLoader ( ) ) ;
private String debug ;
if ( debug ! = null ) {
System . out . print ( charSequence ) ;
Collections . sort ( staticInitTasks ) ;
public void getSkippedStatusInEmptyElementsTest ( ) {
public void getPassedStatusTest ( ) {
report . setFeatureIndex ( featureUris . indexOf ( featureName ) ) ;
private static final int EXPECTED_CLASS_COUNT = 8 ;
pojoClass - > ! pojoClass . getSourcePath ( ) . contains ( "str" ) ) ;
private static final int EXPECTED_CLASS_COUNT = 12 ;
pojoClass - > ! pojoClass . getSourcePath ( ) . contains ( "str" ) ) ;
private static final int EXPECTED_CLASS_COUNT = 14 ;
mOrientedViewPager . setOffscreenPageLimit ( 4 ) ;
GDK . gdk_test_simulate_button ( gdkWindow , x [ 0 ] , y [ 0 ] , button , cachedModifier , type = = SWT . MouseDown ? GDK . GDK_BUTTON_PRESS : GDK . GDK_BUTTON_RELEASE ) ;
if ( shellHandle ! = 0 & & ! ( disposed instanceof Shell ) ) {
if ( idx > = 0 & & idx < widgetTable . length ) {
if ( w ! = null & & w . isDisposed ( ) ) {
if ( list = = null ) {
if ( ! disposed . isEmpty ( ) ) {
if ( menu ! = null & & ! menu . isDisposed ( ) & & ! newParent . isDisposed ( ) ) menu . fixMenus ( newParent ) ;
if ( menu ! = null & & ! menu . isDisposed ( ) & & ! newParent . isDisposed ( ) ) menu . fixMenus ( newParent ) ;
SWT . error ( SWT . ERROR_NO_HANDLES , null , "str" ) ;
private static HashMap < Integer , Webkit2EvalReturnObj > callbackMap = new HashMap < > ( ) ;
static Webkit2EvalReturnObj getObj ( int id ) {
static void removeObject ( int id ) {
if ( nextCallbackId ! = Integer . MAX_VALUE )
int callbackId = CallBackMap . putObject ( retObj ) ;
int callbackId = ( int ) user_data ;
display . sendPreEvent ( SWT . None ) ;
display . sendPostEvent ( SWT . None ) ;
display . sendPreEvent ( SWT . None ) ;
display . sendPostEvent ( SWT . None ) ;
long gtk_button_release_event ( long widget , long event ) {
private GdkEventButton getEventInfoFromOS ( long nativeEventPointer ) {
AccessibleControlEvent event = new AccessibleControlEvent ( shell . getAccessible ( ) ) ;
AccessibleEvent event = new AccessibleEvent ( shell . getAccessible ( ) ) ;
AccessibleTextEvent event = new AccessibleTextEvent ( shell . getAccessible ( ) ) ;
if ( ( style & SWT . MOZILLA ) ! = 0 ) {
@SuppressWarnings ( "str" )
@SuppressWarnings ( "str" )
@SuppressWarnings ( "str" )
if ( accessibleTextExtendedListeners . size ( ) > 0 | | accessibleAttributeListeners . size ( ) > 0 ) {
size . x + = 2 ; size . y + = 2 ;
size . x - = 2 ; size . y - = 2 ;
static long cairoPolygonRgn ( int [ ] pointArray ) {
import org . eclipse . swt . widgets . * ;
void dealloc ( long id , long sel ) {
long cairo = OS . gdk_cairo_create ( window ) ;
OS . gtk_render_check ( context , cairo , x , y , width , height ) ;
OS . gtk_paint_check ( style , window , state_type , shadow_type , null , widget , detail , x , y , width , height ) ;
long bpr = srcRep . bytesPerRow ( ) ;
long data = rep . bitmapData ( ) ;
long width = imageRep . pixelsWide ( ) ;
return Color . cocoa_new ( device , new double [ ] { red / 255 f , green / 255 f , blue / 255 f , 1 } ) ;
long maskBpl = ( ( ( width + 7 ) / 8 ) + ( maskPad - 1 ) ) / maskPad * maskPad ;
long count = reps . count ( ) ;
public long internal_new_GC ( GCData data ) {
long hHeap = OS . GetProcessHeap ( ) ;
long lpLogFont = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , LOGFONT . sizeof ) ;
long hDC = OS . GetDC ( 0 ) ;
long hDC = OS . GetDC ( 0 ) ;
public nsISupports ( long address ) {
public long getAddress ( ) {
public int QueryInterface ( nsID uuid , long [ ] result ) {
public WebPolicyDecisionListener ( long id ) {
public long window ;
public long axes ;
public long device ;
long pValue = OS . g_malloc ( byteCount ) ;
long mozillaHandle , embedHandle ;
static long eventProc ;
static Browser findBrowser ( long handle ) {
long parent = OS . gtk_widget_get_parent ( handle ) ;
long ptr = C . getenv ( wcsToMbcs ( null , "str" , true ) ) ;
long getHandle ( ) {
long getSiteWindow ( ) {
long gtk_event ( long handle , long gdkEvent , long pointer ) {
long list = OS . gtk_container_get_children ( embedHandle ) ;
void onDispose ( long embedHandle ) {
void setSize ( long embedHandle , int width , int height ) {
public NSColorList ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_allKeys ) ;
long result = OS . objc_msgSend ( OS . class_NSColorList , OS . sel_colorListNamed_ , name ! = null ? name . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_colorWithKey_ , key ! = null ? key . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_initWithName_ , name ! = null ? name . id : 0 ) ;
public void insertColor ( NSColor color , NSString key , long loc ) {
public NSPanel ( long id ) {
public static long windowNumberAtPoint ( NSPoint point , long windowNumber ) {
public long hwndItem ;
public long hDC ;
public long itemData ;
public nsIPromptService ( long address ) {
public int Alert ( long aParent , char [ ] aDialogTitle , char [ ] aText ) {
public int AlertCheck ( long aParent , char [ ] aDialogTitle , char [ ] aText , char [ ] aCheckMsg , int [ ] aCheckState ) {
public int Confirm ( long aParent , char [ ] aDialogTitle , char [ ] aText , int [ ] _retval ) {
public int ConfirmCheck ( long aParent , char [ ] aDialogTitle , char [ ] aText , char [ ] aCheckMsg , int [ ] aCheckState , int [ ] _retval ) {
public int ConfirmEx ( long aParent , char [ ] aDialogTitle , char [ ] aText , int aButtonFlags , char [ ] aButton0Title , char [ ] aButton1Title , char [ ] aButton2Title , char [ ] aCheckMsg , int [ ] aCheckState , int [ ] _retval ) {
public int Prompt ( long aParent , char [ ] aDialogTitle , char [ ] aText , long [ ] aValue , char [ ] aCheckMsg , int [ ] aCheckState , int [ ] _retval ) {
public int PromptUsernameAndPassword ( long aParent , char [ ] aDialogTitle , char [ ] aText , long [ ] aUsername , long [ ] aPassword , char [ ] aCheckMsg , int [ ] aCheckState , int [ ] _retval ) {
public int PromptPassword ( long aParent , char [ ] aDialogTitle , char [ ] aText , long [ ] aPassword , char [ ] aCheckMsg , int [ ] aCheckState , int [ ] _retval ) {
public int Select ( long aParent , char [ ] aDialogTitle , char [ ] aText , int aCount , long [ ] aSelectList , int [ ] aOutSelection , int [ ] _retval ) {
public nsIMemory ( long address ) {
public long Alloc ( int size ) {
public long Realloc ( long ptr , int newSize ) {
public int Free ( long ptr ) {
public static final native int CoCreateInstance ( GUID rclsid , long pUnkOuter , int dwClsContext , GUID riid , long [ ] ppv ) ;
public static final native int CoGetClassObject ( GUID rclsid , int dwClsContext , long pServerInfo , GUID riid , long [ ] ppv ) ;
public static final native int CoLockObjectExternal ( long pUnk , boolean fLock , boolean fLastUnlockReleases ) ;
public static final native int DoDragDrop ( long pDataObject , long pDropSource , int dwOKEffect , int [ ] pdwEffect ) ;
public static final native void MoveMemory ( long Destination , FORMATETC Source , int Length ) ;
public static final native void MoveMemory ( long DestinationPtr , GUID Source , int Length ) ;
public static final native void MoveMemory ( long DestinationPtr , OLEINPLACEFRAMEINFO Source , int Length ) ;
public static final native void MoveMemory ( long Destination , STATSTG Source , int Length ) ;
public static final native void MoveMemory ( long Destination , STGMEDIUM Source , int Length ) ;
public static final native void MoveMemory ( STGMEDIUM Destination , long SourcePtr , int Length ) ;
public static final native void MoveMemory ( DISPPARAMS Destination , long SourcePtr , int Length ) ;
public static final native void MoveMemory ( FORMATETC Destination , long Source , int Length ) ;
public static final native void MoveMemory ( GUID Destination , long SourcePtr , int Length ) ;
public static final native void MoveMemory ( STATSTG Destination , long Source , int Length ) ;
public static final native void MoveMemory ( TYPEATTR Destination , long SourcePtr , int Length ) ;
public static final native void MoveMemory ( RECT Destination , long Source , int Length ) ;
public static final native void MoveMemory ( FUNCDESC Destination , long Source , int Length ) ;
public static final native void MoveMemory ( VARDESC Destination , long Source , int Length ) ;
public static final native void MoveMemory ( VARIANT Destination , long Source , int Length ) ;
public static final native int OleCreate ( GUID rclsid , GUID riid , int renderopt , FORMATETC pFormatEtc , long pClientSite , long pStg , long [ ] ppvObject ) ;
public static final native int OleCreateFromFile ( GUID rclsid , char [ ] lpszFileName , GUID riid , int renderopt , FORMATETC pFormatEtc , long pClientSite , long pStg , long [ ] ppvObj ) ;
public static final native int OleCreatePropertyFrame ( long hwndOwner , int x , int y , char [ ] lpszCaption , int cObjects , long [ ] lplpUnk , int cPages , long lpPageClsID , int lcid , int dwReserved , long lpvReserved ) ;
public static final native int OleDraw ( long pUnk , int dwAspect , long hdcDraw , long lprcBounds ) ;
public static final native int OleGetClipboard ( long [ ] ppDataObject ) ;
public static final native int OleIsCurrentClipboard ( long pDataObject ) ;
public static final native boolean OleIsRunning ( long pObject ) ;
public static final native int OleLoad ( long pStg , GUID riid , long pClientSite , long [ ] ppvObj ) ;
public static final native int OleRun ( long pUnknown ) ;
public static final native int OleSave ( long pPS , long pStg , boolean fSameAsLoad ) ;
public static final native int OleSetClipboard ( long pDataObject ) ;
public static final native int OleSetContainedObject ( long pUnk , boolean fContained ) ;
public static final native int OleSetMenuDescriptor ( long holemenu , long hwndFrame , long hwndActiveObject , long lpFrame , long lpActiveObj ) ;
public static final native int OleTranslateColor ( int clr , long hpal , int [ ] pcolorref ) ;
public static final native int ProgIDFromCLSID ( GUID clsid , long [ ] lplpszProgID ) ;
public static final native int RegisterDragDrop ( long hwnd , long pDropTarget ) ;
public static final native void ReleaseStgMedium ( long pmedium ) ;
public static final native int RevokeDragDrop ( long hwnd ) ;
public static final native int SHDoDragDrop ( long hwnd , long pDataObject , long pDropSource , int dwOKEffect , int [ ] pdwEffect ) ;
public static final native int StgCreateDocfile ( char [ ] pwcsName , int grfMode , int reserved , long [ ] ppstgOpen ) ;
public static final native int StgOpenStorage ( char [ ] pwcsName , long pstgPriority , int grfMode , long snbExclude , int reserved , long [ ] ppstgOpen ) ;
public static final native int StringFromCLSID ( GUID rclsid , long [ ] ppsz ) ;
public static final native long SysAllocString ( char [ ] sz ) ;
public static final native void SysFreeString ( long bstr ) ;
public static final native int SysStringByteLen ( long bstr ) ;
public static final native int SysStringLen ( long bstr ) ;
public static final native int VariantChangeType ( long pvargDest , long pvarSrc , short wFlags , short vt ) ;
public static final native int VariantClear ( long pvarg ) ;
public static final native void VariantInit ( long pvarg ) ;
public static final native int VtblCall ( int fnNumber , long ppVtbl , char [ ] arg0 , char [ ] arg1 ) ;
public static final native int VtblCall ( int fnNumber , long ppVtbl , long arg0 , long [ ] arg1 ) ;
public static final native int VtblCall ( int fnNumber , long ppVtbl , int arg0 , int arg1 , long arg2 ) ;
public static final native int VtblCall ( int fnNumber , long ppVtbl , int arg0 , int arg1 , DVTARGETDEVICE arg2 , SIZE arg3 ) ;
public static final native int VtblCall ( int fnNumber , long ppVtbl , int arg0 , GUID arg1 ) ;
public static final native int VtblCall ( int fnNumber , long ppVtbl , MSG arg0 ) ;
public static final native int VtblCall ( int fnNumber , long ppVtbl , int arg0 , SIZE arg1 ) ;
public static final native int VtblCall ( int fnNumber , long ppVtbl , GUID arg0 , int arg1 , OLECMD arg2 , OLECMDTEXT arg3 ) ;
public static final native int VtblCall ( int fnNumber , long ppVtbl , LICINFO arg0 ) ;
public static final native int VtblCall ( int fnNumber , long ppVtbl , RECT arg0 , int arg1 , int arg2 ) ;
public static final native int VtblCall ( int fnNumber , long ppVtbl , RECT arg0 , long arg1 , long arg2 ) ;
public static final native int WriteClassStg ( long pStg , GUID rclsid ) ;
public static final native int AccessibleObjectFromWindow ( long hwnd , int dwObjectID , GUID riid , long [ ] ppvObject ) ;
public static final native int CreateStdAccessibleObject ( long hwnd , int idObject , GUID riidInterface , long [ ] ppvObject ) ;
public static final native long LresultFromObject ( GUID riid , long wParam , long pAcc ) ;
public static final native int AccessibleChildren ( long paccContainer , int iChildStart , int cChildren , long rgvarChildren , int [ ] pcObtained ) ;
public static final native int VtblCall_VARIANT ( int fnNumber , long ppVtbl , long arg0 ) ;
public static final native int VtblCall_VARIANTP ( int fnNumber , long ppVtbl , long arg0 , long arg1 ) ;
public static final native int VtblCall_IVARIANT ( int fnNumber , long ppVtbl , int arg0 , long arg1 ) ;
public static final native int VtblCall_IVARIANTP ( int fnNumber , long ppVtbl , int arg0 , long arg1 , long arg2 ) ;
public static final native int VtblCall_PVARIANTP ( int fnNumber , long ppVtbl , long arg0 , long arg1 , long arg2 ) ;
public static final native int VtblCall_PPPPVARIANT ( int fnNumber , long ppVtbl , long arg0 , long arg1 , long arg2 , long arg3 , long arg4 ) ;
public static final native long get_accChild_CALLBACK ( long func ) ;
public static final native long get_accName_CALLBACK ( long func ) ;
public static final native long get_accValue_CALLBACK ( long func ) ;
public static final native long get_accDescription_CALLBACK ( long func ) ;
public static final native long get_accRole_CALLBACK ( long func ) ;
public static final native long get_accState_CALLBACK ( long func ) ;
public static final native long get_accHelp_CALLBACK ( long func ) ;
public static final native long get_accHelpTopic_CALLBACK ( long func ) ;
public static final native long get_accKeyboardShortcut_CALLBACK ( long func ) ;
public static final native long get_accDefaultAction_CALLBACK ( long func ) ;
public static final native long accSelect_CALLBACK ( long func ) ;
public static final native long accLocation_CALLBACK ( long func ) ;
public static final native long accNavigate_CALLBACK ( long func ) ;
public static final native long accDoDefaultAction_CALLBACK ( long func ) ;
public static final native long put_accName_CALLBACK ( long func ) ;
public static final native long put_accValue_CALLBACK ( long func ) ;
public static final native long CALLBACK_setCurrentValue ( long func ) ;
public IOleInPlaceObject ( long address ) {
static final long DateTimeProc ;
static final long CalendarProc ;
long lpszClassName = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount ) ;
long lpszClassName = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount ) ;
long callWindowProc ( long hwnd , int msg , long wParam , long lParam ) {
long windowProc ( ) {
LRESULT wmNotifyChild ( NMHDR hdr , long wParam , long lParam ) {
LRESULT WM_CHAR ( long wParam , long lParam ) {
LRESULT WM_LBUTTONDBLCLK ( long wParam , long lParam ) {
long code = OS . SendMessage ( handle , OS . MCM_HITTEST , 0 , pMCHitTest ) ;
LRESULT WM_LBUTTONDOWN ( long wParam , long lParam ) {
LRESULT WM_LBUTTONUP ( long wParam , long lParam ) {
LRESULT WM_TIMER ( long wParam , long lParam ) {
long code = callWindowProc ( handle , OS . WM_TIMER , wParam , lParam ) ;
public long handle ;
TreeItem ( Tree parent , int style , long hParent , long hInsertAfter , long hItem ) {
static long findPrevious ( Tree parent , int index ) {
static long findPrevious ( TreeItem parentItem , int index ) {
long hwnd = parent . handle ;
long fontHandle ( int index ) {
RECT getBounds ( int index , boolean getText , boolean getImage , boolean fullText , boolean fullImage , boolean clip , long hDC ) {
long hwnd = parent . handle ;
long hwndHeader = parent . hwndHeader ;
long hNewDC = hDC , hFont = 0 ;
long hwnd = parent . handle ;
long result = OS . SendMessage ( hwnd , OS . TVM_GETITEM , 0 , tvItem ) ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long result = OS . SendMessage ( hwnd , OS . TVM_GETITEM , 0 , tvItem ) ;
long hItem = parent . findItem ( hFirstItem , index ) ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hBottomItem = 0 ;
long hTopItem = OS . SendMessage ( hwnd , OS . TVM_GETNEXTITEM , OS . TVGN_FIRSTVISIBLE , 0 ) ;
long hItem = hTopItem ;
long topHandle = parent . topHandle ( ) ;
long hOldItem = OS . SendMessage ( hwnd , OS . TVM_GETNEXTITEM , OS . TVGN_CARET , 0 ) ;
long lParam = OS . MAKELPARAM ( OS . SB_THUMBPOSITION , oldInfo . nPos ) ;
long hItem = hTopItem ;
long topHandle = parent . topHandle ( ) ;
long hNewItem = OS . SendMessage ( hwnd , OS . TVM_GETNEXTITEM , OS . TVGN_CARET , 0 ) ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
public NSTableHeaderView ( long id ) {
public long columnAtPoint ( NSPoint point ) {
public NSRect headerRectOfColumn ( long column ) {
public long hWnd ;
public long hIcon ;
public NSTimeZone ( long id ) {
long result = OS . objc_msgSend ( OS . class_NSTimeZone , OS . sel_defaultTimeZone ) ;
public IPersistFile ( long address ) {
public int Load ( long pszFileName , int dwMode ) {
public int Save ( long pszFileName , boolean fRemember ) {
public int SaveCompleted ( long pszFileName ) {
public int GetCurFile ( long [ ] ppszFileName ) {
public NSButtonCell ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_backgroundColor ) ;
public void setButtonType ( long aType ) {
public void setHighlightsBy ( long aType ) {
public void setImagePosition ( long aPosition ) {
long result = OS . objc_msgSend ( this . id , OS . sel_title ) ;
public nsIXPCSecurityManager ( long address ) {
public int CanCreateWrapper ( long aJSContext , nsID aIID , long aObj , long aClassInfo , long [ ] aPolicy ) {
public int CanCreateInstance ( long aJSContext , nsID aCID ) {
public int CanGetService ( long aJSContext , nsID aCID ) {
public int CanAccess ( int aAction , long aCallContext , long aJSContext , long aJSObject , long aObj , long aClassInfo , long aName , long [ ] aPolicy ) {
public long hbmMask ;
public long hbmColor ;
public NSMutableURLRequest ( long id ) {
public void setCachePolicy ( long policy ) {
long result = OS . objc_msgSend ( OS . class_NSMutableURLRequest , OS . sel_requestWithURL_ , URL ! = null ? URL . id : 0 ) ;
public NSMutableSet ( long id ) {
long result = OS . objc_msgSend ( OS . class_NSMutableSet , OS . sel_set ) ;
public nsIWebNavigation ( long address ) {
public int LoadURI ( char [ ] uri , int loadFlags , long referrer , long postData , long headers ) {
public int GetDocument ( long [ ] aDocument ) {
public int GetCurrentURI ( long [ ] aCurrentURI ) {
public int GetReferringURI ( long [ ] aReferringURI ) {
public int GetSessionHistory ( long [ ] aSessionHistory ) {
public int SetSessionHistory ( long aSessionHistory ) {
long pValue = OS . g_malloc ( buffer . length ) ;
public NSActionCell ( long id ) {
public long action ( ) {
public void setAction ( long aSelector ) {
long result = OS . objc_msgSend ( this . id , OS . sel_target ) ;
public NSValue ( long id ) {
public long objCType ( ) {
long result = OS . objc_msgSend ( OS . class_NSValue , OS . sel_valueWithPoint_ , point ) ;
long result = OS . objc_msgSend ( OS . class_NSValue , OS . sel_valueWithRange_ , range ) ;
long result = OS . objc_msgSend ( OS . class_NSValue , OS . sel_valueWithRect_ , rect ) ;
long result = OS . objc_msgSend ( OS . class_NSValue , OS . sel_valueWithSize_ , size ) ;
public NSTouch ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_device ) ;
public long phase ( ) {
public NSFileManager ( long id ) {
long result = OS . objc_msgSend ( OS . class_NSFileManager , OS . sel_defaultManager ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_enumeratorAtPath_ , path ! = null ? path . id : 0 ) ;
public boolean fileExistsAtPath ( NSString path , long isDirectory ) {
public boolean removeItemAtPath ( NSString path , long error ) {
public long functionName ;
public long function ;
public NSCursor ( long id ) {
long result = OS . objc_msgSend ( OS . class_NSCursor , OS . sel_IBeamCursor ) ;
long result = OS . objc_msgSend ( OS . class_NSCursor , OS . sel_arrowCursor ) ;
long result = OS . objc_msgSend ( OS . class_NSCursor , OS . sel_crosshairCursor ) ;
long result = OS . objc_msgSend ( OS . class_NSCursor , OS . sel_currentCursor ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_initWithImage_hotSpot_ , newImage ! = null ? newImage . id : 0 , aPoint ) ;
long result = OS . objc_msgSend ( OS . class_NSCursor , OS . sel_pointingHandCursor ) ;
long result = OS . objc_msgSend ( OS . class_NSCursor , OS . sel_resizeDownCursor ) ;
long result = OS . objc_msgSend ( OS . class_NSCursor , OS . sel_resizeLeftCursor ) ;
long result = OS . objc_msgSend ( OS . class_NSCursor , OS . sel_resizeLeftRightCursor ) ;
long result = OS . objc_msgSend ( OS . class_NSCursor , OS . sel_resizeRightCursor ) ;
long result = OS . objc_msgSend ( OS . class_NSCursor , OS . sel_resizeUpCursor ) ;
long result = OS . objc_msgSend ( OS . class_NSCursor , OS . sel_resizeUpDownCursor ) ;
public long pbData ;
public static final native void free ( long ptr ) ;
public static final native void memmove ( long dest , byte [ ] src , long size ) ;
public static final native void memmove ( long dest , char [ ] src , long size ) ;
public static final native void memmove ( long dest , double [ ] src , long size ) ;
public static final native void memmove ( long dest , float [ ] src , long size ) ;
public static final native void memmove ( long dest , int [ ] src , long size ) ;
public static final native void memmove ( long dest , long [ ] src , long size ) ;
public static final native void memmove ( long dest , short [ ] src , long size ) ;
public static final native void memmove ( byte [ ] dest , char [ ] src , long size ) ;
public static final native void memmove ( byte [ ] dest , long src , long size ) ;
public static final native void memmove ( long dest , long src , long size ) ;
public static final native void memmove ( char [ ] dest , long src , long size ) ;
public static final native void memmove ( double [ ] dest , long src , long size ) ;
public static final native void memmove ( float [ ] dest , long src , long size ) ;
public static final native void memmove ( int [ ] dest , byte [ ] src , long size ) ;
public static final native void memmove ( short [ ] dest , long src , long size ) ;
public static final native void memmove ( int [ ] dest , long src , long size ) ;
public static final native void memmove ( long [ ] dest , long src , long size ) ;
public static final native long memset ( long buffer , int c , long num ) ;
public static final native int strlen ( long s ) ;
long ptr = OS . malloc ( NSPoint . sizeof ) ;
public NSGraphicsContext ( long id ) {
long result = OS . objc_msgSend ( OS . class_NSGraphicsContext , OS . sel_currentContext ) ;
long result = OS . objc_msgSend ( OS . class_NSGraphicsContext , OS . sel_graphicsContextWithBitmapImageRep_ , bitmapRep ! = null ? bitmapRep . id : 0 ) ;
long result = OS . objc_msgSend ( OS . class_NSGraphicsContext , OS . sel_graphicsContextWithWindow_ , window ! = null ? window . id : 0 ) ;
public long graphicsPort ( ) {
public long imageInterpolation ( ) {
public void setCompositingOperation ( long operation ) {
public void setImageInterpolation ( long interpolation ) {
public nsIEmbeddingSiteWindow ( long address ) {
public int GetTitle ( long [ ] aTitle ) {
public int GetSiteWindow ( long [ ] aSiteWindow ) {
String message = "str" + ( ( Element ) node . getElementsByTagName ( "str" ) . item ( 0 ) ) . getAttribute ( "str" ) ;
long libcairo = OS . dlopen ( buffer , OS . RTLD_LAZY ) ;
public SFCertificateTrustPanel ( long id ) {
public void beginSheetForWindow ( NSWindow docWindow , id delegate , long didEndSelector , long contextInfo , long trust , NSString message ) {
long result = OS . objc_msgSend ( OS . class_SFCertificateTrustPanel , OS . sel_sharedCertificateTrustPanel ) ;
public static long windowNumberAtPoint ( NSPoint point , long windowNumber ) {
long [ ] ppvObject = new long [ 1 ] ;
Accessible ( Accessible parent , long iaccessible_address ) {
long [ ] funcs = new long [ 28 ] ;
long [ ] funcs = new long [ 28 ] ;
long [ ] funcs = new long [ 7 ] ;
long getAddress ( ) {
public long internal_WM_GETOBJECT ( long wParam , long lParam ) {
COM . MoveMemory ( ppvObject , new long [ ] { getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { objIAccessible . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { objIEnumVARIANT . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { objIServiceProvider . getAddress ( ) } , OS . PTR_SIZEOF ) ;
long [ ] ppv = new long [ 1 ] ;
COM . MoveMemory ( ppvObject , new long [ ] { objIAccessible . getAddress ( ) } , OS . PTR_SIZEOF ) ;
long [ ] ppv = new long [ 1 ] ;
long [ ] ppvx = new long [ 1 ] ;
int queryAccessible2Interfaces ( GUID guid , long ppvObject ) {
COM . MoveMemory ( ppvObject , new long [ ] { objIAccessible2 . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { objIAccessibleAction . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { objIAccessibleApplication . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { objIAccessibleEditableText . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { objIAccessibleHyperlink . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { objIAccessibleHypertext . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { objIAccessibleTable2 . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { objIAccessibleTableCell . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { objIAccessibleText . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { objIAccessibleValue . getAddress ( ) } , OS . PTR_SIZEOF ) ;
int accDoDefaultAction ( long varChild ) {
int accHitTest ( int xLeft , int yTop , long pvarChild ) {
long osChildObject = 0 ;
int accLocation ( long pxLeft , long pyTop , long pcxWidth , long pcyHeight , long varChild ) {
int accNavigate ( int navDir , long varStart , long pvarEndUpAt ) {
int accSelect ( int flagsSelect , long varChild ) {
int get_accChild ( long varChild , long ppdispChild ) {
COM . MoveMemory ( ppdispChild , new long [ ] { getAddress ( ) } , OS . PTR_SIZEOF ) ;
long [ ] addr = new long [ 1 ] ;
COM . MoveMemory ( ppdispChild , new long [ ] { accessible . getAddress ( ) } , OS . PTR_SIZEOF ) ;
int get_accChildCount ( long pcountChildren ) {
int get_accDefaultAction ( long varChild , long pszDefaultAction ) {
long [ ] pDefaultAction = new long [ 1 ] ;
int get_accDescription ( long varChild , long pszDescription ) {
long [ ] pDescription = new long [ 1 ] ;
long hwnd = control . handle , hItem = 0 ;
int get_accFocus ( long pvarChild ) {
int get_accHelp ( long varChild , long pszHelp ) {
long [ ] pHelp = new long [ 1 ] ;
int get_accHelpTopic ( long pszHelpFile , long varChild , long pidTopic ) {
int get_accKeyboardShortcut ( long varChild , long pszKeyboardShortcut ) {
long [ ] pKeyboardShortcut = new long [ 1 ] ;
int get_accName ( long varChild , long pszName ) {
long [ ] pName = new long [ 1 ] ;
int get_accParent ( long ppdispParent ) {
COM . MoveMemory ( ppdispParent , new long [ ] { parent . getAddress ( ) } , OS . PTR_SIZEOF ) ;
int get_accRole ( long varChild , long pvarRole ) {
int get_accSelection ( long pvarChildren ) {
long osChildObject = 0 ;
int get_accState ( long varChild , long pvarState ) {
long hwnd = control . handle ;
long result = OS . SendMessage ( hwnd , OS . TVM_GETITEM , 0 , tvItem ) ;
int get_accValue ( long varChild , long pszValue ) {
long [ ] pValue = new long [ 1 ] ;
int put_accName ( long varChild , long szName ) {
int put_accValue ( long varChild , long szValue ) {
int Next ( int celt , long rgvar , long pceltFetched ) {
long [ ] ppvObject = new long [ 1 ] ;
long [ ] ppvObject = new long [ 1 ] ;
long [ ] ppvObject = new long [ 1 ] ;
int Clone ( long ppEnum ) {
long [ ] ppvObject = new long [ 1 ] ;
long [ ] pEnum = new long [ 1 ] ;
COM . MoveMemory ( ppEnum , new long [ ] { objIEnumVARIANT . getAddress ( ) } , OS . PTR_SIZEOF ) ;
int get_nRelations ( long pNRelations ) {
int get_relation ( int relationIndex , long ppRelation ) {
COM . MoveMemory ( ppRelation , new long [ ] { relation . getAddress ( ) } , OS . PTR_SIZEOF ) ;
int get_relations ( int maxRelations , long ppRelations , long pNRelations ) {
COM . MoveMemory ( ppRelations + count * OS . PTR_SIZEOF , new long [ ] { relation . getAddress ( ) } , OS . PTR_SIZEOF ) ;
int get_role ( long pRole ) {
int get_groupPosition ( long pGroupLevel , long pSimilarItemsInGroup , long pPositionInGroup ) {
int get_states ( long pStates ) {
int get_extendedRole ( long pbstrExtendedRole ) {
int get_localizedExtendedRole ( long pbstrLocalizedExtendedRole ) {
int get_nExtendedStates ( long pNExtendedStates ) {
int get_extendedStates ( int maxExtendedStates , long ppbstrExtendedStates , long pNExtendedStates ) {
int get_localizedExtendedStates ( int maxLocalizedExtendedStates , long ppbstrLocalizedExtendedStates , long pNLocalizedExtendedStates ) {
int get_uniqueID ( long pUniqueID ) {
COM . MoveMemory ( pUniqueID , new long [ ] { uniqueID } , 4 ) ;
int get_windowHandle ( long pWindowHandle ) {
COM . MoveMemory ( pWindowHandle , new long [ ] { control . handle } , OS . PTR_SIZEOF ) ;
int get_indexInParent ( long pIndexInParent ) {
int get_locale ( long pLocale ) {
COM . MoveMemory ( pLocale + OS . PTR_SIZEOF , new long [ ] { ptr } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( pLocale + 2 * OS . PTR_SIZEOF , new long [ ] { ptr } , OS . PTR_SIZEOF ) ;
int get_attributes ( long pbstrAttributes ) {
int get_nActions ( long pNActions ) {
int get_description ( int actionIndex , long pbstrDescription ) {
int get_keyBinding ( int actionIndex , int nMaxBindings , long ppbstrKeyBindings , long pNBindings ) {
int get_name ( int actionIndex , long pbstrName ) {
int get_localizedName ( int actionIndex , long pbstrLocalizedName ) {
int get_appName ( long pbstrName ) {
int get_appVersion ( long pbstrVersion ) {
int get_toolkitName ( long pbstrName ) {
int get_toolkitVersion ( long pbstrVersion ) {
int insertText ( int offset , long pbstrText ) {
int replaceText ( int startOffset , int endOffset , long pbstrText ) {
int setAttributes ( int startOffset , int endOffset , long pbstrAttributes ) {
int get_anchor ( int index , long pAnchor ) {
int get_anchorTarget ( int index , long pAnchorTarget ) {
int get_startIndex ( long pIndex ) {
int get_endIndex ( long pIndex ) {
int get_valid ( long pValid ) {
int get_nHyperlinks ( long pHyperlinkCount ) {
int get_hyperlink ( int index , long ppHyperlink ) {
COM . MoveMemory ( ppHyperlink , new long [ ] { accessible . getAddress ( ) } , OS . PTR_SIZEOF ) ;
int get_hyperlinkIndex ( int charIndex , long pHyperlinkIndex ) {
int get_cellAt ( int row , int column , long ppCell ) {
COM . MoveMemory ( ppCell , new long [ ] { accessible . getAddress ( ) } , OS . PTR_SIZEOF ) ;
int get_caption ( long ppAccessible ) {
COM . MoveMemory ( ppAccessible , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppAccessible , new long [ ] { accessible . getAddress ( ) } , OS . PTR_SIZEOF ) ;
int get_columnDescription ( int column , long pbstrDescription ) {
int get_nColumns ( long pColumnCount ) {
int get_nRows ( long pRowCount ) {
int get_nSelectedCells ( long pCellCount ) {
int get_nSelectedColumns ( long pColumnCount ) {
int get_nSelectedRows ( long pRowCount ) {
int get_rowDescription ( int row , long pbstrDescription ) {
int get_selectedCells ( long ppCells , long pNSelectedCells ) {
COM . MoveMemory ( ppCells , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
long pv = COM . CoTaskMemAlloc ( length * OS . PTR_SIZEOF ) ;
COM . MoveMemory ( pv + i * OS . PTR_SIZEOF , new long [ ] { accessible . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppCells , new long [ ] { pv } , OS . PTR_SIZEOF ) ;
int get_selectedColumns ( long ppSelectedColumns , long pNColumns ) {
COM . MoveMemory ( ppSelectedColumns , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
long pv = COM . CoTaskMemAlloc ( count * 4 ) ;
COM . MoveMemory ( ppSelectedColumns , new long [ ] { pv } , OS . PTR_SIZEOF ) ;
int get_selectedRows ( long ppSelectedRows , long pNRows ) {
COM . MoveMemory ( ppSelectedRows , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
long pv = COM . CoTaskMemAlloc ( count * 4 ) ;
COM . MoveMemory ( ppSelectedRows , new long [ ] { pv } , OS . PTR_SIZEOF ) ;
int get_summary ( long ppAccessible ) {
COM . MoveMemory ( ppAccessible , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppAccessible , new long [ ] { accessible . getAddress ( ) } , OS . PTR_SIZEOF ) ;
int get_isColumnSelected ( int column , long pIsSelected ) {
int get_isRowSelected ( int row , long pIsSelected ) {
int get_modelChange ( long pModelChange ) {
COM . MoveMemory ( pModelChange , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
int get_columnExtent ( long pNColumnsSpanned ) {
int get_columnHeaderCells ( long ppCellAccessibles , long pNColumnHeaderCells ) {
COM . MoveMemory ( ppCellAccessibles , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
long pv = COM . CoTaskMemAlloc ( length * OS . PTR_SIZEOF ) ;
COM . MoveMemory ( pv + i * OS . PTR_SIZEOF , new long [ ] { accessible . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppCellAccessibles , new long [ ] { pv } , OS . PTR_SIZEOF ) ;
int get_columnIndex ( long pColumnIndex ) {
int get_rowExtent ( long pNRowsSpanned ) {
int get_rowHeaderCells ( long ppCellAccessibles , long pNRowHeaderCells ) {
COM . MoveMemory ( ppCellAccessibles , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
long pv = COM . CoTaskMemAlloc ( length * OS . PTR_SIZEOF ) ;
COM . MoveMemory ( pv + i * OS . PTR_SIZEOF , new long [ ] { accessible . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppCellAccessibles , new long [ ] { pv } , OS . PTR_SIZEOF ) ;
int get_rowIndex ( long pRowIndex ) {
int get_isSelected ( long pIsSelected ) {
int get_rowColumnExtents ( long pRow , long pColumn , long pRowExtents , long pColumnExtents , long pIsSelected ) {
int get_table ( long ppTable ) {
COM . MoveMemory ( ppTable , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppTable , new long [ ] { accessible . getAddress ( ) } , OS . PTR_SIZEOF ) ;
int get_attributes ( int offset , long pStartOffset , long pEndOffset , long pbstrTextAttributes ) {
int get_caretOffset ( long pOffset ) {
int get_characterExtents ( int offset , int coordType , long pX , long pY , long pWidth , long pHeight ) {
int get_nSelections ( long pNSelections ) {
int get_offsetAtPoint ( int x , int y , int coordType , long pOffset ) {
int get_selection ( int selectionIndex , long pStartOffset , long pEndOffset ) {
int get_text ( int startOffset , int endOffset , long pbstrText ) {
int get_textBeforeOffset ( int offset , int boundaryType , long pStartOffset , long pEndOffset , long pbstrText ) {
int get_textAfterOffset ( int offset , int boundaryType , long pStartOffset , long pEndOffset , long pbstrText ) {
int get_textAtOffset ( int offset , int boundaryType , long pStartOffset , long pEndOffset , long pbstrText ) {
int get_nCharacters ( long pNCharacters ) {
int get_newText ( long pNewText ) {
int get_oldText ( long pOldText ) {
int get_currentValue ( long pCurrentValue ) {
int setCurrentValue ( long value ) {
int get_maximumValue ( long pMaximumValue ) {
int get_minimumValue ( long pMinimumValue ) {
long varChild = OS . GlobalAlloc ( OS . GMEM_FIXED | OS . GMEM_ZEROINIT , VARIANT . sizeof ) ;
long pvarRole = OS . GlobalAlloc ( OS . GMEM_FIXED | OS . GMEM_ZEROINIT , VARIANT . sizeof ) ;
VARIANT getVARIANT ( long variant ) {
Number getNumberVARIANT ( long variant ) {
void setIntVARIANT ( long variant , short vt , int lVal ) {
void setPtrVARIANT ( long variant , short vt , long lVal ) {
COM . MoveMemory ( variant + 8 , new long [ ] { lVal } , OS . PTR_SIZEOF ) ;
void setNumberVARIANT ( long variant , Number number ) {
COM . MoveMemory ( psz , new long [ ] { ptr } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( variant + 8 , new long [ ] { ptr } , OS . PTR_SIZEOF ) ;
public NSCharacterSet ( long id ) {
long result = OS . objc_msgSend ( OS . class_NSCharacterSet , OS . sel_decimalDigitCharacterSet ) ;
public nsIWindowCreator2 ( long address ) {
public int CreateChromeWindow2 ( long parent , int chromeFlags , int contextFlags , long uri , int [ ] cancel , long [ ] _retval ) {
public long hwnd ;
public long hwndInsertAfter ;
public nsICertificateDialogs ( long address ) {
public int ConfirmDownloadCACert ( long ctx , long cert , int [ ] trust , int [ ] _retval ) {
public int NotifyCACertExists ( long ctx ) {
public int SetPKCS12FilePassword ( long ctx , long password , int [ ] _retval ) {
public int GetPKCS12FilePassword ( long ctx , long password , int [ ] _retval ) {
public int ViewCert ( long ctx , long cert ) {
public int CrlImportStatusDialog ( long ctx , long crl ) {
public long hItem ;
public long Scan0 ;
public long Reserved ;
long accessibilityAttributeNames ( long id , long sel ) {
double maxValue = ( style & SWT . VERTICAL ) ! = 0 ?
boolean accessibilityIsIgnored ( long id , long sel ) {
boolean becomeFirstResponder ( long id , long sel ) {
void drawBackground ( long id , NSGraphicsContext context , NSRect rect ) {
long modifiers = nsEvent . modifierFlags ( ) ;
void mouseDown ( long id , long sel , long theEvent ) {
boolean mouseEvent ( long id , long sel , long theEvent , int type ) {
void mouseDragged ( long id , long sel , long theEvent ) {
void mouseUp ( long id , long sel , long theEvent ) {
void superKeyDown ( long id , long sel , long theEvent ) {
void superKeyUp ( long id , long sel , long theEvent ) {
public NSOpenPanel ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_filenames ) ;
long result = OS . objc_msgSend ( OS . class_NSOpenPanel , OS . sel_openPanel ) ;
long result = OS . objc_msgSend ( OS . class_NSOpenPanel , OS . sel_savePanel ) ;
public static long windowNumberAtPoint ( NSPoint point , long windowNumber ) {
public NSTextFieldCell ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_textColor ) ;
long pValue = OS . g_malloc ( byteCount ) ;
public IOleLink ( long address ) {
public int GetSourceMoniker ( long [ ] ppmk ) {
public NSComboBoxCell ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_objectValues ) ;
public IWebDataSource ( long address ) {
public int representation ( long [ ] rep ) {
public int webFrame ( long [ ] frame ) {
public int request ( long [ ] request ) {
public int pageTitle ( long [ ] title ) {
public WebDataSource ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_pageTitle ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_representation ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_request ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_webFrame ) ;
public nsIDOMWindowCollection ( long address ) {
public int Item ( int index , long [ ] _retval ) {
public int NamedItem ( long name , long [ ] _retval ) {
long colormap = OS . gdk_colormap_get_system ( ) ;
long colormap = OS . gdk_colormap_get_system ( ) ;
long layout , context , attrList , selAttrList ;
long ptr = OS . pango_layout_get_text ( layout ) ;
long linePtr = OS . pango_layout_get_line ( layout , lineIndex ) ;
long attr = OS . pango_attr_shape_new ( rect , rect ) ;
long attr = OS . pango_attr_font_desc_new ( font . handle ) ;
long attr = OS . pango_attr_foreground_new ( ( short ) 0 , ( short ) 0x3333 , ( short ) 0x9999 ) ;
long attr = OS . pango_attr_underline_new ( underlineStyle ) ;
long attr = OS . pango_attr_strikethrough_new ( true ) ;
long attr = OS . pango_attr_foreground_new ( fg . red , fg . green , fg . blue ) ;
long attr = OS . pango_attr_background_new ( bg . red , bg . green , bg . blue ) ;
long attr = OS . pango_attr_shape_new ( rect , rect ) ;
long attr = OS . pango_attr_rise_new ( rise * OS . PANGO_SCALE ) ;
long cairo = data . cairo ;
long [ ] attrs = new long [ 1 ] ;
long ptr = OS . pango_layout_get_text ( layout ) ;
long ptr = OS . pango_layout_get_text ( layout ) ;
long rgn = OS . gdk_pango_layout_get_clip_region ( layout , x , y , ranges , ranges . length / 2 ) ;
long cairo = data . cairo ;
long rgn = OS . gdk_pango_layout_get_clip_region ( layout , x , y , ranges , ranges . length / 2 ) ;
long rgn = OS . gdk_pango_layout_get_clip_region ( layout , x , y , ranges , ranges . length / 2 ) ;
long [ ] rects = new long [ 1 ] ;
long ptr = OS . pango_layout_get_text ( layout ) ;
long clipRegion = OS . gdk_pango_layout_get_clip_region ( layout , 0 , 0 , ranges , 1 ) ;
long iter = OS . pango_layout_get_iter ( layout ) ;
long linesRegion = OS . gdk_region_new ( ) ;
long iter = OS . pango_layout_get_iter ( layout ) ;
long runPtr = OS . pango_layout_iter_get_run ( iter ) ;
long iter = OS . pango_layout_get_iter ( layout ) ;
long iter = OS . pango_layout_get_iter ( layout ) ;
long ptr = OS . pango_layout_get_text ( layout ) ;
long linePtr = OS . pango_layout_get_line ( layout , i ) ;
long ptr = OS . pango_layout_get_text ( layout ) ;
long [ ] attrs = new long [ 1 ] ;
long ptr = OS . pango_layout_get_text ( layout ) ;
long iter = OS . pango_layout_get_iter ( layout ) ;
long ptr = OS . pango_layout_get_text ( layout ) ;
long tabArray = OS . pango_tab_array_new ( tabs . length , true ) ;
public long lpszDefaultScheme ;
public NSAutoreleasePool ( long id ) {
public long handle ;
long attributedSubstringFromRange ( long id , long sel , long rangePtr ) {
long characterIndexForPoint ( long id , long sel , long point ) {
NSRect firstRectForCharacterRange ( long id , long sel , long range ) {
long count = keys . count ( ) ;
boolean hasMarkedText ( long id , long sel ) {
boolean insertText ( long id , long sel , long string ) {
NSRange markedRange ( long id , long sel ) {
NSRange selectedRange ( long id , long sel ) {
boolean setMarkedText_selectedRange ( long id , long sel , long string , long selRange ) {
long ptr = OS . malloc ( NSRange . sizeof ) ;
long validAttributesForMarkedText ( long id , long sel ) {
void drawInteriorWithFrame_inView ( long id , long sel , NSRect cellRect , long view ) {
public long window ;
public long string ;
public long pszText ;
public long lParam ;
public NSFormatter ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_stringForObjectValue_ , obj ! = null ? obj . id : 0 ) ;
long getSiteWindow ( ) {
public NSStepper ( long id ) {
public static long cellClass ( ) {
public static void setCellClass ( long factoryId ) {
long gtk_button_press_event ( long widget , long event ) {
long result = ime . gtk_button_press_event ( widget , event ) ;
long gtk_commit ( long imcontext , long text ) {
long result = ime . gtk_commit ( imcontext , text ) ;
long gtk_expose_event ( long widget , long event ) {
long result = super . gtk_expose_event ( widget , event ) ;
long gtk_preedit_changed ( long imcontext ) {
long result = ime . gtk_preedit_changed ( imcontext ) ;
long copyRegion = OS . gdk_region_rectangle ( srcRect ) ;
long invalidateRegion = OS . gdk_region_rectangle ( srcRect ) ;
long gdkGC = OS . gdk_gc_new ( window ) ;
long imHandle = imHandle ( ) ;
public NSTableHeaderCell ( long id ) {
public void drawSortIndicatorWithFrame ( NSRect cellFrame , NSView controlView , boolean ascending , long priority ) {
public long type_name ;
public long add_focus_handler ;
public long contains ;
public long ref_accessible_at_point ;
public long get_extents ;
public long get_position ;
public long get_size ;
public long grab_focus ;
public long remove_focus_handler ;
public long set_extents ;
public long set_position ;
public long set_size ;
public long get_layer ;
public long get_mdi_zorder ;
long imHandle = imHandle ( ) ;
void drawBackground ( Control control , long window , long region , int x , int y , int width , int height ) {
long cairo = OS . gdk_cairo_create ( window ) ;
long pattern = Cairo . cairo_pattern_create_for_surface ( control . backgroundImage . surface ) ;
long gdkGC = OS . gdk_gc_new ( window ) ;
long enterExitHandle ( ) {
long eventHandle ( ) {
long focusHandle = shell . vboxHandle ;
void fixStyle ( long handle ) {
long childStyle = parent . childStyle ( ) ;
long focusHandle ( ) {
long fontHandle ( ) {
long focusHandle = focusHandle ( ) ;
long eventHandle = eventHandle ( ) ;
long enterExitHandle = enterExitHandle ( ) ;
long blockHandle = fixedHandle ! = 0 ? fixedHandle : eventHandle ;
long paintHandle = paintHandle ( ) ;
long imHandle = imHandle ( ) ;
long topHandle = topHandle ( ) ;
long hoverProc ( long widget ) {
long topHandle ( ) {
long topHandle = topHandle ( ) ;
long window = gtk_widget_get_window ( topHandle ) ;
long drawable = data . drawable ;
void printWidget ( GC gc , long drawable , int depth , int x , int y ) {
void printWindow ( boolean first , Control control , GC gc , long drawable , int depth , long window , int x , int y ) {
long [ ] real_drawable = new long [ 1 ] ;
long [ ] userData = new long [ 1 ] ;
long eventPtr = OS . gdk_event_new ( OS . GDK_EXPOSE ) ;
long parentWindow = OS . gdk_window_get_parent ( window ) ;
long cairo = gcData . cairo ;
long pattern = Cairo . cairo_pattern_create_for_surface ( surface ) ;
long children = OS . gdk_window_get_children ( window ) ;
long windows = children ;
long child = OS . g_list_data ( windows ) ;
long [ ] data = new long [ 1 ] ;
long childStyle ( ) {
Point computeNativeSize ( long h , int wHint , int hHint , boolean changed ) {
long topHandle = topHandle ( ) ;
long topHandle = topHandle ( ) ;
void modifyStyle ( long handle , long style ) {
long topHandle = topHandle ( ) ;
long topHandle = topHandle ( ) ;
long topHandle = topHandle ( ) ;
long topHandle = topHandle ( ) ;
long handle = OS . g_list_nth_data ( list , count - 2 ) ;
boolean isFocusHandle ( long widget ) {
long window = eventWindow ( ) ;
long window = eventWindow ( ) ;
long eventPtr = 0 ;
long fixedMapProc ( long widget ) {
long widgetList = OS . gtk_container_get_children ( widget ) ;
long widgets = widgetList ;
long child = OS . g_list_data ( widgets ) ;
void fixModal ( long group , long modalGroup ) {
boolean forceFocus ( long focusHandle ) {
long fontHandle = fontHandle ( ) ;
long fontHandle = fontHandle ( ) ;
long fontHandle = fontHandle ( ) ;
long fontHandle = fontHandle ( ) ;
long screen = OS . gdk_screen_get_default ( ) ;
long gtk_button_press_event ( long widget , long event ) {
long gtk_button_press_event ( long widget , long event , boolean sendMouseDown ) {
long result = 0 ;
long nextEvent = OS . gdk_event_peek ( ) ;
long gtk_button_release_event ( long widget , long event ) {
long gtk_commit ( long imcontext , long text ) {
long gtk_enter_notify_event ( long widget , long event ) {
long toolHandle = getShell ( ) . handle ;
long gtk_event_after ( long widget , long gdkEvent ) {
long grabHandle = OS . gtk_grab_get_current ( ) ;
long gtk_expose_event ( long widget , long eventPtr ) {
long gtk_focus ( long widget , long directionType ) {
long gtk_focus_in_event ( long widget , long event ) {
long oldIMHandle = oldControl . imHandle ( ) ;
long imHandle = imHandle ( ) ;
long gtk_focus_out_event ( long widget , long event ) {
long imHandle = imHandle ( ) ;
long gtk_key_press_event ( long widget , long event ) {
long gtk_key_release_event ( long widget , long event ) {
long imHandle = imHandle ( ) ;
long gtk_leave_notify_event ( long widget , long event ) {
long gtk_mnemonic_activate ( long widget , long arg1 ) {
long eventPtr = OS . gtk_get_current_event ( ) ;
long focusHandle = focusControl ! = null ? focusControl . focusHandle ( ) : 0 ;
long gtk_motion_notify_event ( long widget , long event ) {
long window = eventWindow ( ) ;
long gtk_popup_menu ( long widget ) {
long gtk_preedit_changed ( long imcontext ) {
long window = gtk_widget_get_window ( paintHandle ( ) ) ;
long gtk_scroll_event ( long widget , long eventPtr ) {
long gtk_show_help ( long widget , long helpType ) {
long gtk_style_set ( long widget , long previousStyle ) {
long gtk_visibility_notify_event ( long widget , long event ) {
void gtk_widget_set_has_window ( long fixedHandle , boolean value ) {
void gtk_widget_size_request ( long widget , GtkRequisition requisition ) {
public long internal_new_GC ( GCData data ) {
long window = paintWindow ( ) ;
long imHandle ( ) {
public void internal_dispose_GC ( long hDC , GCData data ) {
long gc = hDC ;
long imHandle = imHandle ( ) ;
long window = paintWindow ( ) ;
long imHandle = imHandle ( ) ;
void restackWindow ( long window , long sibling , boolean above ) {
boolean sendHelpEvent ( long helpType ) {
long window = eventWindow ( ) ;
long style = OS . gtk_widget_get_modifier_style ( handle ) ;
void setBackgroundColor ( long handle , GdkColor color ) {
long window = gtk_widget_get_window ( paintHandle ( ) ) ;
long xDisplay = OS . gdk_x11_display_get_xdisplay ( OS . gdk_display_get_default ( ) ) ;
void setFontDescription ( long font ) {
long style = OS . gtk_widget_get_modifier_style ( handle ) ;
long topHandle = topHandle ( ) ;
long topHandle = topHandle ( ) ;
long newParent = parent . parentingHandle ( ) ;
void setParentWindow ( long widget ) {
long window = paintWindow ( ) ;
long window = paintWindow ( ) ;
long topHandle = topHandle ( ) ;
long siblingWindow = 0 ;
long redrawWindow = fixChildren ? parent . redrawWindow : 0 ;
long siblingW = siblingWindow ! = 0 ? siblingWindow : redrawWindow ;
long window = paintWindow ( ) ;
long windowProc ( long handle , long arg0 , long user_data ) {
long gdkGC = OS . gdk_gc_new ( window ) ;
long shellHandle , tooltipsHandle , tooltipWindow , group , modalGroup ;
Shell ( Display display , Shell parent , int style , long handle , boolean embedded ) {
public static Shell gtk_new ( Display display , long handle ) {
public static Shell internal_new ( Display display , long handle ) {
long window = gtk_widget_get_window ( shellHandle ) ;
long focusHandle = OS . gtk_window_get_focus ( activeShell . shellHandle ) ;
long window = gtk_widget_get_window ( shellHandle ) ;
long childStyle ( ) {
long children = OS . gtk_container_get_children ( vboxHandle ) ;
long filterProc ( long xEvent , long gdkEvent , long data2 ) {
long window = gtk_widget_get_window ( shellHandle ) ;
long topHandle ( ) {
long fixedSizeAllocateProc ( long widget , long allocationPtr ) {
long result = super . fixedSizeAllocateProc ( widget , allocationPtr ) ;
void fixStyle ( long handle ) {
long gtk_button_press_event ( long widget , long event ) {
long gtk_configure_event ( long widget , long event ) {
long gtk_delete_event ( long widget , long event ) {
long gtk_enter_notify_event ( long widget , long event ) {
long gtk_expose_event ( long widget , long event ) {
long gtk_focus ( long widget , long directionType ) {
long gtk_leave_notify_event ( long widget , long event ) {
long window = gtk_widget_get_window ( shellHandle ) ;
long gtk_move_focus ( long widget , long directionType ) {
long focusHandle = control . focusHandle ( ) ;
long gtk_motion_notify_event ( long widget , long event ) {
long gtk_key_press_event ( long widget , long event ) {
long gtk_size_allocate ( long widget , long allocation ) {
long gtk_window_state_event ( long widget , long event ) {
void setCursor ( long cursor ) {
long xDisplay = OS . gdk_x11_display_get_xdisplay ( OS . gdk_display_get_default ( ) ) ;
long parentHandle = shellHandle ;
long window = gtk_widget_get_window ( parentHandle ) ;
long xDisplay = OS . gdk_x11_display_get_xdisplay ( OS . gdk_display_get_default ( ) ) ;
long screen = OS . gdk_screen_get_default ( ) ;
long menuHandle = menuBar . handle ;
long menuHandle = menu . handle ;
long shellMapProc ( long handle , long arg0 , long user_data ) {
long sizeAllocateProc ( long handle , long arg0 , long user_data ) {
long screen = OS . gdk_screen_get_default ( ) ;
long sizeRequestProc ( long handle , long arg0 , long user_data ) {
long group = 0 ;
long window = gtk_widget_get_window ( shellHandle ) ;
void setToolTipText ( long tipWidget , String string ) {
void setToolTipText ( long rootWidget , long tipWidget , String string ) {
long oldTooltip = OS . gtk_widget_get_tooltip_text ( rootWidget ) ;
long tipData = OS . gtk_tooltips_data_get ( tipWidget ) ;
long oldTooltip = OS . GTK_TOOLTIPS_GET_TIP_TEXT ( tipData ) ;
long tipWindow = OS . GTK_TOOLTIPS_TIP_WINDOW ( tooltipsHandle ) ;
long window = OS . gdk_window_at_pointer ( x , y ) ;
long [ ] user_data = new long [ 1 ] ;
long data = OS . gtk_tooltips_data_get ( tipWidget ) ;
public nsICookieManager ( long address ) {
public int GetEnumerator ( long [ ] aEnumerator ) {
public int Remove ( long aDomain , long aName , long aPath , int aBlocked ) {
public long content ;
static final long GroupProc ;
long hInstance = OS . GetModuleHandle ( null ) ;
long hHeap = OS . GetProcessHeap ( ) ;
long lpszClassName = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount ) ;
long callWindowProc ( long hwnd , int msg , long wParam , long lParam ) {
void printWidget ( long hwnd , long hdc , GC gc ) {
long topHandle = children [ i ] . topHandle ( ) ;
long windowProc ( ) {
LRESULT WM_ERASEBKGND ( long wParam , long lParam ) {
LRESULT WM_NCHITTEST ( long wParam , long lParam ) {
long code = callWindowProc ( handle , OS . WM_NCHITTEST , wParam , lParam ) ;
LRESULT WM_MOUSEMOVE ( long wParam , long lParam ) {
LRESULT WM_PRINTCLIENT ( long wParam , long lParam ) {
long code = callWindowProc ( handle , OS . WM_PRINTCLIENT , wParam , lParam ) ;
LRESULT WM_UPDATEUISTATE ( long wParam , long lParam ) {
long code = OS . DefWindowProc ( handle , OS . WM_UPDATEUISTATE , wParam , lParam ) ;
LRESULT WM_WINDOWPOSCHANGING ( long wParam , long lParam ) {
public IWebFramePrivate ( long address ) {
public int setInPrintingMode ( int value , long printDC ) {
public int getPrintedPageCount ( long printDC , int [ ] pageCount ) {
public int spoolPages ( long printDC , int startPage , int endPage , long [ ] ctx ) {
long clipboardOwner = OS . gtk_window_new ( 0 ) ;
long clearFunc ( long clipboard , long user_data_or_owner ) {
long getFunc ( long clipboard , long selection_data , long info , long user_data_or_owner ) {
long pTargetsList = 0 ;
long pName = OS . g_malloc ( buffer . length ) ;
long handle = table . handle ;
long handle = table . handle ;
long [ ] path = new long [ 1 ] ;
long indices = OS . gtk_tree_path_get_indices ( path [ 0 ] ) ;
public nsIPrincipal ( long address ) {
public int GetPreferences ( long [ ] prefBranch , long [ ] id , long [ ] subjectName , long [ ] grantedList , long [ ] deniedList , int [ ] isTrusted ) {
public int Equals ( long other , int [ ] _retval ) {
public int EqualsIgnoringDomain ( long other , int [ ] _retval ) {
public int GetJSPrincipals ( long cx , long [ ] _retval ) {
public int GetSecurityPolicy ( long [ ] aSecurityPolicy ) {
public int SetSecurityPolicy ( long aSecurityPolicy ) {
public int CanEnableCapability ( byte [ ] capability , long _retval ) {
public int IsCapabilityEnabled ( byte [ ] capability , long annotation , int [ ] _retval ) {
public int EnableCapability ( byte [ ] capability , long [ ] annotation ) {
public int RevertCapability ( byte [ ] capability , long [ ] annotation ) {
public int DisableCapability ( byte [ ] capability , long [ ] annotation ) {
public int GetURI ( long [ ] aURI ) {
public int GetDomain ( long [ ] aDomain ) {
public int SetDomain ( long aDomain ) {
public int GetOrigin ( long [ ] aOrigin ) {
public int GetFingerprint ( long aFingerprint ) {
public int GetPrettyName ( long aPrettyName ) {
public int Subsumes ( long other , int [ ] _retval ) {
public int CheckMayLoad ( long uri , int report ) {
public int GetSubjectName ( long aSubjectName ) {
public int GetCertificate ( long [ ] aCertificate ) {
public int GetCsp ( long [ ] aCsp ) {
public int SetCsp ( long aCsp ) {
long lastHwnd , lastGetHwnd ;
long hButtonTheme , hEditTheme , hExplorerBarTheme , hScrollBarTheme , hTabTheme ;
long msgFilterProc , filterHook ;
long foregroundIdleProc , idleHook ;
long getMsgProc , msgHook , embeddedHwnd , embeddedProc ;
long [ ] timerIds ;
long nextTimerId = SETTINGS_ID + 1 ;
static final long SETTINGS_ID = 100 ;
long hwndMessage , messageProc ;
void addControl ( long handle , Control control ) {
static long create32bitDIB ( Image image ) {
long hMask = 0 , hBitmap = 0 ;
long oldMemBitmap = OS . SelectObject ( memHdc , memDib ) ;
static long create32bitDIB ( long hBitmap , int alpha , byte [ ] alphaData , int transparentPixel ) {
long oldMemBitmap = OS . SelectObject ( memHdc , memDib ) ;
long hIcon = OS . CreateIconIndirect ( info ) ;
static long createMaskFromAlpha ( ImageData data , int destWidth , int destHeight ) {
long hMask = OS . CreateBitmap ( srcWidth , srcHeight , 1 , 1 , mask . data ) ;
long embeddedProc ( long hwnd , long msg , long wParam , long lParam ) {
long hHeap = OS . GetProcessHeap ( ) ;
Control findControl ( long handle ) {
long hwndOwner = 0 ;
public Widget findWidget ( long handle ) {
public Widget findWidget ( long handle , long id ) {
public Widget findWidget ( Widget widget , long id ) {
long foregroundIdleProc ( long code , long wParam , long lParam ) {
TouchSource findTouchSource ( long touchDevice , Monitor monitor ) {
int getClickCount ( int type , int button , long hwnd , long lParam ) {
Control getControl ( long handle ) {
long [ ] phkResult = new long [ 1 ] ;
long lpfnEnum = callback . getAddress ( ) ;
long getMsgProc ( long code , long wParam , long lParam ) {
long hInstance = OS . GetModuleHandle ( null ) ;
long lpfnEnum = callback . getAddress ( ) ;
long hFont = 0 ;
long hIcon = OS . LoadImage ( 0 , OS . OIC_HAND , OS . IMAGE_ICON , 0 , 0 , OS . LR_SHARED ) ;
long hIcon = OS . LoadImage ( 0 , OS . OIC_INFORMATION , OS . IMAGE_ICON , 0 , 0 , OS . LR_SHARED ) ;
long hIcon = OS . LoadImage ( 0 , OS . OIC_QUES , OS . IMAGE_ICON , 0 , 0 , OS . LR_SHARED ) ;
long hIcon = OS . LoadImage ( 0 , OS . OIC_BANG , OS . IMAGE_ICON , 0 , 0 , OS . LR_SHARED ) ;
long hButtonTheme ( ) {
long hEditTheme ( ) {
long hExplorerBarTheme ( ) {
long hScrollBarTheme ( ) {
long hTabTheme ( ) {
public long internal_new_GC ( GCData data ) {
long hDC = OS . GetDC ( 0 ) ;
long [ ] appID = new long [ 1 ] ;
long [ ] ppv = new long [ 1 ] ;
public void internal_dispose_GC ( long hDC , GCData data ) {
long [ ] phKey = new long [ 1 ] ;
long messageProc ( long hwnd , long msg , long wParam , long lParam ) {
long hHeap = OS . GetProcessHeap ( ) ;
long hwndActive = OS . GetActiveWindow ( ) ;
long hwndModal = modal . handle ;
long hwndPopup = OS . GetLastActivePopup ( hwndModal ) ;
long [ ] mapHandle = new long [ 1 ] ;
long processHandle = OS . OpenProcess ( OS . PROCESS_VM_READ | OS . PROCESS_DUP_HANDLE , false , pid ) ;
long sharedData = OS . MapViewOfFile ( mapHandle [ 0 ] , OS . FILE_MAP_READ , 0 , 0 , 0 ) ;
long monitorEnumProc ( long hmonitor , long hdc , long lprcMonitor , long dwData ) {
long msgFilterProc ( long code , long wParam , long lParam ) {
Control removeControl ( long handle ) {
boolean runTimer ( long id ) {
if ( timerIds = = null ) timerIds = new long [ 4 ] ;
long timerId = 0 ;
long [ ] newTimerIds = new long [ timerIds . length + 4 ] ;
long newTimerID = OS . SetTimer ( hwndMessage , timerId , milliseconds , 0 ) ;
long windowProc ( long hwnd , long msg , long wParam , long lParam ) {
long getAddress ( ) {
int QueryInterface ( long riid , long ppvObject ) {
XPCOM . memmove ( ppvObject , new long [ ] { supports . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { factory . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
int CreateInstance ( long aOuter , long iid , long result ) {
XPCOM . memmove ( result , new long [ ] { promptService . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( result , new long [ ] { promptFactory . getAddress ( ) } , C . PTR_SIZEOF ) ;
public long analysis_shape_engine ;
public long analysis_lang_engine ;
public long analysis_font ;
public long analysis_language ;
public long analysis_extra_attrs ;
long timerProc ( long widget ) {
long window = paintWindow ( ) ;
long newPtr = OS . GlobalAlloc ( OS . GMEM_FIXED | OS . GMEM_ZEROINIT , BITMAPINFOHEADER . sizeof + colorSize + imageSize ) ;
long pBitDest = newPtr + BITMAPINFOHEADER . sizeof + colorSize ;
long hMem = stgmedium . unionField ;
long ptr = OS . GlobalLock ( hMem ) ;
long bits = ptr + bmiHeader . biSize ;
long [ ] ptr = new long [ 1 ] ;
long [ ] ptr = new long [ 1 ] ;
long [ ] ptr = new long [ 1 ] ;
long [ ] ptr = new long [ 1 ] ;
long [ ] ptr = new long [ 1 ] ;
long [ ] ptr = new long [ 1 ] ;
OS . gtk_list_store_set ( parent . modelHandle , handle , i , ( long ) 0 , - 1 ) ;
long path = OS . gtk_tree_model_get_path ( parent . modelHandle , handle ) ;
long path = OS . gtk_tree_model_get_path ( parent . modelHandle , handle ) ;
long pixbufRenderer = parent . getPixbufRenderer ( column ) ;
long path = OS . gtk_tree_model_get_path ( parent . modelHandle , handle ) ;
long path = OS . gtk_tree_model_get_path ( parent . modelHandle , handle ) ;
long window = OS . gtk_tree_view_get_bin_window ( parentHandle ) ;
long fontHandle = font ! = null ? font . handle : 0 ;
long fontHandle = font ! = null ? font . handle : 0 ;
long pixbuf = 0 ;
long pixbufRenderer = parent . getPixbufRenderer ( column ) ;
long style = OS . gtk_widget_get_modifier_style ( parentHandle ) ;
public NSSet ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_allObjects ) ;
public long count ( ) {
long result = OS . objc_msgSend ( this . id , OS . sel_objectEnumerator ) ;
long result = OS . objc_msgSend ( OS . class_NSSet , OS . sel_set ) ;
public long pchHostCss ;
public long pchHostNS ;
boolean acceptsFirstMouse ( long id , long sel , long theEvent ) {
boolean acceptsFirstResponder ( long id , long sel ) {
long accessibilityAttributeValue ( long id , long sel , long arg0 ) {
long superValue = super . accessibilityAttributeValue ( id , sel , arg0 ) ;
boolean accessibilityIsIgnored ( long id , long sel ) {
void drawBackground ( long id , NSGraphicsContext context , NSRect rect ) {
boolean isOpaque ( long id , long sel ) {
void keyDown ( long id , long sel , long theEvent ) {
boolean mouseEvent ( long id , long sel , long theEvent , int type ) {
void pageDown ( long id , long sel , long sender ) {
void pageUp ( long id , long sel , long sender ) {
void reflectScrolledClipView ( long id , long sel , long aClipView ) {
void scrollWheel ( long id , long sel , long theEvent ) {
public nsIFilePicker_1_8 ( long address ) {
public int Init ( long parent , long title , short mode ) {
public int AppendFilter ( long title , long filter ) {
public int GetDefaultString ( long aDefaultString ) {
public int SetDefaultString ( long aDefaultString ) {
public int GetDefaultExtension ( long aDefaultExtension ) {
public int SetDefaultExtension ( long aDefaultExtension ) {
public int GetDisplayDirectory ( long [ ] aDisplayDirectory ) {
public int SetDisplayDirectory ( long aDisplayDirectory ) {
public int GetFile ( long [ ] aFile ) {
public int GetFileURL ( long [ ] aFileURL ) {
public int GetFiles ( long [ ] aFiles ) {
public int Show ( long _retval ) {
public nsIDirectoryServiceProvider ( long address ) {
public int GetFile ( byte [ ] prop , int [ ] persistent , long [ ] _retval ) {
public IEnumSTATSTG ( long address ) {
public IWebURLProtectionSpace ( long address ) {
public int host ( long [ ] result ) {
public int realm ( long [ ] result ) {
public long lprgscode ;
public long lprgelemdescParam ;
public long elemdescFunc_tdesc_union ;
public long elemdescFunc_paramdesc_pparamdescex ;
public nsIProperties ( long address ) {
public int Get ( byte [ ] prop , nsID iid , long [ ] result ) {
public int Set ( byte [ ] prop , long value ) {
public int GetKeys ( int [ ] count , long [ ] keys ) {
public NSToolbar ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_initWithIdentifier_ , identifier ! = null ? identifier . id : 0 ) ;
public void insertItemWithItemIdentifier ( NSString itemIdentifier , long index ) {
public void removeItemAtIndex ( long index ) {
public void setDisplayMode ( long displayMode ) {
long parentHandle = ( parent ! = null ) ? parent . topHandle ( ) : 0 ;
long pixbufs = OS . gtk_window_get_icon_list ( parentHandle ) ;
long group = OS . gtk_window_get_group ( 0 ) ;
long hookId = 0 ;
long selection = widget . indexOfSelectedItem ( ) ;
long selection = widget . indexOfSelectedItem ( ) ;
boolean becomeFirstResponder ( long id , long sel ) {
void setObjectValue ( long id , long sel , long arg0 ) {
void comboBoxSelectionDidChange ( long id , long sel , long notification ) {
long tableSelection = widget . indexOfSelectedItem ( ) ;
void comboBoxWillDismiss ( long id , long sel , long notification ) {
void comboBoxWillPopUp ( long id , long sel , long notification ) {
long index = widget . indexOfSelectedItem ( ) ;
long charPosition = feAsTextView . characterIndexForInsertionAtPoint ( textViewMouse ) ;
long length = str . length ( ) ;
boolean isEventView ( long id ) {
void menuWillOpen ( long id , long sel , long menu ) {
void menuDidClose ( long id , long sel , long menu ) {
void mouseDown ( long id , long sel , long theEvent ) {
long modifierFlags = nsEvent . modifierFlags ( ) ;
void setForeground ( double [ ] color ) {
boolean shouldChangeTextInRange_replacementString ( long id , long sel , long affectedCharRange , long replacementString ) {
long type = currentEvent . type ( ) ;
void textViewDidChangeSelection ( long id , long sel , long aNotification ) {
void textDidChange ( long id , long sel , long aNotification ) {
NSRange textView_willChangeSelectionFromCharacterRange_toCharacterRange ( long id , long sel , long aTextView , long oldSelectedCharRange , long newSelectedCharRange ) {
public IOleWindow ( long address ) {
public int GetWindow ( long [ ] phwnd ) {
static final long ProgressBarProc ;
long lpszClassName = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount ) ;
long callWindowProc ( long hwnd , int msg , long wParam , long lParam ) {
long state = OS . SendMessage ( handle , OS . PBM_GETSTATE , 0 , 0 ) ;
long windowProc ( ) {
LRESULT WM_GETDLGCODE ( long wParam , long lParam ) {
LRESULT WM_SIZE ( long wParam , long lParam ) {
LRESULT WM_TIMER ( long wParam , long lParam ) {
NSSize cellSizeForBounds ( long id , long sel , NSRect cellFrame ) {
double trimHeight = size . height - titleRect . height ;
void drawImageWithFrameInView ( long id , long sel , long image , NSRect rect , long view ) {
void drawInteriorWithFrame_inView ( long id , long sel , NSRect cellRect , long viewid ) {
NSRect drawTitleWithFrameInView ( long id , long sel , long title , NSRect titleRect , long view ) {
void drawWidget ( long id , NSGraphicsContext context , NSRect rect ) {
long nextState ( long id , long sel ) {
void setForeground ( double [ ] color ) {
NSRect titleRectForBounds ( long id , long sel , NSRect cellFrame ) {
long [ ] funcs = new long [ 17 ] ;
int didChangeLocationWithinPageForFrame ( long webView , long frame ) {
long [ ] result = new long [ 1 ] ;
int didClearWindowObject ( long webView , long context , long windowScriptObject , long frame ) {
long name = WebKit_win32 . JSStringCreateWithUTF8CString ( bytes ) ;
long [ ] mainFrame = new long [ 1 ] ;
int didCommitLoadForFrame ( long webview , long frame ) {
long [ ] result = new long [ 1 ] ;
int didFailProvisionalLoadWithError ( long webView , long error , long frame ) {
long [ ] failingURL = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long [ ] certificate = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
int didFinishLoadForFrame ( long webview , long frame ) {
long [ ] iWebFrame = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
int didStartProvisionalLoadForFrame ( long webView , long frame ) {
long getAddress ( ) {
int QueryInterface ( long riid , long ppvObject ) {
COM . MoveMemory ( ppvObject , new long [ ] { iWebFrameLoadDelegate . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { iWebFrameLoadDelegate . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
boolean showCertificateDialog ( long webView , final String failingUrlString , final String description , final long certificate ) {
void showCertificate ( Shell parent , long certificate ) {
public NSSavePanel ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_filename ) ;
public long runModal ( ) {
public long runModalForDirectory ( NSString path , NSString name ) {
long result = OS . objc_msgSend ( OS . class_NSSavePanel , OS . sel_savePanel ) ;
public static long windowNumberAtPoint ( NSPoint point , long windowNumber ) {
long hFont = defaultFont ( ) ;
long hwnd = parent . handle ;
long hBitmap = image ! = null ? image . handle : 0 ;
long hFont = 0 ;
long hwnd = parent . handle ;
public long window ;
public long atom ;
public NSDockTile ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_badgeLabel ) ;
long getAddress ( ) {
private int Next ( int celt , long rgelt , long pceltFetched ) {
private int QueryInterface ( long riid , long ppvObject ) {
COM . MoveMemory ( ppvObject , new long [ ] { iUnknown . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { iEnumFORMATETC . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
long accessibilityAttributeValue ( long id , long sel , long arg0 ) {
boolean acceptsFirstResponder ( long id , long sel ) {
long row = widget . rowAtPoint ( pt ) ;
void drawBackgroundInClipRect ( long id , long sel , NSRect rect ) {
long [ ] indexBuffer = new long [ count ] ;
long [ ] result = new long [ count ] ;
long [ ] indices = new long [ count ] ;
long menuForEvent ( long id , long sel , long theEvent ) {
long row = table . rowAtPoint ( mousePoint ) ;
void mouseDownSuper ( long id , long sel , long theEvent ) {
boolean needsPanelToBecomeKey ( long id , long sel ) {
long numberOfRowsInTableView ( long id , long sel , long aTableView ) {
double oldWidth = column . width ( ) ;
double width = 0 ;
void tableViewSelectionDidChange ( long id , long sel , long aNotification ) {
void tableViewSelectionIsChanging ( long id , long sel , long aNotification ) {
long tableView_selectionIndexesForProposedSelection ( long id , long sel , long aTableView , long indexSet ) {
long getAddress ( ) {
int QueryInterface ( long riid , long ppvObject ) {
XPCOM . memmove ( ppvObject , new long [ ] { supports . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { download . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { progressDialog . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { webProgressListener . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
int Init ( long aSource , long aTarget , long aDisplayName , long aMIMEInfo , long startTime1 , long startTime2 , long aPersist ) {
long aSpec = XPCOM . nsEmbedCString_new ( ) ;
long buffer = XPCOM . nsEmbedCString_get ( aSpec ) ;
long [ ] result = new long [ 1 ] ;
long aPath = XPCOM . nsEmbedCString_new ( ) ;
long aNativeTarget = XPCOM . nsEmbedString_new ( ) ;
int GetSource ( long aSource ) {
int GetTarget ( long aTarget ) {
int GetPersist ( long aPersist ) {
int GetPercentComplete ( long aPercentComplete ) {
int GetDisplayName ( long aDisplayName ) {
int SetDisplayName ( long aDisplayName ) {
int GetStartTime ( long aStartTime ) {
int GetMIMEInfo ( long aMIMEInfo ) {
int GetListener ( long aListener ) {
int SetListener ( long aListener ) {
int GetObserver ( long aObserver ) {
int SetObserver ( long aObserver ) {
long [ ] result = new long [ 1 ] ;
int Open ( long aParent ) {
int GetCancelDownloadOnClose ( long aCancelDownloadOnClose ) {
int GetDialog ( long aDialog ) {
int SetDialog ( long aDialog ) {
int OnStateChange ( long aWebProgress , long aRequest , int aStateFlags , int aStatus ) {
int OnProgressChange ( long aWebProgress , long aRequest , int aCurSelfProgress , int aMaxSelfProgress , int aCurTotalProgress , int aMaxTotalProgress ) {
int OnLocationChange ( long aWebProgress , long aRequest , long aLocation ) {
int OnStatusChange ( long aWebProgress , long aRequest , int aStatus , long aMessage ) {
int OnSecurityChange ( long aWebProgress , long aRequest , int state ) {
public nsIDOMEventTarget ( long address ) {
public int AddEventListener ( long type , long listener , int useCapture ) {
public int AddEventListener ( long type , long listener , int useCapture , int wantsUntrusted , int _argc ) {
public int RemoveEventListener ( long type , long listener , int useCapture ) {
public int DispatchEvent ( long evt , int [ ] _retval ) {
public static final native int GdiplusStartup ( long [ ] token , GdiplusStartupInput input , long output ) ;
public static final native void GdiplusShutdown ( long token ) ;
public static final native long Bitmap_new ( long hbm , long hpal ) ;
public static final native long Bitmap_new ( long hicon ) ;
public static final native long Bitmap_new ( int width , int height , int stride , int format , long scan0 ) ;
public static final native long Bitmap_new ( char [ ] filename , boolean useIcm ) ;
public static final native void Bitmap_delete ( long bitmap ) ;
public static final native int Bitmap_GetHBITMAP ( long bitmap , long colorBackground , long [ ] hbmReturn ) ;
public static final native int Bitmap_GetHICON ( long bitmap , long [ ] hicon ) ;
public static final native long BitmapData_new ( ) ;
public static final native void BitmapData_delete ( long bitmapData ) ;
public static final native int Bitmap_LockBits ( long bitmap , long rect , int flags , int pixelFormat , long lockedBitmapData ) ;
public static final native int Bitmap_UnlockBits ( long bitmap , long lockedBitmapData ) ;
public static final native long Brush_Clone ( long brush ) ;
public static final native int Brush_GetType ( long brush ) ;
public static final native long Color_new ( int argb ) ;
public static final native void Color_delete ( long color ) ;
public static final native long PrivateFontCollection_new ( ) ;
public static final native void PrivateFontCollection_delete ( long collection ) ;
public static final native int PrivateFontCollection_AddFontFile ( long collection , char [ ] filename ) ;
public static final native long Font_new ( long hdc , long hfont ) ;
public static final native long Font_new ( long family , float emSize , int style , int unit ) ;
public static final native long Font_new ( char [ ] familyName , float emSize , int style , int unit , long fontCollection ) ;
public static final native void Font_delete ( long font ) ;
public static final native int Font_GetFamily ( long font , long family ) ;
public static final native float Font_GetSize ( long font ) ;
public static final native int Font_GetStyle ( long font ) ;
public static final native int Font_GetLogFontW ( long font , long g , long logfontW ) ;
public static final native boolean Font_IsAvailable ( long font ) ;
public static final native long FontFamily_new ( ) ;
public static final native long FontFamily_new ( char [ ] name , long fontCollection ) ;
public static final native void FontFamily_delete ( long family ) ;
public static final native int FontFamily_GetFamilyName ( long family , char [ ] name , char language ) ;
public static final native boolean FontFamily_IsAvailable ( long family ) ;
public static final native long Graphics_new ( long hdc ) ;
public static final native void Graphics_delete ( long graphics ) ;
public static final native int Graphics_DrawArc ( long graphics , long pen , int x , int y , int width , int height , float startAngle , float sweepAngle ) ;
public static final native int Graphics_DrawDriverString ( long graphics , long text , int length , long font , long brush , PointF positions , int flags , long matrix ) ;
public static final native int Graphics_DrawDriverString ( long graphics , long text , int length , long font , long brush , float [ ] positions , int flags , long matrix ) ;
public static final native int Graphics_DrawEllipse ( long graphics , long pen , int x , int y , int width , int height ) ;
public static final native int Graphics_DrawImage ( long graphics , long image , int x , int y ) ;
public static final native int Graphics_DrawImage ( long graphics , long image , Rect destRect , int srcx , int srcy , int srcwidth , int srcheight , int srcUnit , long imageAttributes , long callback , long callbackData ) ;
public static final native int Graphics_DrawLine ( long graphics , long pen , int x1 , int y1 , int x2 , int y2 ) ;
public static final native int Graphics_DrawLines ( long graphics , long pen , int [ ] points , int count ) ;
public static final native int Graphics_DrawPath ( long graphics , long pen , long path ) ;
public static final native int Graphics_DrawPolygon ( long graphics , long pen , int [ ] points , int count ) ;
public static final native int Graphics_DrawRectangle ( long graphics , long pen , int x , int y , int width , int height ) ;
public static final native int Graphics_DrawString ( long graphics , char [ ] string , int length , long font , PointF origin , long brush ) ;
public static final native int Graphics_DrawString ( long graphics , char [ ] string , int length , long font , PointF origin , long format , long brush ) ;
public static final native int Graphics_FillEllipse ( long graphics , long brush , int x , int y , int width , int height ) ;
public static final native int Graphics_FillPath ( long graphics , long brush , long path ) ;
public static final native void Graphics_Flush ( long graphics , int intention ) ;
public static final native int Graphics_FillPie ( long graphics , long brush , int x , int y , int width , int height , float startAngle , float sweepAngle ) ;
public static final native int Graphics_FillPolygon ( long graphics , long brush , int [ ] points , int count , int fillMode ) ;
public static final native int Graphics_FillRectangle ( long graphics , long brush , int x , int y , int width , int height ) ;
public static final native int Graphics_GetClipBounds ( long graphics , RectF rect ) ;
public static final native int Graphics_GetClipBounds ( long graphics , Rect rect ) ;
public static final native int Graphics_GetClip ( long graphics , long region ) ;
public static final native long Graphics_GetHDC ( long graphics ) ;
public static final native void Graphics_ReleaseHDC ( long graphics , long hdc ) ;
public static final native int Graphics_GetInterpolationMode ( long graphics ) ;
public static final native int Graphics_GetSmoothingMode ( long graphics ) ;
public static final native int Graphics_GetTextRenderingHint ( long graphics ) ;
public static final native int Graphics_GetTransform ( long graphics , long matrix ) ;
public static final native int Graphics_GetVisibleClipBounds ( long graphics , Rect rect ) ;
public static final native int Graphics_MeasureDriverString ( long graphics , long text , int length , long font , float [ ] positions , int flags , long matrix , RectF boundingBox ) ;
public static final native int Graphics_MeasureString ( long graphics , char [ ] string , int length , long font , PointF origin , RectF boundingBox ) ;
public static final native int Graphics_MeasureString ( long graphics , char [ ] string , int length , long font , PointF origin , long format , RectF boundingBox ) ;
public static final native int Graphics_ResetClip ( long graphics ) ;
public static final native int Graphics_Restore ( long graphics , int gstate ) ;
public static final native int Graphics_Save ( long graphics ) ;
public static final native int Graphics_ScaleTransform ( long graphics , float sx , float sy , int order ) ;
public static final native int Graphics_SetClip ( long graphics , long hrgn , int combineMode ) ;
public static final native int Graphics_SetClip ( long graphics , Rect rect , int combineMode ) ;
public static final native int Graphics_SetClipPath ( long graphics , long path ) ;
public static final native int Graphics_SetClipPath ( long graphics , long path , int combineMode ) ;
public static final native int Graphics_SetCompositingQuality ( long graphics , int compositingQuality ) ;
public static final native int Graphics_SetPageUnit ( long graphics , int unit ) ;
public static final native int Graphics_SetPixelOffsetMode ( long graphics , int pixelOffsetMode ) ;
public static final native int Graphics_SetSmoothingMode ( long graphics , int smoothingMode ) ;
public static final native int Graphics_SetTransform ( long graphics , long matrix ) ;
public static final native int Graphics_SetInterpolationMode ( long graphics , int mode ) ;
public static final native int Graphics_SetTextRenderingHint ( long graphics , int mode ) ;
public static final native int Graphics_TranslateTransform ( long graphics , float dx , float dy , int order ) ;
public static final native long GraphicsPath_new ( int fillMode ) ;
public static final native long GraphicsPath_new ( int [ ] points , byte [ ] types , int count , int fillMode ) ;
public static final native void GraphicsPath_delete ( long path ) ;
public static final native int GraphicsPath_AddArc ( long path , float x , float y , float width , float height , float startAngle , float sweepAngle ) ;
public static final native int GraphicsPath_AddBezier ( long path , float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , float x4 , float y4 ) ;
public static final native int GraphicsPath_AddLine ( long path , float x1 , float y1 , float x2 , float y2 ) ;
public static final native int GraphicsPath_AddPath ( long path , long addingPath , boolean connect ) ;
public static final native int GraphicsPath_AddRectangle ( long path , RectF rect ) ;
public static final native int GraphicsPath_AddString ( long path , char [ ] string , int length , long family , int style , float emSize , PointF origin , long format ) ;
public static final native int GraphicsPath_CloseFigure ( long path ) ;
public static final native long GraphicsPath_Clone ( long path ) ;
public static final native int GraphicsPath_Flatten ( long path , long matrix , float flatness ) ;
public static final native int GraphicsPath_GetBounds ( long path , RectF bounds , long matrix , long pen ) ;
public static final native int GraphicsPath_GetLastPoint ( long path , PointF lastPoint ) ;
public static final native int GraphicsPath_GetPathPoints ( long path , float [ ] points , int count ) ;
public static final native int GraphicsPath_GetPathTypes ( long path , byte [ ] types , int count ) ;
public static final native int GraphicsPath_GetPointCount ( long path ) ;
public static final native boolean GraphicsPath_IsOutlineVisible ( long path , float x , float y , long pen , long g ) ;
public static final native boolean GraphicsPath_IsVisible ( long path , float x , float y , long g ) ;
public static final native int GraphicsPath_SetFillMode ( long path , int fillmode ) ;
public static final native int GraphicsPath_StartFigure ( long path ) ;
public static final native int GraphicsPath_Transform ( long path , long matrix ) ;
public static final native long HatchBrush_new ( int hatchStyle , long foreColor , long backColor ) ;
public static final native int Image_GetLastStatus ( long image ) ;
public static final native int Image_GetPixelFormat ( long image ) ;
public static final native int Image_GetWidth ( long image ) ;
public static final native int Image_GetHeight ( long image ) ;
public static final native int Image_GetPalette ( long image , long palette , int size ) ;
public static final native int Image_GetPaletteSize ( long image ) ;
public static final native long ImageAttributes_new ( ) ;
public static final native void ImageAttributes_delete ( long attrib ) ;
public static final native int ImageAttributes_SetWrapMode ( long attrib , int wrap ) ;
public static final native int ImageAttributes_SetColorMatrix ( long attrib , float [ ] matrix , int mode , int type ) ;
public static final native void HatchBrush_delete ( long brush ) ;
public static final native long LinearGradientBrush_new ( PointF point1 , PointF point2 , long color1 , long color2 ) ;
public static final native void LinearGradientBrush_delete ( long brush ) ;
public static final native int LinearGradientBrush_SetInterpolationColors ( long brush , long [ ] presetColors , float [ ] blendPositions , int count ) ;
public static final native int LinearGradientBrush_SetWrapMode ( long brush , int wrapMode ) ;
public static final native int LinearGradientBrush_ResetTransform ( long brush ) ;
public static final native int LinearGradientBrush_ScaleTransform ( long brush , float sx , float sy , int order ) ;
public static final native int LinearGradientBrush_TranslateTransform ( long brush , float dx , float dy , int order ) ;
public static final native long Matrix_new ( float m11 , float m12 , float m21 , float m22 , float dx , float dy ) ;
public static final native void Matrix_delete ( long matrix ) ;
public static final native int Matrix_GetElements ( long matrix , float [ ] m ) ;
public static final native int Matrix_Invert ( long matrix ) ;
public static final native boolean Matrix_IsIdentity ( long matrix ) ;
public static final native int Matrix_Multiply ( long matrix , long matrix1 , int order ) ;
public static final native int Matrix_Rotate ( long matrix , float angle , int order ) ;
public static final native int Matrix_Scale ( long matrix , float scaleX , float scaleY , int order ) ;
public static final native int Matrix_Shear ( long matrix , float shearX , float shearY , int order ) ;
public static final native int Matrix_TransformPoints ( long matrix , PointF pts , int count ) ;
public static final native int Matrix_TransformPoints ( long matrix , float [ ] pts , int count ) ;
public static final native int Matrix_TransformVectors ( long matrix , PointF pts , int count ) ;
public static final native int Matrix_Translate ( long matrix , float offsetX , float offsetY , int order ) ;
public static final native int Matrix_SetElements ( long matrix , float m11 , float m12 , float m21 , float m22 , float dx , float dy ) ;
public static final native void MoveMemory ( ColorPalette Destination , long SourcePtr , int Length ) ;
public static final native void MoveMemory ( BitmapData Destination , long SourcePtr ) ;
public static final native long PathGradientBrush_new ( long path ) ;
public static final native void PathGradientBrush_delete ( long brush ) ;
public static final native int PathGradientBrush_SetCenterColor ( long brush , long color ) ;
public static final native int PathGradientBrush_SetCenterPoint ( long brush , PointF pt ) ;
public static final native int PathGradientBrush_SetInterpolationColors ( long brush , long [ ] presetColors , float [ ] blendPositions , int count ) ;
public static final native int PathGradientBrush_SetSurroundColors ( long brush , long [ ] colors , int [ ] count ) ;
public static final native int PathGradientBrush_SetGraphicsPath ( long brush , long path ) ;
public static final native int PathGradientBrush_SetWrapMode ( long brush , int wrapMode ) ;
public static final native long Pen_new ( long brush , float width ) ;
public static final native void Pen_delete ( long pen ) ;
public static final native long Pen_GetBrush ( long pen ) ;
public static final native int Pen_SetBrush ( long pen , long brush ) ;
public static final native int Pen_SetDashOffset ( long pen , float dashOffset ) ;
public static final native int Pen_SetDashPattern ( long pen , float [ ] dashArray , int count ) ;
public static final native int Pen_SetDashStyle ( long pen , int dashStyle ) ;
public static final native int Pen_SetLineCap ( long pen , int startCap , int endCap , int dashCap ) ;
public static final native int Pen_SetLineJoin ( long pen , int lineJoin ) ;
public static final native int Pen_SetMiterLimit ( long pen , float miterLimit ) ;
public static final native int Pen_SetWidth ( long pen , float width ) ;
public static final native long Point_new ( int x , int y ) ;
public static final native void Point_delete ( long point ) ;
public static final native long Region_new ( long hRgn ) ;
public static final native long Region_newGraphicsPath ( long path ) ;
public static final native long Region_new ( ) ;
public static final native void Region_delete ( long region ) ;
public static final native long Region_GetHRGN ( long region , long graphics ) ;
public static final native boolean Region_IsInfinite ( long region , long graphics ) ;
public static final native long SolidBrush_new ( long color ) ;
public static final native void SolidBrush_delete ( long brush ) ;
public static final native void StringFormat_delete ( long format ) ;
public static final native long StringFormat_Clone ( long format ) ;
public static final native long StringFormat_GenericDefault ( ) ;
public static final native long StringFormat_GenericTypographic ( ) ;
public static final native int StringFormat_GetFormatFlags ( long format ) ;
public static final native int StringFormat_SetHotkeyPrefix ( long format , int hotkeyPrefix ) ;
public static final native int StringFormat_SetFormatFlags ( long format , int flags ) ;
public static final native int StringFormat_SetTabStops ( long format , float firstTabOffset , int count , float [ ] tabStops ) ;
public static final native long TextureBrush_new ( long image , int wrapMode , float dstX , float dstY , float dstWidth , float dstHeight ) ;
public static final native void TextureBrush_delete ( long brush ) ;
public static final native int TextureBrush_SetTransform ( long brush , long matrix ) ;
public static final native int TextureBrush_ResetTransform ( long brush ) ;
public static final native int TextureBrush_ScaleTransform ( long brush , float sx , float sy , int order ) ;
public static final native int TextureBrush_TranslateTransform ( long brush , float dx , float dy , int order ) ;
public long hItem ;
public long pszText ;
public long lParam ;
public long handle ;
long lpCursorName = 0 ;
long hInst = OS . GetModuleHandle ( null ) ;
long hInst = OS . GetModuleHandle ( null ) ;
long [ ] result = Image . init ( this . device , null , source , mask ) ;
public double drawXOffset , drawYOffset ;
public long visibleRgn ;
OleEventSink ( OleControlSite widget , long iUnknown , GUID riid ) {
long [ ] ppvObject = new long [ 1 ] ;
long [ ] ppCP = new long [ 1 ] ;
public long method6 ( long [ ] args ) { return Invoke ( ( int ) args [ 0 ] , args [ 1 ] , ( int ) args [ 2 ] , ( int ) args [ 3 ] , args [ 4 ] , args [ 5 ] , args [ 6 ] , args [ 7 ] ) ; }
long [ ] ppvObject = new long [ 1 ] ;
private int Invoke ( int dispIdMember , long riid , int lcid , int dwFlags , long pDispParams , long pVarResult , long pExcepInfo , long pArgErr )
long offset = ( dispParams . cArgs - 1 ) * size ;
private int QueryInterface ( long riid , long ppvObject ) {
COM . MoveMemory ( ppvObject , new long [ ] { iDispatch . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
public nsIHelperAppLauncher ( long address ) {
public int GetMIMEInfo ( long [ ] aMIMEInfo ) {
public int GetSource ( long [ ] aSource ) {
public int GetSuggestedFileName ( long [ ] aSuggestedFileName ) {
public int SaveToDisk ( long aNewFileLocation , int aRememberThisPreference ) {
public int LaunchWithApplication ( long aApplication , int aRememberThisPreference ) {
public int SetWebProgressListener ( long aWebProgressListener ) {
public int GetDownloadInfo ( long [ ] aSourceUrl , long [ ] aTimeDownloadStarted , long [ ] _retval ) {
long getAddress ( ) {
int QueryInterface ( long riid , long ppvObject ) {
XPCOM . memmove ( ppvObject , new long [ ] { supports . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { promptAuth . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
void setParent ( long aParent ) {
int PromptAuth ( long aChannel , int level , long authInfo , long _retval ) {
long ptr = XPCOM . nsEmbedString_new ( ) ;
long buffer = XPCOM . nsEmbedString_get ( ptr ) ;
long [ ] uri = new long [ 1 ] ;
long host = XPCOM . nsEmbedCString_new ( ) ;
int AsyncPromptAuth ( long aChannel , long aCallback , long aContext , int level , long authInfo , long _retval ) {
public nsIWebBrowserStream ( long address ) {
public int OpenStream ( long aBaseURI , long aContentType ) {
public int AppendToStream ( long aData , int aLen ) {
public IPersistStreamInit ( long address ) {
public int Load ( long pStm ) {
public nsIDOMNode ( long address ) {
public int GetNodeName ( long aNodeName ) {
public int GetNodeValue ( long aNodeValue ) {
public int SetNodeValue ( long aNodeValue ) {
public int GetParentNode ( long [ ] aParentNode ) {
public int GetParentElement ( long [ ] aParentElement ) {
public int GetChildNodes ( long [ ] aChildNodes ) {
public int GetFirstChild ( long [ ] aFirstChild ) {
public int GetLastChild ( long [ ] aLastChild ) {
public int GetPreviousSibling ( long [ ] aPreviousSibling ) {
public int GetNextSibling ( long [ ] aNextSibling ) {
public int GetAttributes ( long [ ] aAttributes ) {
public int GetOwnerDocument ( long [ ] aOwnerDocument ) {
public int InsertBefore ( long newChild , long refChild , long [ ] _retval ) {
public int ReplaceChild ( long newChild , long oldChild , long [ ] _retval ) {
public int RemoveChild ( long oldChild , long [ ] _retval ) {
public int AppendChild ( long newChild , long [ ] _retval ) {
public int CloneNode ( int deep , long [ ] _retval ) {
public int IsSupported ( long feature , long version , int [ ] _retval ) {
public int GetNamespaceURI ( long aNamespaceURI ) {
public int GetPrefix ( long aPrefix ) {
public int SetPrefix ( long aPrefix ) {
public int GetLocalName ( long aLocalName ) {
public int GetDOMBaseURI ( long aBaseURI ) {
public int CompareDocumentPosition ( long other , short [ ] _retval ) {
public int GetTextContent ( long aTextContent ) {
public int SetTextContent ( long aTextContent ) {
public int LookupPrefix ( long namespaceURI , long _retval ) {
public int IsDefaultNamespace ( long namespaceURI , int [ ] _retval ) {
public int LookupNamespaceURI ( long prefix , long _retval ) {
public int IsEqualNode ( long arg , int [ ] _retval ) {
public int SetUserData ( long key , long data , long handler , long [ ] _retval ) {
public int GetUserData ( long key , long [ ] _retval ) {
public int Contains ( long aOther , int [ ] _retval ) {
static long MozillaProc ;
static Browser findBrowser ( long handle ) {
static long windowProc ( long hwnd , long msg , long wParam , long lParam ) {
long hwndChild = OS . GetWindow ( browser . handle , OS . GW_CHILD ) ;
long getHandle ( ) {
long getSiteWindow ( ) {
long [ ] result = new long [ 1 ] ;
void onDispose ( long embedHandle ) {
long hwndChild = OS . GetWindow ( browser . handle , OS . GW_CHILD ) ;
void setSize ( long embedHandle , int width , int height ) {
public static void memmove ( long dest , boolean [ ] src ) {
public static void memmove ( boolean [ ] dest , long src ) {
public static final native void memmove ( long dest , nsDynamicFunctionLoad src , long size ) ;
public static final native void memmove ( nsID dest , long src , int nbytes ) ;
public static final native void memmove ( long dest , nsID src , int nbytes ) ;
public static final native int strlen_PRUnichar ( long s ) ;
public static final native long CALLBACK_JSNative ( long func ) ;
double oldKnob = widget . knobProportion ( ) ;
public NSTextAttachment ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_initWithFileWrapper_ , fileWrapper ! = null ? fileWrapper . id : 0 ) ;
long handle = tree . handle ;
long handle = tree . handle ;
long [ ] path = new long [ 1 ] ;
long indices = OS . gtk_tree_path_get_indices ( path [ 0 ] ) ;
public long hRgnBlur ;
public NSSecureTextField ( long id ) {
public static long cellClass ( ) {
public static void setCellClass ( long factoryId ) {
long clientHandle ( ) {
long clientHandle = clientHandle ( ) ;
long list = OS . gtk_container_get_children ( handle ) ;
long boxHandle = gtk_box_new ( OS . GTK_ORIENTATION_HORIZONTAL , false , 0 ) ;
long labelHandle = OS . gtk_label_new_with_mnemonic ( null ) ;
long imageHandle = OS . gtk_image_new ( ) ;
long pageHandle = OS . g_object_new ( display . gtk_fixed_get_type ( ) , 0 ) ;
long eventHandle ( ) {
long list = OS . gtk_container_get_children ( handle ) ;
long list = OS . gtk_container_get_children ( handle ) ;
long list = OS . gtk_container_get_children ( handle ) ;
long gtk_focus ( long widget , long directionType ) {
long gtk_switch_page ( long widget , long page , long page_num ) {
long list = OS . gtk_container_get_children ( handle ) ;
long list = OS . gtk_container_get_children ( handle ) ;
long labelHandle = items [ i ] . labelHandle ;
long labelHandle = items [ i ] . labelHandle ;
long list = OS . gtk_container_get_children ( handle ) ;
void setFontDescription ( long font ) {
long imItem , imSeparator , imHandle ;
long address = hasLocation ? display . menuPositionProc : 0 ;
long data = 0 ;
void addAccelerators ( long accelGroup ) {
long vboxHandle = parent . vboxHandle ;
void createIMMenu ( long imHandle ) {
long settings = OS . gtk_settings_get_default ( ) ;
long imSubmenu = OS . gtk_menu_new ( ) ;
long window = gtk_widget_get_window ( handle ) ;
long list = OS . gtk_container_get_children ( handle ) ;
long data = OS . g_list_nth_data ( list , index ) ;
long list = OS . gtk_container_get_children ( handle ) ;
long list = OS . gtk_container_get_children ( handle ) ;
long data = OS . g_list_nth_data ( list , i ) ;
long gtk_hide ( long widget ) {
long gtk_show ( long widget ) {
long gtk_show_help ( long widget , long helpType ) {
long menuPositionProc ( long menu , long x , long y , long push_in , long user_data ) {
void removeAccelerators ( long accelGroup ) {
boolean sendHelpEvent ( long helpType ) {
public IPersist ( long address ) {
long webViewWindowHandle , webViewData ;
static long ExternalClass ;
long [ ] result = new long [ 1 ] ;
long [ ] storage = new long [ 1 ] ;
long cookies = WebKit_win32 . CFHTTPCookieStorageCopyCookies ( storage [ 0 ] ) ;
long [ ] result = new long [ 1 ] ;
long [ ] storage = new long [ 1 ] ;
long string = WebKit_win32 . CFStringCreateWithCharacters ( 0 , chars , chars . length ) ;
long cfUrl = WebKit_win32 . CFURLCreateWithString ( 0 , string , 0 ) ;
long cookiesArray = WebKit_win32 . CFHTTPCookieStorageCopyCookiesForURL ( storage [ 0 ] , cfUrl , secure ) ;
long cookie = WebKit_win32 . CFArrayGetValueAtIndex ( cookiesArray , i ) ;
long cookieName = WebKit_win32 . CFHTTPCookieGetName ( cookie ) ;
long value = WebKit_win32 . CFHTTPCookieGetValue ( cookie ) ;
long [ ] result = new long [ 1 ] ;
long [ ] storage = new long [ 1 ] ;
long string = WebKit_win32 . CFStringCreateWithCharacters ( 0 , chars , chars . length ) ;
long cfUrl = WebKit_win32 . CFURLCreateWithString ( 0 , string , 0 ) ;
long value = WebKit_win32 . CFStringCreateWithCharacters ( 0 , chars , chars . length ) ;
long key = WebKit_win32 . CFStringCreateWithCharacters ( 0 , chars , chars . length ) ;
long headers = WebKit_win32 . CFDictionaryCreate ( 0 , new long [ ] { key } , new long [ ] { value } , 1 , WebKit_win32 . kCFCopyStringDictionaryKeyCallBacks ( ) , WebKit_win32 . kCFTypeDictionaryValueCallBacks ( ) ) ;
long cookies = WebKit_win32 . CFHTTPCookieCreateWithResponseHeaderFields ( 0 , headers , cfUrl ) ;
long cookie = WebKit_win32 . CFArrayGetValueAtIndex ( cookies , 0 ) ;
static long createBSTR ( String string ) {
static String extractBSTR ( long bstrString ) {
static Browser findBrowser ( long webView ) {
long [ ] result = new long [ 1 ] ;
static long JSObjectCallAsFunctionProc ( long ctx , long function , long thisObject , long argumentCount , long arguments , long exception ) {
static long JSObjectGetPropertyProc ( long ctx , long object , long propertyName , long exception ) {
static long JSObjectHasPropertyProc ( long ctx , long object , long propertyName ) {
long [ ] phkResult = new long [ 1 ] ;
static String stringFromCFString ( long cfString ) {
long ptr = WebKit_win32 . CFStringGetCharactersPtr ( cfString ) ;
static String stringFromJSString ( long jsString ) {
long callJava ( long ctx , long func , long thisObject , long argumentCount , long arguments , long exception ) {
long [ ] result = new long [ 1 ] ;
Object convertToJava ( long ctx , long value ) {
long string = WebKit_win32 . JSValueToStringCopy ( ctx , value , null ) ;
long length = WebKit_win32 . JSStringGetMaximumUTF8CStringSize ( string ) ;
long current = WebKit_win32 . JSObjectGetPropertyAtIndex ( ctx , value , i , null ) ;
long convertToJS ( long ctx , Object value ) {
long [ ] arguments = new long [ length ] ;
long jsObject = convertToJS ( ctx , javaObject ) ;
long addr = WebKit_win32 . JSObjectHasPropertyProc_CALLBACK ( JSObjectHasPropertyProc . getAddress ( ) ) ;
long classDefinitionPtr = C . malloc ( JSClassDefinition . sizeof ) ;
long [ ] result = new long [ 1 ] ;
C . memmove ( webViewData , new long [ ] { webView . getAddress ( ) } , C . PTR_SIZEOF ) ;
long [ ] result = new long [ 1 ] ;
long context = frame . globalContext ( ) ;
long scriptString = WebKit_win32 . JSStringCreateWithUTF8CString ( bytes ) ;
long urlString = WebKit_win32 . JSStringCreateWithUTF8CString ( bytes ) ;
long evalResult = WebKit_win32 . JSEvaluateScript ( context , scriptString , 0 , urlString , 0 , null ) ;
long [ ] result = new long [ 1 ] ;
long [ ] address = new long [ 1 ] ;
long hwndFocus = OS . GetFocus ( ) ;
long [ ] address = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long urlString = createBSTR ( ABOUT_BLANK ) ;
long [ ] result = new long [ 1 ] ;
long valueString = createBSTR ( value ) ;
long keyString = createBSTR ( key ) ;
long urlString = createBSTR ( url ) ;
long [ ] address = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
public nsIAuthInformation ( long address ) {
public int GetRealm ( long aRealm ) {
public int GetAuthenticationScheme ( long aAuthenticationScheme ) {
public int GetUsername ( long aUsername ) {
public int SetUsername ( long aUsername ) {
public int GetPassword ( long aPassword ) {
public int SetPassword ( long aPassword ) {
public int GetDomain ( long aDomain ) {
public int SetDomain ( long aDomain ) {
long clientHandle ( ) {
long style = OS . gtk_widget_get_style ( scrolledHandle ) ;
long clientHandle = clientHandle ( ) ;
long hBarHandle = 0 ;
long topHandle = topHandle ( ) , paintHandle = paintHandle ( ) ;
long window = gtk_widget_get_window ( topHandle ) ;
long topHandle ( ) {
long vBarHandle = 0 ;
private long byRefPtr ;
public static void win32_copy ( long pVarDest , Variant varSrc ) {
public static Variant win32_new ( long pVariant ) {
public Variant ( long ptr , short byRefType ) {
public long getByRef ( ) {
void getData ( long pData ) {
COM . MoveMemory ( pData + 8 , new long [ ] { byRefPtr } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( pData + 8 , new long [ ] { dispatchData . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( pData + 8 , new long [ ] { unknownData . getAddress ( ) } , OS . PTR_SIZEOF ) ;
public void setByRef ( long val ) {
COM . MoveMemory ( byRefPtr , new long [ ] { val } , OS . PTR_SIZEOF ) ;
void setData ( long pData ) {
long [ ] newByRefPtr = new long [ 1 ] ;
long [ ] ppvObject = new long [ 1 ] ;
long [ ] ppvObject = new long [ 1 ] ;
long [ ] hMem = new long [ 1 ] ;
long newPData = OS . GlobalAlloc ( OS . GMEM_FIXED | OS . GMEM_ZEROINIT , sizeof ) ;
static long findPrinter ;
if ( ! OS . gtk_init_check ( new long [ ] { 0 } , null ) ) {
long GtkPrinterFunc_List = printerCallback . getAddress ( ) ;
static long GtkPrinterFunc_List ( long printer , long user_data ) {
long GtkPrinterFunc_Default = printerCallback . getAddress ( ) ;
static long GtkPrinterFunc_Default ( long printer , long user_data ) {
static long gtkPrinterFromPrinterData ( PrinterData data ) {
long GtkPrinterFunc_FindNamedPrinter = printerCallback . getAddress ( ) ;
static long GtkPrinterFunc_FindNamedPrinter ( long printer , long user_data ) {
static void restore ( byte [ ] data , long settings , long page_setup ) {
long paper_size = 0 ;
long localePtr = OS . g_filename_from_utf8 ( utf8Ptr , - 1 , null , null , error ) ;
long uriPtr = OS . g_filename_to_uri ( localePtr , 0 , error ) ;
long filePrinter = gtkPrinterFromPrinterData ( data ) ;
public long pszText ;
public long interface_init ;
public long interface_finalize ;
public long interface_data ;
long getAddress ( ) {
int QueryInterface ( long riid , long ppvObject ) {
XPCOM . memmove ( ppvObject , new long [ ] { supports . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { helperAppLauncherDialog . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
int Show ( long aLauncher , long aContext , int aReason ) {
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
public IWebURLResponse ( long address ) {
public int URL ( long [ ] result ) {
int decideDestinationWithSuggestedFilename ( long download , long filename ) {
int didBegin ( long download ) {
int didFailWithError ( long download , long error ) {
int didFinish ( long download ) {
int didReceiveDataOfLength ( long download , int length ) {
int didReceiveResponse ( long download , long response ) {
long [ ] result = new long [ 1 ] ;
long getAddress ( ) {
int QueryInterface ( long riid , long ppvObject ) {
COM . MoveMemory ( ppvObject , new long [ ] { iWebDownloadDelegate . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { iWebDownloadDelegate . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
int willSendRequest ( long download , long request , long redirectResponse , long finalRequest ) {
OS . MoveMemory ( finalRequest , new long [ ] { request } , C . PTR_SIZEOF ) ;
long cairo = data . cairo ;
long newRgn = OS . XCreateRegion ( ) ;
long polyRgn = OS . XPolygonRegion ( pointArray , pointArray . length / 2 , OS . EvenOddRule ) ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long pattern = Cairo . cairo_pattern_create_for_surface ( srcImage . surface ) ;
long newPattern = Cairo . cairo_pattern_create_for_surface ( surface ) ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long copy = Cairo . cairo_copy_path ( path . handle ) ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long cairo = data . cairo ;
void drawPolyline ( long cairo , int [ ] pointArray , boolean close ) {
long cairo = data . cairo ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long options = Cairo . cairo_font_options_create ( ) ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long surface = Cairo . cairo_xlib_surface_create ( xDisplay , xDrawable , xVisual , width [ 0 ] , height [ 0 ] ) ;
long cairo = data . cairo ;
long cairo = data . cairo ;
static void setCairoFont ( long cairo , Font font ) {
static void setCairoRegion ( long cairo , long rgn ) {
static void setCairoPatternColor ( long pattern , int offset , Color c , int alpha ) {
long cairo = data . cairo ;
long cairo = data . cairo ;
long options = Cairo . cairo_font_options_create ( ) ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long cairo = data . cairo ;
public long hinst ;
public long lpReserved ;
public long lpCreateParams ;
public long hInstance ;
public long hMenu ;
public long hwndParent ;
public long lpszName ;
public long lpszClass ;
public nsIObserverService ( long address ) {
public int AddObserver ( long anObserver , byte [ ] aTopic , int ownsWeak ) {
public int RemoveObserver ( long anObserver , byte [ ] aTopic ) {
public int NotifyObservers ( long aSubject , byte [ ] aTopic , char [ ] someData ) {
public int EnumerateObservers ( byte [ ] aTopic , long [ ] _retval ) {
long hwndOwner = parent ! = null ? parent . handle : 0 ;
public IConnectionPoint ( long address ) {
public int Advise ( long pUnk , int [ ] pdwCookie ) {
long hwndChild = OS . GetWindow ( handle , OS . GW_CHILD ) ;
long hwndParent = parent . handle ;
long hDC = gc . handle ;
long hwndParent = OS . GetParent ( handle ) ;
long hDC = gc . handle ;
long hwndChild = OS . GetWindow ( handle , OS . GW_CHILD ) ;
long hwndChild = OS . GetWindow ( handle , OS . GW_CHILD ) ;
long hdwp = 0 ;
void resizeEmbeddedHandle ( long embeddedHandle , int width , int height ) {
long hwndShell = getShell ( ) . handle ;
LRESULT WM_ERASEBKGND ( long wParam , long lParam ) {
LRESULT WM_GETDLGCODE ( long wParam , long lParam ) {
LRESULT WM_GETFONT ( long wParam , long lParam ) {
long code = callWindowProc ( handle , OS . WM_GETFONT , wParam , lParam ) ;
LRESULT WM_LBUTTONDOWN ( long wParam , long lParam ) {
LRESULT WM_NCHITTEST ( long wParam , long lParam ) {
long code = callWindowProc ( handle , OS . WM_NCHITTEST , wParam , lParam ) ;
LRESULT WM_PARENTNOTIFY ( long wParam , long lParam ) {
LRESULT WM_PAINT ( long wParam , long lParam ) {
long hDC = OS . BeginPaint ( handle , ps ) ;
long [ ] phdc = new long [ 1 ] ;
long hBufferedPaint = OS . BeginBufferedPaint ( hDC , prcTarget , flags , null , phdc ) ;
long sysRgn = 0 ;
long newSysRgn = OS . ExtCreateRegion ( new float [ ] { - 1 , 0 , 0 , 1 , 0 , 0 } , nBytes , lpRgnData ) ;
long hDC = OS . BeginPaint ( handle , ps ) ;
LRESULT WM_PRINTCLIENT ( long wParam , long lParam ) {
LRESULT WM_SETFONT ( long wParam , long lParam ) {
LRESULT WM_SIZE ( long wParam , long lParam ) {
LRESULT WM_SYSCOLORCHANGE ( long wParam , long lParam ) {
long hwndChild = OS . GetWindow ( handle , OS . GW_CHILD ) ;
LRESULT WM_SYSCOMMAND ( long wParam , long lParam ) {
long code = callWindowProc ( handle , OS . WM_SYSCOMMAND , wParam , lParam ) ;
LRESULT WM_UPDATEUISTATE ( long wParam , long lParam ) {
LRESULT wmNCPaint ( long hwnd , long wParam , long lParam ) {
long borderHandle = borderHandle ( ) ;
long code = 0 ;
long hDC = OS . GetWindowDC ( hwnd ) ;
LRESULT wmNotify ( NMHDR hdr , long wParam , long lParam ) {
long hwndParent = hdr . hwndFrom ;
long hwndInsertAfter = hdr . code = = OS . TTN_SHOW ? OS . HWND_TOPMOST : OS . HWND_NOTOPMOST ;
long hwnd = hdr . idFrom ;
public NSMutableArray ( long id ) {
public void removeObjectAtIndex ( long index ) {
long result = OS . objc_msgSend ( OS . class_NSMutableArray , OS . sel_array ) ;
long result = OS . objc_msgSend ( OS . class_NSMutableArray , OS . sel_arrayWithObject_ , anObject ! = null ? anObject . id : 0 ) ;
boolean acceptsFirstResponder ( long id , long sel ) {
boolean accessibilityIsIgnored ( long id , long sel ) {
double width = 0 , height = 0 ;
void drawBackground ( long id , NSGraphicsContext context , NSRect rect ) {
boolean handleIsAccessible ( long id ) {
boolean isEventView ( long id ) {
void setForeground ( double [ ] color ) {
boolean shouldChangeTextInRange_replacementString ( long id , long sel , long affectedCharRange , long replacementString ) {
long type = currentEvent . type ( ) ;
long charCount = fieldEditor . string ( ) . length ( ) ;
void textDidChange ( long id , long sel , long aNotification ) {
NSRange textView_willChangeSelectionFromCharacterRange_toCharacterRange ( long id , long sel , long aTextView , long oldSelectedCharRange , long newSelectedCharRange ) {
void textDidEndEditing ( long id , long sel , long aNotification ) {
public long root ;
public long subwindow ;
static long proc2Args , proc3Args , proc4Args ;
long cls = OS . objc_allocateClassPair ( OS . class_NSObject , className , 0 ) ;
static long accessibleProc ( long id , long sel ) {
static long accessibleProc ( long id , long sel , long arg0 ) {
static long accessibleProc ( long id , long sel , long arg0 , long arg1 ) {
static SWTAccessibleDelegate getAccessibleDelegate ( long id ) {
long [ ] jniRef = new long [ 1 ] ;
public long handle ;
long paintWindow ( ) {
long cellDataProc ( long tree_column , long cell , long tree_model , long iter , long data ) {
long topHandle = topHandle ( ) ;
long gtk_activate ( long widget ) {
long gtk_button_press_event ( long widget , long event ) {
long gtk_button_release_event ( long widget , long event ) {
long gtk_changed ( long widget ) {
long gtk_change_value ( long widget , long scroll , long value1 , long value2 ) {
long gtk_clicked ( long widget ) {
long gtk_commit ( long imcontext , long text ) {
long gtk_configure_event ( long widget , long event ) {
long gtk_create_menu_proxy ( long widget ) {
long gtk_day_selected ( long widget ) {
long gtk_day_selected_double_click ( long widget ) {
long gtk_delete_event ( long widget , long event ) {
long gtk_delete_range ( long widget , long iter1 , long iter2 ) {
long gtk_delete_text ( long widget , long start_pos , long end_pos ) {
long gtk_enter_notify_event ( long widget , long event ) {
long gtk_event ( long widget , long event ) {
long gtk_event_after ( long widget , long event ) {
long gtk_expand_collapse_cursor_row ( long widget , long logical , long expand , long open_all ) {
long gtk_expose_event ( long widget , long event ) {
long gtk_focus ( long widget , long event ) {
long gtk_focus_in_event ( long widget , long event ) {
long gtk_focus_out_event ( long widget , long event ) {
long gtk_grab_focus ( long widget ) {
long gtk_hide ( long widget ) {
long gtk_icon_release ( long widget , long icon_pos , long event ) {
long gtk_input ( long widget , long arg1 ) {
long gtk_insert_text ( long widget , long new_text , long new_text_length , long position ) {
long gtk_key_press_event ( long widget , long event ) {
long gtk_key_release_event ( long widget , long event ) {
long gtk_leave_notify_event ( long widget , long event ) {
long gtk_map ( long widget ) {
long gtk_map_event ( long widget , long event ) {
long gtk_mnemonic_activate ( long widget , long arg1 ) {
long gtk_month_changed ( long widget ) {
long gtk_motion_notify_event ( long widget , long event ) {
long gtk_move_focus ( long widget , long event ) {
long gtk_output ( long widget ) {
long gtk_populate_popup ( long widget , long menu ) {
long gtk_popup_menu ( long widget ) {
long gtk_preedit_changed ( long imcontext ) {
long gtk_realize ( long widget ) {
long gtk_row_activated ( long tree , long path , long column ) {
long gtk_row_deleted ( long model , long path ) {
long gtk_row_inserted ( long model , long path , long iter ) {
long gtk_scroll_child ( long widget , long scrollType , long horizontal ) {
long gtk_scroll_event ( long widget , long event ) {
long gtk_select ( long item ) {
long gtk_selection_done ( long menushell ) {
long gtk_show ( long widget ) {
long gtk_show_help ( long widget , long helpType ) {
long gtk_size_allocate ( long widget , long allocation ) {
long gtk_status_icon_popup_menu ( long handle , long button , long activate_time ) {
long gtk_start_interactive_search ( long widget ) {
long gtk_style_set ( long widget , long previousStyle ) {
long gtk_switch_page ( long widget , long page , long page_num ) {
long gtk_test_collapse_row ( long tree , long iter , long path ) {
long gtk_test_expand_row ( long tree , long iter , long path ) {
long gtk_text_buffer_insert_text ( long widget , long iter , long text , long length ) {
long gtk_timer ( ) {
long gtk_toggled ( long renderer , long pathStr ) {
long gtk_unmap ( long widget ) {
long gtk_unmap_event ( long widget , long event ) {
long gtk_unrealize ( long widget ) {
long gtk_value_changed ( long adjustment ) {
long gtk_visibility_notify_event ( long widget , long event ) {
void gtk_widget_get_allocation ( long widget , GtkAllocation allocation ) {
boolean gtk_widget_get_mapped ( long widget ) {
boolean gtk_widget_has_focus ( long widget ) {
long gtk_window_state_event ( long widget , long event ) {
long filterProc ( long xEvent , long gdkEvent , long data2 ) {
long fixedMapProc ( long widget ) {
long fixedSizeAllocateProc ( long widget , long allocationPtr ) {
long hoverProc ( long widget ) {
long menuPositionProc ( long menu , long x , long y , long push_in , long user_data ) {
boolean mnemonicHit ( long mnemonicHandle , char key ) {
boolean mnemonicMatch ( long mnemonicHandle , char key ) {
void modifyStyle ( long handle , long style ) {
long rendererGetSizeProc ( long cell , long handle , long cell_area , long x_offset , long y_offset , long width , long height ) {
long rendererRenderProc ( long cell , long window , long handle , long background_area , long cell_area , long expose_area , long flags ) {
long ptr = 0 ;
long ptr = OS . gtk_get_current_event ( ) ;
long shellMapProc ( long handle , long arg0 , long user_data ) {
long sizeAllocateProc ( long handle , long arg0 , long user_data ) {
long sizeRequestProc ( long handle , long arg0 , long user_data ) {
long g_object_ref_sink ( long object ) {
boolean gtk_widget_get_sensitive ( long widget ) {
boolean gtk_widget_get_visible ( long widget ) {
boolean gtk_widget_get_realized ( long widget ) {
boolean gtk_widget_get_can_default ( long widget ) {
boolean gtk_widget_get_has_window ( long widget ) {
long gtk_widget_get_window ( long widget ) {
void gtk_widget_set_can_default ( long widget , boolean can_default ) {
void gtk_widget_set_can_focus ( long widget , boolean can_focus ) {
void gtk_widget_set_mapped ( long widget , boolean mapped ) {
void gtk_widget_set_visible ( long widget , boolean visible ) {
void gtk_widget_set_receives_default ( long widget , boolean receives_default ) {
void gdk_pixmap_get_size ( long pixmap , int [ ] width , int [ ] height ) {
void gdk_window_get_size ( long drawable , int [ ] width , int [ ] height ) {
int gdk_pointer_grab ( long window , int grab_ownership , boolean owner_events , int event_mask , long confine_to , long cursor , int time_ ) {
long display = 0 ;
long topHandle ( ) {
long timerProc ( long widget ) {
long windowProc ( long handle , long user_data ) {
long windowProc ( long handle , long arg0 , long user_data ) {
long windowProc ( long handle , long arg0 , long arg1 , long user_data ) {
long windowProc ( long handle , long arg0 , long arg1 , long arg2 , long user_data ) {
public long window ;
public long axes ;
public long device ;
public long target ;
public long prc ;
public long pwpos ;
public long hParent ;
public long hInsertAfter ;
public long hItem ;
public long pszText ;
public long lParam ;
public NSCell ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_attributedStringValue ) ;
public long controlSize ( ) {
long result = OS . objc_msgSend ( this . id , OS . sel_font ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_highlightColorWithFrame_inView_ , cellFrame , controlView ! = null ? controlView . id : 0 ) ;
public long hitTestForEvent ( NSEvent event , NSRect cellFrame , NSView controlView ) {
long result = OS . objc_msgSend ( this . id , OS . sel_image ) ;
public long nextState ( ) {
public void setAlignment ( long mode ) {
public void setBackgroundStyle ( long style ) {
public void setBaseWritingDirection ( long writingDirection ) {
public void setControlSize ( long size ) {
public void setLineBreakMode ( long mode ) {
long result = OS . objc_msgSend ( this . id , OS . sel_title ) ;
public long layout ;
public long runs ;
long BrowseCallbackProc ( long hwnd , long uMsg , long lParam , long lpData ) {
long hHeap = OS . GetProcessHeap ( ) ;
long hwndOwner = 0 ;
long lpszTitle = 0 ;
long lpfn = callback . getAddress ( ) ;
long lpItemIdList = OS . SHBrowseForFolder ( lpbi ) ;
long [ ] ppMalloc = new long [ 1 ] ;
public IWebMutableURLRequestPrivate ( long address ) {
void addAccelerator ( long accelGroup ) {
void addAccelerators ( long accelGroup ) {
long group = OS . gtk_radio_menu_item_get_group ( groupHandle ) ;
long label = OS . gtk_bin_get_child ( handle ) ;
long parentHandle = parent . handle ;
long getAccelGroup ( ) {
long gtk_activate ( long widget ) {
long gtk_select ( long item ) {
long gtk_show_help ( long widget , long helpType ) {
long accelGroup = getAccelGroup ( ) ;
void removeAccelerator ( long accelGroup ) {
void removeAccelerators ( long accelGroup ) {
long accelGroup = getAccelGroup ( ) ;
long accelGroup = getAccelGroup ( ) ;
long accelGroup = getAccelGroup ( ) ;
long label = OS . gtk_bin_get_child ( handle ) ;
long ptr = OS . g_malloc ( buffer . length ) ;
long oldPtr = OS . GTK_ACCEL_LABEL_GET_ACCEL_STRING ( label ) ;
void updateAccelerator ( long accelGroup , boolean add ) {
long accelGroup = getAccelGroup ( ) ;
public nsIServiceManager ( long address ) {
public int GetService ( nsID aClass , nsID aIID , long [ ] result ) {
public int GetServiceByContractID ( byte [ ] aContractID , nsID aIID , long [ ] result ) {
public nsIDOMUIEvent ( long address ) {
public int GetView ( long [ ] aView ) {
public int InitUIEvent ( long typeArg , int canBubbleArg , int cancelableArg , long viewArg , int detailArg ) {
public int GetRangeParent ( long [ ] aRangeParent ) {
public long DebugEventCallback ;
public long pitem ;
public NSSlider ( long id ) {
public static long cellClass ( ) {
public static void setCellClass ( long factoryId ) {
public nsIURIContentListener ( long address ) {
public int OnStartURIOpen ( long aURI , int [ ] _retval ) {
public int DoContent ( byte [ ] aContentType , int aIsContentPreferred , long aRequest , long [ ] aContentHandler , int [ ] _retval ) {
public int IsPreferred ( byte [ ] aContentType , long [ ] aDesiredContentType , int [ ] _retval ) {
public int CanHandleContent ( byte [ ] aContentType , int aIsContentPreferred , long [ ] aDesiredContentType , int [ ] _retval ) {
public int GetLoadCookie ( long [ ] aLoadCookie ) {
public int SetLoadCookie ( long aLoadCookie ) {
public int GetParentContentListener ( long [ ] aParentContentListener ) {
public int SetParentContentListener ( long aParentContentListener ) {
public IDispatchEx ( long address ) {
public int GetDispID ( long bstrName , int grfdex , int [ ] pid ) {
public int InvokeEx ( int id , int lcid , int wFlags , DISPPARAMS pdp , long pvarRes , EXCEPINFO pei , long pspCaller ) {
public int DeleteMemberByName ( long bstrName , int grfdex ) {
public int GetMemberName ( int id , long [ ] pbstrName ) {
public int GetNameSpaceParent ( long [ ] ppunk ) {
long [ ] phkResult = new long [ 1 ] ;
phkResult = new long [ 1 ] ;
long [ ] phkResult2 = new long [ 1 ] ;
long [ ] key = new long [ 1 ] ;
long [ ] key = new long [ 1 ] ;
long pCancel = cancel . getByRef ( ) ;
long pCancel = cancel . getByRef ( ) ;
long pCancel = cancel . getByRef ( ) ;
long pCancel = cancel . getByRef ( ) ;
long pCancel = cancel . getByRef ( ) ;
long pCancel = cancel . getByRef ( ) ;
long pvData = OS . GlobalAlloc ( OS . GMEM_FIXED | OS . GMEM_ZEROINIT , length ) ;
long pSafeArray = OS . GlobalAlloc ( OS . GMEM_FIXED | OS . GMEM_ZEROINIT , SAFEARRAY . sizeof ) ;
long pVariant = OS . GlobalAlloc ( OS . GMEM_FIXED | OS . GMEM_ZEROINIT , Variant . sizeof ) ;
OS . MoveMemory ( pVariant + 8 , new long [ ] { pSafeArray } , C . PTR_SIZEOF ) ;
long hGlobal = OS . GlobalAlloc ( OS . GMEM_FIXED | OS . GMEM_ZEROINIT , UTF8BOM . length + byteCount ) ;
long [ ] ppstm = new long [ 1 ] ;
long [ ] ppvObject = new long [ 1 ] ;
public long lpReserved ;
public long lpDesktop ;
public long lpTitle ;
public long lpReserved2 ;
public long hStdInput ;
public long hStdOutput ;
public long hStdError ;
long arrowHandle = theme . arrowHandle ;
long entryHandle = theme . entryHandle ;
public nsIHelperAppLauncher_1_8 ( long address ) {
public int GetMIMEInfo ( long [ ] aMIMEInfo ) {
public int GetSource ( long [ ] aSource ) {
public int GetSuggestedFileName ( long aSuggestedFileName ) {
public int SaveToDisk ( long aNewFileLocation , int aRememberThisPreference ) {
public int LaunchWithApplication ( long aApplication , int aRememberThisPreference ) {
public int SetWebProgressListener ( long aWebProgressListener ) {
public int GetTargetFile ( long [ ] aTargetFile ) {
public int GetTimeDownloadStarted ( long aTimeDownloadStarted ) {
long [ ] ppvObject = new long [ 1 ] ;
long [ ] ppvObject = new long [ 1 ] ;
private int QueryInterface ( long riid , long ppvObject ) {
COM . MoveMemory ( ppvObject , new long [ ] { iUnknown . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { iPropertyNotifySink . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
public nsIX509CertValidity ( long address ) {
public int GetNotBefore ( long aNotBefore ) {
public int GetNotBeforeLocalTime ( long aNotBeforeLocalTime ) {
public int GetNotBeforeLocalDay ( long aNotBeforeLocalDay ) {
public int GetNotBeforeGMT ( long aNotBeforeGMT ) {
public int GetNotAfter ( long aNotAfter ) {
public int GetNotAfterLocalTime ( long aNotAfterLocalTime ) {
public int GetNotAfterLocalDay ( long aNotAfterLocalDay ) {
public int GetNotAfterGMT ( long aNotAfterGMT ) {
public long getAddress ( ) {
long buffer = XPCOM . nsEmbedString_get ( handle ) ;
public NSPopUpButton ( long id ) {
public long indexOfSelectedItem ( ) {
long result = OS . objc_msgSend ( this . id , OS . sel_initWithFrame_pullsDown_ , buttonFrame , flag ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_menu ) ;
public long numberOfItems ( ) {
public void removeItemAtIndex ( long index ) {
public void selectItemAtIndex ( long index ) {
long result = OS . objc_msgSend ( this . id , OS . sel_titleOfSelectedItem ) ;
public static long cellClass ( ) {
public static void setCellClass ( long factoryId ) {
long ptr = XPCOM . nsID_new ( ) ;
long otherPtr = XPCOM . nsID_new ( ) ;
long hwndTransparent , hwndOpaque , oldTransparentProc , oldOpaqueProc ;
long newCursor = 0 ;
long newProcAddress = newProc . getAddress ( ) ;
long newProcAddress = newProc . getAddress ( ) ;
long transparentProc ( long hwnd , long msg , long wParam , long lParam ) {
LRESULT wmKeyDown ( long hwnd , long wParam , long lParam ) {
LRESULT wmSysKeyDown ( long hwnd , long wParam , long lParam ) {
LRESULT wmMouse ( int message , long wParam , long lParam ) {
long xDisplay = OS . gdk_x11_drawable_get_xdisplay ( window ) ;
long xDisplay = OS . gdk_x11_drawable_get_xdisplay ( window ) ;
long shellHandle , fixedHandle , buttonHandle , arrowHandle ,
int getWidgetProperty ( long handle , String name ) {
long getBorderProperty ( long handle , String name ) {
long [ ] result = new long [ 1 ] ;
void transferClipping ( GC gc , long style ) {
long [ ] curGC = new long [ 1 ] ;
public DOMWheelEvent ( long id ) {
long hwnd = hwndScrollBar ( ) ;
long hwnd = hwndScrollBar ( ) ;
long hwnd = hwndScrollBar ( ) ;
long hwnd = hwndScrollBar ( ) ;
long hwnd = hwndScrollBar ( ) ;
long hwndScrollBar ( ) {
long hwnd = hwndScrollBar ( ) ;
long hwnd = hwndScrollBar ( ) ;
long hwnd = hwndScrollBar ( ) ;
boolean SetScrollInfo ( long hwnd , int flags , SCROLLINFO info , boolean fRedraw ) {
long hwnd = hwndScrollBar ( ) ;
long hwnd = hwndScrollBar ( ) ;
long hwnd = hwndScrollBar ( ) ;
long hwnd = hwndScrollBar ( ) ;
long hwnd = hwndScrollBar ( ) ;
LRESULT wmScrollChild ( long wParam , long lParam ) {
public long rgExtension ;
public nsIIOService ( long address ) {
public int GetProtocolHandler ( byte [ ] aScheme , long [ ] _retval ) {
public int NewURI ( long aSpec , byte [ ] aOriginCharset , long aBaseURI , long [ ] _retval ) {
public int NewFileURI ( long aFile , long [ ] _retval ) {
public int NewChannelFromURI ( long aURI , long [ ] _retval ) {
public int NewChannel ( long aSpec , byte [ ] aOriginCharset , long aBaseURI , long [ ] _retval ) {
public int ExtractScheme ( long urlString , long _retval ) {
public long method4 ( long [ ] args ) {
int DragEnter_64 ( long pDataObject , int grfKeyState , long pt , long pdwEffect ) {
int DragEnter ( long pDataObject , int grfKeyState , int pt_x , int pt_y , long pdwEffect ) {
int DragOver_64 ( int grfKeyState , long pt , long pdwEffect ) {
int DragOver ( int grfKeyState , int pt_x , int pt_y , long pdwEffect ) {
int Drop_64 ( long pDataObject , int grfKeyState , long pt , long pdwEffect ) {
int Drop ( long pDataObject , int grfKeyState , int pt_x , int pt_y , long pdwEffect ) {
int QueryInterface ( long riid , long ppvObject ) {
COM . MoveMemory ( ppvObject , new long [ ] { iDropTarget . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
long handle = control . handle ;
boolean setEventData ( DNDEvent event , long pDataObject , int grfKeyState , int pt_x , int pt_y , long pdwEffect ) {
long [ ] address = new long [ 1 ] ;
long rgelt = OS . GlobalAlloc ( OS . GMEM_FIXED | OS . GMEM_ZEROINIT , FORMATETC . sizeof ) ;
public NSRunLoop ( long id ) {
long result = OS . objc_msgSend ( OS . class_NSRunLoop , OS . sel_currentRunLoop ) ;
long result = OS . objc_msgSend ( OS . class_NSRunLoop , OS . sel_mainRunLoop ) ;
public NSInputManager ( long id ) {
long result = OS . objc_msgSend ( OS . class_NSInputManager , OS . sel_currentInputManager ) ;
boolean textView_clickOnLink_atIndex ( long id , long sel , long textView , long link , long charIndex ) {
void drawBackground ( long id , NSGraphicsContext context , NSRect rectangle ) {
long rangePtr = OS . malloc ( NSRange . sizeof ) ;
void mouseUp ( long id , long sel , long theEvent ) {
boolean shouldDrawInsertionPoint ( long id , long sel ) {
void setForeground ( double [ ] color ) {
long modifierFlags = theEvent . modifierFlags ( ) ;
long attributedSubstringFromRange ( long id , long sel , long range ) {
long characterIndexForPoint ( long id , long sel , long point ) {
void drawBackground ( long id , NSGraphicsContext context , NSRect rect ) {
long visibleRegion = getVisibleRegion ( ) ;
void drawRect ( long id , long sel , NSRect rect ) {
void drawWidget ( long id , NSGraphicsContext context , NSRect rect ) {
long ctx = context . graphicsPort ( ) ;
long colorspace = OS . CGColorSpaceCreateDeviceRGB ( ) ;
OS . CGContextSetFillColor ( ctx , new double [ ] { 1 , 1 , 1 , 1 } ) ;
NSRect firstRectForCharacterRange ( long id , long sel , long range ) {
boolean hasMarkedText ( long id , long sel ) {
boolean insertText ( long id , long sel , long string ) {
boolean isOpaque ( long id , long sel ) {
NSRange markedRange ( long id , long sel ) {
boolean readSelectionFromPasteboard ( long id , long sel , long pasteboard ) {
for ( long i = 0 ; i < supportedPboardTypes . count ( ) ; i + + ) {
NSRange selectedRange ( long id , long sel ) {
boolean setMarkedText_selectedRange ( long id , long sel , long string , long range ) {
long validAttributesForMarkedText ( long id , long sel ) {
long validRequestorForSendType ( long id , long sel , long sendType , long returnType ) {
void updateOpenGLContext ( long id , long sel , long notification ) {
void viewWillMoveToWindow ( long id , long sel , long arg0 ) {
boolean writeSelectionToPasteboard ( long id , long sel , long pasteboardObj , long typesObj ) {
for ( long i = 0 ; i < supportedPboardTypes . count ( ) ; i + + ) {
for ( long i = 0 ; i < typesToDeclare . count ( ) ; i + + ) {
public NSURLProtectionSpace ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_host ) ;
public long port ( ) {
long result = OS . objc_msgSend ( this . id , OS . sel_realm ) ;
public NSEnumerator ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_nextObject ) ;
public nsICategoryManager ( long address ) {
public int GetCategoryEntry ( byte [ ] aCategory , byte [ ] aEntry , long [ ] _retval ) {
public int AddCategoryEntry ( byte [ ] aCategory , byte [ ] aEntry , byte [ ] aValue , int aPersist , int aReplace , long [ ] _retval ) {
public int EnumerateCategory ( byte [ ] aCategory , long [ ] _retval ) {
public int EnumerateCategories ( long [ ] _retval ) {
public long id ;
public long name ;
public long command ;
public long supported_uri_schemes ;
long [ ] items_read = new long [ 1 ] , items_written = new long [ 1 ] ;
long ptr = OS . g_utf16_to_utf8 ( buffer , buffer . length , items_read , items_written , null ) ;
public NSFontPanel ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_panelConvertFont_ , fontObj ! = null ? fontObj . id : 0 ) ;
long result = OS . objc_msgSend ( OS . class_NSFontPanel , OS . sel_sharedFontPanel ) ;
public static long windowNumberAtPoint ( NSPoint point , long windowNumber ) {
public nsICookieService_1_9 ( long address ) {
public int GetCookieString ( long aURI , long aChannel , long [ ] _retval ) {
public int GetCookieStringFromHttp ( long aURI , long aFirstURI , long aChannel , long [ ] _retval ) {
public int SetCookieString ( long aURI , long aPrompt , byte [ ] aCookie , long aChannel ) {
public int SetCookieStringFromHttp ( long aURI , long aFirstURI , long aPrompt , byte [ ] aCookie , byte [ ] aServerTime , long aChannel ) {
public long lParam ;
public long dwData ;
public long iString ;
public long pszText ;
public NSColorSpace ( long id ) {
public long colorSpaceModel ( ) {
long result = OS . objc_msgSend ( OS . class_NSColorSpace , OS . sel_genericRGBColorSpace ) ;
public long value ;
public LRESULT ( long value ) {
public long bmBits ;
public NSBrowserCell ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_highlightColorInView_ , controlView ! = null ? controlView . id : 0 ) ;
public nsIWebBrowserChromeFocus ( long address ) {
long hImage = shdi . hbmpDragImage ;
long oldMemBitmap = OS . SelectObject ( memHdc , memDib ) ;
long tableImageList = OS . SendMessage ( table . handle , OS . LVM_GETIMAGELIST , OS . LVSIL_SMALL , 0 ) ;
long hBrush = OS . GetStockObject ( OS . WHITE_BRUSH ) ;
long imageList = OS . SendMessage ( table . handle , OS . LVM_CREATEDRAGIMAGE , table . indexOf ( selected ) , pt ) ;
public long render ;
public long get_size ;
public long cairo ;
long hTheme = OS . OpenThemeData ( 0 , getClassId ( ) ) ;
public long dwExtraInfo ;
long gtk_button_press_event ( long widget , long event ) {
long imHandle = imHandle ( ) ;
long gtk_commit ( long imcontext , long textPtr ) {
long gtk_preedit_changed ( long imcontext ) {
long iterator = OS . pango_attr_list_get_iterator ( pangoAttrs [ 0 ] ) ;
long attr = OS . pango_attr_iterator_get ( iterator , OS . PANGO_ATTR_FOREGROUND ) ;
long imHandle ( ) {
long gdkEventKey = 0 ;
long ptr = OS . pango_layout_get_text ( layout ) ;
long style = OS . gtk_widget_get_style ( handle ) ;
long fontDesc = OS . gtk_style_get_font_desc ( style ) ;
long adjustment = OS . gtk_adjustment_new ( 0 , 0 , 100 , 1 , 10 , 0 ) ;
long imContext = imContext ( ) ;
long eventWindow ( ) {
long enterExitHandle ( ) {
boolean filterKey ( int keyval , long event ) {
long imContext = imContext ( ) ;
long imContext = imContext ( ) ;
long style = OS . gtk_widget_get_style ( handle ) ;
long hAdjustment = OS . gtk_spin_button_get_adjustment ( handle ) ;
long hAdjustment = OS . gtk_spin_button_get_adjustment ( handle ) ;
long hAdjustment = OS . gtk_spin_button_get_adjustment ( handle ) ;
long hAdjustment = OS . gtk_spin_button_get_adjustment ( handle ) ;
long hAdjustment = OS . gtk_spin_button_get_adjustment ( handle ) ;
long str = OS . gtk_entry_get_text ( handle ) ;
long ptr = OS . localeconv_decimal_point ( ) ;
long gtk_activate ( long widget ) {
long [ ] endptr = new long [ 1 ] ;
long hAdjustment = OS . gtk_spin_button_get_adjustment ( handle ) ;
long eventPtr = OS . gtk_get_current_event ( ) ;
long gtk_commit ( long imContext , long text ) {
long gtk_delete_text ( long widget , long start_pos , long end_pos ) {
long ptr = OS . gtk_entry_get_text ( handle ) ;
long gtk_event_after ( long widget , long gdkEvent ) {
long gtk_focus_out_event ( long widget , long event ) {
long gtk_insert_text ( long widget , long new_text , long new_text_length , long position ) {
long ptr = OS . gtk_entry_get_text ( handle ) ;
long gtk_populate_popup ( long widget , long menu ) {
long gtk_value_changed ( long widget ) {
long imContext = imContext ( ) ;
long imContext ( ) {
long imContext = imContext ( ) ;
void setFontDescription ( long font ) {
long hAdjustment = OS . gtk_spin_button_get_adjustment ( handle ) ;
long hAdjustment = OS . gtk_spin_button_get_adjustment ( handle ) ;
long hAdjustment = OS . gtk_spin_button_get_adjustment ( handle ) ;
long hAdjustment = OS . gtk_spin_button_get_adjustment ( handle ) ;
long hAdjustment = OS . gtk_spin_button_get_adjustment ( handle ) ;
long adjustment = OS . gtk_spin_button_get_adjustment ( handle ) ;
long imContext = imContext ( ) ;
long [ ] preeditString = new long [ 1 ] ;
long eventPtr = OS . gtk_get_current_event ( ) ;
long hAdjustment = OS . gtk_spin_button_get_adjustment ( handle ) ;
public static final native long GTK_TYPE_ACCESSIBLE ( ) ;
public static final native long ATK_TYPE_ACTION ( ) ;
public static final native long ATK_TYPE_COMPONENT ( ) ;
public static final native long ATK_TYPE_EDITABLE_TEXT ( ) ;
public static final native long ATK_TYPE_HYPERTEXT ( ) ;
public static final native long ATK_TYPE_SELECTION ( ) ;
public static final native long ATK_TYPE_TABLE ( ) ;
public static final native long ATK_TYPE_TEXT ( ) ;
public static final native long ATK_TYPE_VALUE ( ) ;
public static final native void memmove ( long dest , AtkTextRectangle src , int size ) ;
public static final native void memmove ( AtkTextRectangle dest , long src , int size ) ;
public static final native void memmove ( long dest , AtkTextRange src , int size ) ;
public static final native void memmove ( AtkTextRange dest , long src , int size ) ;
public static final native void memmove ( long dest , AtkAttribute src , int size ) ;
public static final native void memmove ( AtkAttribute dest , long src , int size ) ;
public NSArray ( long id ) {
long result = OS . objc_msgSend ( OS . class_NSArray , OS . sel_array ) ;
long result = OS . objc_msgSend ( OS . class_NSArray , OS . sel_arrayWithObject_ , anObject ! = null ? anObject . id : 0 ) ;
public long count ( ) {
public long indexOfObjectIdenticalTo ( id anObject ) {
long hTheme = OS . OpenThemeData ( 0 , getClassId ( ) ) ;
long hTheme = OS . OpenThemeData ( 0 , getClassId ( ) ) ;
long hwndHeader = parent . hwndHeader ;
long hwnd = parent . handle , hwndHeader = parent . hwndHeader ;
long hFont = item . fontHandle ( index ) ;
long hwndHeader = parent . hwndHeader ;
long hwnd = parent . handle ;
long hwndHeader = parent . hwndHeader ;
long hwndHeader = parent . hwndHeader ;
long hwnd = parent . handle ;
long hHeap = OS . GetProcessHeap ( ) ;
long pszText = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount ) ;
long hwndHeader = parent . hwndHeader ;
long result = OS . SendMessage ( hwndHeader , OS . HDM_SETITEM , index , hdItem ) ;
long hwndHeaderToolTip = parent . headerToolTipHandle ;
long hwndHeader = parent . hwndHeader ;
long hwnd = parent . handle ;
long hwndHeaderToolTip = parent . headerToolTipHandle ;
long hwndHeader = parent . hwndHeader ;
long settings = printInfo . PMPrintSettings ( ) ;
long cls = OS . objc_allocateClassPair ( OS . class_NSView , className , 0 ) ;
public long internal_new_GC ( GCData data ) {
public void internal_dispose_GC ( long hDC , GCData data ) {
long printSettings = printInfo . PMPrintSettings ( ) ;
public long prcExclude ;
public long pBlendFunction ;
public NSNumber ( long id ) {
public long integerValue ( ) {
long result = OS . objc_msgSend ( OS . class_NSNumber , OS . sel_numberWithBool_ , value ) ;
long result = OS . objc_msgSend ( OS . class_NSNumber , OS . sel_numberWithDouble_ , value ) ;
long result = OS . objc_msgSend ( OS . class_NSNumber , OS . sel_numberWithInt_ , value ) ;
long result = OS . objc_msgSend ( OS . class_NSNumber , OS . sel_valueWithPoint_ , point ) ;
long result = OS . objc_msgSend ( OS . class_NSNumber , OS . sel_valueWithRange_ , range ) ;
long result = OS . objc_msgSend ( OS . class_NSNumber , OS . sel_valueWithRect_ , rect ) ;
long result = OS . objc_msgSend ( OS . class_NSNumber , OS . sel_valueWithSize_ , size ) ;
long primary = OS . gdk_atom_intern ( buffer , false ) ;
long selection_data = 0 ;
long pName = OS . gdk_atom_name ( types1 [ i ] ) ;
long pName = OS . gdk_atom_name ( types2 [ i ] ) ;
long selection_data = gtk_clipboard_wait_for_contents ( GTKPRIMARYCLIPBOARD , TARGET ) ;
long selection_data = gtk_clipboard_wait_for_contents ( GTKCLIPBOARD , TARGET ) ;
long gtk_clipboard_wait_for_contents ( long clipboard , long target ) {
long selection_data = OS . gtk_clipboard_wait_for_contents ( clipboard , target ) ;
public nsIWebBrowserChrome ( long address ) {
public int GetWebBrowser ( long [ ] aWebBrowser ) {
public int SetWebBrowser ( long aWebBrowser ) {
public nsIDownload ( long address ) {
public int Init ( long aSource , long aTarget , char [ ] aDisplayName , long aMIMEInfo , long startTime , long aPersist ) {
public int GetSource ( long [ ] aSource ) {
public int GetTarget ( long [ ] aTarget ) {
public int GetPersist ( long [ ] aPersist ) {
public int GetDisplayName ( long [ ] aDisplayName ) {
public int GetMIMEInfo ( long [ ] aMIMEInfo ) {
public int GetListener ( long [ ] aListener ) {
public int SetListener ( long aListener ) {
public int GetObserver ( long [ ] aObserver ) {
public int SetObserver ( long aObserver ) {
public SFCertificatePanel ( long id ) {
public static long windowNumberAtPoint ( NSPoint point , long windowNumber ) {
long hTheme = OS . OpenThemeData ( 0 , EDIT ) ;
long hTheme = OS . OpenThemeData ( 0 , EDIT ) ;
long treeHandle = theme . treeHandle ;
long hDC = OS . GetDCEx ( handle , 0 , OS . DCX_CACHE | OS . DCX_CLIPCHILDREN | OS . DCX_CLIPSIBLINGS ) ;
long windowProc ( long hwnd , int msg , long wParam , long lParam ) {
LRESULT WM_CHAR ( long wParam , long lParam ) {
LRESULT WM_IME_COMPOSITION ( long wParam , long lParam ) {
long hIMC = OS . ImmGetContext ( handle ) ;
LRESULT WM_IME_COMPOSITION_START ( long wParam , long lParam ) {
LRESULT WM_IME_ENDCOMPOSITION ( long wParam , long lParam ) {
LRESULT WM_INPUTLANGCHANGE ( long wParam , long lParam ) {
LRESULT WM_KILLFOCUS ( long wParam , long lParam ) {
LRESULT WM_LBUTTONDOWN ( long wParam , long lParam ) {
LRESULT WM_SETFOCUS ( long wParam , long lParam ) {
LRESULT WM_SIZE ( long wParam , long lParam ) {
LRESULT WM_WINDOWPOSCHANGED ( long wParam , long lParam ) {
LRESULT WM_WINDOWPOSCHANGING ( long wParam , long lParam ) {
long hModule = OS . GetLibraryHandle ( ) ;
long hHeap = OS . GetProcessHeap ( ) ;
long pszText = OS . HeapAlloc ( hHeap , HEAP_ZERO_MEMORY , byteCount ) ;
long hActCtx = OS . CreateActCtx ( pActCtx ) ;
long [ ] lpCookie = new long [ 1 ] ;
long hModule = OS . LoadLibrary ( lpLibFileName ) ;
long DllGetVersion = OS . GetProcAddress ( hModule , lpProcName ) ;
long hModule = OS . LoadLibrary ( lpLibFileName ) ;
long DllGetVersion = OS . GetProcAddress ( hModule , lpProcName ) ;
public static final long AddFontResourceEx ( TCHAR lpszFilename , int fl , long pdv ) {
public static final long CallWindowProc ( long lpPrevWndFunc , long hWnd , int Msg , long wParam , long lParam ) {
public static final long CharUpper ( long ch ) {
public static final long CharLower ( long ch ) {
public static final long CreateActCtx ( ACTCTX pActCtx ) {
public static final long CreateAcceleratorTable ( byte [ ] lpaccl , int cEntries ) {
public static final long CreateDC ( TCHAR lpszDriver , TCHAR lpszDevice , long lpszOutput , long lpInitData ) {
public static final long CreateEnhMetaFile ( long hdcRef , TCHAR lpFilename , RECT lpRect , TCHAR lpDescription ) {
public static final long CreateFontIndirect ( long lplf ) {
public static final long CreateFontIndirect ( LOGFONT lplf ) {
public static final boolean CreateProcess ( long lpApplicationName , long lpCommandLine , long lpProcessAttributes , long lpThreadAttributes , boolean bInheritHandles , int dwCreationFlags , long lpEnvironment , long lpCurrentDirectory , STARTUPINFO lpStartupInfo , PROCESS_INFORMATION lpProcessInformation ) {
public static final long CreateWindowEx ( int dwExStyle , TCHAR lpClassName , TCHAR lpWindowName , int dwStyle , int X , int Y , int nWidth , int nHeight , long hWndParent , long hMenu , long hInstance , CREATESTRUCT lpParam ) {
public static final long DefMDIChildProc ( long hWnd , int Msg , long wParam , long lParam ) {
public static final long DefFrameProc ( long hWnd , long hWndMDIClient , int Msg , long wParam , long lParam ) {
public static final long DefWindowProc ( long hWnd , int Msg , long wParam , long lParam ) {
public static final long DispatchMessage ( MSG lpmsg ) {
public static final int DocumentProperties ( long hWnd , long hPrinter , TCHAR pDeviceName , long pDevModeOutput , long pDevModeInput , int fMode ) {
public static final int DragQueryFile ( long hDrop , int iFile , TCHAR lpszFile , int cch ) {
public static final boolean DrawState ( long hdc , long hbr , long lpOutputFunc , long lData , long wData , int x , int y , int cx , int cy , int fuFlags ) {
public static final int DrawText ( long hDC , TCHAR lpString , int nCount , RECT lpRect , int uFormat ) {
public static final int EnumFontFamilies ( long hdc , TCHAR lpszFamily , long lpEnumFontFamProc , long lParam ) {
public static final int EnumFontFamiliesEx ( long hdc , LOGFONT lpLogfont , long lpEnumFontFamExProc , long lParam , int dwFlags ) {
public static final boolean EnumSystemLocales ( long lpLocaleEnumProc , int dwFlags ) {
public static final boolean EnumSystemLanguageGroups ( long pLangGroupEnumProc , int dwFlags , long lParam ) {
public static final int ExtractIconEx ( TCHAR lpszFile , int nIconIndex , long [ ] phiconLarge , long [ ] phiconSmall , int nIcons ) {
public static final boolean ExtTextOut ( long hdc , int X , int Y , int fuOptions , RECT lprc , TCHAR lpString , int cbCount , int [ ] lpDx ) {
public static final long FindWindow ( TCHAR lpClassName , TCHAR lpWindowName ) {
public static final int FormatMessage ( int dwFlags , long lpSource , int dwMessageId , int dwLanguageId , long [ ] lpBuffer , int nSize , long Arguments ) {
public static final boolean GetCharABCWidths ( long hdc , int iFirstChar , int iLastChar , int [ ] lpabc ) {
public static final int GetCharacterPlacement ( long hdc , TCHAR lpString , int nCount , int nMaxExtent , GCP_RESULTS lpResults , int dwFlags ) {
public static final boolean GetCharWidth ( long hdc , int iFirstChar , int iLastChar , int [ ] lpabc ) {
public static final boolean GetClassInfo ( long hInstance , TCHAR lpClassName , WNDCLASS lpWndClass ) {
public static final int GetClassName ( long hWnd , TCHAR lpClassName , int nMaxCount ) {
public static final boolean GetMenuItemInfo ( long hMenu , int uItem , boolean fByPosition , MENUITEMINFO lpmii ) {
public static final boolean GetMessage ( MSG lpMsg , long hWnd , int wMsgFilterMin , int wMsgFilterMax ) {
public static final int GetModuleFileName ( long hModule , TCHAR lpFilename , int inSize ) {
public static final long GetModuleHandle ( TCHAR lpModuleName ) {
public static final boolean GetMonitorInfo ( long hmonitor , MONITORINFO lpmi ) {
public static final int GetObject ( long hgdiobj , int cbBuffer , BITMAP lpvObject ) {
public static final int GetObject ( long hgdiobj , int cbBuffer , DIBSECTION lpvObject ) {
public static final int GetObject ( long hgdiobj , int cbBuffer , EXTLOGPEN lpvObject ) {
public static final int GetObject ( long hgdiobj , int cbBuffer , LOGBRUSH lpvObject ) {
public static final int GetObject ( long hgdiobj , int cbBuffer , LOGFONT lpvObject ) {
public static final int GetObject ( long hgdiobj , int cbBuffer , LOGPEN lpvObject ) {
public static final int GetObject ( long hgdiobj , int cbBuffer , long lpvObject ) {
public static final int GetOutlineTextMetrics ( long hdc , int cbData , OUTLINETEXTMETRIC lpOTM ) {
public static long GetProp ( long hWnd , long lpString ) {
public static final boolean GetTextExtentPoint32 ( long hdc , TCHAR lpString , int cbString , SIZE lpSize ) {
public static final boolean GetTextMetrics ( long hdc , TEXTMETRIC lptm ) {
public static final int GetWindowLong ( long hWnd , int nIndex ) {
public static final long GetWindowLongPtr ( long hWnd , int nIndex ) {
public static final int GetWindowText ( long hWnd , TCHAR lpString , int nMaxCount ) {
public static final int GetWindowTextLength ( long hWnd ) {
public static final boolean ImmGetCompositionFont ( long hIMC , LOGFONT lplf ) {
public static final boolean ImmSetCompositionFont ( long hIMC , LOGFONT lplf ) {
public static final int ImmGetCompositionString ( long hIMC , int dwIndex , byte [ ] lpBuf , int dwBufLen ) {
public static final int ImmGetCompositionString ( long hIMC , int dwIndex , int [ ] lpBuf , int dwBufLen ) {
public static final int ImmGetCompositionString ( long hIMC , int dwIndex , TCHAR lpBuf , int dwBufLen ) {
public static final boolean InsertMenu ( long hMenu , int uPosition , int uFlags , long uIDNewItem , TCHAR lpNewItem ) {
public static final boolean InsertMenuItem ( long hMenu , int uItem , boolean fByPosition , MENUITEMINFO lpmii ) {
public static final long LoadBitmap ( long hInstance , long lpBitmapName ) {
public static final long LoadCursor ( long hInstance , long lpCursorName ) {
public static final long LoadIcon ( long hInstance , long lpIconName ) {
public static final long LoadImage ( long hinst , TCHAR lpszName , int uType , int cxDesired , int cyDesired , int fuLoad ) {
public static final long LoadImage ( long hinst , long lpszName , int uType , int cxDesired , int cyDesired , int fuLoad ) {
public static final long LoadLibrary ( TCHAR lpLibFileName ) {
public static final int LoadString ( long hinst , int uID , TCHAR lpBuffer , int nBufferMax ) {
public static final int MessageBox ( long hWnd , TCHAR lpText , TCHAR lpCaption , int uType ) {
public static final void MoveMemory ( long Destination , TCHAR Source , int Length ) {
public static final void MoveMemory ( TCHAR Destination , long Source , int Length ) {
public static final void MoveMemory ( long Destination , DEVMODE Source , int Length ) {
public static final void MoveMemory ( DEVMODE Destination , long Source , int Length ) {
public static final void MoveMemory ( long Destination , LOGFONT Source , int Length ) {
public static final void MoveMemory ( LOGFONT Destination , long Source , int Length ) {
public static final void MoveMemory ( long Destination , NMTTDISPINFO Source , int Length ) {
public static final void MoveMemory ( NMTTDISPINFO Destination , long Source , int Length ) {
public static final void MoveMemory ( TEXTMETRIC Destination , long Source , int Length ) {
public static final boolean OpenPrinter ( TCHAR pPrinterName , long [ ] phPrinter , long pDefault ) {
public static final boolean PeekMessage ( MSG lpMsg , long hWnd , int wMsgFilterMin , int wMsgFilterMax , int wRemoveMsg ) {
public static final boolean PostMessage ( long hWnd , int Msg , long wParam , long lParam ) {
public static final boolean PostThreadMessage ( int idThread , int Msg , long wParam , long lParam ) {
public static final int RegCreateKeyEx ( long hKey , TCHAR lpSubKey , int Reserved , TCHAR lpClass , int dwOptions , int samDesired , long lpSecurityAttributes , long [ ] phkResult , long [ ] lpdwDisposition ) {
public static final int RegDeleteValue ( long hKey , TCHAR lpValueName ) {
public static final int RegEnumKeyEx ( long hKey , int dwIndex , TCHAR lpName , int [ ] lpcName , int [ ] lpReserved , TCHAR lpClass , int [ ] lpcClass , FILETIME lpftLastWriteTime ) {
public static final int RegOpenKeyEx ( long hKey , TCHAR lpSubKey , int ulOptions , int samDesired , long [ ] phkResult ) {
public static final int RegQueryInfoKey ( long hKey , long lpClass , int [ ] lpcbClass , long lpReserved , int [ ] lpSubKeys , int [ ] lpcbMaxSubKeyLen , int [ ] lpcbMaxClassLen , int [ ] lpcValues , int [ ] lpcbMaxValueNameLen , int [ ] lpcbMaxValueLen , int [ ] lpcbSecurityDescriptor , long lpftLastWriteTime ) {
public static final int RegQueryValueEx ( long hKey , TCHAR lpValueName , long lpReserved , int [ ] lpType , TCHAR lpData , int [ ] lpcbData ) {
public static final int RegQueryValueEx ( long hKey , TCHAR lpValueName , long lpReserved , int [ ] lpType , int [ ] lpData , int [ ] lpcbData ) {
public static final int RegSetValueEx ( long hKey , TCHAR lpValueName , int Reserved , int dwType , int [ ] lpData , int cbData ) {
public static final long RemoveProp ( long hWnd , long lpString ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , TCHAR lParam ) {
public static final long SendMessage ( long hWnd , int Msg , int [ ] wParam , int [ ] lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , SIZE lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long [ ] wParam , long lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , int [ ] lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , char [ ] lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , short [ ] lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , long lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , LITEM lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , LVCOLUMN lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , LVHITTESTINFO lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , LVITEM lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , LVINSERTMARK lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , MARGINS lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , POINT lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , MCHITTESTINFO lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , REBARBANDINFO lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , RECT lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , SYSTEMTIME lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , SHDRAGIMAGE lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , TBBUTTON lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , TBBUTTONINFO lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , TCITEM lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , TCHITTESTINFO lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , TOOLINFO lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , TVHITTESTINFO lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , TVINSERTSTRUCT lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , TVITEM lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , TVSORTCB lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , UDACCEL lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , HDHITTESTINFO lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , HDITEM lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , HDLAYOUT lParam ) {
public static final long SendMessage ( long hWnd , int Msg , long wParam , BUTTON_IMAGELIST lParam ) {
public static final boolean SetMenuItemInfo ( long hMenu , int uItem , boolean fByPosition , MENUITEMINFO lpmii ) {
public static boolean SetProp ( long hWnd , long lpString , long hData ) {
public static final int SetWindowLong ( long hWnd , int nIndex , int dwNewLong ) {
public static final long SetWindowLongPtr ( long hWnd , int nIndex , long dwNewLong ) {
public static final long SetWindowsHookEx ( int idHook , long lpfn , long hMod , int dwThreadId ) {
public static final boolean SetWindowText ( long hWnd , TCHAR lpString ) {
public static final long SHBrowseForFolder ( BROWSEINFO lpbi ) {
public static long SHGetFileInfo ( TCHAR pszPath , int dwFileAttributes , SHFILEINFO psfi , int cbFileInfo , int uFlags ) {
public static final int SHGetFolderPath ( long hwndOwner , int nFolder , long hToken , int dwFlags , TCHAR pszPath ) {
public static final boolean SHGetPathFromIDList ( long pidl , TCHAR pszPath ) {
public static final int StartDoc ( long hdc , DOCINFO lpdi ) {
public static final int TranslateAccelerator ( long hWnd , long hAccTable , MSG lpMsg ) {
public static final boolean UnregisterClass ( TCHAR lpClassName , long hInstance ) {
public static final native int AbortDoc ( long hdc ) ;
public static final native boolean ActivateActCtx ( long hActCtx , long [ ] lpCookie ) ;
public static final native long ActivateKeyboardLayout ( long hkl , int Flags ) ;
public static final native int AddFontResourceExW ( char [ ] lpszFilename , int fl , long pdv ) ;
public static final native int AddFontResourceExA ( byte [ ] lpszFilename , int fl , long pdv ) ;
public static final native boolean AlphaBlend ( long hdcDest , int nXOriginDest , int nYOriginDest , int nWidthDest , int nHeightDest , long hdcSrc , int nXOriginSrc , int nYOriginSrc , int nWidthSrc , int nHeightSrc , BLENDFUNCTION blendFunction ) ;
public static final native boolean AnimateWindow ( long hwnd , int dwTime , int dwFlags ) ;
public static final native boolean Arc ( long hdc , int nLeftRect , int nTopRect , int nRightRect , int nBottomRect , int nXStartArc , int nYStartArc , int nXEndArc , int nYEndArc ) ;
public static final native long BeginPaint ( long hWnd , PAINTSTRUCT lpPaint ) ;
public static final native boolean BeginPath ( long hdc ) ;
public static final native boolean BitBlt ( long hdcDest , int nXDest , int nYDest , int nWidth , int nHeight , long hdcSrc , int nXSrc , int nYSrc , int dwRop ) ;
public static final native boolean BringWindowToTop ( long hWnd ) ;
public static final native int BufferedPaintSetAlpha ( long hBufferedPaint , RECT prc , byte alpha ) ;
public static final native int Call ( long address ) ;
public static final native int Call ( long address , DLLVERSIONINFO arg0 ) ;
public static final native long CallNextHookEx ( long hhk , int nCode , long wParam , long lParam ) ;
public static final native long CallWindowProcW ( long lpPrevWndFunc , long hWnd , int Msg , long wParam , long lParam ) ;
public static final native long CallWindowProcA ( long lpPrevWndFunc , long hWnd , int Msg , long wParam , long lParam ) ;
public static final native long CharLowerW ( long ch ) ;
public static final native long CharLowerA ( long ch ) ;
public static final native long CharUpperW ( long ch ) ;
public static final native long CharUpperA ( long ch ) ;
public static final native boolean CheckMenuItem ( long hmenu , int uIDCheckItem , int uCheck ) ;
public static final native boolean ClientToScreen ( long hWnd , POINT lpPoint ) ;
public static final native long CloseEnhMetaFile ( long hdc ) ;
public static final native long CloseGestureInfoHandle ( long hGesture ) ;
public static final native boolean CloseHandle ( long hObject ) ;
public static final native boolean ClosePrinter ( long hPrinter ) ;
public static final native int CloseThemeData ( long hTheme ) ;
public static final native boolean CloseTouchInputHandle ( long hTouchInput ) ;
public static final native int CoCreateInstance ( byte [ ] rclsid , long pUnkOuter , int dwClsContext , byte [ ] riid , long [ ] ppv ) ;
public static final native int CombineRgn ( long hrgnDest , long hrgnSrc1 , long hrgnSrc2 , int fnCombineMode ) ;
public static final native boolean CommandBar_AddAdornments ( long hwndCB , int dwFlags , int dwReserved ) ;
public static final native long CommandBar_Create ( long hInst , long hwndParent , int idCmdBar ) ;
public static final native void CommandBar_Destroy ( long hwndCB ) ;
public static final native boolean CommandBar_DrawMenuBar ( long hwndCB , int iButton ) ;
public static final native int CommandBar_Height ( long hdnwCB ) ;
public static final native boolean CommandBar_InsertMenubarEx ( long hwndCB , long hInst , long pszMenu , int iButton ) ;
public static final native boolean CommandBar_Show ( long hwndCB , boolean fShow ) ;
public static final native long CopyImage ( long hImage , int uType , int cxDesired , int cyDesired , int fuFlags ) ;
public static final native long CoTaskMemAlloc ( int cb ) ;
public static final native void CoTaskMemFree ( long pv ) ;
public static final native long CreateAcceleratorTableW ( byte [ ] lpaccl , int cEntries ) ;
public static final native long CreateAcceleratorTableA ( byte [ ] lpaccl , int cEntries ) ;
public static final native long CreateActCtxW ( ACTCTX pActCtx ) ;
public static final native long CreateActCtxA ( ACTCTX pActCtx ) ;
public static final native long CreateBitmap ( int nWidth , int nHeight , int cPlanes , int cBitsPerPel , byte [ ] lpvBits ) ;
public static final native boolean CreateCaret ( long hWnd , long hBitmap , int nWidth , int nHeight ) ;
public static final native long CreateCompatibleBitmap ( long hdc , int nWidth , int nHeight ) ;
public static final native long CreateCompatibleDC ( long hdc ) ;
public static final native long CreateCursor ( long hInst , int xHotSpot , int yHotSpot , int nWidth , int nHeight , byte [ ] pvANDPlane , byte [ ] pvXORPlane ) ;
public static final native long CreateDCW ( char [ ] lpszDriver , char [ ] lpszDevice , long lpszOutput , long lpInitData ) ;
public static final native long CreateDCA ( byte [ ] lpszDriver , byte [ ] lpszDevice , long lpszOutput , long lpInitData ) ;
public static final native long CreateDIBSection ( long hdc , byte [ ] pbmi , int iUsage , long [ ] ppvBits , long hSection , int dwOffset ) ;
public static final native long CreateDIBSection ( long hdc , long pbmi , int iUsage , long [ ] ppvBits , long hSection , int dwOffset ) ;
public static final native long CreateEnhMetaFileW ( long hdcRef , char [ ] lpFilename , RECT lpRect , char [ ] lpDescription ) ;
public static final native long CreateEnhMetaFileA ( long hdcRef , byte [ ] lpFilename , RECT lpRect , byte [ ] lpDescription ) ;
public static final native long CreateFontIndirectW ( long lplf ) ;
public static final native long CreateFontIndirectA ( long lplf ) ;
public static final native long CreateFontIndirectW ( LOGFONTW lplf ) ;
public static final native long CreateFontIndirectA ( LOGFONTA lplf ) ;
public static final native long CreatePalette ( byte [ ] logPalette ) ;
public static final native long CreatePatternBrush ( long hbmp ) ;
public static final native long CreatePen ( int fnPenStyle , int nWidth , int crColor ) ;
public static final native boolean CreateProcessW ( long lpApplicationName , long lpCommandLine , long lpProcessAttributes , long lpThreadAttributes , boolean bInheritHandles , int dwCreationFlags , long lpEnvironment , long lpCurrentDirectory , STARTUPINFO lpStartupInfo , PROCESS_INFORMATION lpProcessInformation ) ;
public static final native long CreateSolidBrush ( int colorRef ) ;
public static final native int CreateStreamOnHGlobal ( long hGlobal , boolean fDeleteOnRelease , long [ ] ppstm ) ;
public static final native long CreateWindowExW ( int dwExStyle , char [ ] lpClassName , char [ ] lpWindowName , int dwStyle , int X , int Y , int nWidth , int nHeight , long hWndParent , long hMenu , long hInstance , CREATESTRUCT lpParam ) ;
public static final native long CreateWindowExA ( int dwExStyle , byte [ ] lpClassName , byte [ ] lpWindowName , int dwStyle , int X , int Y , int nWidth , int nHeight , long hWndParent , long hMenu , long hInstance , CREATESTRUCT lpParam ) ;
public static final native long DeferWindowPos ( long hWinPosInfo , long hWnd , long hWndInsertAfter , int X , int Y , int cx , int cy , int uFlags ) ;
public static final native long DefMDIChildProcW ( long hWnd , int Msg , long wParam , long lParam ) ;
public static final native long DefMDIChildProcA ( long hWnd , int Msg , long wParam , long lParam ) ;
public static final native long DefFrameProcW ( long hWnd , long hWndMDIClient , int Msg , long wParam , long lParam ) ;
public static final native long DefFrameProcA ( long hWnd , long hWndMDIClient , int Msg , long wParam , long lParam ) ;
public static final native long DefWindowProcW ( long hWnd , int Msg , long wParam , long lParam ) ;
public static final native long DefWindowProcA ( long hWnd , int Msg , long wParam , long lParam ) ;
public static final native boolean DeleteDC ( long hdc ) ;
public static final native boolean DeleteEnhMetaFile ( long hemf ) ;
public static final native boolean DeleteMenu ( long hMenu , int uPosition , int uFlags ) ;
public static final native boolean DeleteObject ( long hGdiObj ) ;
public static final native boolean DestroyAcceleratorTable ( long hAccel ) ;
public static final native boolean DestroyCursor ( long hCursor ) ;
public static final native boolean DestroyIcon ( long hIcon ) ;
public static final native boolean DestroyMenu ( long hMenu ) ;
public static final native int DocumentPropertiesW ( long hWnd , long hPrinter , char [ ] pDeviceName , long pDevModeOutput , long pDevModeInput , int fMode ) ;
public static final native int DocumentPropertiesA ( long hWnd , long hPrinter , byte [ ] pDeviceName , long pDevModeOutput , long pDevModeInput , int fMode ) ;
public static final native boolean DPtoLP ( long hdc , POINT lpPoints , int nCount ) ;
public static final native boolean DragDetect ( long hwnd , POINT pt ) ;
public static final native void DragFinish ( long hDrop ) ;
public static final native int DragQueryFileA ( long hDrop , int iFile , byte [ ] lpszFile , int cch ) ;
public static final native int DragQueryFileW ( long hDrop , int iFile , char [ ] lpszFile , int cch ) ;
public static final native boolean DrawAnimatedRects ( long hwnd , int idAni , RECT lprcFrom , RECT lprcTo ) ;
public static final native boolean DrawEdge ( long hdc , RECT qrc , int edge , int grfFlags ) ;
public static final native boolean DrawFocusRect ( long hDC , RECT lpRect ) ;
public static final native boolean DrawFrameControl ( long hdc , RECT lprc , int uType , int uState ) ;
public static final native boolean DrawIconEx ( long hdc , int xLeft , int yTop , long hIcon , int cxWidth , int cyWidth , int istepIfAniCur , long hbrFlickerFreeDraw , int diFlags ) ;
public static final native boolean DrawMenuBar ( long hWnd ) ;
public static final native boolean DrawStateW ( long hdc , long hbr , long lpOutputFunc , long lData , long wData , int x , int y , int cx , int cy , int fuFlags ) ;
public static final native boolean DrawStateA ( long hdc , long hbr , long lpOutputFunc , long lData , long wData , int x , int y , int cx , int cy , int fuFlags ) ;
public static final native int DrawTextW ( long hDC , char [ ] lpString , int nCount , RECT lpRect , int uFormat ) ;
public static final native int DrawTextA ( long hDC , byte [ ] lpString , int nCount , RECT lpRect , int uFormat ) ;
public static final native int DrawThemeBackground ( long hTheme , long hdc , int iPartId , int iStateId , RECT pRect , RECT pClipRect ) ;
public static final native int DrawThemeEdge ( long hTheme , long hdc , int iPartId , int iStateId , RECT pDestRect , int uEdge , int uFlags , RECT pContentRect ) ;
public static final native int DrawThemeIcon ( long hTheme , long hdc , int iPartId , int iStateId , RECT pRect , long himl , int iImageIndex ) ;
public static final native int DrawThemeParentBackground ( long hwnd , long hdc , RECT prc ) ;
public static final native int DrawThemeText ( long hTheme , long hdc , int iPartId , int iStateId , char [ ] pszText , int iCharCount , int dwTextFlags , int dwTextFlags2 , RECT pRect ) ;
public static final native int DrawThemeTextEx ( long hTheme , long hdc , int iPartId , int iStateId , char [ ] pszText , int iCharCount , int dwFlags , RECT pRect , DTTOPTS pOptions ) ;
public static final native int DwmEnableBlurBehindWindow ( long hWnd , DWM_BLURBEHIND pBlurBehind ) ;
public static final native int DwmExtendFrameIntoClientArea ( long hWnd , MARGINS pMarInset ) ;
public static final native boolean Ellipse ( long hdc , int nLeftRect , int nTopRect , int nRightRect , int nBottomRect ) ;
public static final native boolean EnableMenuItem ( long hMenu , int uIDEnableItem , int uEnable ) ;
public static final native boolean EnableScrollBar ( long hWnd , int wSBflags , int wArrows ) ;
public static final native boolean EnableWindow ( long hWnd , boolean bEnable ) ;
public static final native boolean EnumSystemLanguageGroupsW ( long pLangGroupEnumProc , int dwFlags , long lParam ) ;
public static final native boolean EnumSystemLanguageGroupsA ( long pLangGroupEnumProc , int dwFlags , long lParam ) ;
public static final native boolean EnumSystemLocalesW ( long lpLocaleEnumProc , int dwFlags ) ;
public static final native boolean EnumSystemLocalesA ( long lpLocaleEnumProc , int dwFlags ) ;
public static final native boolean EndDeferWindowPos ( long hWinPosInfo ) ;
public static final native int EndBufferedPaint ( long hBufferedPaint , boolean fUpdateTarget ) ;
public static final native int EndDoc ( long hdc ) ;
public static final native int EndPage ( long hdc ) ;
public static final native int EndPaint ( long hWnd , PAINTSTRUCT lpPaint ) ;
public static final native boolean EndPath ( long hdc ) ;
public static final native boolean EnumDisplayMonitors ( long hdc , RECT lprcClip , long lpfnEnum , int dwData ) ;
public static final native boolean EnumEnhMetaFile ( long hdc , long hemf , long lpEnhMetaFunc , long lpData , RECT lpRect ) ;
public static final native int EnumFontFamiliesW ( long hdc , char [ ] lpszFamily , long lpEnumFontFamProc , long lParam ) ;
public static final native int EnumFontFamiliesA ( long hdc , byte [ ] lpszFamily , long lpEnumFontFamProc , long lParam ) ;
public static final native int EnumFontFamiliesExW ( long hdc , LOGFONTW lpLogfont , long lpEnumFontFamExProc , long lParam , int dwFlags ) ;
public static final native int EnumFontFamiliesExA ( long hdc , LOGFONTA lpLogfont , long lpEnumFontFamExProc , long lParam , int dwFlags ) ;
public static final native boolean EqualRgn ( long hSrcRgn1 , long hSrcRgn2 ) ;
public static final native int ExcludeClipRect ( long hdc , int nLeftRect , int nTopRect , int nRightRect , int nBottomRect ) ;
public static final native long ExtCreatePen ( int dwPenStyle , int dwWidth , LOGBRUSH lplb , int dwStyleCount , int [ ] lpStyle ) ;
public static final native long ExtCreateRegion ( float [ ] lpXform , int nCount , int [ ] lpRgnData ) ;
public static final native boolean ExtTextOutW ( long hdc , int X , int Y , int fuOptions , RECT lprc , char [ ] lpString , int cbCount , int [ ] lpDx ) ;
public static final native boolean ExtTextOutA ( long hdc , int X , int Y , int fuOptions , RECT lprc , byte [ ] lpString , int cbCount , int [ ] lpDx ) ;
public static final native int ExtractIconExW ( char [ ] lpszFile , int nIconIndex , long [ ] phiconLarge , long [ ] phiconSmall , int nIcons ) ;
public static final native int ExtractIconExA ( byte [ ] lpszFile , int nIconIndex , long [ ] phiconLarge , long [ ] phiconSmall , int nIcons ) ;
public static final native int FillRect ( long hDC , RECT lprc , long hbr ) ;
public static final native boolean FillPath ( long hdc ) ;
public static final native long FindWindowA ( byte [ ] lpClassName , byte [ ] lpWindowName ) ;
public static final native long FindWindowW ( char [ ] lpClassName , char [ ] lpWindowName ) ;
public static final native int FormatMessageA ( int dwFlags , long lpSource , int dwMessageId , int dwLanguageId , long [ ] lpBuffer , int nSize , long Arguments ) ;
public static final native int FormatMessageW ( int dwFlags , long lpSource , int dwMessageId , int dwLanguageId , long [ ] lpBuffer , int nSize , long Arguments ) ;
public static final native boolean FreeLibrary ( long hLibModule ) ;
public static final native long GetActiveWindow ( ) ;
public static final native boolean GetCharABCWidthsA ( long hdc , int iFirstChar , int iLastChar , int [ ] lpabc ) ;
public static final native boolean GetCharABCWidthsW ( long hdc , int iFirstChar , int iLastChar , int [ ] lpabc ) ;
public static final native int GetCharacterPlacementW ( long hdc , char [ ] lpString , int nCount , int nMaxExtent , GCP_RESULTS lpResults , int dwFlags ) ;
public static final native int GetCharacterPlacementA ( long hdc , byte [ ] lpString , int nCount , int nMaxExtent , GCP_RESULTS lpResults , int dwFlags ) ;
public static final native boolean GetCharWidthA ( long hdc , int iFirstChar , int iLastChar , int [ ] lpBuffer ) ;
public static final native boolean GetCharWidthW ( long hdc , int iFirstChar , int iLastChar , int [ ] lpBuffer ) ;
public static final native boolean GetClassInfoW ( long hInstance , char [ ] lpClassName , WNDCLASS lpWndClass ) ;
public static final native boolean GetClassInfoA ( long hInstance , byte [ ] lpClassName , WNDCLASS lpWndClass ) ;
public static final native int GetClassNameW ( long hWnd , char [ ] lpClassName , int nMaxCount ) ;
public static final native int GetClassNameA ( long hWnd , byte [ ] lpClassName , int nMaxCount ) ;
public static final native int GetClipBox ( long hdc , RECT lprc ) ;
public static final native int GetClipRgn ( long hdc , long hrgn ) ;
public static final native boolean GetComboBoxInfo ( long hwndCombo , COMBOBOXINFO pcbi ) ;
public static final native long GetCurrentObject ( long hdc , int uObjectType ) ;
public static final native long GetDC ( long hwnd ) ;
public static final native int GetDeviceCaps ( long hdc , int nIndex ) ;
public static final native int GetDIBColorTable ( long hdc , int uStartIndex , int cEntries , byte [ ] pColors ) ;
public static final native int GetDIBits ( long hdc , long hbmp , int uStartScan , int cScanLines , byte [ ] lpvBits , byte [ ] lpbi , int uUsage ) ;
public static final native long GetDlgItem ( long hDlg , int nIDDlgItem ) ;
public static final native long GetFocus ( ) ;
public static final native boolean GetGestureInfo ( long hGestureInfo , GESTUREINFO pGestureInfo ) ;
public static final native int GetGraphicsMode ( long hdc ) ;
public static final native int GetGlyphIndicesW ( long hdc , char [ ] lpstr , int c , short [ ] pgi , int fl ) ;
public static final native boolean GetIconInfo ( long hIcon , ICONINFO piconinfo ) ;
public static final native long GetLastActivePopup ( long hWnd ) ;
public static final native boolean GetLayeredWindowAttributes ( long hwnd , int [ ] pcrKey , byte [ ] pbAlpha , int [ ] pdwFlags ) ;
public static final native int GetLayout ( long hdc ) ;
public static final native long GetLibraryHandle ( ) ;
public static final native long GetMenu ( long hWnd ) ;
public static final native boolean GetMenuBarInfo ( long hWnd , int idObject , int idItem , MENUBARINFO pmbi ) ;
public static final native int GetMenuDefaultItem ( long hMenu , int fByPos , int gmdiFlags ) ;
public static final native boolean GetMenuInfo ( long hmenu , MENUINFO lpcmi ) ;
public static final native int GetMenuItemCount ( long hMenu ) ;
public static final native boolean GetMenuItemInfoW ( long hMenu , int uItem , boolean fByPosition , MENUITEMINFO lpmii ) ;
public static final native boolean GetMenuItemInfoA ( long hMenu , int uItem , boolean fByPosition , MENUITEMINFO lpmii ) ;
public static final native boolean GetMenuItemRect ( long hWnd , long hMenu , int uItem , RECT lprcItem ) ;
public static final native boolean GetMessageW ( MSG lpMsg , long hWnd , int wMsgFilterMin , int wMsgFilterMax ) ;
public static final native boolean GetMessageA ( MSG lpMsg , long hWnd , int wMsgFilterMin , int wMsgFilterMax ) ;
public static final native int GetMetaRgn ( long hdc , long hrgn ) ;
public static final native int GetThemeBitmap ( long hTheme , int iPartId , int iStateId , int iPropId , int dwFlags , long [ ] hBitmap ) ;
public static final native int GetThemeColor ( long hTheme , int iPartId , int iStateId , int iPropId , int [ ] pColor ) ;
public static final native int GetThemeTextExtent ( long hTheme , long hdc , int iPartId , int iStateId , char [ ] pszText , int iCharCount , int dwTextFlags , RECT pBoundingRect , RECT pExtentRect ) ;
public static final native int GetTextCharset ( long hdc ) ;
public static final native int GetMapMode ( long hdc ) ;
public static final native int GetModuleFileNameW ( long hModule , char [ ] lpFilename , int inSize ) ;
public static final native int GetModuleFileNameA ( long hModule , byte [ ] lpFilename , int inSize ) ;
public static final native long GetModuleHandleW ( char [ ] lpModuleName ) ;
public static final native long GetModuleHandleA ( byte [ ] lpModuleName ) ;
public static final native boolean GetMonitorInfoW ( long hmonitor , MONITORINFO lpmi ) ;
public static final native boolean GetMonitorInfoA ( long hmonitor , MONITORINFO lpmi ) ;
public static final native int GetNearestPaletteIndex ( long hPal , int crColor ) ;
public static final native int GetObjectA ( long hgdiobj , int cbBuffer , BITMAP lpvObject ) ;
public static final native int GetObjectW ( long hgdiobj , int cbBuffer , BITMAP lpvObject ) ;
public static final native int GetObjectA ( long hgdiobj , int cbBuffer , DIBSECTION lpvObject ) ;
public static final native int GetObjectW ( long hgdiobj , int cbBuffer , DIBSECTION lpvObject ) ;
public static final native int GetObjectA ( long hgdiobj , int cbBuffer , EXTLOGPEN lpvObject ) ;
public static final native int GetObjectW ( long hgdiobj , int cbBuffer , EXTLOGPEN lpvObject ) ;
public static final native int GetObjectA ( long hgdiobj , int cbBuffer , LOGBRUSH lpvObject ) ;
public static final native int GetObjectW ( long hgdiobj , int cbBuffer , LOGBRUSH lpvObject ) ;
public static final native int GetObjectA ( long hgdiobj , int cbBuffer , LOGFONTA lpvObject ) ;
public static final native int GetObjectW ( long hgdiobj , int cbBuffer , LOGFONTW lpvObject ) ;
public static final native int GetObjectA ( long hgdiobj , int cbBuffer , LOGPEN lpvObject ) ;
public static final native int GetObjectW ( long hgdiobj , int cbBuffer , LOGPEN lpvObject ) ;
public static final native int GetObjectA ( long hgdiobj , int cbBuffer , long lpvObject ) ;
public static final native int GetObjectW ( long hgdiobj , int cbBuffer , long lpvObject ) ;
public static final native int GetOutlineTextMetricsW ( long hdc , int cbData , OUTLINETEXTMETRICW lpOTM ) ;
public static final native int GetOutlineTextMetricsA ( long hdc , int cbData , OUTLINETEXTMETRICA lpOTM ) ;
public static final native int GetPath ( long hdc , int [ ] lpPoints , byte [ ] lpTypes , int nSize ) ;
public static final native int GetPaletteEntries ( long hPalette , int iStartIndex , int nEntries , byte [ ] logPalette ) ;
public static final native long GetParent ( long hWnd ) ;
public static final native int GetPixel ( long hdc , int x , int y ) ;
public static final native int GetPolyFillMode ( long hdc ) ;
public static final native boolean OpenPrinterW ( char [ ] pPrinterName , long [ ] phPrinter , long pDefault ) ;
public static final native boolean OpenPrinterA ( byte [ ] pPrinterName , long [ ] phPrinter , long pDefault ) ;
public static final native int GetProcessHeaps ( int NumberOfHeaps , long [ ] ProcessHeaps ) ;
public static final native long GetPropW ( long hWnd , long lpString ) ;
public static final native long GetPropA ( long hWnd , long lpString ) ;
public static final native int GetRandomRgn ( long hdc , long hrgn , int iNum ) ;
public static final native int GetRegionData ( long hRgn , int dwCount , int [ ] lpRgnData ) ;
public static final native int GetRgnBox ( long hrgn , RECT lprc ) ;
public static final native int GetROP2 ( long hdc ) ;
public static final native boolean GetScrollBarInfo ( long hwnd , int idObject , SCROLLBARINFO psbi ) ;
public static final native boolean GetScrollInfo ( long hwnd , int flags , SCROLLINFO info ) ;
public static final native long GetStockObject ( int fnObject ) ;
public static final native long GetSysColorBrush ( int nIndex ) ;
public static final native long GetSystemMenu ( long hWnd , boolean bRevert ) ;
public static final native int GetSystemPaletteEntries ( long hdc , int iStartIndex , int nEntries , byte [ ] lppe ) ;
public static final native int GetTextColor ( long hDC ) ;
public static final native boolean GetTextExtentPoint32W ( long hdc , char [ ] lpString , int cbString , SIZE lpSize ) ;
public static final native boolean GetTextExtentPoint32A ( long hdc , byte [ ] lpString , int cbString , SIZE lpSize ) ;
public static final native boolean GetTextMetricsW ( long hdc , TEXTMETRICW lptm ) ;
public static final native boolean GetTextMetricsA ( long hdc , TEXTMETRICA lptm ) ;
public static final native int GetThemeInt ( long hTheme , int iPartId , int iStateId , int iPropId , int [ ] piVal ) ;
public static final native int GetThemeMargins ( long hTheme , long hdc , int iPartId , int iStateId , int iPropId , RECT prc , MARGINS pMargins ) ;
public static final native int GetThemeBackgroundContentRect ( long hTheme , long hdc , int iPartId , int iStateId , RECT pBoundingRect , RECT pContentRect ) ;
public static final native int GetThemeBackgroundExtent ( long hTheme , long hdc , int iPartId , int iStateId , RECT pContentRect , RECT pExtentRect ) ;
public static final native int GetThemePartSize ( long hTheme , long hdc , int iPartId , int iStateId , RECT prc , int eSize , SIZE psz ) ;
public static final native int GetThemeMetric ( long hTheme , long hdc , int iPartId , int iStateId , int iPropId , int [ ] piVal ) ;
public static final native int GetThemeRect ( long hTheme , int iPartId , int iStateId , int iPropId , RECT pRect ) ;
public static final native int GetThemeSysSize ( long hTheme , int iSizeID ) ;
public static final native boolean GetTouchInputInfo ( long hTouchInput , int cInputs , long pTouchInputs , int cbSize ) ;
public static final native boolean GetUpdateRect ( long hWnd , RECT lpRect , boolean bErase ) ;
public static final native int GetUpdateRgn ( long hWnd , long hRgn , boolean bErase ) ;
public static final native long GetWindow ( long hWnd , int uCmd ) ;
public static final native int GetWindowLongW ( long hWnd , int nIndex ) ;
public static final native int GetWindowLongA ( long hWnd , int nIndex ) ;
public static final native long GetWindowLongPtrW ( long hWnd , int nIndex ) ;
public static final native long GetWindowLongPtrA ( long hWnd , int nIndex ) ;
public static final native long GetWindowDC ( long hWnd ) ;
public static final native boolean GetWindowOrgEx ( long hdc , POINT lpPoint ) ;
public static final native boolean GetWindowPlacement ( long hWnd , WINDOWPLACEMENT lpwndpl ) ;
public static final native boolean GetWindowRect ( long hWnd , RECT lpRect ) ;
public static final native int GetWindowRgn ( long hWnd , long hRgn ) ;
public static final native int GetWindowTextW ( long hWnd , char [ ] lpString , int nMaxCount ) ;
public static final native int GetWindowTextA ( long hWnd , byte [ ] lpString , int nMaxCount ) ;
public static final native int GetWindowTextLengthW ( long hWnd ) ;
public static final native int GetWindowTextLengthA ( long hWnd ) ;
public static final native long GetWindowTheme ( long hWnd ) ;
public static final native int GetWindowThreadProcessId ( long hWnd , int [ ] lpdwProcessId ) ;
public static final native boolean GetWorldTransform ( long hdc , float [ ] lpXform ) ;
public static final native long GlobalAlloc ( int uFlags , int dwBytes ) ;
public static final native long GlobalFree ( long hMem ) ;
public static final native long GlobalLock ( long hMem ) ;
public static final native int GlobalSize ( long hMem ) ;
public static final native boolean GlobalUnlock ( long hMem ) ;
public static final native long HeapAlloc ( long hHeap , int dwFlags , int dwBytes ) ;
public static final native boolean HeapFree ( long hHeap , int dwFlags , long lpMem ) ;
public static final native boolean HeapValidate ( long hHeap , int dwFlags , long lpMem ) ;
public static final native boolean HideCaret ( long hWnd ) ;
public static final native int HitTestThemeBackground ( long hTheme , long hdc , int iPartId , int iStateId , int dwOptions , RECT pRect , long hrgn , POINT ptTest , short [ ] pwHitTestCode ) ;
public static final native int ImageList_Add ( long himl , long hbmImage , long hbmMask ) ;
public static final native int ImageList_AddMasked ( long himl , long hbmImage , int crMask ) ;
public static final native boolean ImageList_Destroy ( long himl ) ;
public static final native boolean ImageList_DragEnter ( long hwndLock , int x , int y ) ;
public static final native boolean ImageList_DragLeave ( long hwndLock ) ;
public static final native boolean ImageList_Draw ( long himl , int i , long hdcDst , int x , int y , int fStyle ) ;
public static final native long ImageList_GetDragImage ( POINT ppt , POINT pptHotspot ) ;
public static final native long ImageList_GetIcon ( long himl , int i , int flags ) ;
public static final native boolean ImageList_GetIconSize ( long himl , int [ ] cx , int [ ] cy ) ;
public static final native int ImageList_GetImageCount ( long himl ) ;
public static final native boolean ImageList_Remove ( long himl , int i ) ;
public static final native boolean ImageList_Replace ( long himl , int i , long hbmImage , long hbmMask ) ;
public static final native int ImageList_ReplaceIcon ( long himl , int i , long hicon ) ;
public static final native boolean ImageList_SetIconSize ( long himl , int cx , int cy ) ;
public static final native boolean ImmDestroyContext ( long hIMC ) ;
public static final native boolean ImmGetCompositionFontW ( long hIMC , LOGFONTW lplf ) ;
public static final native boolean ImmGetCompositionFontA ( long hIMC , LOGFONTA lplf ) ;
public static final native int ImmGetCompositionStringW ( long hIMC , int dwIndex , char [ ] lpBuf , int dwBufLen ) ;
public static final native int ImmGetCompositionStringA ( long hIMC , int dwIndex , byte [ ] lpBuf , int dwBufLen ) ;
public static final native int ImmGetCompositionStringW ( long hIMC , int dwIndex , int [ ] lpBuf , int dwBufLen ) ;
public static final native int ImmGetCompositionStringA ( long hIMC , int dwIndex , int [ ] lpBuf , int dwBufLen ) ;
public static final native int ImmGetCompositionStringW ( long hIMC , int dwIndex , byte [ ] lpBuf , int dwBufLen ) ;
public static final native long ImmGetContext ( long hWnd ) ;
public static final native boolean ImmGetConversionStatus ( long hIMC , int [ ] lpfdwConversion , int [ ] lpfdwSentence ) ;
public static final native long ImmGetDefaultIMEWnd ( long hWnd ) ;
public static final native boolean ImmGetOpenStatus ( long hIMC ) ;
public static final native boolean ImmNotifyIME ( long hIMC , int dwAction , int dwIndex , int dwValue ) ;
public static final native boolean ImmReleaseContext ( long hWnd , long hIMC ) ;
public static final native boolean ImmSetCompositionFontW ( long hIMC , LOGFONTW lplf ) ;
public static final native boolean ImmSetCompositionFontA ( long hIMC , LOGFONTA lplf ) ;
public static final native boolean ImmSetCompositionWindow ( long hIMC , COMPOSITIONFORM lpCompForm ) ;
public static final native boolean ImmSetCandidateWindow ( long hIMC , CANDIDATEFORM lpCandidate ) ;
public static final native boolean ImmSetConversionStatus ( long hIMC , int fdwConversion , int dwSentence ) ;
public static final native boolean ImmSetOpenStatus ( long hIMC , boolean fOpen ) ;
public static final native boolean InsertMenuW ( long hMenu , int uPosition , int uFlags , long uIDNewItem , char [ ] lpNewItem ) ;
public static final native boolean InsertMenuA ( long hMenu , int uPosition , int uFlags , long uIDNewItem , byte [ ] lpNewItem ) ;
public static final native boolean InsertMenuItemW ( long hMenu , int uItem , boolean fByPosition , MENUITEMINFO lpmii ) ;
public static final native boolean InsertMenuItemA ( long hMenu , int uItem , boolean fByPosition , MENUITEMINFO lpmii ) ;
public static final native boolean InternetSetOption ( long hInternet , int dwOption , long lpBuffer , int dwBufferLength ) ;
public static final native int IntersectClipRect ( long hdc , int nLeftRect , int nTopRect , int nRightRect , int nBottomRect ) ;
public static final native boolean InvalidateRect ( long hWnd , RECT lpRect , boolean bErase ) ;
public static final native boolean InvalidateRgn ( long hWnd , long hRgn , boolean bErase ) ;
public static final native boolean IsBadReadPtr ( long lp , int ucb ) ;
public static final native boolean IsBadWritePtr ( long lp , int ucb ) ;
public static final native boolean IsHungAppWindow ( long hWnd ) ;
public static final native boolean IsIconic ( long hWnd ) ;
public static final native boolean IsTouchWindow ( long hWnd , long [ ] outFlags ) ;
public static final native boolean IsWindowEnabled ( long hWnd ) ;
public static final native boolean IsWindowVisible ( long hWnd ) ;
public static final native boolean IsZoomed ( long hWnd ) ;
public static final native boolean KillTimer ( long hWnd , long uIDEvent ) ;
public static final native boolean LineTo ( long hdc , int x1 , int x2 ) ;
public static final native long LoadBitmapW ( long hInstance , long lpBitmapName ) ;
public static final native long LoadBitmapA ( long hInstance , long lpBitmapName ) ;
public static final native long LoadCursorW ( long hInstance , long lpCursorName ) ;
public static final native long LoadCursorA ( long hInstance , long lpCursorName ) ;
public static final native long LoadIconW ( long hInstance , long lpIconName ) ;
public static final native long LoadIconA ( long hInstance , long lpIconName ) ;
public static final native long LoadImageW ( long hinst , char [ ] lpszName , int uType , int cxDesired , int cyDesired , int fuLoad ) ;
public static final native long LoadImageA ( long hinst , byte [ ] lpszName , int uType , int cxDesired , int cyDesired , int fuLoad ) ;
public static final native long LoadImageW ( long hinst , long lpszName , int uType , int cxDesired , int cyDesired , int fuLoad ) ;
public static final native long LoadImageA ( long hinst , long lpszName , int uType , int cxDesired , int cyDesired , int fuLoad ) ;
public static final native int LoadStringW ( long hinst , int uID , char [ ] lpBuffer , int nBufferMax ) ;
public static final native int LoadStringA ( long hinst , int uID , byte [ ] lpBuffer , int nBufferMax ) ;
public static final native long LoadLibraryW ( char [ ] lpLibFileName ) ;
public static final native long LoadLibraryA ( byte [ ] lpLibFileName ) ;
public static final native long LocalFree ( long hMem ) ;
public static final native boolean LockWindowUpdate ( long hWndLock ) ;
public static final native int LOWORD ( long l ) ;
public static final native boolean LPtoDP ( long hdc , POINT lpPoints , int nCount ) ;
public static final native int MapWindowPoints ( long hWndFrom , long hWndTo , POINT lpPoints , int cPoints ) ;
public static final native int MapWindowPoints ( long hWndFrom , long hWndTo , RECT lpPoints , int cPoints ) ;
public static final native int MessageBoxW ( long hWnd , char [ ] lpText , char [ ] lpCaption , int uType ) ;
public static final native int MessageBoxA ( long hWnd , byte [ ] lpText , byte [ ] lpCaption , int uType ) ;
public static final native boolean ModifyWorldTransform ( long hdc , float [ ] lpXform , int iMode ) ;
public static final native long MonitorFromWindow ( long hwnd , int dwFlags ) ;
public static final native void MoveMemory ( char [ ] Destination , long SourcePtr , int Length ) ;
public static final native void MoveMemory ( byte [ ] Destination , long Source , int Length ) ;
public static final native void MoveMemory ( int [ ] Destination , long Source , int Length ) ;
public static final native void MoveMemory ( long [ ] Destination , long SourcePtr , int Length ) ;
public static final native void MoveMemory ( double [ ] Destination , long SourcePtr , int Length ) ;
public static final native void MoveMemory ( float [ ] Destination , long SourcePtr , int Length ) ;
public static final native void MoveMemory ( short [ ] Destination , long SourcePtr , int Length ) ;
public static final native void MoveMemory ( long Destination , byte [ ] Source , int Length ) ;
public static final native void MoveMemory ( long Destination , char [ ] Source , int Length ) ;
public static final native void MoveMemory ( long Destination , int [ ] Source , int Length ) ;
public static final native void MoveMemory ( long Destination , long Source , int Length ) ;
public static final native void MoveMemory ( long Destination , DEVMODEW Source , int Length ) ;
public static final native void MoveMemory ( long Destination , DEVMODEA Source , int Length ) ;
public static final native void MoveMemory ( long Destination , DOCHOSTUIINFO Source , int Length ) ;
public static final native void MoveMemory ( long Destination , GRADIENT_RECT Source , int Length ) ;
public static final native void MoveMemory ( long Destination , LOGFONTW Source , int Length ) ;
public static final native void MoveMemory ( long Destination , LOGFONTA Source , int Length ) ;
public static final native void MoveMemory ( long Destination , MEASUREITEMSTRUCT Source , int Length ) ;
public static final native void MoveMemory ( long Destination , MINMAXINFO Source , int Length ) ;
public static final native void MoveMemory ( long Destination , MSG Source , int Length ) ;
public static final native void MoveMemory ( long Destination , UDACCEL Source , int Length ) ;
public static final native void MoveMemory ( long Destination , NMTTDISPINFOW Source , int Length ) ;
public static final native void MoveMemory ( long Destination , NMTTDISPINFOA Source , int Length ) ;
public static final native void MoveMemory ( long Destination , OPENFILENAME Source , int Length ) ;
public static final native void MoveMemory ( long Destination , RECT Source , int Length ) ;
public static final native void MoveMemory ( long Destination , SAFEARRAY Source , int Length ) ;
public static final native void MoveMemory ( long Destination , TRIVERTEX Source , int Length ) ;
public static final native void MoveMemory ( long Destination , WINDOWPOS Source , int Length ) ;
public static final native void MoveMemory ( BITMAPINFOHEADER Destination , long Source , int Length ) ;
public static final native void MoveMemory ( CERT_CONTEXT Destination , long Source , int Length ) ;
public static final native void MoveMemory ( CERT_INFO Destination , long Source , int Length ) ;
public static final native void MoveMemory ( DEVMODEW Destination , long Source , int Length ) ;
public static final native void MoveMemory ( DEVMODEA Destination , long Source , int Length ) ;
public static final native void MoveMemory ( DOCHOSTUIINFO Destination , long Source , int Length ) ;
public static final native void MoveMemory ( DRAWITEMSTRUCT Destination , long Source , int Length ) ;
public static final native void MoveMemory ( EXTLOGPEN Destination , long Source , int Length ) ;
public static final native void MoveMemory ( FLICK_DATA Destination , long [ ] Source , int Length ) ;
public static final native void MoveMemory ( FLICK_POINT Destination , long [ ] Source , int Length ) ;
public static final native void MoveMemory ( HDITEM Destination , long Source , int Length ) ;
public static final native void MoveMemory ( HELPINFO Destination , long Source , int Length ) ;
public static final native void MoveMemory ( LOGFONTW Destination , long Source , int Length ) ;
public static final native void MoveMemory ( LOGFONTA Destination , long Source , int Length ) ;
public static final native void MoveMemory ( MEASUREITEMSTRUCT Destination , long Source , int Length ) ;
public static final native void MoveMemory ( MINMAXINFO Destination , long Source , int Length ) ;
public static final native void MoveMemory ( OFNOTIFY Destination , long Source , int Length ) ;
public static final native void MoveMemory ( OPENFILENAME Destination , long Source , int Length ) ;
public static final native void MoveMemory ( POINT Destination , long Source , int Length ) ;
public static final native void MoveMemory ( NMHDR Destination , long Source , int Length ) ;
public static final native void MoveMemory ( NMRGINFO Destination , long Source , int Length ) ;
public static final native void MoveMemory ( NMCUSTOMDRAW Destination , long Source , int Length ) ;
public static final native void MoveMemory ( NMLVCUSTOMDRAW Destination , long Source , int Length ) ;
public static final native void MoveMemory ( NMTBHOTITEM Destination , long Source , int Length ) ;
public static final native void MoveMemory ( NMTREEVIEW Destination , long Source , int Length ) ;
public static final native void MoveMemory ( NMTVCUSTOMDRAW Destination , long Source , int Length ) ;
public static final native void MoveMemory ( NMTVITEMCHANGE Destination , long Source , int Length ) ;
public static final native void MoveMemory ( NMUPDOWN Destination , long Source , int Length ) ;
public static final native void MoveMemory ( long Destination , NMLVCUSTOMDRAW Source , int Length ) ;
public static final native void MoveMemory ( long Destination , NMTVCUSTOMDRAW Source , int Length ) ;
public static final native void MoveMemory ( long Destination , NMTTCUSTOMDRAW Source , int Length ) ;
public static final native void MoveMemory ( long Destination , NMLVDISPINFO Source , int Length ) ;
public static final native void MoveMemory ( long Destination , NMTVDISPINFO Source , int Length ) ;
public static final native void MoveMemory ( NMLVDISPINFO Destination , long Source , int Length ) ;
public static final native void MoveMemory ( NMTVDISPINFO Destination , long Source , int Length ) ;
public static final native void MoveMemory ( NMLVFINDITEM Destination , long Source , int Length ) ;
public static final native void MoveMemory ( NMLVODSTATECHANGE Destination , long Source , int Length ) ;
public static final native void MoveMemory ( NMHEADER Destination , long Source , int Length ) ;
public static final native void MoveMemory ( NMLINK Destination , long Source , int Length ) ;
public static final native void MoveMemory ( NMLISTVIEW Destination , long Source , int Length ) ;
public static final native void MoveMemory ( NMREBARCHILDSIZE Destination , long Source , int Length ) ;
public static final native void MoveMemory ( NMREBARCHEVRON Destination , long Source , int Length ) ;
public static final native void MoveMemory ( NMTOOLBAR Destination , long Source , int Length ) ;
public static final native void MoveMemory ( NMTTCUSTOMDRAW Destination , long Source , int Length ) ;
public static final native void MoveMemory ( NMTTDISPINFOW Destination , long Source , int Length ) ;
public static final native void MoveMemory ( SHDRAGIMAGE Destination , long Source , int Length ) ;
public static final native void MoveMemory ( EMR Destination , long Source , int Length ) ;
public static final native void MoveMemory ( EMREXTCREATEFONTINDIRECTW Destination , long Source , int Length ) ;
public static final native void MoveMemory ( long Destination , SHDRAGIMAGE Source , int Length ) ;
public static final native void MoveMemory ( TEXTMETRICW Destination , long Source , int Length ) ;
public static final native void MoveMemory ( TEXTMETRICA Destination , long Source , int Length ) ;
public static final native void MoveMemory ( TOUCHINPUT Destination , long Source , int Length ) ;
public static final native void MoveMemory ( TVITEM Destination , long Source , int Length ) ;
public static final native void MoveMemory ( WINDOWPOS Destination , long Source , int Length ) ;
public static final native void MoveMemory ( MSG Destination , long Source , int Length ) ;
public static final native void MoveMemory ( UDACCEL Destination , long Source , int Length ) ;
public static final native void MoveMemory ( long Destination , DROPFILES Source , int Length ) ;
public static final native void MoveMemory ( long DestinationPtr , double [ ] Source , int Length ) ;
public static final native void MoveMemory ( long DestinationPtr , float [ ] Source , int Length ) ;
public static final native void MoveMemory ( long DestinationPtr , long [ ] Source , int Length ) ;
public static final native void MoveMemory ( long DestinationPtr , short [ ] Source , int Length ) ;
public static final native void MoveMemory ( SCRIPT_ITEM Destination , long SourcePtr , int Length ) ;
public static final native void MoveMemory ( SCRIPT_LOGATTR Destination , long SourcePtr , int Length ) ;
public static final native void MoveMemory ( SCRIPT_PROPERTIES Destination , long SourcePtr , int Length ) ;
public static final native void MoveMemory ( long Destination , KEYBDINPUT Source , int Length ) ;
public static final native void MoveMemory ( long Destination , MOUSEINPUT Source , int Length ) ;
public static final native void MoveMemory ( long Destination , GESTURECONFIG Source , int Length ) ;
public static final native boolean MoveToEx ( long hdc , int x1 , int x2 , long lPoint ) ;
public static final native int MsgWaitForMultipleObjectsEx ( int nCount , long pHandles , int dwMilliseconds , int dwWakeMask , int dwFlags ) ;
public static final native int MultiByteToWideChar ( int CodePage , int dwFlags , long lpMultiByteStr , int cchMultiByte , char [ ] lpWideCharStr , int cchWideChar ) ;
public static final native void NotifyWinEvent ( int event , long hwnd , int idObject , int idChild ) ;
public static final native int OffsetRgn ( long hrgn , int nXOffset , int nYOffset ) ;
public static final native int OleInitialize ( long pvReserved ) ;
public static final native boolean OpenClipboard ( long hWndNewOwner ) ;
public static final native long OpenThemeData ( long hwnd , char [ ] pszClassList ) ;
public static final native boolean PatBlt ( long hdc , int x1 , int x2 , int w , int h , int rop ) ;
public static final native boolean PathIsExe ( long szfile ) ;
public static final native boolean PeekMessageW ( MSG lpMsg , long hWnd , int wMsgFilterMin , int wMsgFilterMax , int wRemoveMsg ) ;
public static final native boolean PeekMessageA ( MSG lpMsg , long hWnd , int wMsgFilterMin , int wMsgFilterMax , int wRemoveMsg ) ;
public static final native boolean Pie ( long hdc , int nLeftRect , int nTopRect , int nRightRect , int nBottomRect , int nXStartArc , int nYStartArc , int nXEndArc , int nYEndArc ) ;
public static final native void POINTSTOPOINT ( POINT pt , long pts ) ;
public static final native boolean Polygon ( long hdc , int [ ] points , int nPoints ) ;
public static final native boolean Polyline ( long hdc , int [ ] points , int nPoints ) ;
public static final native boolean PostMessageW ( long hWnd , int Msg , long wParam , long lParam ) ;
public static final native boolean PostMessageA ( long hWnd , int Msg , long wParam , long lParam ) ;
public static final native boolean PostThreadMessageW ( int idThread , int Msg , long wParam , long lParam ) ;
public static final native boolean PostThreadMessageA ( int idThread , int Msg , long wParam , long lParam ) ;
public static final native boolean PrintWindow ( long hwnd , long hdcBlt , int nFlags ) ;
public static final native boolean PtInRegion ( long hrgn , int X , int Y ) ;
public static final native int RealizePalette ( long hDC ) ;
public static final native boolean Rectangle ( long hdc , int nLeftRect , int nTopRect , int nRightRect , int nBottomRect ) ;
public static final native boolean RectInRegion ( long hrgn , RECT lprc ) ;
public static final native boolean RedrawWindow ( long hWnd , RECT lprcUpdate , long hrgnUpdate , int flags ) ;
public static final native int RegCloseKey ( long hKey ) ;
public static final native int RegCreateKeyExW ( long hKey , char [ ] lpSubKey , int Reserved , char [ ] lpClass , int dwOptions , int samDesired , long lpSecurityAttributes , long [ ] phkResult , long [ ] lpdwDisposition ) ;
public static final native int RegCreateKeyExA ( long hKey , byte [ ] lpSubKey , int Reserved , byte [ ] lpClass , int dwOptions , int samDesired , long lpSecurityAttributes , long [ ] phkResult , long [ ] lpdwDisposition ) ;
public static final native int RegDeleteValueW ( long hKey , char [ ] lpValueName ) ;
public static final native int RegDeleteValueA ( long hKey , byte [ ] lpValueName ) ;
public static final native int RegEnumKeyExW ( long hKey , int dwIndex , char [ ] lpName , int [ ] lpcName , int [ ] lpReserved , char [ ] lpClass , int [ ] lpcClass , FILETIME lpftLastWriteTime ) ;
public static final native int RegEnumKeyExA ( long hKey , int dwIndex , byte [ ] lpName , int [ ] lpcName , int [ ] lpReserved , byte [ ] lpClass , int [ ] lpcClass , FILETIME lpftLastWriteTime ) ;
public static final native boolean RegisterTouchWindow ( long hWnd , int ulFlags ) ;
public static final native int RegOpenKeyExW ( long hKey , char [ ] lpSubKey , int ulOptions , int samDesired , long [ ] phkResult ) ;
public static final native int RegOpenKeyExA ( long hKey , byte [ ] lpSubKey , int ulOptions , int samDesired , long [ ] phkResult ) ;
public static final native int RegQueryInfoKeyW ( long hKey , long lpClass , int [ ] lpcbClass , long lpReserved , int [ ] lpSubKeys , int [ ] lpcbMaxSubKeyLen , int [ ] lpcbMaxClassLen , int [ ] lpcValues , int [ ] lpcbMaxValueNameLen , int [ ] lpcbMaxValueLen , int [ ] lpcbSecurityDescriptor , long lpftLastWriteTime ) ;
public static final native int RegQueryInfoKeyA ( long hKey , long lpClass , int [ ] lpcbClass , long lpReserved , int [ ] lpSubKeys , int [ ] lpcbMaxSubKeyLen , int [ ] lpcbMaxClassLen , int [ ] lpcValues , int [ ] lpcbMaxValueNameLen , int [ ] lpcbMaxValueLen , int [ ] lpcbSecurityDescriptor , long lpftLastWriteTime ) ;
public static final native int RegQueryValueExW ( long hKey , char [ ] lpValueName , long lpReserved , int [ ] lpType , char [ ] lpData , int [ ] lpcbData ) ;
public static final native int RegQueryValueExW ( long hKey , char [ ] lpValueName , long lpReserved , int [ ] lpType , int [ ] lpData , int [ ] lpcbData ) ;
public static final native int RegQueryValueExA ( long hKey , byte [ ] lpValueName , long lpReserved , int [ ] lpType , byte [ ] lpData , int [ ] lpcbData ) ;
public static final native int RegSetValueExW ( long hKey , char [ ] lpValueName , int Reserved , int dwType , int [ ] lpData , int cbData ) ;
public static final native int RegSetValueExA ( long hKey , byte [ ] lpValueName , int Reserved , int dwType , int [ ] lpData , int cbData ) ;
public static final native int RegQueryValueExA ( long hKey , byte [ ] lpValueName , long lpReserved , int [ ] lpType , int [ ] lpData , int [ ] lpcbData ) ;
public static final native int ReleaseDC ( long hWnd , long hDC ) ;
public static final native boolean RemoveMenu ( long hMenu , int uPosition , int uFlags ) ;
public static final native long RemovePropA ( long hWnd , long lpString ) ;
public static final native boolean RestoreDC ( long hdc , int nSavedDC ) ;
public static final native boolean RoundRect ( long hdc , int nLeftRect , int nTopRect , int nRightRect , int nBottomRect , int nWidth , int nHeight ) ;
public static final native int SaveDC ( long hdc ) ;
public static final native boolean ScreenToClient ( long hWnd , POINT lpPoint ) ;
public static final native int ScriptBreak ( char [ ] pwcChars , int cChars , SCRIPT_ANALYSIS psa , long psla ) ;
public static final native int ScriptGetProperties ( long [ ] ppSp , int [ ] piNumScripts ) ;
public static final native int ScriptCacheGetHeight ( long hdc , long psc , int [ ] tmHeight ) ;
public static final native int ScriptCPtoX ( int iCP , boolean fTrailing , int cChars , int cGlyphs , long pwLogClust , long psva , long piAdvance , SCRIPT_ANALYSIS psa , int [ ] piX ) ;
public static final native int ScriptFreeCache ( long psc ) ;
public static final native int ScriptGetFontProperties ( long hdc , long psc , SCRIPT_FONTPROPERTIES sfp ) ;
public static final native int ScriptGetLogicalWidths ( SCRIPT_ANALYSIS psa , int cChars , int cGlyphs , long piGlyphWidth , long pwLogClust , long psva , int [ ] piDx ) ;
public static final native int ScriptItemize ( char [ ] pwcInChars , int cInChars , int cMaxItems , SCRIPT_CONTROL psControl , SCRIPT_STATE psState , long pItems , int [ ] pcItems ) ;
public static final native int ScriptJustify ( long psva , long piAdvance , int cGlyphs , int iDx , int iMinKashida , long piJustify ) ;
public static final native int ScriptPlace ( long hdc , long psc , long pwGlyphs , int cGlyphs , long psva , SCRIPT_ANALYSIS psa , long piAdvance , long pGoffset , int [ ] pABC ) ;
public static final native int ScriptGetCMap ( long hdc , long psc , char [ ] pwcChars , int cChars , int dwFlags , short [ ] pwOutGlyphs ) ;
public static final native int ScriptShape ( long hdc , long psc , char [ ] pwcChars , int cChars , int cMaxGlyphs , SCRIPT_ANALYSIS psa , long pwOutGlyphs , long pwLogClust , long psva , int [ ] pcGlyphs ) ;
public static final native int ScriptStringAnalyse ( long hdc , char [ ] pString , int cString , int cGlyphs , int iCharset , int dwFlags , int iReqWidth , SCRIPT_CONTROL psControl , SCRIPT_STATE psState , long piDx , long pTabdef , long pbInClass , long pssa ) ;
public static final native int ScriptStringOut ( long ssa , int iX , int iY , int uOptions , RECT prc , int iMinSel , int iMaxSel , boolean fDisabled ) ;
public static final native int ScriptStringFree ( long pssa ) ;
public static final native int ScriptTextOut ( long hdc , long psc , int x , int y , int fuOptions , RECT lprc , SCRIPT_ANALYSIS psa , long pwcReserved , int iReserved , long pwGlyphs , int cGlyphs , long piAdvance , long piJustify , long pGoffset ) ;
public static final native int ScriptXtoCP ( int iX , int cChars , int cGlyphs , long pwLogClust , long psva , long piAdvance , SCRIPT_ANALYSIS psa , int [ ] piCP , int [ ] piTrailing ) ;
public static final native int ScrollWindowEx ( long hWnd , int dx , int dy , RECT prcScroll , RECT prcClip , long hrgnUpdate , RECT prcUpdate , int flags ) ;
public static final native int SelectClipRgn ( long hdc , long hrgn ) ;
public static final native long SelectObject ( long hDC , long HGDIObj ) ;
public static final native long SelectPalette ( long hDC , long hpal , boolean bForceBackground ) ;
public static final native int SendInput ( int nInputs , long pInputs , int cbSize ) ;
public static final native long SendMessageW ( long hWnd , int Msg , int [ ] wParam , int [ ] lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long [ ] wParam , long lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , char [ ] lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , int [ ] lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , short [ ] lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , long lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , LVCOLUMN lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , LVHITTESTINFO lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , LITEM lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , LVITEM lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , LVINSERTMARK lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , MARGINS lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , MCHITTESTINFO lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , POINT lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , REBARBANDINFO lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , RECT lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , SYSTEMTIME lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , SHDRAGIMAGE lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , TBBUTTON lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , TBBUTTONINFO lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , TCITEM lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , TCHITTESTINFO lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , TOOLINFO lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , TVHITTESTINFO lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , TVINSERTSTRUCT lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , TVITEM lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , TVSORTCB lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , UDACCEL lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , HDHITTESTINFO lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , HDITEM lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , HDLAYOUT lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , BUTTON_IMAGELIST lParam ) ;
public static final native long SendMessageW ( long hWnd , int Msg , long wParam , SIZE lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , int [ ] wParam , int [ ] lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long [ ] wParam , long lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , byte [ ] lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , int [ ] lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , short [ ] lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , char [ ] lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , long lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , LVCOLUMN lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , LVHITTESTINFO lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , LITEM lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , LVINSERTMARK lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , LVITEM lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , MARGINS lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , MCHITTESTINFO lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , POINT lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , REBARBANDINFO lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , RECT lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , SYSTEMTIME lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , SHDRAGIMAGE lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , TBBUTTON lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , TBBUTTONINFO lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , TCITEM lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , TCHITTESTINFO lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , TOOLINFO lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , TVHITTESTINFO lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , TVINSERTSTRUCT lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , TVITEM lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , TVSORTCB lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , UDACCEL lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , HDHITTESTINFO lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , HDITEM lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , HDLAYOUT lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , BUTTON_IMAGELIST lParam ) ;
public static final native long SendMessageA ( long hWnd , int Msg , long wParam , SIZE lParam ) ;
public static final native long SetActiveWindow ( long hWnd ) ;
public static final native int SetBkColor ( long hdc , int colorRef ) ;
public static final native int SetBkMode ( long hdc , int mode ) ;
public static final native boolean SetBrushOrgEx ( long hdc , int nXOrg , int nYOrg , POINT lppt ) ;
public static final native long SetCapture ( long hWnd ) ;
public static final native long SetClipboardData ( int uFormat , long hMem ) ;
public static final native long SetCursor ( long hCursor ) ;
public static final native int SetDIBColorTable ( long hdc , int uStartIndex , int cEntries , byte [ ] pColors ) ;
public static final native long SetFocus ( long hWnd ) ;
public static final native boolean SetForegroundWindow ( long hWnd ) ;
public static final native boolean SetGestureConfig ( long hwnd , int dwReserved , int cIDs , long pGestureConfig , int cbSize ) ;
public static final native int SetGraphicsMode ( long hdc , int iMode ) ;
public static final native boolean SetLayeredWindowAttributes ( long hwnd , int crKey , byte bAlpha , int dwFlags ) ;
public static final native int SetLayout ( long hdc , int dwLayout ) ;
public static final native int SetMapMode ( long hdc , int fnMapMode ) ;
public static final native int SetMapperFlags ( long hdc , int dwFlag ) ;
public static final native boolean SetMenu ( long hWnd , long hMenu ) ;
public static final native boolean SetMenuDefaultItem ( long hMenu , int uItem , int fByPos ) ;
public static final native boolean SetMenuInfo ( long hmenu , MENUINFO lpcmi ) ;
public static final native boolean SetMenuItemInfoW ( long hMenu , int uItem , boolean fByPosition , MENUITEMINFO lpmii ) ;
public static final native boolean SetMenuItemInfoA ( long hMenu , int uItem , boolean fByPosition , MENUITEMINFO lpmii ) ;
public static final native int SetMetaRgn ( long hdc ) ;
public static final native int SetPaletteEntries ( long hPal , int iStart , int cEntries , byte [ ] lppe ) ;
public static final native long SetParent ( long hWndChild , long hWndNewParent ) ;
public static final native int SetPixel ( long hdc , int X , int Y , int crColor ) ;
public static final native int SetPolyFillMode ( long hdc , int iPolyFillMode ) ;
public static final native boolean SetRectRgn ( long hrgn , int nLeftRect , int nTopRect , int nRightRect , int nBottomRect ) ;
public static final native int SetROP2 ( long hdc , int fnDrawMode ) ;
public static final native boolean SetScrollInfo ( long hwnd , int flags , SCROLLINFO info , boolean fRedraw ) ;
public static final native int SetStretchBltMode ( long hdc , int iStretchMode ) ;
public static final native boolean SetPropW ( long hWnd , long lpString , long hData ) ;
public static final native boolean SetPropA ( long hWnd , long lpString , long hData ) ;
public static final native int SetTextAlign ( long hdc , int fMode ) ;
public static final native int SetTextColor ( long hdc , int colorRef ) ;
public static final native long SetTimer ( long hWnd , long nIDEvent , int Elapse , long lpTimerFunc ) ;
public static final native boolean SetViewportExtEx ( long hdc , int nXExtent , int nYExtent , SIZE lpSize ) ;
public static final native boolean SetViewportOrgEx ( long hdc , int X , int Y , POINT lpPoint ) ;
public static final native int SetWindowLongW ( long hWnd , int nIndex , int dwNewLong ) ;
public static final native int SetWindowLongA ( long hWnd , int nIndex , int dwNewLong ) ;
public static final native long SetWindowLongPtrW ( long hWnd , int nIndex , long dwNewLong ) ;
public static final native long SetWindowLongPtrA ( long hWnd , int nIndex , long dwNewLong ) ;
public static final native boolean SetWindowExtEx ( long hdc , int nXExtent , int nYExtent , SIZE lpSize ) ;
public static final native boolean SetWindowOrgEx ( long hdc , int X , int Y , POINT lpPoint ) ;
public static final native boolean SetWindowPlacement ( long hWnd , WINDOWPLACEMENT lpwndpl ) ;
public static final native boolean SetWindowPos ( long hWnd , long hWndInsertAfter , int X , int Y , int cx , int cy , int uFlags ) ;
public static final native int SetWindowRgn ( long hWnd , long hRgn , boolean bRedraw ) ;
public static final native boolean SetWindowTextW ( long hWnd , char [ ] lpString ) ;
public static final native boolean SetWindowTextA ( long hWnd , byte [ ] lpString ) ;
public static final native int SetWindowTheme ( long hwnd , char [ ] pszSubAppName , char [ ] pszSubIdList ) ;
public static final native long SetWindowsHookExW ( int idHook , long lpfn , long hMod , int dwThreadId ) ;
public static final native long SetWindowsHookExA ( int idHook , long lpfn , long hMod , int dwThreadId ) ;
public static final native boolean SetWorldTransform ( long hdc , float [ ] lpXform ) ;
public static final native long SHGetFileInfoW ( char [ ] pszPath , int dwFileAttributes , SHFILEINFOW psfi , int cbFileInfo , int uFlags ) ;
public static final native long SHGetFileInfoA ( byte [ ] pszPath , int dwFileAttributes , SHFILEINFOA psfi , int cbFileInfo , int uFlags ) ;
public static final native int SHGetFolderPathW ( long hwndOwner , int nFolder , long hToken , int dwFlags , char [ ] pszPath ) ;
public static final native int SHGetFolderPathA ( long hwndOwner , int nFolder , long hToken , int dwFlags , byte [ ] pszPath ) ;
public static final native boolean SHHandleWMSettingChange ( long hwnd , long wParam , long lParam , SHACTIVATEINFO psai ) ;
public static final native void SHSendBackToFocusWindow ( int uMsg , long wp , long lp ) ;
public static final native boolean SHSipPreference ( long hwnd , int st ) ;
public static final native int SHGetMalloc ( long [ ] ppMalloc ) ;
public static final native boolean SHGetPathFromIDListW ( long pidl , char [ ] pszPath ) ;
public static final native boolean SHGetPathFromIDListA ( long pidl , byte [ ] pszPath ) ;
public static final native int SHCreateItemInKnownFolder ( byte [ ] kfid , int dwKFFlags , char [ ] pszItem , byte [ ] riid , long [ ] ppv ) ;
public static final native int SHCreateItemFromRelativeName ( long psiParent , char [ ] pszName , long pbc , byte [ ] riid , long [ ] ppv ) ;
public static final native boolean SHSetAppKeyWndAssoc ( byte bVk , long hwnd ) ;
public static final native boolean ShowCaret ( long hWnd ) ;
public static final native boolean ShowOwnedPopups ( long hWnd , boolean fShow ) ;
public static final native boolean ShowScrollBar ( long hWnd , int wBar , boolean bShow ) ;
public static final native boolean ShowWindow ( long hWnd , int nCmdShow ) ;
public static final native int StartDocW ( long hdc , DOCINFO lpdi ) ;
public static final native int StartDocA ( long hdc , DOCINFO lpdi ) ;
public static final native int StartPage ( long hdc ) ;
public static final native boolean StretchBlt ( long hdcDest , int nXOriginDest , int nYOriginDest , int nWidthDest , int nHeightDest , long hdcSrc , int nXOriginSrc , int nYOriginSrc , int nWidthSrc , int nHeightSrc , int dwRop ) ;
public static final native boolean StrokePath ( long hdc ) ;
public static final native boolean TreeView_GetItemRect ( long hwndTV , long hitem , RECT prc , boolean fItemRect ) ;
public static final native boolean TrackPopupMenu ( long hMenu , int uFlags , int x , int y , int nReserved , long hWnd , RECT prcRect ) ;
public static final native int TranslateAcceleratorW ( long hWnd , long hAccTable , MSG lpMsg ) ;
public static final native int TranslateAcceleratorA ( long hWnd , long hAccTable , MSG lpMsg ) ;
public static final native boolean TranslateCharsetInfo ( long lpSrc , int [ ] lpCs , int dwFlags ) ;
public static final native boolean TranslateMDISysAccel ( long hWndClient , MSG lpMsg ) ;
public static final native boolean TransparentBlt ( long hdcDest , int nXOriginDest , int nYOriginDest , int nWidthDest , int hHeightDest , long hdcSrc , int nXOriginSrc , int nYOriginSrc , int nWidthSrc , int nHeightSrc , int crTransparent ) ;
public static final native boolean TransparentImage ( long hdcDest , int DstX , int DstY , int DstCx , int DstCy , long hSrc , int SrcX , int SrcY , int SrcCx , int SrcCy , int TransparentColor ) ;
public static final native boolean UnhookWindowsHookEx ( long hhk ) ;
public static final native boolean UnregisterClassW ( char [ ] lpClassName , long hInstance ) ;
public static final native boolean UnregisterClassA ( byte [ ] lpClassName , long hInstance ) ;
public static final native boolean UpdateLayeredWindow ( long hwnd , long hdcDst , POINT pptDst , SIZE psize , long hdcSrc , POINT pptSrc , int crKey , BLENDFUNCTION pblend , int dwFlags ) ;
public static final native boolean UnregisterTouchWindow ( long hwnd ) ;
public static final native boolean UpdateWindow ( long hWnd ) ;
public static final native boolean ValidateRect ( long hWnd , RECT lpRect ) ;
public static final native int WideCharToMultiByte ( int CodePage , int dwFlags , char [ ] lpWideCharStr , int cchWideChar , long lpMultiByteStr , int cchMultiByte , byte [ ] lpDefaultChar , boolean [ ] lpUsedDefaultChar ) ;
public static final native long WindowFromDC ( long hDC ) ;
public static final native long WindowFromPoint ( POINT lpPoint ) ;
public static final native int wcslen ( long string ) ;
public static final native long MapViewOfFile ( long hFileMappingObject , int dwDesiredAccess , int dwFileOffsetHigh , int dwFileOffsetLow , int dwNumberOfBytesToMap ) ;
public static final native boolean UnmapViewOfFile ( long lpBaseAddress ) ;
public static final native long OpenProcess ( int dwDesiredAccess , boolean bInheritHandle , int dwProcessId ) ;
public static final native long GetCurrentProcess ( ) ;
int canTakeFocus ( long sender , int forward , long result ) {
int contextMenuItemsForElement ( long sender , long element , long defaultItemsHMenu , long resultHMenu ) {
OS . MoveMemory ( resultHMenu , new long [ ] { defaultItemsHMenu } , C . PTR_SIZEOF ) ;
OS . MoveMemory ( resultHMenu , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
int createWebViewWithRequest ( long sender , long request , long webView ) {
OS . MoveMemory ( webView , new long [ ] { iwebview . getAddress ( ) } , OS . PTR_SIZEOF ) ;
long [ ] result = new long [ 1 ] ;
long getAddress ( ) {
int mouseDidMoveOverElement ( long sender , long elementInformation , int modifierFlags ) {
int printFrame ( long webView , long frame ) {
long printDC = pd . hDC ;
long [ ] result = new long [ 1 ] ;
int QueryInterface ( long riid , long ppvObject ) {
COM . MoveMemory ( ppvObject , new long [ ] { iWebUIDelegate . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { iWebUIDelegate . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
int runBeforeUnloadConfirmPanelWithMessage ( long sender , long message , long initiatedByFrame , long result ) {
int runJavaScriptAlertPanelWithMessage ( long sender , long message ) {
int runJavaScriptConfirmPanelWithMessage ( long sender , long message , long result ) {
int runJavaScriptTextInputPanelWithPrompt ( long sender , long message , long defaultText , long result ) {
long [ ] response = new long [ 1 ] ;
int runOpenPanelForFileButtonWithResultListener ( long sender , long resultListener ) {
int setFrame ( long sender , long frame ) {
int setMenuBarVisible ( long sender , int visible ) {
int setStatusBarVisible ( long sender , int visible ) {
int setStatusText ( long sender , long text ) {
int setToolbarsVisible ( long sender , int visible ) {
int takeFocus ( long sender , int forward ) {
int webViewClose ( long sender ) {
int webViewFrame ( long sender , long frame ) {
int webViewShow ( long sender ) {
public NSLocale ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_displayNameForKey_value_ , key ! = null ? key . id : 0 , value ! = null ? value . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_initWithLocaleIdentifier_ , string ! = null ? string . id : 0 ) ;
public NSBezierPath ( long id ) {
public void appendBezierPathWithArcWithCenter ( NSPoint center , double radius , double startAngle , double endAngle ) {
public void appendBezierPathWithArcWithCenter ( NSPoint center , double radius , double startAngle , double endAngle , boolean clockwise ) {
public void appendBezierPathWithGlyphs ( long glyphs , long count , NSFont font ) {
public void appendBezierPathWithRoundedRect ( NSRect rect , double xRadius , double yRadius ) {
long result = OS . objc_msgSend ( OS . class_NSBezierPath , OS . sel_bezierPath ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_bezierPathByFlatteningPath ) ;
long result = OS . objc_msgSend ( OS . class_NSBezierPath , OS . sel_bezierPathWithRect_ , rect ) ;
public long elementAtIndex ( long index , long points ) {
public long elementCount ( ) {
public static void setDefaultFlatness ( double flatness ) {
public void setLineCapStyle ( long lineCapStyle ) {
public void setLineDash ( double [ ] pattern , long count , double phase ) {
public void setLineJoinStyle ( long lineJoinStyle ) {
public void setLineWidth ( double lineWidth ) {
public void setMiterLimit ( double miterLimit ) {
public void setWindingRule ( long windingRule ) {
public long hwndParent ;
public long hInstRes ;
public long hwndMB ;
long pValue = OS . g_malloc ( buffer . length ) ;
public IStorage ( long address ) {
long [ ] ppStg
long [ ] ppStm
long [ ] ppenum
long [ ] ppStg
long [ ] ppStm
static long getParentType ( long widgetType ) {
static long atkObjectFactory_create_accessible ( long widget ) {
long result = OS . g_object_new ( getParentType ( OS . G_OBJECT_TYPE ( widget ) ) , 0 ) ;
long type = getType ( getTypeName ( widgetType ) , accessible , parentType , ACC . CHILDID_SELF ) ;
long childType = getType ( CHILD_TYPENAME , accessible , ATK . GTK_TYPE_ACCESSIBLE ( ) , childId ) ;
long controlHandle = accessible . getControlHandle ( ) ;
static long getType ( String widgetTypeName , Accessible accessible , long parentType , int childId ) {
long type = OS . g_type_from_name ( nameBytes ) ;
long queryPtr = OS . g_malloc ( GTypeQuery . sizeof ) ;
long definition = OS . g_malloc ( GTypeInfo . sizeof ) ;
static long gTypeInfo_base_init_factory ( long klass ) {
static long gTypeInfo_base_init_type ( long klass ) {
long gObjectClass = OS . G_OBJECT_CLASS ( klass ) ;
static long initActionIfaceCB ( long iface ) {
static long initComponentIfaceCB ( long iface ) {
static long initEditableTextIfaceCB ( long iface ) {
static long initHypertextIfaceCB ( long iface ) {
static long initSelectionIfaceCB ( long iface ) {
static long initTableIfaceCB ( long iface ) {
static long initTextIfaceCB ( long iface ) {
static long initValueIfaceCB ( long iface ) {
long info = OS . g_malloc ( GTypeInfo . sizeof ) ;
long widget = accessible . getControlHandle ( ) ;
long tooltipOwner , tooltipTag , tooltipUserData ;
Shell ( Display display , Shell parent , int style , long handle , boolean embedded ) {
public static Shell internal_new ( Display display , long handle ) {
public static Shell cocoa_new ( Display display , long handle ) {
boolean accessibilityIsIgnored ( long id , long sel ) {
long embeddedSubclass = display . createWindowSubclass ( newHostWindowClass , "str" , true ) ;
void becomeKeyWindow ( long id , long sel ) {
boolean canBecomeKeyWindow ( long id , long sel ) {
long styleMask = window . styleMask ( ) ;
void clearDeferFlushing ( long id , long sel ) {
double h = rect . height ;
double width = screenFrame . width * 5 / 8 , height = screenFrame . height * 5 / 8 ; ;
void drawBackground ( long id , NSGraphicsContext context , NSRect rect ) {
double y = display . getPrimaryFrame ( ) . height - ( int ) ( frame . y + frame . height ) ;
double scaleFactor = view . window ( ) . userSpaceScaleFactor ( ) ;
double scaleFactor = window . userSpaceScaleFactor ( ) ;
double y = display . getPrimaryFrame ( ) . height - ( int ) ( frame . y + frame . height ) ;
double scaleFactor = view . window ( ) . userSpaceScaleFactor ( ) ;
double scaleFactor = view . window ( ) . userSpaceScaleFactor ( ) ;
double scaleFactor = view . window ( ) . userSpaceScaleFactor ( ) ;
void helpRequested ( long id , long sel , long theEvent ) {
boolean makeFirstResponder ( long id , long sel , long responder ) {
void mouseMoved ( long id , long sel , long theEvent ) {
void noResponderFor ( long id , long sel , long selector ) {
long [ ] value = new long [ 1 ] ;
double scaleFactor = window . userSpaceScaleFactor ( ) ;
double menuBarHt = NSStatusBar . systemStatusBar ( ) . thickness ( ) ;
double scaleFactor = window . userSpaceScaleFactor ( ) ;
long view_stringForToolTip_point_userData ( long id , long sel , long view , long tag , long point , long userData ) {
void viewWillMoveToWindow ( long id , long sel , long newWindow ) {
long currentWindow = hostWindow ! = null ? hostWindow . id : 0 ;
void windowDidBecomeKey ( long id , long sel , long notification ) {
void windowDidDeminiturize ( long id , long sel , long notification ) {
void windowDidMiniturize ( long id , long sel , long notification ) {
void windowDidMove ( long id , long sel , long notification ) {
void windowDidResize ( long id , long sel , long notification ) {
double scaleFactor = window . userSpaceScaleFactor ( ) ;
void windowDidResignKey ( long id , long sel , long notification ) {
void windowSendEvent ( long id , long sel , long event ) {
boolean windowShouldClose ( long id , long sel , long window ) {
void windowWillClose ( long id , long sel , long notification ) {
public NSMutableAttributedString ( long id ) {
public void setBaseWritingDirection ( long writingDirection , NSRange range ) {
long result = OS . objc_msgSend ( this . id , OS . sel_mutableString ) ;
long result = OS . objc_msgSend ( OS . class_NSMutableAttributedString , OS . sel_attributedStringWithAttachment_ , attachment ! = null ? attachment . id : 0 ) ;
long hwndCB = menuBar . hwndCB ;
long callWindowProc ( long hwnd , int msg , long wParam , long lParam ) {
Menu findMenu ( long hMenu ) {
long hwndCB = menuBar . hwndCB ;
long hSmallIcon = 0 , hLargeIcon = 0 ;
long hMenu = menuBar ! = null ? menuBar . handle : 0 ;
long hwndParent = parent . handle ;
long hMenu = OS . GetSystemMenu ( handle , false ) ;
long hHeap = OS . GetProcessHeap ( ) ;
long pszText = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount ) ;
long hwndCB = menuBar . hwndCB ;
long hwndMDIClient = shell . hwndMDIClient ;
long widgetParent ( ) {
long windowProc ( long hwnd , int msg , long wParam , long lParam ) {
LRESULT WM_ACTIVATE ( long wParam , long lParam ) {
LRESULT WM_CLOSE ( long wParam , long lParam ) {
LRESULT WM_HOTKEY ( long wParam , long lParam ) {
LRESULT WM_KILLFOCUS ( long wParam , long lParam ) {
LRESULT WM_MOVE ( long wParam , long lParam ) {
LRESULT WM_NCACTIVATE ( long wParam , long lParam ) {
long hwndShell = getShell ( ) . handle ;
LRESULT WM_QUERYOPEN ( long wParam , long lParam ) {
LRESULT WM_SETFOCUS ( long wParam , long lParam ) {
LRESULT WM_SIZE ( long wParam , long lParam ) {
LRESULT WM_SYSCOMMAND ( long wParam , long lParam ) {
LRESULT WM_WINDOWPOSCHANGING ( long wParam , long lParam ) {
long CCHookProc ( long hdlg , long uiMsg , long lParam , long lpData ) {
long lpfnHook = callback . getAddress ( ) ;
long hHeap = OS . GetProcessHeap ( ) ;
public NSColor ( long id ) {
long result = OS . objc_msgSend ( OS . class_NSColor , OS . sel_alternateSelectedControlColor ) ;
long result = OS . objc_msgSend ( OS . class_NSColor , OS . sel_alternateSelectedControlTextColor ) ;
long result = OS . objc_msgSend ( OS . class_NSColor , OS . sel_blackColor ) ;
long result = OS . objc_msgSend ( OS . class_NSColor , OS . sel_clearColor ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_colorSpace ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_colorUsingColorSpaceName_ , colorSpace ! = null ? colorSpace . id : 0 ) ;
long result = OS . objc_msgSend ( OS . class_NSColor , OS . sel_colorWithPatternImage_ , image ! = null ? image . id : 0 ) ;
long result = OS . objc_msgSend ( OS . class_NSColor , OS . sel_controlBackgroundColor ) ;
long result = OS . objc_msgSend ( OS . class_NSColor , OS . sel_controlDarkShadowColor ) ;
long result = OS . objc_msgSend ( OS . class_NSColor , OS . sel_controlHighlightColor ) ;
long result = OS . objc_msgSend ( OS . class_NSColor , OS . sel_controlLightHighlightColor ) ;
long result = OS . objc_msgSend ( OS . class_NSColor , OS . sel_controlShadowColor ) ;
long result = OS . objc_msgSend ( OS . class_NSColor , OS . sel_controlTextColor ) ;
long result = OS . objc_msgSend ( OS . class_NSColor , OS . sel_disabledControlTextColor ) ;
public void getComponents ( double [ ] components ) {
public long numberOfComponents ( ) {
long result = OS . objc_msgSend ( OS . class_NSColor , OS . sel_secondarySelectedControlColor ) ;
long result = OS . objc_msgSend ( OS . class_NSColor , OS . sel_selectedControlColor ) ;
long result = OS . objc_msgSend ( OS . class_NSColor , OS . sel_selectedControlTextColor ) ;
long result = OS . objc_msgSend ( OS . class_NSColor , OS . sel_selectedTextBackgroundColor ) ;
long result = OS . objc_msgSend ( OS . class_NSColor , OS . sel_selectedTextColor ) ;
long result = OS . objc_msgSend ( OS . class_NSColor , OS . sel_textBackgroundColor ) ;
long result = OS . objc_msgSend ( OS . class_NSColor , OS . sel_textColor ) ;
long result = OS . objc_msgSend ( OS . class_NSColor , OS . sel_windowBackgroundColor ) ;
long result = OS . objc_msgSend ( OS . class_NSColor , OS . sel_windowFrameColor ) ;
long result = OS . objc_msgSend ( OS . class_NSColor , OS . sel_windowFrameTextColor ) ;
static final long ReBarProc ;
long callWindowProc ( long hwnd , int msg , long wParam , long lParam ) {
long hFont = OS . GetStockObject ( OS . SYSTEM_FONT ) ;
void drawThemeBackground ( long hDC , long hwnd , RECT rect ) {
long windowProc ( ) {
LRESULT WM_COMMAND ( long wParam , long lParam ) {
LRESULT WM_ERASEBKGND ( long wParam , long lParam ) {
LRESULT WM_NOTIFY ( long wParam , long lParam ) {
LRESULT WM_SETREDRAW ( long wParam , long lParam ) {
long code = callWindowProc ( handle , OS . WM_SETREDRAW , wParam , lParam ) ;
LRESULT WM_SIZE ( long wParam , long lParam ) {
long code = callWindowProc ( handle , OS . WM_SIZE , wParam , lParam ) ;
LRESULT wmNotifyChild ( NMHDR hdr , long wParam , long lParam ) {
public long itemData ;
public long hwndTarget ;
long hTheme = OS . OpenThemeData ( 0 , getClassId ( ) ) ;
long hTheme = OS . OpenThemeData ( 0 , getClassId ( ) ) ;
public nsIPrefLocalizedString ( long address ) {
public int GetData ( long [ ] aData ) {
public int ToString ( long [ ] _retval ) {
long window = parent . paintWindow ( ) ;
long cairo = OS . gdk_cairo_create ( window ) ;
long surface = Cairo . cairo_get_target ( cairo ) ;
long gc = OS . gdk_gc_new ( window ) ;
long colormap = OS . gdk_colormap_get_system ( ) ;
long hTheme = OS . OpenThemeData ( 0 , getClassId ( ) ) ;
public NSIndexSet ( long id ) {
public boolean containsIndex ( long value ) {
public long count ( ) {
public long firstIndex ( ) {
public long getIndexes ( long [ ] indexBuffer , long bufferSize , long range ) {
long result = OS . objc_msgSend ( this . id , OS . sel_initWithIndexSet_ , indexSet ! = null ? indexSet . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_initWithIndexesInRange_ , range ) ;
static final boolean IS_64 = longConst ( ) = = ( long ) longConst ( ) ;
static long HeaderProc ;
static final long TableProc ;
long callWindowProc ( long hwnd , int msg , long wParam , long lParam ) {
long callWindowProc ( long hwnd , int msg , long wParam , long lParam , boolean forceSelect ) {
long hwndParent = OS . GetParent ( handle ) , hwndOwner = 0 ;
long code = 0 ;
long hDC = OS . BeginPaint ( hwnd , ps ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
LRESULT CDDS_ITEMPREPAINT ( NMLVCUSTOMDRAW nmcd , long wParam , long lParam ) {
long hrgn = OS . CreateRectRgn ( 0 , 0 , 0 , 0 ) ;
LRESULT CDDS_POSTPAINT ( NMLVCUSTOMDRAW nmcd , long wParam , long lParam ) {
long hwndToolTip = OS . SendMessage ( handle , OS . LVM_SETTOOLTIPS , 0 , 0 ) ;
long rgn = OS . CreateRectRgn ( 0 , 0 , 0 , 0 ) ;
LRESULT CDDS_PREPAINT ( NMLVCUSTOMDRAW nmcd , long wParam , long lParam ) {
long hwndToolTip = OS . SendMessage ( handle , OS . LVM_SETTOOLTIPS , 0 , 0 ) ;
long rgn = OS . CreateRectRgn ( 0 , 0 , 0 , 0 ) ;
long hDC = nmcd . hdc ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
LRESULT CDDS_SUBITEMPOSTPAINT ( NMLVCUSTOMDRAW nmcd , long wParam , long lParam ) {
long hDC = nmcd . hdc ;
long rgn = 0 ;
long hFont = item . fontHandle ( nmcd . iSubItem ) ;
long result = OS . SendMessage ( handle , OS . LVM_GETITEM , 0 , lvItem ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long rgn = 0 ;
boolean checkHandle ( long hwnd ) {
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long result = OS . SendMessage ( handle , OS . LVM_APPROXIMATEVIEWRECT , - 1 , OS . MAKELPARAM ( bits , 0xFFFF ) ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long hFont = OS . GetStockObject ( OS . SYSTEM_FONT ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long hwndTooltop = OS . SendMessage ( handle , OS . LVM_GETTOOLTIPS , 0 , 0 ) ;
long hHeap = OS . GetProcessHeap ( ) ;
long pszText = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long hHeap = OS . GetProcessHeap ( ) ;
long pszText = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long code = OS . SendMessage ( handle , OS . LVM_DELETEITEM , index , 0 ) ;
long hImageList = OS . SendMessage ( handle , OS . LVM_GETIMAGELIST , OS . LVSIL_SMALL , 0 ) ;
long hStateList = OS . SendMessage ( handle , OS . LVM_GETIMAGELIST , OS . LVSIL_STATE , 0 ) ;
long hStateList = OS . SendMessage ( handle , OS . LVM_GETIMAGELIST , OS . LVSIL_STATE , 0 ) ;
long hOldList = OS . SendMessage ( handle , OS . LVM_GETIMAGELIST , OS . LVSIL_SMALL , 0 ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long hImageList = OS . ImageList_Create ( 1 , height , 0 , 0 , 0 ) ;
long hHeaderImageList = headerImageList . getHandle ( ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long code = OS . SendMessage ( handle , OS . LVM_GETITEMRECT , 0 , rect ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long hFont = item . fontHandle ( 0 ) ;
long hImageList = imageList . getHandle ( ) ;
long result = OS . SendMessage ( handle , OS . LVM_GETITEM , 0 , lvItem ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long hStateList = OS . SendMessage ( handle , OS . LVM_GETIMAGELIST , OS . LVSIL_STATE , 0 ) ;
long code = OS . SendMessage ( handle , OS . LVM_DELETEITEM , index , 0 ) ;
long code = OS . SendMessage ( handle , OS . LVM_DELETEITEM , index , 0 ) ;
long code = OS . SendMessage ( handle , OS . LVM_DELETEITEM , start , 0 ) ;
long code = OS . SendMessage ( handle , OS . LVM_DELETEITEM , index , 0 ) ;
long code = OS . SendMessage ( handle , OS . LVM_DELETEALLITEMS , 0 , 0 ) ;
long result = OS . SendMessage ( handle , OS . LVM_GETITEM , 0 , lvItem ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long hTheme = OS . OpenThemeData ( handle , Display . LISTVIEW ) ;
Event sendMeasureItemEvent ( TableItem item , int row , int column , long hDC ) {
long result = OS . SendMessage ( handle , OS . LVM_GETITEM , 0 , lvItem ) ;
LRESULT sendMouseDownEvent ( int type , int button , int msg , long wParam , long lParam ) {
long code = OS . SendMessage ( handle , OS . LVM_GETITEMRECT , 0 , rect ) ;
long code = callWindowProc ( handle , msg , wParam , lParam , forceSelect ) ;
long hDC = nmcd . hdc ;
long result = OS . SendMessage ( handle , OS . LVM_GETITEM , 0 , lvItem ) ;
void setBackgroundImage ( long hBitmap ) {
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long hDC = OS . GetDC ( handle ) ;
long hBrush = OS . CreateSolidBrush ( clrBackground ) ;
long oldFont = OS . SelectObject ( hDC , defaultFont ( ) ) ;
long hTheme = display . hButtonTheme ( ) ;
long hOldStateList = OS . SendMessage ( handle , OS . LVM_GETIMAGELIST , OS . LVSIL_STATE , 0 ) ;
long hImageList = OS . SendMessage ( handle , OS . LVM_GETIMAGELIST , OS . LVSIL_SMALL , 0 ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long code = OS . SendMessage ( handle , OS . LVM_DELETEITEM , count , 0 ) ;
long hFont = OS . SendMessage ( handle , OS . WM_GETFONT , 0 , 0 ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long hFont = - 1 ;
long hStateList = OS . SendMessage ( handle , OS . LVM_GETIMAGELIST , OS . LVSIL_STATE , 0 ) ;
long hImageList = OS . SendMessage ( handle , OS . LVM_GETIMAGELIST , OS . LVSIL_SMALL , 0 ) ;
long hImageList = OS . ImageList_Create ( 1 , 1 , 0 , 0 , 0 ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long hwndToolTip = OS . SendMessage ( handle , OS . LVM_GETTOOLTIPS , 0 , 0 ) ;
long hwndToolTip = OS . SendMessage ( handle , OS . LVM_GETTOOLTIPS , 0 , 0 ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long hImageList = imageList . getHandle ( ) ;
long hHeaderImageList = headerImageList . getHandle ( ) ;
long windowProc ( ) {
long windowProc ( long hwnd , int msg , long wParam , long lParam ) {
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long hRgn = OS . CreateRectRgn ( rect . left , rect . top , rect . right , rect . bottom ) ;
long rectRgn = OS . CreateRectRgn ( rect . left , itemRect . top , rect . right , itemRect . bottom ) ;
long oldMemBitmap = OS . SelectObject ( memHdc , memDib ) ;
LRESULT WM_CHAR ( long wParam , long lParam ) {
long code = callWindowProc ( handle , OS . WM_KEYDOWN , wParam , lParam ) ;
LRESULT WM_CONTEXTMENU ( long wParam , long lParam ) {
LRESULT WM_ERASEBKGND ( long wParam , long lParam ) {
LRESULT WM_GETOBJECT ( long wParam , long lParam ) {
LRESULT WM_KEYDOWN ( long wParam , long lParam ) {
long code = callWindowProc ( handle , OS . WM_KEYDOWN , wParam , lParam ) ;
LRESULT WM_KILLFOCUS ( long wParam , long lParam ) {
LRESULT WM_LBUTTONDBLCLK ( long wParam , long lParam ) {
LRESULT WM_LBUTTONDOWN ( long wParam , long lParam ) {
LRESULT WM_MOUSEHOVER ( long wParam , long lParam ) {
LRESULT WM_PAINT ( long wParam , long lParam ) {
long paintDC = 0 ;
long hDC = OS . CreateCompatibleDC ( paintDC ) ;
LRESULT WM_RBUTTONDBLCLK ( long wParam , long lParam ) {
LRESULT WM_RBUTTONDOWN ( long wParam , long lParam ) {
LRESULT WM_SETFOCUS ( long wParam , long lParam ) {
LRESULT WM_SETFONT ( long wParam , long lParam ) {
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
LRESULT WM_SETREDRAW ( long wParam , long lParam ) {
long code = callWindowProc ( handle , OS . WM_SETREDRAW , wParam , lParam ) ;
LRESULT WM_SIZE ( long wParam , long lParam ) {
LRESULT WM_SYSCOLORCHANGE ( long wParam , long lParam ) {
LRESULT WM_HSCROLL ( long wParam , long lParam ) {
LRESULT WM_VSCROLL ( long wParam , long lParam ) {
LRESULT wmMeasureChild ( long wParam , long lParam ) {
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
LRESULT wmNotifyChild ( NMHDR hdr , long wParam , long lParam ) {
long code = OS . SendMessage ( handle , OS . LVM_GETITEMRECT , plvfi . iItem , rect ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
long hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
LRESULT wmNotifyHeader ( NMHDR hdr , long wParam , long lParam ) {
LRESULT wmNotifyToolTip ( NMHDR hdr , long wParam , long lParam ) {
long code = callWindowProc ( handle , OS . WM_NOTIFY , wParam , lParam ) ;
long hFont = item . fontHandle ( pinfo . iSubItem ) ;
long hwndToolTip = OS . SendMessage ( handle , OS . LVM_GETTOOLTIPS , 0 , 0 ) ;
LRESULT wmNotifyToolTip ( NMTTCUSTOMDRAW nmcd , long lParam ) {
long oldFont = OS . SelectObject ( hDC , hFont ) ;
public long hwndOwner ;
public long pidlRoot ;
public long pszDisplayName ;
public long lpszTitle ;
private long [ ] oleEventSinkIUnknown = new long [ 0 ] ;
long licinfo = getLicenseInfo ( appClsid ) ;
long [ ] address = new long [ 1 ] ;
long clientSite = isICAClient ( ) ? 0 : iOleClientSite . getAddress ( ) ;
long [ ] ppvObject = new long [ 1 ] ;
ppvObject = new long [ 1 ] ;
ppvObject = new long [ 1 ] ;
long [ ] ppvObject = new long [ 1 ] ;
long [ ] ppTypeAttr = new long [ 1 ] ;
ppTypeAttr = new long [ 1 ] ;
long address = automation . getAddress ( ) ;
long address = automation . getAddress ( ) ;
void addEventListener ( long iunknown , GUID guid , int eventID , OleListener listener ) {
long [ ] newOleEventSinkIUnknown = new long [ oldLength + 1 ] ;
long [ ] ppvObject = new long [ 1 ] ;
public long method8 ( long [ ] args ) { return OnFocus ( ( int ) args [ 0 ] ) ; }
public long method6 ( long [ ] args ) { return Invoke ( ( int ) args [ 0 ] , args [ 1 ] , ( int ) args [ 2 ] , ( int ) args [ 3 ] , args [ 4 ] , args [ 5 ] , args [ 6 ] , args [ 7 ] ) ; }
oleEventSinkIUnknown = new long [ 0 ] ;
long result = 0 ;
long [ ] pBstrKey = new long [ 1 ] ;
protected int GetWindow ( long phwnd ) {
COM . MoveMemory ( phwnd , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( phwnd , new long [ ] { handle } , OS . PTR_SIZEOF ) ;
private int Invoke ( int dispIdMember , long riid , int lcid , int dwFlags , long pDispParams , long pVarResult , long pExcepInfo , long pArgErr ) {
if ( pExcepInfo ! = 0 ) COM . MoveMemory ( pExcepInfo , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
long [ ] ppvObject = new long [ 1 ] ;
long [ ] phwnd = new long [ 1 ] ;
protected int QueryInterface ( long riid , long ppvObject ) {
COM . MoveMemory ( ppvObject , new long [ ] { iOleControlSite . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { iDispatch . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
long address = automation . getAddress ( ) ;
void removeEventListener ( long iunknown , GUID guid , int eventID , OleListener listener ) {
oleEventSinkIUnknown = new long [ 0 ] ;
long [ ] newOleEventSinkIUnknown = new long [ oldLength - 1 ] ;
public nsIDocShell ( long address ) {
public int LoadURI ( long uri , long loadInfo , int aLoadFlags , int firstParty ) {
public int LoadStream ( long aStream , long aURI , long aContentType , long aContentCharset , long aLoadInfo ) {
public int InternalLoad ( long aURI , long aReferrer , long aOwner , int aInheritOwner , char [ ] aWindowTarget , long aPostDataStream , long aHeadersStream , int aLoadFlags , long aSHEntry , int firstParty , long [ ] aDocShell , long [ ] aRequest ) {
public int CreateLoadInfo ( long [ ] loadInfo ) {
public int SetCurrentURI ( long aURI ) {
public int GetPresContext ( long [ ] aPresContext ) {
public int GetPresShell ( long [ ] aPresShell ) {
public int GetEldestPresShell ( long [ ] aEldestPresShell ) {
public int GetContentViewer ( long [ ] aContentViewer ) {
public int GetChromeEventHandler ( long [ ] aChromeEventHandler ) {
public int SetChromeEventHandler ( long aChromeEventHandler ) {
public int GetParentURIContentListener ( long [ ] aParentURIContentListener ) {
public int SetParentURIContentListener ( long aParentURIContentListener ) {
public int GetDocumentCharsetInfo ( long [ ] aDocumentCharsetInfo ) {
public int SetDocumentCharsetInfo ( long aDocumentCharsetInfo ) {
public int GetDocShellEnumerator ( int aItemType , int aDirection , long [ ] _retval ) {
public int GetLayoutHistoryState ( long [ ] aLayoutHistoryState ) {
public int SetLayoutHistoryState ( long aLayoutHistoryState ) {
long accelGroup , vboxHandle ;
long pixbufs = 0 ;
long pixbuf = ImageList . createPixbuf ( image ) ;
long shellHandle = topHandle ( ) ;
long shellHandle = topHandle ( ) ;
long buttonHandle = 0 ;
long shellHandle = _getShell ( ) . topHandle ( ) ;
long id = OS . gtk_plug_get_id ( handle ) ;
long screen = OS . gdk_screen_get_default ( ) ;
long clientEvent = OS . g_malloc ( XClientMessageEvent . sizeof ) ;
long gtk_activate ( long widget ) {
long nextEvent = OS . gdk_event_peek ( ) ;
long currEvent = OS . gtk_get_current_event ( ) ;
long gtk_button_press_event ( long widget , long eventPtr ) {
long gtk_size_allocate ( long widget , long allocation ) {
long gdkImagePtr = OS . gdk_drawable_get_image ( image . mask , 0 , 0 , b . width , b . height ) ;
long window = gtk_widget_get_window ( handle ) ;
long gtk_status_icon_popup_menu ( long widget , long button , long activate_time ) {
long pixbuf = imageList . getPixbuf ( imageIndex ) ;
public NSKeyedArchiver ( long id ) {
long result = OS . objc_msgSend ( OS . class_NSKeyedArchiver , OS . sel_archivedDataWithRootObject_ , rootObject ! = null ? rootObject . id : 0 ) ;
static long modTime ;
static long cdeShell ;
long gnome = OS . XInternAtom ( xDisplay , gnomeName , true ) ;
long libgio = OS . dlopen ( buffer , flags ) ;
long g_app_info_launch_default_for_uri = OS . dlsym ( libgio , buffer ) ;
long icon_theme = GNOME . gnome_icon_theme_new ( ) ;
long libgnomevfs = OS . dlopen ( buffer , OS . RTLD_LAZY ) ;
long gnome_vfs_url_show = OS . dlsym ( libgnomevfs , buffer ) ;
long cde = OS . XInternAtom ( xDisplay , cdeName , true ) ;
long ptr = OS . g_malloc ( fileArg . length ) ;
long attrValue = CDE . DtDtsDataTypeToAttributeValue ( dataTypeBuf , attrNameBuf , optNameBuf ) ;
long dataTypeList = CDE . DtDtsDataTypeNames ( ) ;
long [ ] dataType = new long [ 1 ] ;
long [ ] argc = new long [ ] { 0 } ;
long widgetClass = CDE . topLevelShellWidgetClass ( ) ;
long ptr = GNOME . gnome_vfs_mime_get_default_application ( mimeTypeBuffer ) ;
long uri = GNOME . gnome_vfs_make_uri_from_input_with_dirs ( fileNameBuffer , GNOME . GNOME_VFS_MAKE_URI_DIR_CURRENT ) ;
long uri = GNOME . gnome_vfs_make_uri_from_input ( fileNameBuffer ) ;
long mimePtr = mimeData [ 0 ] ;
long extensionList = GNOME . gnome_vfs_mime_get_extensions_list ( mimePtr ) ;
long extensionElement = extensionList ;
long extensionPtr = extensionData [ 0 ] ;
long typeName = GNOME . gnome_vfs_mime_type_from_name ( extensionBuffer ) ;
long ptr = GNOME . gnome_vfs_mime_get_default_application ( mimeTypeBuffer ) ;
long icon_name = GNOME . gnome_icon_lookup ( gnomeIconTheme . value , 0 , null , buffer , 0 , mimeTypeBuffer ,
long path = 0 ;
long icon_theme = OS . gtk_icon_theme_get_default ( ) ;
long gicon = OS . g_icon_new_for_string ( icon , null ) ;
long gicon_info = OS . gtk_icon_theme_lookup_by_gicon ( icon_theme , gicon , 16 , 0 ) ;
long pixbuf = OS . gtk_icon_info_load_icon ( gicon_info , null ) ;
long pixels = OS . gdk_pixbuf_get_pixels ( pixbuf ) ;
long mimeDatabase = 0 , fileInfo = 0 ;
long fileInputStream = OS . g_file_read ( mimeDatabase , 0 , 0 ) ;
long [ ] modTimestamp = new long [ 2 ] ;
long reader = OS . g_data_input_stream_new ( fileInputStream ) ;
long linePtr = OS . g_data_input_stream_read_line ( reader , length , 0 , 0 ) ;
long application = OS . g_app_info_get_default_for_type ( mimeTypeBuffer , false ) ;
static Program gio_getProgram ( Display display , long application ) {
long applicationName = OS . g_app_info_get_name ( application ) ;
long applicationCommand = OS . g_app_info_get_executable ( application ) ;
long icon = OS . g_app_info_get_icon ( application ) ;
long icon_name = OS . g_icon_to_string ( icon ) ;
long application = OS . g_list_data ( list ) ;
long file = OS . g_file_new_for_path ( fileNameBuffer ) ;
long fileInfo = OS . g_file_query_info ( file , buffer , 0 , 0 , 0 ) ;
long contentType = OS . g_file_info_get_content_type ( fileInfo ) ;
long file = OS . g_file_new_for_commandline_arg ( fileNameBuffer ) ;
long uri = OS . g_file_get_uri ( file ) ;
long application = OS . g_app_info_create_from_commandline ( commandBuffer , nameBuffer , gnomeExpectUri
long file = 0 ;
long list = 0 ;
public NSData ( long id ) {
public long bytes ( ) {
public void getBytes ( long buffer , long length ) {
public long length ( ) {
public long hdc ;
public long dwItemSpec ;
public long lItemlParam ;
double [ ] foreground , background ;
boolean acceptsFirstMouse ( long id , long sel , long theEvent ) {
long accessibilityActionDescription ( long id , long sel , long arg0 ) {
long accessibilityAttributeNames ( long id , long sel ) {
long returnValue = 0 ;
boolean handleIsAccessible ( long id ) {
long accessibilityParameterizedAttributeNames ( long id , long sel ) {
void accessibilityPerformAction ( long id , long sel , long arg0 ) {
long accessibilityFocusedUIElement ( long id , long sel ) {
long accessibilityHitTest ( long id , long sel , NSPoint point ) {
long accessibilityAttributeValue ( long id , long sel , long arg0 ) {
long returnValue = 0 ;
long accessibilityAttributeValue_forParameter ( long id , long sel , long arg0 , long arg1 ) {
boolean accessibilityIsAttributeSettable ( long id , long sel , long arg0 ) {
void accessibilitySetValue_forAttribute ( long id , long sel , long arg0 , long arg1 ) {
boolean becomeFirstResponder ( long id , long sel ) {
void beginGestureWithEvent ( long id , long sel , long event ) {
void endGestureWithEvent ( long id , long sel , long event ) {
long childRgn = OS . NewRgn ( ) ;
long count = subviews . count ( ) ;
void cancelOperation ( long id , long sel , long sender ) {
NSAttributedString createString ( String string , Font font , double [ ] foreground , int alignment , boolean wrap , boolean enabled , boolean mnemonics ) {
void doCommandBySelector ( long id , long sel , long selector ) {
long modifiers = nsEvent . modifierFlags ( ) ;
void drawWidget ( long id , NSGraphicsContext context , NSRect rect ) {
boolean equals ( double [ ] color1 , double [ ] color2 ) {
void flagsChanged ( long id , long sel , long theEvent ) {
long modifiers = nsEvent . modifierFlags ( ) ;
boolean gestureEvent ( long id , long eventPtr , int detail ) {
NSBezierPath getPath ( long region ) {
long getVisibleRegion ( ) {
long result = OS . NewRgn ( ) ;
long hitTest ( long id , long sel , NSPoint point ) {
boolean insertText ( long id , long sel , long string ) {
long type = nsEvent . type ( ) ;
public long internal_new_GC ( GCData data ) {
long context = 0 ;
double alpha = window . alphaValue ( ) ;
public void internal_dispose_GC ( long hDC , GCData data ) {
long context = hDC ;
long visibleRgn = getVisibleRegion ( ) , boundsRgn = OS . NewRgn ( ) ;
void keyDown ( long id , long sel , long theEvent ) {
boolean hasKeyboardFocus ( long inId ) {
void keyUp ( long id , long sel , long theEvent ) {
void magnifyWithEvent ( long id , long sel , long event ) {
long menuForEvent ( long id , long sel , long theEvent ) {
void scrollWheel ( long id , long sel , long theEvent ) {
boolean isEventView ( long id ) {
boolean mouseEvent ( long id , long sel , long theEvent , int type ) {
void mouseDown ( long id , long sel , long theEvent ) {
void mouseUp ( long id , long sel , long theEvent ) {
void mouseDragged ( long id , long sel , long theEvent ) {
void rightMouseDown ( long id , long sel , long theEvent ) {
void rightMouseUp ( long id , long sel , long theEvent ) {
void rightMouseDragged ( long id , long sel , long theEvent ) {
void otherMouseDown ( long id , long sel , long theEvent ) {
void otherMouseUp ( long id , long sel , long theEvent ) {
void otherMouseDragged ( long id , long sel , long theEvent ) {
long regionToRects ( long message , long rgn , long r , long path ) {
long visibleRgn = 0 ;
void rotateWithEvent ( long id , long sel , long event ) {
double delta = nsEvent . deltaY ( ) ;
double delta = nsEvent . deltaX ( ) ;
long osPhase = touch . phase ( ) ;
double [ ] color = control . background ! = null ? control . background : control . defaultBackground ( ) . handle ;
double [ ] background = color ! = null ? color . handle : null ;
double [ ] foreground = color ! = null ? color . handle : null ;
void setForeground ( double [ ] color ) {
void setFrameOrigin ( long id , long sel , NSPoint point ) {
void setFrameSize ( long id , long sel , NSSize size ) {
boolean shouldDelayWindowOrderingForEvent ( long id , long sel , long theEvent ) {
void swipeWithEvent ( long id , long sel , long event ) {
boolean touchEvent ( long id , long sel , long eventPtr ) {
long touchCount = allTouchesSet . count ( ) ;
for ( long j = currentTouches . count ( ) - 1 ; j > = 0 ; j - - ) {
void touchesBeganWithEvent ( long id , long sel , long event ) {
void touchesCancelledWithEvent ( long id , long sel , long event ) {
void touchesEndedWithEvent ( long id , long sel , long event ) {
void touchesMovedWithEvent ( long id , long sel , long event ) {
long modifiers = theEvent . modifierFlags ( ) ;
long modifiers = theEvent . modifierFlags ( ) ;
double [ ] color = control . background ! = null ? control . background : control . defaultBackground ( ) . handle ;
void resetCursorRects ( long id , long sel ) {
void updateTrackingAreas ( long id , long sel ) {
void drawBackground ( long id , NSGraphicsContext context , NSRect rect ) {
void setForeground ( double [ ] color ) {
long hDC = OS . GetDC ( 0 ) ;
long copyBitmap ( long hImage , int width , int height ) {
long hdc2 = OS . CreateCompatibleDC ( hDC ) ;
long [ ] pBits = new long [ 1 ] ;
long copyIcon ( long hImage , int width , int height ) {
long hIcon = OS . CopyImage ( hImage , OS . IMAGE_ICON , width , height , 0 ) ;
long copyWithAlpha ( long hBitmap , int background , byte [ ] alphaData , int destWidth , int destHeight ) {
long oldMemBitmap = OS . SelectObject ( memHdc , memDib ) ;
long createMaskFromAlpha ( ImageData data , int destWidth , int destHeight ) {
long hMask = OS . CreateBitmap ( srcWidth , srcHeight , 1 , 1 , mask . data ) ;
long createMask ( long hBitmap , int destWidth , int destHeight , int background , int transparentPixel ) {
long hdc2 = OS . CreateCompatibleDC ( hDC ) ;
long hOldBitmap = OS . SelectObject ( hdc1 , hMask ) ;
public long getHandle ( ) {
long hImage = image . handle ;
long hBitmap = 0 , hMask = 0 ;
long hIcon = copyIcon ( hImage , cx [ 0 ] , cy [ 0 ] ) ;
public NSProgressIndicator ( long id ) {
public long controlSize ( ) {
public void setControlSize ( long size ) {
long handle = table . handle ;
long handle = table . handle ;
public NSDirectoryEnumerator ( long id ) {
public IWebDocumentRepresentation ( long address ) {
public int documentSource ( long [ ] source ) {
long actionSearch , actionCancel ;
boolean becomeFirstResponder ( long id , long sel ) {
long nsSecureTextViewClass = OS . objc_lookUpClass ( "str" ) ;
long editorClass = OS . objc_getClass ( "str" ) ;
void drawBackground ( long id , NSGraphicsContext context , NSRect rect ) {
long position = getPosition ( x , y ) ;
boolean acceptsFirstResponder ( long id , long sel ) {
long length = string . length ( ) , c ;
long getPosition ( long x , long y ) {
boolean isEventView ( long id ) {
long modifierFlags = nsEvent . modifierFlags ( ) ;
void setFrameSize ( long id , long sel , NSSize size ) {
void setForeground ( double [ ] color ) {
double alpha = 1 ;
double size = textExtent ( "str" ) . width * tabs ;
boolean shouldChangeTextInRange_replacementString ( long id , long sel , long affectedCharRange , long replacementString ) {
long type = currentEvent . type ( ) ;
void textViewDidChangeSelection ( long id , long sel , long aNotification ) {
void textDidChange ( long id , long sel , long aNotification ) {
NSRange textView_willChangeSelectionFromCharacterRange_toCharacterRange ( long id , long sel , long aTextView , long oldSelectedCharRange , long newSelectedCharRange ) {
long modifiers = theEvent . modifierFlags ( ) ;
public long hwndOwner ;
public long hDC ;
public long lpLogFont ;
public long lCustData ;
public long lpfnHook ;
public long lpTemplateName ;
public long hInstance ;
public long lpszStyle ;
long [ ] ppv = new long [ 1 ] ;
public long method5 ( long [ ] args ) { return QueryGetData ( args [ 0 ] ) ; }
public long method8 ( long [ ] args ) { return EnumFormatEtc ( ( int ) args [ 0 ] , args [ 1 ] ) ; }
private int EnumFormatEtc ( int dwDirection , long ppenumFormatetc ) {
OS . MoveMemory ( ppenumFormatetc , new long [ ] { enumFORMATETC . getAddress ( ) } , OS . PTR_SIZEOF ) ;
private int GetData ( long pFormatetc , long pmedium ) {
private int QueryGetData ( long pFormatetc ) {
private int QueryInterface ( long riid , long ppvObject ) {
OS . MoveMemory ( ppvObject , new long [ ] { iDataObject . getAddress ( ) } , OS . PTR_SIZEOF ) ;
OS . MoveMemory ( ppvObject , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
long [ ] ppv = new long [ 1 ] ;
long [ ] ppFormatetc = new long [ 1 ] ;
long rgelt = OS . GlobalAlloc ( OS . GMEM_FIXED | OS . GMEM_ZEROINIT , FORMATETC . sizeof ) ;
public long window ;
public long device ;
public long hProcess ;
public long hThread ;
public NSLayoutManager ( long id ) {
public long characterIndexForGlyphAtIndex ( long glyphIndex ) {
public long getGlyphs ( long glyphArray , NSRange glyphRange ) {
public long getGlyphsInRange ( NSRange glyphRange , long glyphBuffer , long charIndexBuffer , long inscribeBuffer , long elasticBuffer , byte [ ] bidiLevelBuffer ) {
public long glyphIndexForCharacterAtIndex ( long charIndex ) {
public long glyphIndexForPoint ( NSPoint point , NSTextContainer container , double [ ] partialFraction ) {
public NSRange glyphRangeForCharacterRange ( NSRange charRange , long actualCharRange ) {
public NSRect lineFragmentUsedRectForGlyphAtIndex ( long glyphIndex , long effectiveGlyphRange ) {
public NSRect lineFragmentUsedRectForGlyphAtIndex ( long glyphIndex , long effectiveGlyphRange , boolean flag ) {
public NSPoint locationForGlyphAtIndex ( long glyphIndex ) {
public long numberOfGlyphs ( ) {
public long rectArrayForCharacterRange ( NSRange charRange , NSRange selCharRange , NSTextContainer container , long [ ] rectCount ) {
public long rectArrayForGlyphRange ( NSRange glyphRange , NSRange selGlyphRange , NSTextContainer container , long [ ] rectCount ) {
long result = OS . objc_msgSend ( this . id , OS . sel_typesetter ) ;
int didReceiveAuthenticationChallenge ( long webView , long identifier , long challenge , long dataSource ) {
long [ ] result = new long [ 1 ] ;
long getAddress ( ) {
int identifierForInitialRequest ( long webView , long request , long dataSource , long identifier ) {
long [ ] frame = new long [ 1 ] ;
long [ ] mainFrame = new long [ 1 ] ;
long ptr = OS . malloc ( 8 ) ;
int QueryInterface ( long riid , long ppvObject ) {
COM . MoveMemory ( ppvObject , new long [ ] { iWebResourceLoadDelegate . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { iWebResourceLoadDelegate . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
int willSendRequest ( long webView , long identifier , long request , long redirectResponse , long dataSource , long newRequest ) {
long [ ] result = new long [ 1 ] ;
long urlString = WebKit . createBSTR ( url ) ;
OS . MoveMemory ( newRequest , new long [ ] { mReq . getAddress ( ) } , C . PTR_SIZEOF ) ;
OS . MoveMemory ( newRequest , new long [ ] { request } , C . PTR_SIZEOF ) ;
public long pbData ;
long fontHandle ( int index ) {
RECT getBounds ( int row , int column , boolean getText , boolean getImage , boolean fullText , boolean fullImage , long hDC ) {
long hwnd = parent . handle ;
long code = OS . SendMessage ( hwnd , OS . LVM_GETITEMRECT , row , rect ) ;
long hFont = fontHandle ( column ) ;
long textDC = hDC ! = 0 ? hDC : OS . GetDC ( hwnd ) , oldFont = - 1 ;
long code = OS . SendMessage ( hwnd , OS . LVM_GETITEMRECT , row , rect ) ;
long code = OS . SendMessage ( hwnd , OS . LVM_GETITEMRECT , row , rect ) ;
long hwndHeader = OS . SendMessage ( hwnd , OS . LVM_GETHEADER , 0 , 0 ) ;
long code = OS . SendMessage ( hwnd , OS . LVM_GETSUBITEMRECT , row , rect ) ;
long hwndHeader = OS . SendMessage ( hwnd , OS . LVM_GETHEADER , 0 , 0 ) ;
long code = OS . SendMessage ( hwnd , OS . LVM_GETSUBITEMRECT , row , rect ) ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
static long DragDataDelete ( long widget , long context ) {
static long DragEnd ( long widget , long context ) {
static long DragGetData ( long widget , long context , long selection_data , long info , long time ) {
static DragSource FindDragSource ( long handle ) {
long context = OS . gtk_drag_begin ( control . handle , targetList , actions , 1 , 0 ) ;
long pixbuf = ImageList . createPixbuf ( image ) ;
void dragEnd ( long widget , long context ) {
void dragGetData ( long widget , long context , long selection_data , int info , int time ) {
void dragDataDelete ( long widget , long context ) {
long pTargets = OS . g_malloc ( targets . length * GtkTargetEntry . sizeof ) ;
public NSScreen ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_deviceDescription ) ;
long result = OS . objc_msgSend ( OS . class_NSScreen , OS . sel_mainScreen ) ;
long result = OS . objc_msgSend ( OS . class_NSScreen , OS . sel_screens ) ;
boolean isEventView ( long id ) {
void scrollClipViewToPoint ( long id , long sel , long clipView , NSPoint point ) {
long pszText = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount ) ;
long hwnd = parent . handle ;
long labelHandle , imageHandle , buttonHandle ;
long gtk_clicked ( long widget ) {
long eventPtr = OS . gtk_get_current_event ( ) ;
long gtk_event_after ( long widget , long gdkEvent ) {
long gtk_mnemonic_activate ( long widget , long arg1 ) {
long gtk_size_allocate ( long widget , long allocation ) {
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
void setFontDescription ( long font ) {
long pixbuf = headerImageList . getPixbuf ( imageIndex ) ;
long window = OS . gtk_widget_get_parent_window ( buttonHandle ) ;
long windowList = OS . gdk_window_get_children ( window ) ;
long child = OS . g_list_data ( windows ) ;
public NSKeyedUnarchiver ( long id ) {
long result = OS . objc_msgSend ( OS . class_NSKeyedUnarchiver , OS . sel_unarchiveObjectWithData_ , data ! = null ? data . id : 0 ) ;
public nsIHelperAppLauncher_1_9 ( long address ) {
public int GetMIMEInfo ( long [ ] aMIMEInfo ) {
public int GetSource ( long [ ] aSource ) {
public int GetSuggestedFileName ( long aSuggestedFileName ) {
public int SaveToDisk ( long aNewFileLocation , int aRememberThisPreference ) {
public int LaunchWithApplication ( long aApplication , int aRememberThisPreference ) {
public int SetWebProgressListener ( long aWebProgressListener ) {
public int GetTargetFile ( long [ ] aTargetFile ) {
public int GetTimeDownloadStarted ( long aTimeDownloadStarted ) {
public NSMutableString ( long id ) {
long result = OS . objc_msgSend ( OS . class_NSMutableString , OS . sel_string ) ;
long result = OS . objc_msgSend ( OS . class_NSMutableString , OS . sel_stringWithFormat_ , format ! = null ? format . id : 0 ) ;
public NSWindow ( long id ) {
public void addChildWindow ( NSWindow childWin , long place ) {
public long collectionBehavior ( ) {
long result = OS . objc_msgSend ( this . id , OS . sel_contentView ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_defaultButtonCell ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_delegate ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_fieldEditor_forObject_ , createFlag , anObject ! = null ? anObject . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_firstResponder ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_graphicsContext ) ;
public long level ( ) {
public void orderWindow ( long place , long otherWin ) {
long result = OS . objc_msgSend ( this . id , OS . sel_parentWindow ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_screen ) ;
public void setAlphaValue ( double windowAlpha ) {
public void setCollectionBehavior ( long behavior ) {
public void setLevel ( long newLevel ) {
public long styleMask ( ) {
long result = OS . objc_msgSend ( this . id , OS . sel_toolbar ) ;
public long windowNumber ( ) {
public static long windowNumberAtPoint ( NSPoint point , long windowNumber ) {
public long windowRef ( ) {
public NSBox ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_contentView ) ;
public void setBorderType ( long aType ) {
public void setBorderWidth ( double borderWidth ) {
public void setBoxType ( long boxType ) {
public void setTitlePosition ( long aPosition ) {
long result = OS . objc_msgSend ( this . id , OS . sel_titleCell ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_titleFont ) ;
long hwnd = parent . handle ;
long lParam = OS . MAKELPARAM ( dropDown ? rect . right - 1 : rect . left , y ) ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hHeap = OS . GetProcessHeap ( ) , pszText = 0 ;
long hFont = OS . SendMessage ( hwnd , OS . WM_GETFONT , 0 , 0 ) ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hFont = OS . SendMessage ( hwnd , OS . WM_GETFONT , 0 , 0 ) ;
LRESULT wmCommandChild ( long wParam , long lParam ) {
public long window ;
long proc = callback . getAddress ( ) ;
long jniRef = 0 ;
long response = panel . runModalForDirectory ( dir , file ) ;
long _overwriteExistingFileCheck ( long id , long sel , long str ) {
long panel_shouldShowFilename ( long id , long sel , long arg0 , long arg1 ) {
long ptr = OS . malloc ( 1 ) ;
void sendSelection ( long id , long sel , long arg ) {
public IOleCommandTarget ( long address ) {
public long unionField ;
public long pUnkForRelease ;
public IFont ( long address ) {
public int get_hFont ( long [ ] phfont ) {
public long window ;
public IDragSourceHelper2 ( long address ) {
public long lpstrSchema ;
public long elemdescVar_tdesc_union ;
public long elemdescVar_paramdesc_pparamdescex ;
public long method0 ( long [ ] args ) {
COM . MoveMemory ( args [ 1 ] , new long [ ] { iDispatch . getAddress ( ) } , OS . PTR_SIZEOF ) ;
protected int QueryInterface ( long riid , long ppvObject ) {
COM . MoveMemory ( ppvObject , new long [ ] { iDocHostUIHandler . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { iDocHostShowUI . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { iServiceProvider . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { iInternetSecurityManager . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { iOleCommandTarget . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
int FilterDataObject ( long pDO , long ppDORet ) {
int GetDropTarget ( long pDropTarget , long ppDropTarget ) {
int GetHostInfo ( long pInfo ) {
int GetOptionKeyPath ( long pchKey , int dw ) {
int ResizeBorder ( long prcBorder , long pUIWindow , int fFrameWindow ) {
int ShowContextMenu ( int dwID , long ppt , long pcmdtReserved , long pdispReserved ) {
int ShowUI ( int dwID , long pActiveObject , long pCommandTarget , long pFrame , long pDoc ) {
int TranslateAccelerator ( long lpMsg , long pguidCmdGroup , int nCmdID ) {
int TranslateUrl ( int dwTranslate , long pchURLIn , long ppchURLOut ) {
int ShowMessage ( long hwnd , long lpstrText , long lpstrCaption , int dwType , long lpstrHelpFile , int dwHelpContext , long plResult ) {
int ShowHelp_64 ( long hwnd , long pszHelpFile , int uCommand , int dwData , long pt , long pDispatchObjectHit ) {
int ShowHelp ( long hwnd , long pszHelpFile , int uCommand , int dwData , int ptMouse_x , int ptMouse_y , long pDispatchObjectHit ) {
int QueryService ( long guidService , long riid , long ppvObject ) {
COM . MoveMemory ( ppvObject , new long [ ] { iInternetSecurityManager . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { iAuthenticate . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
int SetSecuritySite ( long pSite ) {
int GetSecuritySite ( long ppSite ) {
int MapUrlToZone ( long pwszUrl , long pdwZone , int dwFlags ) {
int GetSecurityId ( long pwszUrl , long pbSecurityId , long pcbSecurityId , long dwReserved ) {
int ProcessUrlAction ( long pwszUrl , int dwAction , long pPolicy , int cbPolicy , long pContext , int cbContext , int dwFlags , int dwReserved ) {
int QueryCustomPolicy ( long pwszUrl , long guidKey , long ppPolicy , long pcbPolicy , long pContext , int cbContext , int dwReserved ) {
int SetZoneMapping ( int dwZone , long lpszPattern , int dwFlags ) {
int GetZoneMappings ( int dwZone , long ppenumString , int dwFlags ) {
int QueryStatus ( long pguidCmdGroup , int cCmds , long prgCmds , long pCmdText ) {
int Exec ( long pguidCmdGroup , int nCmdID , int nCmdExecOpt , long pvaIn , long pvaOut ) {
int Authenticate ( long hwnd , long szUsername , long szPassword ) {
long userPtr = COM . CoTaskMemAlloc ( size ) ;
long passwordPtr = COM . CoTaskMemAlloc ( size ) ;
C . memmove ( hwnd , new long [ ] { getShell ( ) . handle } , C . PTR_SIZEOF ) ;
int GetTypeInfoCount ( long pctinfo ) {
int GetTypeInfo ( int iTInfo , int lcid , long ppTInfo ) {
int Invoke ( int dispIdMember , long riid , int lcid , int dwFlags , long pDispParams , long pVarResult , long pExcepInfo , long pArgErr ) {
COM . MoveMemory ( pVarResult , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
COM . MoveMemory ( pVarResult , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
long ptr = dispParams . rgvarg + 2 * Variant . sizeof ;
COM . MoveMemory ( pVarResult , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
COM . MoveMemory ( pVarResult , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
COM . MoveMemory ( pVarResult , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
long [ ] result = new long [ 1 ] ;
long resultPtr = OS . GlobalAlloc ( OS . GMEM_FIXED | OS . GMEM_ZEROINIT , VARIANT . sizeof ) ;
public IWebMutableURLRequest ( long address ) {
public int setURL ( long theUrl ) {
public int setValue ( long value , long field ) {
public nsIMIMEInputStream ( long address ) {
public int SetData ( long stream ) {
public NSString ( long id ) {
public long UTF8String ( ) {
public long characterAtIndex ( long index ) {
public long compare ( NSString string ) {
public long fileSystemRepresentation ( ) {
long result = OS . objc_msgSend ( this . id , OS . sel_lastPathComponent ) ;
public long length ( ) {
long result = OS . objc_msgSend ( this . id , OS . sel_lowercaseString ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_pathExtension ) ;
long result = OS . objc_msgSend ( OS . class_NSString , OS . sel_string ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_stringByAppendingPathComponent_ , str ! = null ? str . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_stringByAppendingPathExtension_ , str ! = null ? str . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_stringByAppendingString_ , aString ! = null ? aString . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_stringByDeletingLastPathComponent ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_stringByDeletingPathExtension ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_stringByReplacingOccurrencesOfString_withString_ , target ! = null ? target . id : 0 , replacement ! = null ? replacement . id : 0 ) ;
long result = OS . objc_msgSend ( OS . class_NSString , OS . sel_stringWithFormat_ , format ! = null ? format . id : 0 ) ;
public NSFileWrapper ( long id ) {
long hImage = shdi . hbmpDragImage ;
long oldMemBitmap = OS . SelectObject ( memHdc , memDib ) ;
long treeImageList = OS . SendMessage ( tree . handle , OS . TVM_GETIMAGELIST , OS . TVSIL_NORMAL , 0 ) ;
long hBrush = OS . GetStockObject ( OS . WHITE_BRUSH ) ;
long imageList = OS . SendMessage ( tree . handle , OS . TVM_CREATEDRAGIMAGE , 0 , selected . handle ) ;
public IWebPreferences ( long address ) {
public int initWithIdentifier ( long identifier , long [ ] preferences ) {
public NSPrinter ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_name ) ;
long result = OS . objc_msgSend ( OS . class_NSPrinter , OS . sel_printerNames ) ;
long result = OS . objc_msgSend ( OS . class_NSPrinter , OS . sel_printerWithName_ , name ! = null ? name . id : 0 ) ;
public NSDatePicker ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_dateValue ) ;
public void setDatePickerElements ( long elementFlags ) {
public void setDatePickerStyle ( long newStyle ) {
public static long cellClass ( ) {
public static void setCellClass ( long factoryId ) {
public NSDate ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_dateWithCalendarFormat_timeZone_ , format ! = null ? format . id : 0 , aTimeZone ! = null ? aTimeZone . id : 0 ) ;
long result = OS . objc_msgSend ( OS . class_NSDate , OS . sel_dateWithTimeIntervalSinceNow_ , secs ) ;
long result = OS . objc_msgSend ( OS . class_NSDate , OS . sel_distantFuture ) ;
long newPtr = OS . GlobalAlloc ( COM . GMEM_FIXED | COM . GMEM_ZEROINIT , byteCount ) ;
long lpMultiByteStr = OS . GlobalAlloc ( COM . GMEM_FIXED | COM . GMEM_ZEROINIT , cchMultiByte ) ;
long hMem = stgmedium . unionField ;
long ptr = OS . GlobalLock ( hMem ) ;
long lpMultiByteStr = OS . GlobalLock ( hMem ) ;
public IOleInPlaceActiveObject ( long address ) {
public int ResizeBorder ( RECT prcBorder , long pUIWindow , boolean fFrameWindow ) {
long drawable = gc . getGCData ( ) . drawable ;
long separatorHandle = theme . separatorHandle ;
long gtkStyle = OS . gtk_widget_get_style ( separatorHandle ) ;
long toolbarHandle = theme . toolbarHandle ;
long [ ] ppv = new long [ 1 ] ;
long [ ] ppv = new long [ 1 ] ;
long [ ] ppvObject = new long [ 1 ] ;
long getAddress ( ) {
long [ ] ppVarDesc = new long [ 1 ] ;
long [ ] ppFuncDesc = new long [ 1 ] ;
long [ ] pTypedesc = new long [ 1 ] ;
long [ ] ppTypeAttr = new long [ 1 ] ;
long pVarResultAddress = 0 ;
long request , badCertRequest ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long aSpec = XPCOM . nsEmbedCString_new ( bytes , bytes . length ) ;
long [ ] result = new long [ 1 ] ;
long aSpec = XPCOM . nsEmbedCString_new ( bytes , bytes . length ) ;
long ptr = C . getenv ( MozillaDelegate . wcsToMbcs ( null , XPCOM . MOZILLA_FIVE_HOME , true ) ) ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long scriptGlobalObject = result [ 0 ] ;
long scriptContext = XPCOM . nsIScriptGlobalObject_GetScriptContext ( scriptGlobalObject , 2 ) ;
long nativeContext = XPCOM . nsIScriptContext_GetNativeContext ( scriptContext ) ;
long principals = result [ 0 ] ;
long globalJSObject = XPCOM . JS_GetGlobalObject ( jsLibPath , nativeContext ) ;
static Browser findBrowser ( long handle ) {
long topDOMWindow = result [ 0 ] ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long path = XPCOM . nsEmbedString_new ( ) ;
long ptr = XPCOM . nsEmbedString_get ( path ) ;
long [ ] result = new long [ 1 ] ;
long document = result [ 0 ] ;
long string = XPCOM . nsEmbedString_new ( ) ;
long buffer = XPCOM . nsEmbedString_get ( string ) ;
long [ ] result = new long [ 1 ] ;
long [ ] aCurrentURI = new long [ 1 ] ;
long aSpec = XPCOM . nsEmbedCString_new ( ) ;
long buffer = XPCOM . nsEmbedCString_get ( aSpec ) ;
long lower = C . malloc ( bytes . length ) ;
long upper = C . malloc ( bytes . length ) ;
long name = C . malloc ( bytes . length ) ;
long value = C . malloc ( bytes . length ) ;
long greBuffer = C . malloc ( length ) ;
long [ ] result = new long [ 1 ] ;
long ptr = C . getenv ( MozillaDelegate . wcsToMbcs ( null , XPCOM . MOZILLA_FIVE_HOME , true ) ) ;
long [ ] result = new long [ 1 ] ;
long ptr = C . malloc ( size * 2 ) ;
C . memmove ( functionLoad . function , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
long functionPtr = result [ 0 ] ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long ptr = C . malloc ( size * 2 ) ;
C . memmove ( functionLoad . function , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
long functionPtr = result [ 0 ] ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
void navigate ( long requestHandle ) {
long [ ] result = new long [ 1 ] ;
public long method0 ( long [ ] args ) {
XPCOM . memmove ( ppvObject , new long [ ] { getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
public long method1 ( long [ ] args ) {
public long method2 ( long [ ] args ) {
public long method3 ( long [ ] args ) {
long buffer = XPCOM . nsEmbedCString_get ( aHeader ) ;
long name = XPCOM . nsEmbedCString_new ( ) ;
long buffer = XPCOM . nsEmbedCString_get ( name ) ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long aContentCharset = XPCOM . nsEmbedCString_new ( contentCharsetBuffer , contentCharsetBuffer . length ) ;
long aContentType = XPCOM . nsEmbedCString_new ( contentTypeBuffer , contentTypeBuffer . length ) ;
long aSpec = XPCOM . nsEmbedCString_new ( aString , aString . length ) ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
int QueryInterface ( long riid , long ppvObject ) {
XPCOM . memmove ( ppvObject , new long [ ] { supports . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { weakReference . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { webProgressListener . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { webBrowserChrome . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { webBrowserChromeFocus . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { embeddingSiteWindow . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { interfaceRequestor . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { supportsWeakReference . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { contextMenuListener . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { uriContentListener . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { tooltipListener . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { badCertListener . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
int QueryReferent ( long riid , long ppvObject ) {
int GetInterface ( long riid , long ppvObject ) {
long [ ] aContentDOMWindow = new long [ 1 ] ;
int OnStateChange ( long aWebProgress , long aRequest , int aStateFlags , int aStatus ) {
long name = XPCOM . nsEmbedCString_new ( ) ;
long buffer = XPCOM . nsEmbedCString_get ( name ) ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long [ ] window = new long [ 1 ] ;
long name = XPCOM . nsEmbedCString_new ( ) ;
long buffer = XPCOM . nsEmbedCString_get ( name ) ;
long aSpec = XPCOM . nsEmbedCString_new ( aString , aString . length ) ;
long aContentType = XPCOM . nsEmbedCString_new ( contentTypeBuffer , contentTypeBuffer . length ) ;
long ptr = C . malloc ( htmlBytes . length ) ;
long current = ptr ;
long [ ] window = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long aSpec = XPCOM . nsEmbedCString_new ( ) ;
long buffer = XPCOM . nsEmbedCString_get ( aSpec ) ;
long [ ] result = new long [ 1 ] ;
int OnProgressChange ( long aWebProgress , long aRequest , int aCurSelfProgress , int aMaxSelfProgress , int aCurTotalProgress , int aMaxTotalProgress ) {
int OnLocationChange ( long aWebProgress , long aRequest , long aLocation ) {
long [ ] aDOMWindow = new long [ 1 ] ;
long [ ] aTop = new long [ 1 ] ;
long aSpec = XPCOM . nsEmbedCString_new ( ) ;
long buffer = XPCOM . nsEmbedCString_get ( aSpec ) ;
int OnStatusChange ( long aWebProgress , long aRequest , int aStatus , long aMessage ) {
int OnSecurityChange ( long aWebProgress , long aRequest , int state ) {
int SetStatus ( int statusType , long status ) {
int SetWebBrowser ( long aWebBrowser ) {
int GetChromeFlags ( long aChromeFlags ) {
long [ ] result = new long [ 1 ] ;
int IsWindowModal ( long retval ) {
int GetDimensions ( int flags , long x , long y , long cx , long cy ) {
long [ ] result = new long [ 1 ] ;
int GetVisibility ( long aVisibility ) {
int GetTitle ( long aTitle ) {
int SetTitle ( long aTitle ) {
int GetSiteWindow ( long aSiteWindow ) {
int OnShowContextMenu ( int aContextFlags , long aEvent , long aNode ) {
long [ ] result = new long [ 1 ] ;
int OnStartURIOpen ( long aURI , long retval ) {
long aSpec = XPCOM . nsEmbedCString_new ( ) ;
long buffer = XPCOM . nsEmbedCString_get ( aSpec ) ;
long [ ] result = new long [ 1 ] ;
int DoContent ( long aContentType , int aIsContentPreferred , long aRequest , long aContentHandler , long retval ) {
int IsPreferred ( long aContentType , long aDesiredContentType , long retval ) {
long [ ] result = new long [ 1 ] ;
long typePtr = XPCOM . nsEmbedCString_new ( bytes , bytes . length ) ;
XPCOM . memmove ( aDesiredContentType , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
int CanHandleContent ( long aContentType , int aIsContentPreferred , long aDesiredContentType , long retval ) {
int GetLoadCookie ( long aLoadCookie ) {
int SetLoadCookie ( long aLoadCookie ) {
int GetParentContentListener ( long aParentContentListener ) {
int SetParentContentListener ( long aParentContentListener ) {
int OnShowTooltip ( int aXCoords , int aYCoords , long aTipText ) {
int HandleEvent ( long event ) {
long type = XPCOM . nsEmbedString_new ( ) ;
long buffer = XPCOM . nsEmbedString_get ( type ) ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
int NotifyCertProblem ( long socketInfo , long status , long targetSite , long _suppressError ) {
long buffer = XPCOM . nsEmbedCString_get ( targetSite ) ;
long [ ] result = new long [ 1 ] ;
long ptr = XPCOM . nsEmbedString_new ( ) ;
long ptr = XPCOM . nsEmbedString_new ( ) ;
long ptr = XPCOM . nsEmbedString_new ( ) ;
long [ ] result = new long [ 1 ] ;
long hostString = XPCOM . nsEmbedCString_new ( hostBytes , hostBytes . length ) ;
static long proc2 = 0 , proc3 = 0 , proc4 = 0 , proc5 = 0 , proc6 = 0 ;
long cls = OS . objc_allocateClassPair ( OS . class_NSObject , className , 0 ) ;
long draggedImage_endedAt_operationProc = OS . CALLBACK_draggedImage_endedAt_operation_ ( proc5 ) ;
private long delegateJniRef ;
long cls = OS . object_getClass ( control . view . id ) ;
long procPtr = OS . class_getMethodImplementation ( cls , OS . sel_draggingSourceOperationMaskForLocal_ ) ;
long draggedImage_endedAt_operationProc = OS . CALLBACK_draggedImage_endedAt_operation_ ( proc5 ) ;
void dndCallSuper ( long id , long sel , long arg0 , NSPoint arg1 , long arg2 ) {
void dndCallSuper ( long id , long sel , long arg0 , long arg1 ) {
long dndCallSuperObject ( long id , long sel , long arg0 , long arg1 , long arg2 , long arg3 ) {
void draggedImage_beganAt ( long id , long sel , long arg0 , long arg1 ) {
void draggedImage_endedAt_operation ( long id , long sel , long arg0 , NSPoint arg1 , long arg2 ) {
long dragImageForRowsWithIndexes_tableColumns_event_offset ( long id , long sel , long arg0 , long arg1 , long arg2 , long arg3 ) {
long draggingSourceOperationMaskForLocal ( long id , long sel , long arg0 ) {
static long dragSourceProc ( long id , long sel ) {
static long dragSourceProc ( long id , long sel , long arg0 ) {
static long dragSourceProc ( long id , long sel , long arg0 , long arg1 ) {
static long dragSourceProc ( long id , long sel , long arg0 , long arg1 , long arg2 ) {
static long dragSourceProc ( long id , long sel , long arg0 , long arg1 , long arg2 , long arg3 ) {
boolean ignoreModifierKeysWhileDragging ( long id , long sel ) {
int osOpToOp ( long osOperation ) {
void pasteboard_provideDataForType ( long id , long sel , long arg0 , long arg1 ) {
public DOMDocument ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_webFrame ) ;
public long className ;
public long parentClass ;
public long staticValues ;
public long staticFunctions ;
public long initialize ;
public long finalize ;
public long hasProperty ;
public long getProperty ;
public long setProperty ;
public long deleteProperty ;
public long getPropertyNames ;
public long callAsFunction ;
public long callAsConstructor ;
public long hasInstance ;
public long convertToType ;
long clientHandle , labelHandle ;
long clientHandle ( ) {
long eventHandle ( ) {
long parentingHandle ( ) {
void setFontDescription ( long font ) {
public nsIContextMenuListener ( long address ) {
public int OnShowContextMenu ( int aContextFlags , long aEvent , long aNode ) {
public nsISSLStatus ( long address ) {
public int GetServerCert ( long [ ] aServerCert ) {
public int GetCipherName ( long [ ] aCipherName ) {
public long hItem ;
public long pszText ;
public long lParam ;
public long get_text ;
public long get_text_after_offset ;
public long get_text_at_offset ;
public long get_character_at_offset ;
public long get_text_before_offset ;
public long get_caret_offset ;
public long get_run_attributes ;
public long get_default_attributes ;
public long get_character_extents ;
public long get_character_count ;
public long get_offset_at_point ;
public long get_n_selections ;
public long get_selection ;
public long add_selection ;
public long remove_selection ;
public long set_selection ;
public long set_caret_offset ;
public long text_changed ;
public long text_caret_moved ;
public long text_selection_changed ;
public long get_range_extents ;
public long get_bounded_ranges ;
public nsIVariant ( long address ) {
public int GetAsInt8 ( long _retval ) {
public int GetAsInt16 ( long _retval ) {
public int GetAsUint8 ( long _retval ) {
public int GetAsUint64 ( long _retval ) {
public int GetAsDouble ( long _retval ) {
public int GetAsID ( long retval ) {
public int GetAsAString ( long _retval ) {
public int GetAsDOMString ( long _retval ) {
public int GetAsACString ( long _retval ) {
public int GetAsAUTF8String ( long _retval ) {
public int GetAsString ( long [ ] _retval ) {
public int GetAsWString ( long [ ] _retval ) {
public int GetAsISupports ( long [ ] _retval ) {
public int GetAsJSVal ( long [ ] _retval ) {
public int GetAsInterface ( long [ ] iid , long [ ] iface ) {
public int GetAsArray ( short [ ] type , long iid , int [ ] count , long [ ] ptr ) {
public int GetAsStringWithSize ( int [ ] size , long [ ] str ) {
public int GetAsWStringWithSize ( int [ ] size , long [ ] str ) {
public static final double MAX_TEXT_CONTAINER_SIZE = 0.5e7f ;
public static final long sel_setMovable_ = OS . sel_registerName ( "str" ) ;
public static final long sel_contextID = OS . sel_registerName ( "str" ) ;
public static final long sel__drawThemeProgressArea_ = OS . sel_registerName ( "str" ) ;
public static final long sel__setDashboardBehavior = OS . sel_registerName ( "str" ) ;
public static final long sel__setNeedsToUseHeartBeatWindow_ = OS . sel_registerName ( "str" ) ;
public static final long sel_clearDeferFlushing = sel_registerName ( "str" ) ;
public static final long sel_setColor_forAttribute_ = sel_registerName ( "str" ) ;
public static final long sel_javaRunLoopMode = sel_registerName ( "str" ) ;
public static final native long CALLBACK_cellBaselineOffset ( long func ) ;
public static final native long NSAccessibilityRowIndexRangeAttribute ( ) ;
public static final native long NSAccessibilityColumnIndexRangeAttribute ( ) ;
public static final native long NSAccessibilityCellForColumnAndRowParameterizedAttribute ( ) ;
public static final native long NSAccessibilityCellRole ( ) ;
public static final long class_NSToolbarView = objc_getClass ( "str" ) ;
public static final native long NewGlobalRef ( Object object ) ;
public static final native void DeleteGlobalRef ( long globalRef ) ;
public static final native Object JNIGetObject ( long globalRef ) ;
public static final native int CPSSetProcessName ( int [ ] psn , long name ) ;
public static final native int GetIconRefFromTypeInfo ( int inCreator , int inType , long inExtension , long inMIMEType , int inUsageFlags , long outIconRef [ ] ) ;
public static final native long CGContextCopyPath ( long context ) ;
public static final native long TISCopyCurrentKeyboardInputSource ( ) ;
public static final native long TISGetInputSourceProperty ( long inputSource , long propertyKey ) ;
public static final native long kTISPropertyUnicodeKeyLayoutData ( ) ;
public static final native int UCKeyTranslate ( long keyLayoutPtr , short virtualKeyCode , short keyAction , int modifierKeyState , int keyboardType , int keyTranslateOptions , int [ ] deadKeyState , int maxStringLength , int [ ] actualStringLength , char [ ] unicodeString ) ;
public static final native boolean UTTypeEqual ( long inUTI1 , long inUTI2 ) ;
public static final native int HIThemeDrawFocusRect ( CGRect inRect , boolean inHasFocus , long inContext , int inOrientation ) ;
public static final native int ATSFontActivateFromFileReference ( byte [ ] iFile , int iContext , int iFormat , long iReserved , int iOptions , long [ ] oContainer ) ;
public static final native int FSPathMakeRef ( long path , byte [ ] ref , boolean [ ] isDirectory ) ;
public static final native long AcquireRootMenu ( ) ;
public static final native int CancelMenuTracking ( long inRootMenu , boolean inImmediate , int inDismissalReason ) ;
public static final native long LSGetApplicationForInfo ( int inType , int inCreator , long inExtension , int inRoleMask , byte [ ] outAppRef , int [ ] outAppURL ) ;
public static final native int GetIndMenuItemWithCommandID ( long mHandle , int commandId , int index , long [ ] outMenu , short [ ] outIndex ) ;
public static final native void DeleteMenuItem ( long mHandle , short index ) ;
public static final native long NSAddImage ( byte [ ] image_name , int options ) ;
public static final native long PMSessionGetCurrentPrinter ( long pmSessionInfo , long [ ] outPMPrinter ) ;
public static final native long PMSessionGetDestinationType ( long pmSessionInfo , long pmPrintSettings , short [ ] outDestinationType ) ;
public static final native long PMGetDuplex ( long printSettings , int [ ] outDuplexSetting ) ;
public static final native long PMSetDuplex ( long printSettings , int duplexSetting ) ;
public static final native long PMPrinterGetPrinterResolutionCount ( long pmPrinter , int [ ] outNumResolutions ) ;
public static final native long PMPrinterGetOutputResolution ( long pmPrinter , long pmPrintSettings , PMResolution outResolution ) ;
public static final native long PMPrinterGetIndexedPrinterResolution ( long pmPrinter , int index , PMResolution outResolution ) ;
public static final native long FindWindow ( long h , long v , long [ ] wHandle ) ;
public static final native long CGDisplayBaseAddress ( int display ) ;
public static final native long CGDisplayBitsPerPixel ( int display ) ;
public static final native long CGDisplayBitsPerSample ( int display ) ;
public static final native long CGDisplayBytesPerRow ( int display ) ;
public static final native void call ( long proc , long id , long sel ) ;
public static final native void CGContextCopyWindowContentsToRect ( long context , CGRect destRect , long contextID , long windowNumber , CGRect srcRect ) ;
public static final native long CGDisplayCreateImage ( int displayID ) ;
public static final native long NewRgn ( ) ;
public static final native void RectRgn ( long rgnHandle , short [ ] rect ) ;
public static final native void OffsetRgn ( long rgnHandle , short dh , short dv ) ;
public static final native void UnionRgn ( long srcRgnA , long srcRgnB , long dstRgn ) ;
public static final native void CloseRgn ( long dstRgn ) ;
public static final native void DisposeRgn ( long rgnHandle ) ;
public static final native boolean PtInRgn ( short [ ] pt , long rgnHandle ) ;
public static final native void GetRegionBounds ( long rgnHandle , short [ ] bounds ) ;
public static final native void SectRgn ( long srcRgnA , long srcRgnB , long dstRgn ) ;
public static final native boolean EmptyRgn ( long rgnHandle ) ;
public static final native void DiffRgn ( long srcRgnA , long srcRgnB , long dstRgn ) ;
public static final native boolean RectInRgn ( short [ ] rect , long rgnHandle ) ;
public static final native int QDRegionToRects ( long rgn , int dir , long proc , long userData ) ;
public static final native void CopyRgn ( long srcRgnHandle , long dstRgnHandle ) ;
public static final native int HIWindowGetCGWindowID ( long inWindow ) ;
public static final native long JSEvaluateScript ( long ctx , long script , long thisObject , long sourceURL , int startingLineNumber , long [ ] exception ) ;
public static final native long JSStringCreateWithUTF8CString ( byte [ ] string ) ;
public static final native void JSStringRelease ( long string ) ;
public static final native int SecPolicySearchCreate ( long certType , long policyOID , long value , long [ ] policySearch ) ;
public static final native int SecPolicySearchCopyNext ( long searchRef , long [ ] policyRef ) ;
public static final native int SecTrustCreateWithCertificates ( long certificates , long policies , long [ ] trustRef ) ;
public static final native long isFlipped_CALLBACK ( ) ;
public static final native long kCFTypeDictionaryKeyCallBacks ( ) ;
public static final native long kCFTypeDictionaryValueCallBacks ( ) ;
public static final native boolean class_addIvar ( long cls , byte [ ] name , long size , byte alignment , byte [ ] types ) ;
public static final native boolean class_addMethod ( long cls , long name , long imp , String types ) ;
public static final native boolean class_addProtocol ( long cls , long protocol ) ;
public static final native long class_getClassMethod ( long aClass , long aSelector ) ;
public static final native long class_getMethodImplementation ( long cls , long name ) ;
public static final native long class_getInstanceMethod ( long cls , long name ) ;
public static final native long class_getSuperclass ( long cls ) ;
public static final native long method_setImplementation ( long method , long imp ) ;
public static final native long sel_getName ( long sel ) ;
public static final native long class_createInstance ( long cls , long extraBytes ) ;
public static final native String class_getName ( long cls ) ;
public static final native long objc_allocateClassPair ( long superclass , String name , long extraBytes ) ;
public static final native void objc_registerClassPair ( long cls ) ;
public static final native long object_getClassName ( long obj ) ;
public static final native long object_getClass ( long obj ) ;
public static final native long object_getInstanceVariable ( long obj , byte [ ] name , long [ ] outValue ) ;
public static final native long object_setInstanceVariable ( long obj , byte [ ] name , long value ) ;
public static final native void objc_msgSend_stret ( NSSize result , long id , long sel , NSSize arg0 , long arg1 , long arg2 , long arg3 , long arg4 , long arg5 ) ;
public static final native long CALLBACK_accessibilityHitTest_ ( long func ) ;
public static final native long CALLBACK_attributedSubstringFromRange_ ( long func ) ;
public static final native long CALLBACK_canDragRowsWithIndexes_atPoint_ ( long func ) ;
public static final native long CALLBACK_cellSize ( long func ) ;
public static final native long CALLBACK_cellSizeForBounds_ ( long func ) ;
public static final native long CALLBACK_characterIndexForPoint_ ( long func ) ;
public static final native long CALLBACK_columnAtPoint_ ( long func ) ;
public static final native long CALLBACK_dragSelectionWithEvent_offset_slideBack_ ( long func ) ;
public static final native long CALLBACK_draggedImage_beganAt_ ( long func ) ;
public static final native long CALLBACK_draggedImage_endedAt_operation_ ( long func ) ;
public static final native long CALLBACK_drawBackgroundInClipRect_ ( long func ) ;
public static final native long CALLBACK_drawImage_withFrame_inView_ ( long func ) ;
public static final native long CALLBACK_drawInteriorWithFrame_inView_ ( long func ) ;
public static final native long CALLBACK_drawLabel_inRect_ ( long func ) ;
public static final native long CALLBACK_drawRect_ ( long func ) ;
public static final native long CALLBACK_drawTitle_withFrame_inView_ ( long func ) ;
public static final native long CALLBACK_drawViewBackgroundInRect_ ( long func ) ;
public static final native long CALLBACK_drawWithExpansionFrame_inView_ ( long func ) ;
public static final native long CALLBACK_expansionFrameWithFrame_inView_ ( long func ) ;
public static final native long CALLBACK_firstRectForCharacterRange_ ( long func ) ;
public static final native long CALLBACK_headerRectOfColumn_ ( long func ) ;
public static final native long CALLBACK_highlightSelectionInClipRect_ ( long func ) ;
public static final native long CALLBACK_hitTest_ ( long func ) ;
public static final native long CALLBACK_hitTestForEvent_inRect_ofView_ ( long func ) ;
public static final native long CALLBACK_imageRectForBounds_ ( long func ) ;
public static final native long CALLBACK_markedRange ( long func ) ;
public static final native long CALLBACK_scrollClipView_toPoint_ ( long func ) ;
public static final native long CALLBACK_selectedRange ( long func ) ;
public static final native long CALLBACK_setFrame_ ( long func ) ;
public static final native long CALLBACK_setFrameOrigin_ ( long func ) ;
public static final native long CALLBACK_setFrameSize_ ( long func ) ;
public static final native long CALLBACK_setMarkedText_selectedRange_ ( long func ) ;
public static final native long CALLBACK_setNeedsDisplayInRect_ ( long func ) ;
public static final native long CALLBACK_shouldChangeTextInRange_replacementString_ ( long func ) ;
public static final native long CALLBACK_sizeOfLabel_ ( long func ) ;
public static final native long CALLBACK_textView_willChangeSelectionFromCharacterRange_toCharacterRange_ ( long func ) ;
public static final native long CALLBACK_titleRectForBounds_ ( long func ) ;
public static final native long CALLBACK_view_stringForToolTip_point_userData_ ( long func ) ;
public static final native long CALLBACK_webView_setFrame_ ( long func ) ;
public static final native long NSAccessibilityAttributedStringForRangeParameterizedAttribute ( ) ;
public static final native long NSAccessibilityBackgroundColorTextAttribute ( ) ;
public static final native long NSAccessibilityBoundsForRangeParameterizedAttribute ( ) ;
public static final native long NSAccessibilityButtonRole ( ) ;
public static final native long NSAccessibilityCheckBoxRole ( ) ;
public static final native long NSAccessibilityChildrenAttribute ( ) ;
public static final native long NSAccessibilityColorWellRole ( ) ;
public static final native long NSAccessibilityColumnRole ( ) ;
public static final native long NSAccessibilityColumnsAttribute ( ) ;
public static final native long NSAccessibilityComboBoxRole ( ) ;
public static final native long NSAccessibilityConfirmAction ( ) ;
public static final native long NSAccessibilityContentsAttribute ( ) ;
public static final native long NSAccessibilityDescriptionAttribute ( ) ;
public static final native long NSAccessibilityDialogSubrole ( ) ;
public static final native long NSAccessibilityEnabledAttribute ( ) ;
public static final native long NSAccessibilityExpandedAttribute ( ) ;
public static final native long NSAccessibilityFloatingWindowSubrole ( ) ;
public static final native long NSAccessibilityFocusedAttribute ( ) ;
public static final native long NSAccessibilityFocusedUIElementChangedNotification ( ) ;
public static final native long NSAccessibilityFocusedWindowChangedNotification ( ) ;
public static final native long NSAccessibilityFontFamilyKey ( ) ;
public static final native long NSAccessibilityFontNameKey ( ) ;
public static final native long NSAccessibilityFontSizeKey ( ) ;
public static final native long NSAccessibilityFontTextAttribute ( ) ;
public static final native long NSAccessibilityForegroundColorTextAttribute ( ) ;
public static final native long NSAccessibilityGridRole ( ) ;
public static final native long NSAccessibilityGroupRole ( ) ;
public static final native long NSAccessibilityHeaderAttribute ( ) ;
public static final native long NSAccessibilityHelpAttribute ( ) ;
public static final native long NSAccessibilityHelpTagRole ( ) ;
public static final native long NSAccessibilityHorizontalOrientationValue ( ) ;
public static final native long NSAccessibilityHorizontalScrollBarAttribute ( ) ;
public static final native long NSAccessibilityImageRole ( ) ;
public static final native long NSAccessibilityIncrementorRole ( ) ;
public static final native long NSAccessibilityIndexAttribute ( ) ;
public static final native long NSAccessibilityInsertionPointLineNumberAttribute ( ) ;
public static final native long NSAccessibilityLabelValueAttribute ( ) ;
public static final native long NSAccessibilityLineForIndexParameterizedAttribute ( ) ;
public static final native long NSAccessibilityLinkRole ( ) ;
public static final native long NSAccessibilityLinkTextAttribute ( ) ;
public static final native long NSAccessibilityLinkedUIElementsAttribute ( ) ;
public static final native long NSAccessibilityListRole ( ) ;
public static final native long NSAccessibilityMaxValueAttribute ( ) ;
public static final native long NSAccessibilityMenuBarRole ( ) ;
public static final native long NSAccessibilityMenuButtonRole ( ) ;
public static final native long NSAccessibilityMenuItemRole ( ) ;
public static final native long NSAccessibilityMenuRole ( ) ;
public static final native long NSAccessibilityMinValueAttribute ( ) ;
public static final native long NSAccessibilityMisspelledTextAttribute ( ) ;
public static final native long NSAccessibilityMovedNotification ( ) ;
public static final native long NSAccessibilityNextContentsAttribute ( ) ;
public static final native long NSAccessibilityNumberOfCharactersAttribute ( ) ;
public static final native long NSAccessibilityOrientationAttribute ( ) ;
public static final native long NSAccessibilityOutlineRole ( ) ;
public static final native long NSAccessibilityOutlineRowSubrole ( ) ;
public static final native long NSAccessibilityParentAttribute ( ) ;
public static final native long NSAccessibilityPopUpButtonRole ( ) ;
public static final native long NSAccessibilityPositionAttribute ( ) ;
public static final native long NSAccessibilityPressAction ( ) ;
public static final native long NSAccessibilityPreviousContentsAttribute ( ) ;
public static final native long NSAccessibilityProgressIndicatorRole ( ) ;
public static final native long NSAccessibilityRTFForRangeParameterizedAttribute ( ) ;
public static final native long NSAccessibilityRadioButtonRole ( ) ;
public static final native long NSAccessibilityRadioGroupRole ( ) ;
public static final native long NSAccessibilityRangeForIndexParameterizedAttribute ( ) ;
public static final native long NSAccessibilityRangeForLineParameterizedAttribute ( ) ;
public static final native long NSAccessibilityRangeForPositionParameterizedAttribute ( ) ;
public static final native long NSAccessibilityResizedNotification ( ) ;
public static final native long NSAccessibilityRoleAttribute ( ) ;
public static final native long NSAccessibilityRoleDescriptionAttribute ( ) ;
public static final native long NSAccessibilityRowCountChangedNotification ( ) ;
public static final native long NSAccessibilityRowRole ( ) ;
public static final native long NSAccessibilityRowsAttribute ( ) ;
public static final native long NSAccessibilityScrollAreaRole ( ) ;
public static final native long NSAccessibilityScrollBarRole ( ) ;
public static final native long NSAccessibilitySelectedAttribute ( ) ;
public static final native long NSAccessibilitySelectedChildrenAttribute ( ) ;
public static final native long NSAccessibilitySelectedChildrenChangedNotification ( ) ;
public static final native long NSAccessibilitySelectedColumnsAttribute ( ) ;
public static final native long NSAccessibilitySelectedRowsAttribute ( ) ;
public static final native long NSAccessibilitySelectedRowsChangedNotification ( ) ;
public static final native long NSAccessibilitySelectedTextAttribute ( ) ;
public static final native long NSAccessibilitySelectedTextChangedNotification ( ) ;
public static final native long NSAccessibilitySelectedTextRangeAttribute ( ) ;
public static final native long NSAccessibilitySelectedTextRangesAttribute ( ) ;
public static final native long NSAccessibilityServesAsTitleForUIElementsAttribute ( ) ;
public static final native long NSAccessibilityShowMenuAction ( ) ;
public static final native long NSAccessibilitySizeAttribute ( ) ;
public static final native long NSAccessibilitySliderRole ( ) ;
public static final native long NSAccessibilitySortButtonRole ( ) ;
public static final native long NSAccessibilitySplitterRole ( ) ;
public static final native long NSAccessibilityStandardWindowSubrole ( ) ;
public static final native long NSAccessibilityStaticTextRole ( ) ;
public static final native long NSAccessibilityStrikethroughColorTextAttribute ( ) ;
public static final native long NSAccessibilityStrikethroughTextAttribute ( ) ;
public static final native long NSAccessibilityStringForRangeParameterizedAttribute ( ) ;
public static final native long NSAccessibilityStyleRangeForIndexParameterizedAttribute ( ) ;
public static final native long NSAccessibilitySubroleAttribute ( ) ;
public static final native long NSAccessibilitySuperscriptTextAttribute ( ) ;
public static final native long NSAccessibilitySystemDialogSubrole ( ) ;
public static final native long NSAccessibilityTabGroupRole ( ) ;
public static final native long NSAccessibilityTableRole ( ) ;
public static final native long NSAccessibilityTableRowSubrole ( ) ;
public static final native long NSAccessibilityTabsAttribute ( ) ;
public static final native long NSAccessibilityTextAreaRole ( ) ;
public static final native long NSAccessibilityTextFieldRole ( ) ;
public static final native long NSAccessibilityTextLinkSubrole ( ) ;
public static final native long NSAccessibilityTitleAttribute ( ) ;
public static final native long NSAccessibilityTitleChangedNotification ( ) ;
public static final native long NSAccessibilityTitleUIElementAttribute ( ) ;
public static final native long NSAccessibilityToolbarRole ( ) ;
public static final native long NSAccessibilityTopLevelUIElementAttribute ( ) ;
public static final native long NSAccessibilityURLAttribute ( ) ;
public static final native long NSAccessibilityUnderlineColorTextAttribute ( ) ;
public static final native long NSAccessibilityUnderlineTextAttribute ( ) ;
public static final native long NSAccessibilityUnknownRole ( ) ;
public static final native long NSAccessibilityUnknownSubrole ( ) ;
public static final native long NSAccessibilityValueAttribute ( ) ;
public static final native long NSAccessibilityValueChangedNotification ( ) ;
public static final native long NSAccessibilityValueDescriptionAttribute ( ) ;
public static final native long NSAccessibilityValueIndicatorRole ( ) ;
public static final native long NSAccessibilityVerticalOrientationValue ( ) ;
public static final native long NSAccessibilityVerticalScrollBarAttribute ( ) ;
public static final native long NSAccessibilityVisibleCharacterRangeAttribute ( ) ;
public static final native long NSAccessibilityVisibleChildrenAttribute ( ) ;
public static final native long NSAccessibilityVisibleColumnsAttribute ( ) ;
public static final native long NSAccessibilityVisibleNameKey ( ) ;
public static final native long NSAccessibilityVisibleRowsAttribute ( ) ;
public static final native long NSAccessibilityWindowAttribute ( ) ;
public static final native long NSAccessibilityWindowRole ( ) ;
public static final native long NSApplicationDidChangeScreenParametersNotification ( ) ;
public static final native long NSAttachmentAttributeName ( ) ;
public static final native long NSBackgroundColorAttributeName ( ) ;
public static final native long NSBaselineOffsetAttributeName ( ) ;
public static final native long NSCalibratedRGBColorSpace ( ) ;
public static final native long NSCursorAttributeName ( ) ;
public static final native long NSDeviceRGBColorSpace ( ) ;
public static final native long NSDeviceResolution ( ) ;
public static final native long NSDragPboard ( ) ;
public static final native long NSEventTrackingRunLoopMode ( ) ;
public static final native long NSFilenamesPboardType ( ) ;
public static final native long NSFontAttributeName ( ) ;
public static final native long NSForegroundColorAttributeName ( ) ;
public static final native long NSHTMLPboardType ( ) ;
public static final native long NSLigatureAttributeName ( ) ;
public static final native long NSLinkAttributeName ( ) ;
public static final native long NSModalPanelRunLoopMode ( ) ;
public static final native long NSObliquenessAttributeName ( ) ;
public static final native long NSOutlineViewColumnDidMoveNotification ( ) ;
public static final native long NSParagraphStyleAttributeName ( ) ;
public static final native long NSPrintAllPages ( ) ;
public static final native long NSPrintCopies ( ) ;
public static final native long NSPrintFirstPage ( ) ;
public static final native long NSPrintJobDisposition ( ) ;
public static final native long NSPrintLastPage ( ) ;
public static final native long NSPrintMustCollate ( ) ;
public static final native long NSPrintOrientation ( ) ;
public static final native long NSPrintPreviewJob ( ) ;
public static final native long NSPrintSaveJob ( ) ;
public static final native long NSPrintSavePath ( ) ;
public static final native long NSPrintScalingFactor ( ) ;
public static final native long NSPrintSpoolJob ( ) ;
public static final native long NSRTFPboardType ( ) ;
public static final native long NSSpellingStateAttributeName ( ) ;
public static final native long NSStrikethroughColorAttributeName ( ) ;
public static final native long NSStrikethroughStyleAttributeName ( ) ;
public static final native long NSStringPboardType ( ) ;
public static final native long NSStrokeWidthAttributeName ( ) ;
public static final native long NSSystemColorsDidChangeNotification ( ) ;
public static final native long NSTIFFPboardType ( ) ;
public static final native long NSTableViewColumnDidMoveNotification ( ) ;
public static final native long NSToolbarCustomizeToolbarItemIdentifier ( ) ;
public static final native long NSToolbarDidRemoveItemNotification ( ) ;
public static final native long NSToolbarFlexibleSpaceItemIdentifier ( ) ;
public static final native long NSToolbarPrintItemIdentifier ( ) ;
public static final native long NSToolbarSeparatorItemIdentifier ( ) ;
public static final native long NSToolbarShowColorsItemIdentifier ( ) ;
public static final native long NSToolbarShowFontsItemIdentifier ( ) ;
public static final native long NSToolbarSpaceItemIdentifier ( ) ;
public static final native long NSToolbarWillAddItemNotification ( ) ;
public static final native long NSURLPboardType ( ) ;
public static final native long NSUnderlineColorAttributeName ( ) ;
public static final native long NSUnderlineStyleAttributeName ( ) ;
public static final native long NSViewGlobalFrameDidChangeNotification ( ) ;
public static final native long NSWindowDidBecomeKeyNotification ( ) ;
public static final native long NSWindowDidDeminiaturizeNotification ( ) ;
public static final native long NSWindowDidMiniaturizeNotification ( ) ;
public static final native long NSWindowDidMoveNotification ( ) ;
public static final native long NSWindowDidResignKeyNotification ( ) ;
public static final native long NSWindowDidResizeNotification ( ) ;
public static final native long NSWindowWillCloseNotification ( ) ;
public static final native long kCFAllocatorDefault ( ) ;
public static final native long kCFRunLoopCommonModes ( ) ;
public static final native long kCTFontAttributeName ( ) ;
public static final native long kCTForegroundColorAttributeName ( ) ;
public static final native long kCTParagraphStyleAttributeName ( ) ;
public static final native long NSDefaultRunLoopMode ( ) ;
public static final native long NSErrorFailingURLStringKey ( ) ;
public static final native long NSLocaleLanguageCode ( ) ;
public static final native long NSAccessibilityActionDescription ( long action ) ;
public static final native void NSAccessibilityPostNotification ( long element , long notification ) ;
public static final native void NSAccessibilityRaiseBadArgumentException ( long element , long attribute , long value ) ;
public static final native long NSAccessibilityRoleDescription ( long role , long subrole ) ;
public static final native long NSAccessibilityRoleDescriptionForUIElement ( long element ) ;
public static final native long NSAccessibilityUnignoredAncestor ( long element ) ;
public static final native long NSAccessibilityUnignoredChildren ( long originalChildren ) ;
public static final native long NSAccessibilityUnignoredChildrenForOnlyChild ( long originalChild ) ;
public static final native long NSAccessibilityUnignoredDescendant ( long element ) ;
public static final native long NSBitsPerPixelFromDepth ( int depth ) ;
public static final native void NSCopyBits ( long srcGState , NSRect srcRect , NSPoint destPoint ) ;
public static final native void NSCountWindows ( long [ ] count ) ;
public static final native long NSNumberOfColorComponents ( long colorSpaceName ) ;
public static final native void NSRectFillUsingOperation ( NSRect aRect , long op ) ;
public static final native void NSWindowList ( long size , long [ ] list ) ;
public static final native long CFAttributedStringCreate ( long alloc , long str , long attributes ) ;
public static final native long CFDataGetBytePtr ( long theData ) ;
public static final native long CFDataGetLength ( long theData ) ;
public static final native void CFDictionaryAddValue ( long theDict , long key , long value ) ;
public static final native long CFDictionaryCreateMutable ( long allocator , long capacity , long keyCallBacks , long valueCallBacks ) ;
public static final native void CFRelease ( long cf ) ;
public static final native long CFRunLoopObserverCreate ( long allocator , long activities , boolean repeats , long order , long callout , long context ) ;
public static final native void CFRunLoopObserverInvalidate ( long observer ) ;
public static final native int CFRunLoopRunInMode ( long mode , double seconds , boolean returnAfterSourceHandled ) ;
public static final native void CFRunLoopStop ( long rl ) ;
public static final native long CFStringCreateWithCharacters ( long alloc , char [ ] chars , long numChars ) ;
public static final native long CFURLCreateFromFSRef ( long allocator , byte [ ] fsRef ) ;
public static final native long CFURLCreateStringByAddingPercentEscapes ( long allocator , long originalString , long charactersToLeaveUnescaped , long legalURLCharactersToBeEscaped , int encoding ) ;
public static final native long CGBitmapContextCreate ( long data , long width , long height , long bitsPerComponent , long bytesPerRow , long colorspace , int bitmapInfo ) ;
public static final native long CGBitmapContextCreateImage ( long c ) ;
public static final native long CGBitmapContextGetData ( long c ) ;
public static final native long CGColorCreate ( long space , double [ ] components ) ;
public static final native void CGColorSpaceRelease ( long space ) ;
public static final native void CGContextAddPath ( long context , long path ) ;
public static final native void CGContextBeginTransparencyLayerWithRect ( long context , CGRect rect , long auxiliaryInfo ) ;
public static final native void CGContextDrawImage ( long c , CGRect rect , long image ) ;
public static final native void CGContextEndTransparencyLayer ( long context ) ;
public static final native void CGContextFillRect ( long c , CGRect rect ) ;
public static final native void CGContextRelease ( long c ) ;
public static final native void CGContextReplacePathWithStrokedPath ( long c ) ;
public static final native void CGContextRestoreGState ( long c ) ;
public static final native void CGContextSaveGState ( long c ) ;
public static final native void CGContextScaleCTM ( long c , double sx , double sy ) ;
public static final native void CGContextSetBlendMode ( long context , int mode ) ;
public static final native void CGContextSetFillColor ( long c , double [ ] components ) ;
public static final native void CGContextSetFillColorSpace ( long c , long colorspace ) ;
public static final native void CGContextSetLineCap ( long c , int cap ) ;
public static final native void CGContextSetLineDash ( long c , double phase , float [ ] lengths , long count ) ;
public static final native void CGContextSetLineJoin ( long c , int join ) ;
public static final native void CGContextSetLineWidth ( long c , double width ) ;
public static final native void CGContextSetMiterLimit ( long c , double limit ) ;
public static final native void CGContextSetShouldAntialias ( long c , boolean shouldAntialias ) ;
public static final native void CGContextSetTextDrawingMode ( long c , int mode ) ;
public static final native void CGContextSetTextMatrix ( long c , CGAffineTransform t ) ;
public static final native void CGContextSetTextPosition ( long c , double x , double y ) ;
public static final native void CGContextStrokePath ( long c ) ;
public static final native void CGContextTranslateCTM ( long c , double tx , double ty ) ;
public static final native long CGDataProviderCreateWithData ( long info , long data , long size , long releaseData ) ;
public static final native void CGDataProviderRelease ( long provider ) ;
public static final native long CGDisplayPixelsHigh ( int display ) ;
public static final native long CGDisplayPixelsWide ( int display ) ;
public static final native long CGEventCreateKeyboardEvent ( long source , short virtualKey , boolean keyDown ) ;
public static final native long CGEventCreateMouseEvent ( long source , int mouseType , CGPoint mouseCursorPosition , int mouseButton ) ;
public static final native long CGEventCreateScrollWheelEvent ( long source , int units , int wheelCount , int wheel1 ) ;
public static final native long CGEventGetIntegerValueField ( long event , int field ) ;
public static final native void CGEventPost ( int tap , long event ) ;
public static final native long CGEventSourceCreate ( int sourceState ) ;
public static final native int CGGetDisplaysWithRect ( CGRect rect , int maxDisplays , long dspys , long dspyCnt ) ;
public static final native long CGImageCreate ( long width , long height , long bitsPerComponent , long bitsPerPixel , long bytesPerRow , long colorspace , int bitmapInfo , long provider , long decode , boolean shouldInterpolate , int intent ) ;
public static final native long CGImageGetHeight ( long image ) ;
public static final native long CGImageGetWidth ( long image ) ;
public static final native void CGImageRelease ( long image ) ;
public static final native void CGPathAddCurveToPoint ( long path , long m , double cp1x , double cp1y , double cp2x , double cp2y , double x , double y ) ;
public static final native void CGPathAddLineToPoint ( long path , long m , double x , double y ) ;
public static final native void CGPathAddRect ( long path , long m , CGRect rect ) ;
public static final native void CGPathApply ( long path , long info , long function ) ;
public static final native void CGPathCloseSubpath ( long path ) ;
public static final native void CGPathMoveToPoint ( long path , long m , double x , double y ) ;
public static final native void CGPathRelease ( long path ) ;
public static final native double CTFontGetAscent ( long font ) ;
public static final native double CTFontGetDescent ( long font ) ;
public static final native double CTFontGetLeading ( long font ) ;
public static final native long CTLineCreateWithAttributedString ( long string ) ;
public static final native void CTLineDraw ( long line , long context ) ;
public static final native double CTLineGetTypographicBounds ( long line , double [ ] ascent , double [ ] descent , double [ ] leading ) ;
public static final native long CTParagraphStyleCreate ( long settings , long settingCount ) ;
public static final native long CTTypesetterCreateLine ( long typesetter , CFRange stringRange ) ;
public static final native long CTTypesetterCreateWithAttributedString ( long string ) ;
public static final native long CTTypesetterSuggestLineBreak ( long typesetter , long startIndex , double width ) ;
public static final native long NSFileTypeForHFSTypeCode ( int hfsFileTypeCode ) ;
public static final native long NSGetSizeAndAlignment ( long typePtr , long [ ] sizep , long [ ] alignp ) ;
public static final native boolean objc_msgSendSuper_bool ( objc_super superId , long sel , NSRange arg0 , long arg1 ) ;
public static final native boolean objc_msgSendSuper_bool ( objc_super superId , long sel , long arg0 , NSPoint arg1 ) ;
public static final native long objc_msgSendSuper ( objc_super superId , long sel ) ;
public static final native long objc_msgSendSuper ( objc_super superId , long sel , NSPoint arg0 ) ;
public static final native long objc_msgSendSuper ( objc_super superId , long sel , NSRect arg0 ) ;
public static final native long objc_msgSendSuper ( objc_super superId , long sel , NSRect arg0 , long arg1 ) ;
public static final native long objc_msgSendSuper ( objc_super superId , long sel , NSSize arg0 ) ;
public static final native long objc_msgSendSuper ( objc_super superId , long sel , boolean arg0 ) ;
public static final native long objc_msgSendSuper ( objc_super superId , long sel , boolean arg0 , NSRect arg1 ) ;
public static final native long objc_msgSendSuper ( objc_super superId , long sel , long arg0 ) ;
public static final native long objc_msgSendSuper ( objc_super superId , long sel , long arg0 , NSPoint arg1 ) ;
public static final native long objc_msgSendSuper ( objc_super superId , long sel , long arg0 , NSPoint arg1 , long arg2 ) ;
public static final native long objc_msgSendSuper ( objc_super superId , long sel , long arg0 , NSRect arg1 , long arg2 ) ;
public static final native long objc_msgSendSuper ( objc_super superId , long sel , long arg0 , boolean arg1 ) ;
public static final native long objc_msgSendSuper ( objc_super superId , long sel , long arg0 , long arg1 ) ;
public static final native long objc_msgSendSuper ( objc_super superId , long sel , long arg0 , long arg1 , long arg2 , boolean arg3 ) ;
public static final native long objc_msgSendSuper ( objc_super superId , long sel , long arg0 , long arg1 , long arg2 , long arg3 ) ;
public static final native void objc_msgSendSuper_stret ( NSRect result , objc_super superId , long sel , NSRect arg0 ) ;
public static final native void objc_msgSendSuper_stret ( NSRect result , objc_super superId , long sel , NSRect arg0 , long arg1 ) ;
public static final native void objc_msgSendSuper_stret ( NSRect result , objc_super superId , long sel , long arg0 ) ;
public static final native void objc_msgSendSuper_stret ( NSRect result , objc_super superId , long sel , long arg0 , NSRect arg1 , long arg2 ) ;
public static final native void objc_msgSendSuper_stret ( NSSize result , objc_super superId , long sel ) ;
public static final native void objc_msgSendSuper_stret ( NSSize result , objc_super superId , long sel , NSRect arg0 ) ;
public static final native void objc_msgSendSuper_stret ( NSSize result , objc_super superId , long sel , boolean arg0 ) ;
public static final native boolean objc_msgSend_bool ( long id , long sel ) ;
public static final native boolean objc_msgSend_bool ( long id , long sel , NSPoint arg0 ) ;
public static final native boolean objc_msgSend_bool ( long id , long sel , NSPoint arg0 , NSRect arg1 ) ;
public static final native boolean objc_msgSend_bool ( long id , long sel , NSRange arg0 , long arg1 ) ;
public static final native boolean objc_msgSend_bool ( long id , long sel , NSRect arg0 ) ;
public static final native boolean objc_msgSend_bool ( long id , long sel , long arg0 ) ;
public static final native boolean objc_msgSend_bool ( long id , long sel , long arg0 , NSPoint arg1 ) ;
public static final native boolean objc_msgSend_bool ( long id , long sel , long arg0 , NSSize arg1 , boolean arg2 ) ;
public static final native boolean objc_msgSend_bool ( long id , long sel , long arg0 , long arg1 ) ;
public static final native boolean objc_msgSend_bool ( long id , long sel , long arg0 , long arg1 , long arg2 ) ;
public static final native boolean objc_msgSend_bool ( long id , long sel , long arg0 , long arg1 , long arg2 , long arg3 ) ;
public static final native boolean objc_msgSend_bool ( long id , long sel , long arg0 , long arg1 , long arg2 , long arg3 , long arg4 ) ;
public static final native boolean objc_msgSend_bool ( long id , long sel , short arg0 ) ;
public static final native double objc_msgSend_fpret ( long id , long sel ) ;
public static final native double objc_msgSend_fpret ( long id , long sel , long arg0 ) ;
public static final native double objc_msgSend_fpret ( long id , long sel , long arg0 , long arg1 ) ;
public static final native float objc_msgSend_floatret ( long id , long sel ) ;
public static final native long objc_msgSend ( long id , long sel ) ;
public static final native long objc_msgSend ( long id , long sel , NSAffineTransformStruct arg0 ) ;
public static final native long objc_msgSend ( long id , long sel , NSPoint arg0 ) ;
public static final native long objc_msgSend ( long id , long sel , NSPoint arg0 , NSPoint arg1 , NSPoint arg2 ) ;
public static final native long objc_msgSend ( long id , long sel , NSPoint arg0 , NSPoint arg1 , long arg2 ) ;
public static final native long objc_msgSend ( long id , long sel , NSPoint arg0 , NSRect arg1 , long arg2 , double arg3 ) ;
public static final native long objc_msgSend ( long id , long sel , NSPoint arg0 , double arg1 , double arg2 , double arg3 ) ;
public static final native long objc_msgSend ( long id , long sel , NSPoint arg0 , double arg1 , double arg2 , double arg3 , boolean arg4 ) ;
public static final native long objc_msgSend ( long id , long sel , NSPoint arg0 , long arg1 ) ;
public static final native long objc_msgSend ( long id , long sel , NSPoint arg0 , long arg1 , double [ ] arg2 ) ;
public static final native long objc_msgSend ( long id , long sel , NSRange arg0 ) ;
public static final native long objc_msgSend ( long id , long sel , NSRange arg0 , NSPoint arg1 ) ;
public static final native long objc_msgSend ( long id , long sel , NSRange arg0 , NSRange arg1 , long arg2 , long [ ] arg3 ) ;
public static final native long objc_msgSend ( long id , long sel , NSRange arg0 , long arg1 ) ;
public static final native long objc_msgSend ( long id , long sel , NSRange arg0 , long arg1 , long arg2 , long arg3 , long arg4 , byte [ ] arg5 ) ;
public static final native long objc_msgSend ( long id , long sel , NSRect arg0 ) ;
public static final native long objc_msgSend ( long id , long sel , NSRect arg0 , NSPoint arg1 ) ;
public static final native long objc_msgSend ( long id , long sel , NSRect arg0 , NSRange arg1 , NSRect arg2 ) ;
public static final native long objc_msgSend ( long id , long sel , NSRect arg0 , NSRect arg1 , long arg2 , double arg3 ) ;
public static final native long objc_msgSend ( long id , long sel , NSRect arg0 , boolean arg1 ) ;
public static final native long objc_msgSend ( long id , long sel , NSRect arg0 , boolean arg1 , boolean arg2 ) ;
public static final native long objc_msgSend ( long id , long sel , NSRect arg0 , double arg1 ) ;
public static final native long objc_msgSend ( long id , long sel , NSRect arg0 , double arg1 , double arg2 ) ;
public static final native long objc_msgSend ( long id , long sel , NSRect arg0 , long arg1 ) ;
public static final native long objc_msgSend ( long id , long sel , NSRect arg0 , long arg1 , boolean arg2 , long arg3 ) ;
public static final native long objc_msgSend ( long id , long sel , NSRect arg0 , long arg1 , long arg2 ) ;
public static final native long objc_msgSend ( long id , long sel , NSRect arg0 , long arg1 , long arg2 , boolean arg3 ) ;
public static final native long objc_msgSend ( long id , long sel , NSRect arg0 , long arg1 , long arg2 , boolean arg3 , long arg4 ) ;
public static final native long objc_msgSend ( long id , long sel , NSRect arg0 , long arg1 , long arg2 , long arg3 ) ;
public static final native long objc_msgSend ( long id , long sel , NSSize arg0 ) ;
public static final native long objc_msgSend ( long id , long sel , boolean arg0 ) ;
public static final native long objc_msgSend ( long id , long sel , boolean arg0 , NSRect arg1 ) ;
public static final native long objc_msgSend ( long id , long sel , boolean arg0 , long arg1 ) ;
public static final native long objc_msgSend ( long id , long sel , byte [ ] arg0 ) ;
public static final native long objc_msgSend ( long id , long sel , byte [ ] arg0 , long arg1 ) ;
public static final native long objc_msgSend ( long id , long sel , char [ ] arg0 ) ;
public static final native long objc_msgSend ( long id , long sel , char [ ] arg0 , NSRange arg1 ) ;
public static final native long objc_msgSend ( long id , long sel , char [ ] arg0 , long arg1 ) ;
public static final native long objc_msgSend ( long id , long sel , double arg0 ) ;
public static final native long objc_msgSend ( long id , long sel , double arg0 , long arg1 , long arg2 , long arg3 , boolean arg4 ) ;
public static final native long objc_msgSend ( long id , long sel , double arg0 , double arg1 ) ;
public static final native long objc_msgSend ( long id , long sel , double arg0 , double arg1 , double arg2 , double arg3 ) ;
public static final native long objc_msgSend ( long id , long sel , double arg0 , long arg1 ) ;
public static final native long objc_msgSend ( long id , long sel , double [ ] arg0 ) ;
public static final native long objc_msgSend ( long id , long sel , double [ ] arg0 , long arg1 , double arg2 ) ;
public static final native long objc_msgSend ( long id , long sel , long arg0 ) ;
public static final native long objc_msgSend ( long id , long sel , long arg0 , NSPoint arg1 ) ;
public static final native long objc_msgSend ( long id , long sel , long arg0 , NSPoint arg1 , NSSize arg2 , long arg3 , long arg4 , long arg5 , boolean arg6 ) ;
public static final native long objc_msgSend ( long id , long sel , long arg0 , NSPoint arg1 , long arg2 ) ;
public static final native long objc_msgSend ( long id , long sel , long arg0 , NSPoint arg1 , long arg2 , double arg3 , long arg4 , long arg5 , long arg6 , long arg7 , long arg8 ) ;
public static final native long objc_msgSend ( long id , long sel , long arg0 , NSPoint arg1 , long arg2 , double arg3 , long arg4 , long arg5 , short arg6 , long arg7 , long arg8 ) ;
public static final native long objc_msgSend ( long id , long sel , long arg0 , NSRange arg1 ) ;
public static final native long objc_msgSend ( long id , long sel , long arg0 , NSRect arg1 , long arg2 ) ;
public static final native long objc_msgSend ( long id , long sel , long arg0 , boolean arg1 ) ;
public static final native long objc_msgSend ( long id , long sel , long arg0 , double arg1 ) ;
public static final native long objc_msgSend ( long id , long sel , long arg0 , long arg1 ) ;
public static final native long objc_msgSend ( long id , long sel , long arg0 , long arg1 , NSRange arg2 ) ;
public static final native long objc_msgSend ( long id , long sel , long arg0 , long arg1 , boolean arg2 ) ;
public static final native long objc_msgSend ( long id , long sel , long arg0 , long arg1 , double arg2 , long arg3 ) ;
public static final native long objc_msgSend ( long id , long sel , long arg0 , long arg1 , long arg2 ) ;
public static final native long objc_msgSend ( long id , long sel , long arg0 , long arg1 , long arg2 , boolean arg3 ) ;
public static final native long objc_msgSend ( long id , long sel , long arg0 , long arg1 , long arg2 , double arg3 ) ;
public static final native long objc_msgSend ( long id , long sel , long arg0 , long arg1 , long arg2 , long arg3 ) ;
public static final native long objc_msgSend ( long id , long sel , long arg0 , long arg1 , long arg2 , long arg3 , long arg4 ) ;
public static final native long objc_msgSend ( long id , long sel , long arg0 , long arg1 , long arg2 , long arg3 , long arg4 , boolean arg5 , boolean arg6 , long arg7 , long arg8 , long arg9 ) ;
public static final native long objc_msgSend ( long id , long sel , long arg0 , long arg1 , long arg2 , long arg3 , long arg4 , boolean arg5 , boolean arg6 , long arg7 , long arg8 , long arg9 , long arg10 ) ;
public static final native long objc_msgSend ( long id , long sel , long arg0 , long arg1 , long arg2 , long arg3 , long arg4 , long arg5 ) ;
public static final native long objc_msgSend ( long id , long sel , long arg0 , long arg1 , long arg2 , long arg3 , long arg4 , long arg5 , long arg6 ) ;
public static final native long objc_msgSend ( long id , long sel , long [ ] arg0 ) ;
public static final native long objc_msgSend ( long id , long sel , long [ ] arg0 , int arg1 , int arg2 ) ;
public static final native long objc_msgSend ( long id , long sel , int [ ] arg0 , int arg1 ) ;
public static final native void objc_msgSend_stret ( NSAffineTransformStruct result , long id , long sel ) ;
public static final native void objc_msgSend_stret ( NSPoint result , long id , long sel ) ;
public static final native void objc_msgSend_stret ( NSPoint result , long id , long sel , NSPoint arg0 ) ;
public static final native void objc_msgSend_stret ( NSPoint result , long id , long sel , NSPoint arg0 , long arg1 ) ;
public static final native void objc_msgSend_stret ( NSPoint result , long id , long sel , long arg0 ) ;
public static final native void objc_msgSend_stret ( NSRange result , long id , long sel ) ;
public static final native void objc_msgSend_stret ( NSRange result , long id , long sel , NSRange arg0 , long arg1 ) ;
public static final native void objc_msgSend_stret ( NSRange result , long id , long sel , NSRect arg0 ) ;
public static final native void objc_msgSend_stret ( NSRange result , long id , long sel , long arg0 ) ;
public static final native void objc_msgSend_stret ( NSRect result , long id , long sel ) ;
public static final native void objc_msgSend_stret ( NSRect result , long id , long sel , NSRange arg0 , long arg1 ) ;
public static final native void objc_msgSend_stret ( NSRect result , long id , long sel , NSRect arg0 ) ;
public static final native void objc_msgSend_stret ( NSRect result , long id , long sel , NSRect arg0 , long arg1 ) ;
public static final native void objc_msgSend_stret ( NSRect result , long id , long sel , NSSize arg0 , long arg1 ) ;
public static final native void objc_msgSend_stret ( NSRect result , long id , long sel , long arg0 ) ;
public static final native void objc_msgSend_stret ( NSRect result , long id , long sel , long arg0 , NSRect arg1 , long arg2 ) ;
public static final native void objc_msgSend_stret ( NSRect result , long id , long sel , long arg0 , long arg1 ) ;
public static final native void objc_msgSend_stret ( NSRect result , long id , long sel , long arg0 , long arg1 , boolean arg2 ) ;
public static final native void objc_msgSend_stret ( NSSize result , long id , long sel ) ;
public static final native void objc_msgSend_stret ( NSSize result , long id , long sel , NSRect arg0 ) ;
public static final native void objc_msgSend_stret ( NSSize result , long id , long sel , NSSize arg0 ) ;
public static final native void objc_msgSend_stret ( NSSize result , long id , long sel , NSSize arg0 , boolean arg1 , boolean arg2 , long arg3 ) ;
public static final native void objc_msgSend_stret ( NSSize result , long id , long sel , NSSize arg0 , long arg1 ) ;
public static final native void objc_msgSend_stret ( NSSize result , long id , long sel , boolean arg0 ) ;
public static final native void memmove ( long dest , CFRange src , long size ) ;
public static final native void memmove ( CFRange dest , long src , long size ) ;
public static final native void memmove ( long dest , CGAffineTransform src , long size ) ;
public static final native void memmove ( CGAffineTransform dest , long src , long size ) ;
public static final native void memmove ( long dest , CGPathElement src , long size ) ;
public static final native void memmove ( CGPathElement dest , long src , long size ) ;
public static final native void memmove ( long dest , CGPoint src , long size ) ;
public static final native void memmove ( CGPoint dest , long src , long size ) ;
public static final native void memmove ( long dest , CGRect src , long size ) ;
public static final native void memmove ( CGRect dest , long src , long size ) ;
public static final native void memmove ( long dest , CGSize src , long size ) ;
public static final native void memmove ( CGSize dest , long src , long size ) ;
public static final native void memmove ( long dest , CTParagraphStyleSetting src , long size ) ;
public static final native void memmove ( CTParagraphStyleSetting dest , long src , long size ) ;
public static final native void memmove ( long dest , NSAffineTransformStruct src , long size ) ;
public static final native void memmove ( NSAffineTransformStruct dest , long src , long size ) ;
public static final native void memmove ( long dest , NSPoint src , long size ) ;
public static final native void memmove ( NSPoint dest , long src , long size ) ;
public static final native void memmove ( long dest , NSRange src , long size ) ;
public static final native void memmove ( NSRange dest , long src , long size ) ;
public static final native void memmove ( long dest , NSRect src , long size ) ;
public static final native void memmove ( NSRect dest , long src , long size ) ;
public static final native void memmove ( long dest , NSSize src , long size ) ;
public static final native void memmove ( NSSize dest , long src , long size ) ;
public nsIWindowCreator ( long address ) {
public int CreateChromeWindow ( long parent , int chromeFlags , long [ ] _retval ) {
public NSTextField ( long id ) {
public static long cellClass ( ) {
public static void setCellClass ( long factoryId ) {
public long handle ;
Region ( Device device , long handle ) {
public static Region cocoa_new ( Device device , long handle ) {
static long polyToRgn ( int [ ] poly , int length ) {
long polyRgn = OS . NewRgn ( ) , rectRgn = OS . NewRgn ( ) ;
static long polyRgn ( int [ ] pointArray , int count ) {
long polyRgn = polyRgn ( pointArray , count ) ;
long rectRgn = OS . NewRgn ( ) ;
long newRgn = OS . NewRgn ( ) ;
long proc = callback . getAddress ( ) ;
long convertRgn ( long message , long rgn , long r , long newRgn ) {
long polyRgn = polyRgn ( points , points . length ) ;
long regionToRects ( long message , long rgn , long r , long path ) {
long rectRgn = OS . NewRgn ( ) ;
long polyRgn = polyRgn ( pointArray , pointArray . length ) ;
long rectRgn = OS . NewRgn ( ) ;
public nsIBadCertListener2 ( long address ) {
public int NotifyCertProblem ( long socketInfo , long status , long targetSite , int [ ] _retval ) {
long modelHandle , checkRenderer ;
long cellDataProc ( long tree_column , long cell , long tree_model , long iter , long data ) {
long path = OS . gtk_tree_model_get_path ( tree_model , iter ) ;
long [ ] ptr = new long [ 1 ] ;
int calculateWidth ( long column , long iter ) {
long list = 0 ;
long temp = list ;
long renderer = OS . g_list_data ( temp ) ;
long [ ] ptr = new long [ 1 ] ;
long newItem = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long oldItem = item . handle ;
long columnHandle = OS . gtk_tree_view_column_new ( ) ;
long [ ] types = getColumnTypes ( 1 ) ;
long selectionHandle = OS . gtk_tree_view_get_selection ( handle ) ;
long boxHandle = gtk_box_new ( OS . GTK_ORIENTATION_HORIZONTAL , false , 3 ) ;
long labelHandle = OS . gtk_label_new_with_mnemonic ( null ) ;
long imageHandle = OS . gtk_image_new ( ) ;
long widget = OS . gtk_widget_get_parent ( boxHandle ) ;
void createRenderers ( long columnHandle , int modelIndex , boolean check , int columnStyle ) {
long pixbufRenderer = ownerDraw ? OS . g_object_new ( display . gtk_cell_renderer_pixbuf_get_type ( ) , 0 ) : OS . gtk_cell_renderer_pixbuf_new ( ) ;
long textRenderer = ownerDraw ? OS . g_object_new ( display . gtk_cell_renderer_text_get_type ( ) , 0 ) : OS . gtk_cell_renderer_text_new ( ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long columnHandle = column . handle ;
long [ ] ptr = new long [ 1 ] ;
long newItem = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long oldItem = item . handle ;
long iter = item . handle ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long [ ] path = new long [ 1 ] ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long eventWindow ( ) {
long clientHandle = clientHandle ( ) ;
long list = OS . gtk_tree_view_get_columns ( handle ) ;
long temp = list ;
long column = OS . g_list_data ( temp ) ;
long [ ] path = new long [ 1 ] ;
long indices = OS . gtk_tree_path_get_indices ( path [ 0 ] ) ;
long buttonHandle = columns [ i ] . buttonHandle ;
long [ ] path = new long [ 1 ] ;
long indices = OS . gtk_tree_path_get_indices ( path [ 0 ] ) ;
long column = OS . gtk_tree_view_get_column ( handle , 0 ) ;
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long column = OS . gtk_tree_view_get_column ( handle , i ) ;
long pixbufRenderer = 0 ;
long renderer = OS . g_list_nth_data ( list , i ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long textRenderer = 0 ;
long renderer = OS . g_list_nth_data ( list , i ) ;
long [ ] path = new long [ 1 ] ;
long indices = OS . gtk_tree_path_get_indices ( path [ 0 ] ) ;
long gtk_button_press_event ( long widget , long event ) {
long result = super . gtk_button_press_event ( widget , event ) ;
long [ ] path = new long [ 1 ] ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long [ ] path = new long [ 1 ] ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long gtk_changed ( long widget ) {
long gtk_event_after ( long widget , long gdkEvent ) {
long gtk_expose_event ( long widget , long eventPtr ) {
long window = OS . gtk_tree_view_get_bin_window ( handle ) ;
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long path = OS . gtk_tree_model_get_path ( modelHandle , iter ) ;
long gtk_row_activated ( long tree , long path , long column ) {
long indices = OS . gtk_tree_path_get_indices ( path ) ;
long gtk_row_deleted ( long model , long path ) {
long gtk_row_inserted ( long model , long path , long iter ) {
long gtk_start_interactive_search ( long widget ) {
long indices = OS . gtk_tree_path_get_indices ( path ) ;
void gtk_widget_size_request ( long widget , GtkRequisition requisition ) {
long columns = OS . gtk_tree_view_get_columns ( handle ) , list = columns ;
long column = OS . g_list_data ( list ) ;
long columnHandle = 0 ;
long firstColumn = OS . gtk_tree_view_get_column ( handle , 0 ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long path = OS . gtk_tree_path_new_from_string ( buffer ) ;
long labelHandle = columns [ i ] . labelHandle ;
long labelHandle = columns [ i ] . labelHandle ;
long paintWindow ( ) {
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long iter = OS . g_object_get_qdata ( cell , Display . SWT_OBJECT_INDEX2 ) ;
long path = OS . gtk_tree_model_get_path ( modelHandle , iter ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long columnHandle = OS . g_object_get_qdata ( cell , Display . SWT_OBJECT_INDEX1 ) ;
long rendererRenderProc ( long cell , long window , long widget , long background_area , long cell_area , long expose_area , long flags ) {
long iter = OS . g_object_get_qdata ( cell , Display . SWT_OBJECT_INDEX2 ) ;
long path = OS . gtk_tree_model_get_path ( modelHandle , iter ) ;
long columnHandle = OS . g_object_get_qdata ( cell , Display . SWT_OBJECT_INDEX1 ) ;
long [ ] ptr = new long [ 1 ] ;
long path = OS . gtk_tree_model_get_path ( modelHandle , iter ) ;
long textRenderer = getTextRenderer ( columnHandle ) ;
long style = OS . gtk_widget_get_style ( widget ) ;
long result = 0 ;
long g_class = OS . g_type_class_peek_parent ( OS . G_OBJECT_GET_CLASS ( cell ) ) ;
long path = OS . gtk_tree_model_get_path ( modelHandle , iter ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long path = OS . gtk_tree_model_get_path ( modelHandle , item . handle ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long path = OS . gtk_tree_model_get_path ( modelHandle , item . handle ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long path = OS . gtk_tree_model_get_path ( modelHandle , item . handle ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
void setFontDescription ( long font ) {
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
void setModel ( long newModel ) {
void setScrollWidth ( long column , TableItem item ) {
long path = OS . gtk_tree_model_get_path ( modelHandle , _getItem ( index ) . handle ) ;
long column = OS . gtk_tree_view_get_column ( handle , i ) ;
long firstColumn = OS . gtk_tree_view_get_column ( handle , 0 ) ;
long temp = list ;
long widget = OS . g_list_data ( temp ) ;
long windowProc ( long handle , long arg0 , long user_data ) {
long window = OS . gtk_tree_view_get_bin_window ( handle ) ;
public NSGradient ( long id ) {
public void drawFromPoint ( NSPoint startingPoint , NSPoint endingPoint , long options ) {
public void drawInRect ( NSRect rect , double angle ) {
long result = OS . objc_msgSend ( this . id , OS . sel_initWithStartingColor_endingColor_ , startingColor ! = null ? startingColor . id : 0 , endingColor ! = null ? endingColor . id : 0 ) ;
long hDC = OS . GetDC ( handle ) ;
long hDC = OS . GetDC ( handle ) ;
long hDC = OS . GetDC ( handle ) ;
long hDC = OS . GetDC ( handle ) ;
static long delegateClass ;
long proc3 = Callback3 . getAddress ( ) ;
long proc4 = Callback4 . getAddress ( ) ;
long proc5 = Callback5 . getAddress ( ) ;
long proc6 = Callback6 . getAddress ( ) ;
long proc7 = Callback7 . getAddress ( ) ;
long setFrameProc = OS . CALLBACK_webView_setFrame_ ( proc4 ) ;
long metaClass = OS . objc_getMetaClass ( className ) ;
static long browserProc ( long id , long sel , long arg0 ) {
static long browserProc ( long id , long sel , long arg0 , long arg1 ) {
static long browserProc ( long id , long sel , long arg0 , long arg1 , long arg2 ) {
static long browserProc ( long id , long sel , long arg0 , long arg1 , long arg2 , long arg3 ) {
static long browserProc ( long id , long sel , long arg0 , long arg1 , long arg2 , long arg3 , long arg4 ) {
static boolean isSelectorExcludedFromWebScript ( long aSelector ) {
static long webScriptNameForSelector ( long aSelector ) {
long context = frame . globalContext ( ) ;
long scriptString = OS . JSStringCreateWithUTF8CString ( bytes ) ;
long urlString = OS . JSStringCreateWithUTF8CString ( bytes ) ;
long result = OS . JSEvaluateScript ( context , scriptString , 0 , urlString , 0 , null ) ;
long ptr = OS . CFURLCreateStringByAddingPercentEscapes ( 0 , str . id , unescapedStr . id , 0 , OS . kCFStringEncodingUTF8 ) ;
void webView_didChangeLocationWithinPageForFrame ( long sender , long frameID ) {
void webView_didFailProvisionalLoadWithError_forFrame ( long sender , long error , long frame ) {
long errorCode = nserror . code ( ) ;
void createPanelDidEnd ( long sheet , long returnCode , long contextInfo ) {
long method = OS . class_getClassMethod ( OS . class_NSURLRequest , OS . sel_setAllowsAnyHTTPSCertificate ) ;
void webView_didFinishLoadForFrame ( long sender , long frameID ) {
void hookDOMKeyListeners ( long frameID ) {
void hookDOMMouseListeners ( long frameID ) {
void webView_didReceiveTitle_forFrame ( long sender , long titleID , long frameID ) {
void webView_didStartProvisionalLoadForFrame ( long sender , long frameID ) {
void webView_didCommitLoadForFrame ( long sender , long frameID ) {
void webView_windowScriptObjectAvailable ( long webView , long windowScriptObject ) {
void webView_resource_didFinishLoadingFromDataSource ( long sender , long identifier , long dataSource ) {
void webView_resource_didFailLoadingWithError_fromDataSource ( long sender , long identifier , long error , long dataSource ) {
void webView_resource_didReceiveAuthenticationChallenge_fromDataSource ( long sender , long identifier , long challenge , long dataSource ) {
long cls = OS . class_WebPanelAuthenticationHandler ;
long method = OS . class_getClassMethod ( cls , OS . sel_sharedHandler ) ;
long handler = OS . objc_msgSend ( cls , OS . sel_sharedHandler ) ;
long webView_identifierForInitialRequest_fromDataSource ( long sender , long request , long dataSourceID ) {
long webView_resource_willSendRequest_redirectResponse_fromDataSource ( long sender , long identifier , long request , long redirectResponse , long dataSource ) {
long webView_createWebViewWithRequest ( long sender , long request ) {
void webViewShow ( long sender ) {
void webView_setFrame ( long sender , long frame ) {
void webViewFocus ( long sender ) {
void webViewUnfocus ( long sender ) {
NSNumber callRunBeforeUnloadConfirmPanelWithMessage ( long messageID , long arg ) {
boolean webView_runBeforeUnloadConfirmPanelWithMessage_initiatedByFrame ( long sender , long messageID , long frame ) {
void webView_runJavaScriptAlertPanelWithMessage ( long sender , long messageID ) {
int webView_runJavaScriptConfirmPanelWithMessage ( long sender , long messageID ) {
void webView_runOpenPanelForFileButtonWithResultListener ( long sender , long resultListenerID ) {
void webViewClose ( long sender ) {
long webView_contextMenuItemsForElement_defaultMenuItems ( long sender , long element , long defaultMenuItems ) {
void webView_setStatusBarVisible ( long sender , boolean visible ) {
void webView_setStatusText ( long sender , long textID ) {
void webView_setResizable ( long sender , boolean visible ) {
void webView_setToolbarsVisible ( long sender , boolean visible ) {
void webView_mouseDidMoveOverElement_modifierFlags ( long sender , long elementInformationID , long modifierFlags ) {
void webView_printFrameView ( long sender , long frameViewID ) {
void webView_decidePolicyForMIMEType_request_frame_decisionListener ( long sender , long type , long request , long frame , long listenerID ) {
void webView_decidePolicyForNavigationAction_request_frame_decisionListener ( long sender , long actionInformation , long request , long frame , long listenerID ) {
void webView_decidePolicyForNewWindowAction_request_newFrameName_decisionListener ( long sender , long actionInformation , long request , long frameName , long listenerID ) {
void webView_unableToImplementPolicyWithError_frame ( long sender , long error , long frame ) {
void download_decideDestinationWithSuggestedFilename ( long downloadId , long filename ) {
void handleEvent ( long evtId ) {
Object convertToJava ( long value ) {
long clazz = OS . objc_lookUpClass ( "str" ) ;
long ptr = number . objCType ( ) ;
long result = OS . objc_msgSend ( OS . class_NSNull , OS . sel_null ) ;
NSObject callJava ( long index , long token , long args , long arg1 ) {
long clazz = OS . objc_lookUpClass ( "str" ) ;
public long do_action ;
public long get_n_actions ;
public long get_description ;
public long get_name ;
public long get_keybinding ;
public long set_description ;
public nsIHttpChannel ( long address ) {
public int GetRequestMethod ( long aRequestMethod ) {
public int SetRequestMethod ( long aRequestMethod ) {
public int GetReferrer ( long [ ] aReferrer ) {
public int SetReferrer ( long aReferrer ) {
public int GetRequestHeader ( long aHeader , long _retval ) {
public int SetRequestHeader ( long aHeader , long aValue , int aMerge ) {
public int VisitRequestHeaders ( long aVisitor ) {
public int GetResponseStatusText ( long aResponseStatusText ) {
public int GetResponseHeader ( long header , long _retval ) {
public int SetResponseHeader ( long header , long value , int merge ) {
public int VisitResponseHeaders ( long aVisitor ) {
public NSThread ( long id ) {
long result = OS . objc_msgSend ( OS . class_NSThread , OS . sel_currentThread ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_threadDictionary ) ;
public long valueSize ;
public long value ;
public long get_current_value ;
public long get_maximum_value ;
public long get_minimum_value ;
public long set_current_value ;
public double [ ] handle ;
double [ ] rgbColor = color . handle ;
double [ ] rgbColor = new double [ 4 ] ;
public nsIPromptService2 ( long address ) {
public int PromptAuth ( long aParent , long aChannel , int level , long authInfo , char [ ] checkboxLabel , int [ ] checkValue , int [ ] _retval ) {
public int AsyncPromptAuth ( long aParent , long aChannel , long aCallback , long aContext , int level , long authInfo , char [ ] checkboxLabel , int [ ] checkValue , long [ ] _retval ) {
long getAddress ( ) {
int QueryInterface ( long riid , long ppvObject ) {
XPCOM . memmove ( ppvObject , new long [ ] { supports . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { factory . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
int CreateInstance ( long aOuter , long iid , long result ) {
XPCOM . memmove ( result , new long [ ] { helperAppLauncherDialog . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( result , new long [ ] { helperAppLauncherDialog . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( result , new long [ ] { helperAppLauncherDialog . getAddress ( ) } , C . PTR_SIZEOF ) ;
static long Drag_Data_Received ( long widget , long context , long x , long y , long data , long info , long time ) {
static long Drag_Drop ( long widget , long context , long x , long y , long time ) {
static long Drag_Leave ( long widget , long context , long time ) {
static long Drag_Motion ( long widget , long context , long x , long y , long time ) {
static DropTarget FindDropTarget ( long handle ) {
void drag_data_received ( long widget , long context , int x , int y , long data , int info , int time ) {
boolean drag_drop ( long widget , long context , int x , int y , int time ) {
void drag_leave ( long widget , long context , int time ) {
boolean drag_motion ( long widget , long context , int x , int y , int time ) {
long pTargets = OS . g_malloc ( targets . length * GtkTargetEntry . sizeof ) ;
long entryHandle = OS . gtk_bin_get_child ( control . handle ) ;
boolean setEventData ( long context , int x , int y , int time , DNDEvent event ) {
long pData = OS . g_list_nth ( dragContext . targets , i ) ;
void changeColor ( long id , long sel , long sender ) {
long jniRef = OS . NewGlobalRef ( this ) ;
double [ ] handle = display . getNSColorRGB ( color ) ;
double [ ] handle = display . getNSColorRGB ( colorList . colorWithKey ( key ) ) ;
void windowWillClose ( long id , long sel , long sender ) {
public nsIXPConnect ( long address ) {
public int JSValToVariant ( long cx , long aJSVal , long [ ] _retval ) {
public int VariantToJS ( long ctx , long scope , long value , long _retval ) {
public NSStatusBar ( long id ) {
long result = OS . objc_msgSend ( OS . class_NSStatusBar , OS . sel_systemStatusBar ) ;
public NSMutableIndexSet ( long id ) {
public void addIndex ( long value ) {
public void removeIndex ( long value ) {
public nsIInputStream ( long address ) {
public int ReadSegments ( long aWriter , long aClosure , int aCount , int [ ] _retval ) {
public long hPalette = 0 ;
long [ ] scripts ;
long [ ] token = new long [ 1 ] ;
long hDC = internal_new_GC ( null ) ;
long oldFont = OS . SelectObject ( hDC , hFont ) ;
long EnumFontFamProc ( long lpelfe , long lpntme , long FontType , long lParam ) {
long hDC = internal_new_GC ( null ) ;
long hDC = internal_new_GC ( null ) ;
long hDC = internal_new_GC ( null ) ;
long lpEnumFontFamProc = callback . getAddress ( ) ;
long hDC = internal_new_GC ( null ) ;
long [ ] buffer = new long [ 1 ] ;
long hFont = OS . GetStockObject ( OS . SYSTEM_FONT ) ;
long [ ] ppSp = new long [ 1 ] ;
scripts = new long [ piNumScripts [ 0 ] ] ;
long hDC = internal_new_GC ( null ) ;
public abstract long internal_new_GC ( GCData data ) ;
public abstract void internal_dispose_GC ( long hDC , GCData data ) ;
public DOMKeyboardEvent ( long id ) {
public nsIWebBrowserFocus ( long address ) {
public int GetFocusedWindow ( long [ ] aFocusedWindow ) {
public int SetFocusedWindow ( long aFocusedWindow ) {
public int GetFocusedElement ( long [ ] aFocusedElement ) {
public int SetFocusedElement ( long aFocusedElement ) {
public nsIWebProgressListener2 ( long address ) {
public int OnProgressChange64 ( long aWebProgress , long aRequest , long aCurSelfProgress , long aMaxSelfProgress , long aCurTotalProgress , long aMaxTotalProgress ) {
public NSAssertionHandler ( long id ) {
long result = OS . objc_msgSend ( OS . class_NSAssertionHandler , OS . sel_currentHandler ) ;
public void handleFailureInFunction ( NSString functionName , NSString fileName , long line , NSString format ) {
public void handleFailureInMethod ( long selector , id object , NSString fileName , long line , NSString format ) {
public WebView ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_initWithFrame_frameName_groupName_ , frame , frameName ! = null ? frameName . id : 0 , groupName ! = null ? groupName . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_mainFrame ) ;
long callWindowProc ( long hwnd , int msg , long wParam , long lParam ) {
long scrolledHandle = scrolledHandle ( ) ;
long hwnd = scrolledHandle ( ) ;
long scrolledHandle = scrolledHandle ( ) ;
long scrolledHandle ( ) {
long windowProc ( ) {
LRESULT WM_HSCROLL ( long wParam , long lParam ) {
LRESULT WM_MOUSEWHEEL ( long wParam , long lParam ) {
LRESULT WM_VSCROLL ( long wParam , long lParam ) {
LRESULT wmNCPaint ( long hwnd , long wParam , long lParam ) {
long hDC = OS . GetWindowDC ( hwnd ) ;
long hwndScroll = shell . scrolledHandle ( ) ;
LRESULT wmScrollWheel ( boolean update , long wParam , long lParam ) {
long code = callWindowProc ( handle , OS . WM_MOUSEWHEEL , wParam , lParam ) ;
LRESULT wmScroll ( ScrollBar bar , boolean update , long hwnd , int msg , long wParam , long lParam ) {
long code = callWindowProc ( hwnd , msg , wParam , lParam ) ;
public long lpOFN ;
public long pszFile ;
public NSURLAuthenticationChallenge ( long id ) {
public long previousFailureCount ( ) {
long result = OS . objc_msgSend ( this . id , OS . sel_proposedCredential ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_protectionSpace ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_sender ) ;
public long serial ;
public long display ;
public long window ;
public long hwndClient ;
long window = gtk_widget_get_window ( parent . scrolledHandle ) ;
long window = gtk_widget_get_window ( parent . scrolledHandle ) ;
long scrolledHandle = parent . scrolledHandle ;
long gtk_change_value ( long widget , long scroll , long value1 , long value2 ) {
void gtk_range_get_slider_range ( long widget , int [ ] slider_start , int [ ] slider_end ) {
long gtk_value_changed ( long adjustment ) {
long gtk_event_after ( long widget , long gdkEvent ) {
public NSUserDefaults ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_objectForKey_ , defaultName ! = null ? defaultName . id : 0 ) ;
long result = OS . objc_msgSend ( OS . class_NSUserDefaults , OS . sel_standardUserDefaults ) ;
public NSImageView ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_image ) ;
public void setImageAlignment ( long newAlign ) {
public void setImageScaling ( long newScaling ) {
public static long cellClass ( ) {
public static void setCellClass ( long factoryId ) {
public IOleControl ( long address ) {
long [ ] encoding = new long [ 1 ] ;
long [ ] ctext = new long [ 1 ] ;
long pValue = OS . g_malloc ( utf8 . length ) ;
long string_target = OS . gdk_utf8_to_string_target ( utf8 ) ;
long [ ] list = new long [ 1 ] ;
long [ ] ptr = new long [ 1 ] ;
public WebScriptObject ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_webScriptValueAtIndex_ , index ) ;
public nsIDirectoryService ( long address ) {
public int RegisterProvider ( long prov ) {
public int UnregisterProvider ( long prov ) {
public NSBitmapImageRep ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_TIFFRepresentation ) ;
public long bitmapData ( ) {
public long bitmapFormat ( ) {
public long bitsPerPixel ( ) {
public long bytesPerPlane ( ) {
public long bytesPerRow ( ) {
public void getBitmapDataPlanes ( long [ ] data ) {
long result = OS . objc_msgSend ( OS . class_NSBitmapImageRep , OS . sel_imageRepWithData_ , data ! = null ? data . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_initWithData_ , data ! = null ? data . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_initWithFocusedViewRect_ , rect ) ;
public long numberOfPlanes ( ) {
public long samplesPerPixel ( ) {
public long hwndCombo ;
public long hwndItem ;
public long hwndList ;
public IWebView ( long address ) {
public int canShowMIMEType ( long mimeType , int [ ] canShow ) {
public int initWithFrame ( RECT frame , long frameName , long groupName ) {
public int setUIDelegate ( long delegate ) {
public int setResourceLoadDelegate ( long delegate ) {
public int setDownloadDelegate ( long delegate ) {
public int setFrameLoadDelegate ( long delegate ) {
public int setPolicyDelegate ( long delegate ) {
public int mainFrame ( long [ ] frame ) {
public int setCustomUserAgent ( long valueString ) {
public int setPreferences ( long prefs ) {
public int preferences ( long [ ] prefs ) {
public int setHostWindow ( long window ) {
public int hostWindow ( long [ ] window ) {
public int estimatedProgress ( long estimatedProgress ) {
public long hwndLastFocus ;
long callWindowProc ( long hwnd , int msg , long wParam , long lParam ) {
long hCurrentFont = 0 , oldFont = 0 ;
void drawThemeBackground ( long hDC , long hwnd , RECT rect ) {
long hTheme = 0 ;
long hCurrentFont = 0 , oldFont = 0 ;
long windowProc ( ) {
LRESULT WM_KEYDOWN ( long wParam , long lParam ) {
LRESULT WM_KILLFOCUS ( long wParam , long lParam ) {
LRESULT WM_LBUTTONDOWN ( long wParam , long lParam ) {
LRESULT WM_LBUTTONUP ( long wParam , long lParam ) {
LRESULT WM_MOUSELEAVE ( long wParam , long lParam ) {
LRESULT WM_MOUSEMOVE ( long wParam , long lParam ) {
LRESULT WM_MOUSEWHEEL ( long wParam , long lParam ) {
LRESULT WM_PAINT ( long wParam , long lParam ) {
LRESULT WM_PRINTCLIENT ( long wParam , long lParam ) {
LRESULT WM_SETCURSOR ( long wParam , long lParam ) {
long hCursor = OS . LoadCursor ( 0 , OS . IDC_HAND ) ;
LRESULT WM_SETFOCUS ( long wParam , long lParam ) {
LRESULT WM_SIZE ( long wParam , long lParam ) {
LRESULT wmScroll ( ScrollBar bar , boolean update , long hwnd , int msg , long wParam , long lParam ) {
long hwnd = OS . GetFocus ( ) ;
long ownerHwnd = OS . GetWindow ( hwnd , OS . GW_OWNER ) ;
long address = callback . getAddress ( ) ;
final long hHook = OS . SetWindowsHookEx ( OS . WH_GETMESSAGE , address , 0 , threadId ) ;
static long getMsgProc ( long code , long wParam , long lParam ) {
long hwnd = msg . hwnd ;
long hwndOld = msg . hwnd ;
public long method14 ( long [ ] args ) { return TranslateAccelerator ( args [ 0 ] , ( int ) args [ 1 ] ) ; }
private int GetBorder ( long lprectBorder ) {
long getIOleInPlaceFrame ( ) {
private int GetWindow ( long phwnd ) {
COM . MoveMemory ( phwnd , new long [ ] { handle } , OS . PTR_SIZEOF ) ;
private int InsertMenus ( long hmenuShared , long lpMenuWidths ) {
long hMenu = menubar . handle ;
long hHeap = OS . GetProcessHeap ( ) ;
long pszText = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount ) ;
private int QueryInterface ( long riid , long ppvObject ) {
COM . MoveMemory ( ppvObject , new long [ ] { iOleInPlaceFrame . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
private int RemoveMenus ( long hmenuShared ) {
long hMenu = menubar . handle ;
long id = getMenuItemID ( hMenu , index ) ;
long id = getMenuItemID ( hMenu , index ) ;
long id = getMenuItemID ( hMenu , index ) ;
long id = getMenuItemID ( hmenuShared , i ) ;
private int RequestBorderSpace ( long pborderwidths ) {
int SetActiveObject ( long pActiveObject , long pszObjName ) {
private int SetBorderSpace ( long pborderwidths ) {
long handle = menubar . getShell ( ) . handle ;
private int TranslateAccelerator ( long lpmsg , int wID ) {
public long hItemHandle ;
long topHandle = getParent ( ) . handle ;
long printer = Printer . gtkPrinterFromPrinterData ( printerData ) ;
long group = OS . gtk_window_get_group ( 0 ) ;
long hookId = 0 ;
long printer = OS . gtk_print_unix_dialog_get_selected_printer ( handle ) ;
long page_ranges = OS . gtk_print_settings_get_page_ranges ( settings , num_ranges ) ;
long address = OS . gtk_print_settings_get ( settings , OS . GTK_PRINT_SETTINGS_OUTPUT_URI ) ;
long GtkPrintSettingsFunc = printSettingsCallback . getAddress ( ) ;
long paper_size = OS . gtk_page_setup_get_paper_size ( page_setup ) ;
long GtkPrintSettingsFunc ( long key , long value , long data ) {
void storeBytes ( String key , long value ) {
public long klass ;
public static final native void memmove ( cairo_path_t dest , long src , long size ) ;
public static final native void memmove ( cairo_path_data_t dest , long src , long size ) ;
public static final native void memmove ( double [ ] dest , long src , long size ) ;
public nsIX509Cert ( long address ) {
public int GetNickname ( long aNickname ) {
public int GetEmailAddress ( long aEmailAddress ) {
public int GetEmailAddresses ( int [ ] length , long [ ] addresses ) {
public int ContainsEmailAddress ( long aEmailAddress , int [ ] _retval ) {
public int GetSubjectName ( long aSubjectName ) {
public int GetCommonName ( long aCommonName ) {
public int GetOrganization ( long aOrganization ) {
public int GetOrganizationalUnit ( long aOrganizationalUnit ) {
public int GetSha1Fingerprint ( long aSha1Fingerprint ) {
public int GetMd5Fingerprint ( long aMd5Fingerprint ) {
public int GetTokenName ( long aTokenName ) {
public int GetIssuerName ( long aIssuerName ) {
public int GetSerialNumber ( long aSerialNumber ) {
public int GetIssuerCommonName ( long aIssuerCommonName ) {
public int GetIssuerOrganization ( long aIssuerOrganization ) {
public int GetIssuerOrganizationUnit ( long aIssuerOrganizationUnit ) {
public int GetIssuer ( long [ ] aIssuer ) {
public int GetValidity ( long [ ] aValidity ) {
public int GetDbKey ( long [ ] aDbKey ) {
public int GetWindowTitle ( long [ ] aWindowTitle ) {
public int GetChain ( long [ ] _retval ) {
public int GetUsagesArray ( int ignoreOcsp , int [ ] verified , int [ ] count , long [ ] usages ) {
public int GetUsagesString ( int ignoreOcsp , int [ ] verified , long usages ) {
public int GetASN1Structure ( long [ ] aASN1Structure ) {
public int GetRawDER ( int [ ] length , long [ ] data ) {
public int Equals ( long other , int [ ] _retval ) {
public NSTextTab ( long id ) {
public long tabStopType ( ) {
public IAccessible ( long address ) {
public int get_accParent ( long ppdispParent ) {
public int get_accChildCount ( long pcountChildren ) {
public int get_accChild ( long variant , long ppdispChild ) {
public int get_accName ( long variant , long pszName ) {
public int get_accValue ( long variant , long pszValue ) {
public int get_accDescription ( long variant , long pszDescription ) {
public int get_accRole ( long variant , long pvarRole ) {
public int get_accState ( long variant , long pvarState ) {
public int get_accHelp ( long variant , long pszHelp ) {
public int get_accHelpTopic ( long pszHelpFile , long variant , long pidTopic ) {
public int get_accKeyboardShortcut ( long variant , long pszKeyboardShortcut ) {
public int get_accFocus ( long pvarChild ) {
public int get_accSelection ( long pvarChildren ) {
public int get_accDefaultAction ( long variant , long pszDefaultAction ) {
public int accSelect ( int flagsSelect , long variant ) {
public int accLocation ( long pxLeft , long pyTop , long pcxWidth , long pcyHeight , long variant ) {
public int accNavigate ( int navDir , long variant , long pvarEndUpAt ) {
public int accHitTest ( int xLeft , int yTop , long pvarChild ) {
public int accDoDefaultAction ( long variant ) {
public int put_accName ( long variant , long szName ) {
public int put_accValue ( long variant , long szValue ) {
long [ ] result = new long [ 1 ] ;
long getAddress ( ) {
int QueryInterface ( long riid , long ppvObject ) {
XPCOM . memmove ( ppvObject , new long [ ] { supports . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { directoryServiceProvider . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { directoryServiceProvider2 . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
int getFiles ( long prop , long _retval ) {
long ptr = C . getenv ( MozillaDelegate . wcsToMbcs ( null , XPCOM . MOZILLA_PLUGIN_PATH , true ) ) ;
XPCOM . memmove ( _retval , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
long [ ] result = new long [ 1 ] ;
XPCOM . memmove ( _retval , new long [ ] { enumerator . getAddress ( ) } , C . PTR_SIZEOF ) ;
int getFile ( long prop , long persistent , long _retval ) {
XPCOM . memmove ( _retval , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
long [ ] result = new long [ 1 ] ;
XPCOM . memmove ( _retval , new long [ ] { result [ 0 ] } , C . PTR_SIZEOF ) ;
public long ptd ;
public NSMutableParagraphStyle ( long id ) {
public void setAlignment ( long alignment ) {
public void setBaseWritingDirection ( long writingDirection ) {
public void setDefaultTabInterval ( double aFloat ) {
public void setFirstLineHeadIndent ( double aFloat ) {
public void setHeadIndent ( double aFloat ) {
public void setLineBreakMode ( long mode ) {
public void setLineSpacing ( double aFloat ) {
public IMoniker ( long address ) {
public long hSubMenu ;
public long hbmpChecked ;
public long dwTypeData ;
public long hbmpItem ;
public static void addLanguageListener ( long hwnd , Runnable runnable ) {
public static void removeLanguageListener ( long hwnd ) {
public static boolean setOrientation ( long hwnd , int orientation ) {
public DOMUIEvent ( long id ) {
long pixbuf = ImageList . createPixbuf ( image ) ;
long loader = OS . gdk_pixbuf_loader_new ( ) ;
long pixbuf = OS . gdk_pixbuf_loader_get_pixbuf ( loader ) ;
public long method9 ( long [ ] args ) {
public long method9 ( long [ ] args ) {
long getAddress ( ) {
int QueryInterface ( long riid , long ppvObject ) {
XPCOM . memmove ( ppvObject , new long [ ] { supports . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { download . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { progressDialog . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { webProgressListener . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
int Init_32 ( long aSource , long aTarget , long aDisplayName , long aMIMEInfo , long startTime1 , long startTime2 , long aTempFile , long aCancelable ) {
int Init ( long aSource , long aTarget , long aDisplayName , long aMIMEInfo , long startTime , long aTempFile , long aCancelable ) {
long aSpec = XPCOM . nsEmbedCString_new ( ) ;
long buffer = XPCOM . nsEmbedCString_get ( aSpec ) ;
long aPath = XPCOM . nsEmbedCString_new ( ) ;
int GetAmountTransferred ( long arg0 ) {
int GetCancelable ( long arg0 ) {
int GetDisplayName ( long aDisplayName ) {
int GetMIMEInfo ( long aMIMEInfo ) {
int GetPercentComplete ( long aPercentComplete ) {
int GetSize ( long arg0 ) {
int GetSource ( long aSource ) {
int GetStartTime ( long aStartTime ) {
int GetTarget ( long aTarget ) {
int GetTargetFile ( long arg0 ) {
int GetCancelDownloadOnClose ( long aCancelDownloadOnClose ) {
int GetDialog ( long aDialog ) {
int GetObserver ( long aObserver ) {
int Open ( long aParent ) {
int SetDialog ( long aDialog ) {
int SetObserver ( long aObserver ) {
int OnLocationChange ( long aWebProgress , long aRequest , long aLocation ) {
int OnProgressChange ( long aWebProgress , long aRequest , int aCurSelfProgress , int aMaxSelfProgress , int aCurTotalProgress , int aMaxTotalProgress ) {
int OnProgressChange64_32 ( long aWebProgress , long aRequest , long aCurSelfProgress1 , long aCurSelfProgress2 , long aMaxSelfProgress1 , long aMaxSelfProgress2 , long aCurTotalProgress1 , long aCurTotalProgress2 , long aMaxTotalProgress1 , long aMaxTotalProgress2 ) {
int OnProgressChange64 ( long aWebProgress , long aRequest , long aCurSelfProgress , long aMaxSelfProgress , long aCurTotalProgress , long aMaxTotalProgress ) {
int OnSecurityChange ( long aWebProgress , long aRequest , int state ) {
int OnStateChange ( long aWebProgress , long aRequest , int aStateFlags , int aStatus ) {
int OnStatusChange ( long aWebProgress , long aRequest , int aStatus , long aMessage ) {
long drawable = gc . getGCData ( ) . drawable ;
long default_border_ptr = theme . getBorderProperty ( buttonHandle , "str" ) ;
long default_outside_border_ptr = theme . getBorderProperty ( buttonHandle , "str" ) ;
public NSTextContainer ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_initWithContainerSize_ , size ) ;
public void setLineFragmentPadding ( double pad ) {
public WebOpenPanelResultListener ( long id ) {
public nsIDOMKeyEvent ( long address ) {
public int InitKeyEvent ( long typeArg , int canBubbleArg , int cancelableArg , long viewArg , int ctrlKeyArg , int altKeyArg , int shiftKeyArg , int metaKeyArg , int keyCodeArg , int charCodeArg ) {
public long lpReserved ;
public long lpDesktop ;
public long lpTitle ;
public long lpReserved2 ;
public long hStdInput ;
public long hStdOutput ;
public long hStdError ;
long address , errorResult ;
public Callback ( Object object , String method , int argCount , boolean isArrayBased , long errorResult ) {
static native synchronized long bind ( Callback callback , Object object , String method , String signature , int argCount , boolean isStatic , boolean isArrayBased , long errorResult ) ;
public long getAddress ( ) {
public long hwndOwner ;
public long hInstance ;
public long lpstrFilter ;
public long lpstrCustomFilter ;
public long lpstrFile ;
public long lpstrFileTitle ;
public long lpstrInitialDir ;
public long lpstrTitle ;
public long lpfnHook ;
public long lpTemplateName ;
public long pvReserved ;
public IOleDocument ( long address ) {
public int CreateView ( long pIPSite , long pstm , int dwReserved , long [ ] ppView ) {
public IWebOpenPanelResultListener ( long address ) {
public int chooseFilename ( long fileName ) {
long settings = printInfo . PMPrintSettings ( ) ;
long jniRef = OS . NewGlobalRef ( this ) ;
long settings = printInfo . PMPrintSettings ( ) ;
long dialogProc5 = dialogCallback5 . getAddress ( ) ;
long cls = OS . objc_allocateClassPair ( OS . class_NSObject , className , 0 ) ;
void panelDidEnd_returnCode_contextInfo ( long id , long sel , long alert , long returnCode , long contextInfo ) {
long getAddress ( ) {
int QueryInterface ( long iid , long ppvObject ) {
COM . MoveMemory ( ppvObject , new long [ ] { getAddress ( ) } , OS . PTR_SIZEOF ) ;
int get_relationType ( long pbstrRelationType ) {
int get_localizedRelationType ( long pbstrLocalizedRelationType ) {
int get_nTargets ( long pNTargets ) {
int get_target ( int targetIndex , long ppTarget ) {
COM . MoveMemory ( ppTarget , new long [ ] { target . getAddress ( ) } , OS . PTR_SIZEOF ) ;
int get_targets ( int maxTargets , long ppTargets , long pNTargets ) {
COM . MoveMemory ( ppTargets + i * OS . PTR_SIZEOF , new long [ ] { target . getAddress ( ) } , OS . PTR_SIZEOF ) ;
void setString ( long psz , String string ) {
long lpMultiByteStr = OS . GlobalAlloc ( OS . GMEM_FIXED | OS . GMEM_ZEROINIT , cchMultiByte ) ;
long hMem = stgmedium . unionField ;
long lpMultiByteStr = OS . GlobalLock ( hMem ) ;
static Browser findBrowser ( long handle ) {
long getHandle ( ) {
long getSiteWindow ( ) {
void onDispose ( long embedHandle ) {
void setSize ( long embedHandle , int width , int height ) {
public long widget ;
long oldBrush = OS . SelectObject ( hDC , OS . GetSysColorBrush ( OS . COLOR_BTNFACE ) ) ;
int getPreferredWidth ( long hTheme , long hDC ) {
long parentHandle = parent . handle ;
long modelHandle , checkRenderer ;
TreeItem _getItem ( long iter ) {
long path = OS . gtk_tree_model_get_path ( modelHandle , iter ) ;
long parentIter = 0 ;
int getId ( long iter , boolean queryModel ) {
long cellDataProc ( long tree_column , long cell , long tree_model , long iter , long data ) {
long [ ] ptr = new long [ 1 ] ;
int calculateWidth ( long column , long iter , boolean recurse ) {
long path = 0 ;
long list = 0 ;
long temp = list ;
long renderer = OS . g_list_data ( temp ) ;
long childIter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
void clearAll ( boolean all , long parentIter ) {
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long [ ] oldItems = new long [ OS . gtk_tree_model_iter_n_children ( oldModel , oldParent ) ] ;
long [ ] ptr = new long [ 1 ] ;
long newItem = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long oldItem = item . handle ;
long oldItem = oldItems [ i ] ;
copyModel ( oldModel , FIRST_COLUMN , newModel , FIRST_COLUMN , types , ( long ) 0 , ( long ) 0 , modelLength ) ;
long columnHandle = OS . gtk_tree_view_column_new ( ) ;
long [ ] types = getColumnTypes ( 1 ) ;
long selectionHandle = OS . gtk_tree_view_get_selection ( handle ) ;
long boxHandle = gtk_box_new ( OS . GTK_ORIENTATION_HORIZONTAL , false , 3 ) ;
long labelHandle = OS . gtk_label_new_with_mnemonic ( null ) ;
long imageHandle = OS . gtk_image_new ( ) ;
long widget = OS . gtk_widget_get_parent ( boxHandle ) ;
void createItem ( TreeItem item , long parentIter , int index ) {
void createRenderers ( long columnHandle , int modelIndex , boolean check , int columnStyle ) {
long pixbufRenderer = ownerDraw ? OS . g_object_new ( display . gtk_cell_renderer_pixbuf_get_type ( ) , 0 ) : OS . gtk_cell_renderer_pixbuf_new ( ) ;
long textRenderer = ownerDraw ? OS . g_object_new ( display . gtk_cell_renderer_text_get_type ( ) , 0 ) : OS . gtk_cell_renderer_text_new ( ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long columnHandle = column . handle ;
copyModel ( oldModel , column . modelIndex , newModel , FIRST_COLUMN , types , ( long ) 0 , ( long ) 0 , FIRST_COLUMN + CELL_TYPES ) ;
long iter = item . handle ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long [ ] path = new long [ 1 ] ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long eventWindow ( ) {
long clientHandle = clientHandle ( ) ;
long list = OS . gtk_tree_view_get_columns ( handle ) ;
long temp = list ;
long column = OS . g_list_data ( temp ) ;
long [ ] path = new long [ 1 ] ;
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long buttonHandle = columns [ i ] . buttonHandle ;
long [ ] path = new long [ 1 ] ;
long [ ] columnHandle = new long [ 1 ] ;
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long column = OS . gtk_tree_view_get_column ( handle , 0 ) ;
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long column = OS . gtk_tree_view_get_column ( handle , i ) ;
TreeItem [ ] getItems ( long parent ) {
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long pixbufRenderer = 0 ;
long renderer = OS . g_list_nth_data ( list , i ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long textRenderer = 0 ;
long renderer = OS . g_list_nth_data ( list , i ) ;
long [ ] path = new long [ 1 ] ;
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long gtk_button_press_event ( long widget , long event ) {
long result = super . gtk_button_press_event ( widget , event ) ;
long [ ] path = new long [ 1 ] ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long [ ] path = new long [ 1 ] ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long gtk_changed ( long widget ) {
long gtk_event_after ( long widget , long gdkEvent ) {
long gtk_expand_collapse_cursor_row ( long widget , long logical , long expand , long open_all ) {
long gtk_expose_event ( long widget , long eventPtr ) {
long window = OS . gtk_tree_view_get_bin_window ( handle ) ;
long parent = 0 ;
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long path = OS . gtk_tree_model_get_path ( modelHandle , iter ) ;
long gtk_row_activated ( long tree , long path , long column ) {
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long gtk_row_deleted ( long model , long path ) {
long gtk_row_inserted ( long model , long path , long iter ) {
long gtk_start_interactive_search ( long widget ) {
long gtk_test_collapse_row ( long tree , long iter , long path ) {
long gtk_test_expand_row ( long tree , long iter , long path ) {
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
void gtk_widget_size_request ( long widget , GtkRequisition requisition ) {
long columns = OS . gtk_tree_view_get_columns ( handle ) , list = columns ;
long column = OS . g_list_data ( list ) ;
long columnHandle = 0 ;
long firstColumn = OS . gtk_tree_view_get_column ( handle , 0 ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long path = OS . gtk_tree_model_get_path ( modelHandle , item . handle ) ;
long indices = OS . gtk_tree_path_get_indices ( path ) ;
long labelHandle = columns [ i ] . labelHandle ;
long labelHandle = columns [ i ] . labelHandle ;
long paintWindow ( ) {
void releaseItems ( long parentIter ) {
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
void remove ( long parentIter , int start , int end ) {
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long iter = OS . g_object_get_qdata ( cell , Display . SWT_OBJECT_INDEX2 ) ;
long columnHandle = OS . g_object_get_qdata ( cell , Display . SWT_OBJECT_INDEX1 ) ;
long rendererRenderProc ( long cell , long window , long widget , long background_area , long cell_area , long expose_area , long flags ) {
long iter = OS . g_object_get_qdata ( cell , Display . SWT_OBJECT_INDEX2 ) ;
long columnHandle = OS . g_object_get_qdata ( cell , Display . SWT_OBJECT_INDEX1 ) ;
long [ ] ptr = new long [ 1 ] ;
long path = OS . gtk_tree_model_get_path ( modelHandle , iter ) ;
long textRenderer = getTextRenderer ( columnHandle ) ;
long style = OS . gtk_widget_get_style ( widget ) ;
long result = 0 ;
long g_class = OS . g_type_class_peek_parent ( OS . G_OBJECT_GET_CLASS ( cell ) ) ;
long path = OS . gtk_tree_model_get_path ( modelHandle , iter ) ;
long [ ] path = new long [ 1 ] ;
void setItemCount ( long parentIter , int count ) {
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long baseColumn = 0 ;
long column = columns [ order [ i ] ] . handle ;
void setFontDescription ( long font ) {
void setModel ( long newModel ) {
void setScrollWidth ( long column , TreeItem item ) {
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long path = OS . gtk_tree_model_get_path ( modelHandle , item . handle ) ;
long path = OS . gtk_tree_model_get_path ( modelHandle , item . handle ) ;
long column = OS . gtk_tree_view_get_column ( handle , i ) ;
long firstColumn = OS . gtk_tree_view_get_column ( handle , 0 ) ;
void showItem ( long path , boolean scroll ) {
long indicesPtr = OS . gtk_tree_path_get_indices ( path ) ;
long tempPath = OS . gtk_tree_path_new ( ) ;
long path = OS . gtk_tree_model_get_path ( modelHandle , item . handle ) ;
long temp = list ;
long widget = OS . g_list_data ( temp ) ;
long windowProc ( long handle , long arg0 , long user_data ) {
long window = OS . gtk_tree_view_get_bin_window ( handle ) ;
public long colorsel ;
public long ok_button ;
public long cancel_button ;
public long help_button ;
double scaleFactor = window . userSpaceScaleFactor ( ) ;
long keyMask = nsItem . keyEquivalentModifierMask ( ) ;
long keyEquiv = 0 ;
void menu_willHighlightItem ( long id , long sel , long menu , long itemID ) {
void menuNeedsUpdate ( long id , long sel , long menu ) {
void menuWillOpen ( long id , long sel , long menu ) {
double width = 0 ;
double w = GAP ;
double tab = width ;
void menuDidClose ( long id , long sel , long menu ) {
public IWebURLCredential ( long address ) {
public int initWithUser ( long user , long password , long persistence ) {
public int password ( long [ ] password ) {
public int user ( long [ ] result ) {
public nsIFile ( long address ) {
public int Append ( long node ) {
public int AppendNative ( long node ) {
public int GetLeafName ( long aLeafName ) {
public int SetLeafName ( long aLeafName ) {
public int GetNativeLeafName ( long aNativeLeafName ) {
public int SetNativeLeafName ( long aNativeLeafName ) {
public int CopyTo ( long newParentDir , long newName ) {
public int CopyToNative ( long newParentDir , long newName ) {
public int CopyToFollowingLinks ( long newParentDir , long newName ) {
public int CopyToFollowingLinksNative ( long newParentDir , long newName ) {
public int MoveTo ( long newParentDir , long newName ) {
public int MoveToNative ( long newParentDir , long newName ) {
public int GetTarget ( long aTarget ) {
public int GetNativeTarget ( long aNativeTarget ) {
public int GetPath ( long aPath ) {
public int GetNativePath ( long aNativePath ) {
public int Clone ( long [ ] _retval ) {
public int Equals ( long inFile , int [ ] _retval ) {
public int Contains ( long inFile , int recur , int [ ] _retval ) {
public int GetParent ( long [ ] aParent ) {
public int GetDirectoryEntries ( long [ ] aDirectoryEntries ) {
public NSScroller ( long id ) {
public long controlSize ( ) {
public long hitPart ( ) {
public NSRect rectForPart ( long partCode ) {
public void setControlSize ( long controlSize ) {
public void setKnobProportion ( double proportion ) {
public long testPart ( NSPoint thePoint ) {
public static long cellClass ( ) {
public static void setCellClass ( long factoryId ) {
AccessibleObject ( long type , long widget , Accessible accessible , boolean isLightweight ) {
static AtkActionIface getActionIface ( long atkObject ) {
static long atkAction_do_action ( long atkObject , long index ) {
long parentResult = 0 ;
static long atkAction_get_n_actions ( long atkObject ) {
long parentResult = 0 ;
static long atkAction_get_description ( long atkObject , long index ) {
long parentResult = 0 ;
static long atkAction_get_keybinding ( long atkObject , long index ) {
long parentResult = 0 ;
static long atkAction_get_name ( long atkObject , long index ) {
long parentResult = 0 ;
static AtkComponentIface getComponentIface ( long atkObject ) {
static long atkComponent_get_extents ( long atkObject , long x , long y , long width , long height , long coord_type ) {
static long atkComponent_get_position ( long atkObject , long x , long y , long coord_type ) {
static long atkComponent_get_size ( long atkObject , long width , long height , long coord_type ) {
static long atkComponent_ref_accessible_at_point ( long atkObject , long x , long y , long coord_type ) {
long parentResult = 0 ;
static AtkEditableTextIface getEditableTextIface ( long atkObject ) {
static long atkEditableText_set_run_attributes ( long atkObject , long attrib_set , long start_offset , long end_offset ) {
long fontDesc = OS . pango_font_description_new ( ) ;
long current = attrib_set ;
long attrPtr = OS . g_slist_data ( current ) ;
long parentResult = 0 ;
static long atkEditableText_set_text_contents ( long atkObject , long string ) {
long parentResult = 0 ;
static long atkEditableText_insert_text ( long atkObject , long string , long string_length , long position ) {
long parentResult = 0 ;
static long atkEditableText_copy_text ( long atkObject , long start_pos , long end_pos ) {
long parentResult = 0 ;
static long atkEditableText_cut_text ( long atkObject , long start_pos , long end_pos ) {
long parentResult = 0 ;
static long atkEditableText_delete_text ( long atkObject , long start_pos , long end_pos ) {
long parentResult = 0 ;
static long atkEditableText_paste_text ( long atkObject , long position ) {
long parentResult = 0 ;
static AtkHypertextIface getHypertextIface ( long atkObject ) {
static long atkHypertext_get_link ( long atkObject , long link_index ) {
long parentResult = 0 ;
static long atkHypertext_get_n_links ( long atkObject ) {
long parentResult = 0 ;
static long atkHypertext_get_link_index ( long atkObject , long char_index ) {
long parentResult = 0 ;
static AtkObjectClass getObjectClass ( long atkObject ) {
static long atkObject_get_description ( long atkObject ) {
long parentResult = 0 ;
static long atkObject_get_attributes ( long atkObject ) {
long parentResult = 0 ;
long attrPtr = OS . g_malloc ( AtkAttribute . sizeof ) ;
long attrPtr = OS . g_malloc ( AtkAttribute . sizeof ) ;
long attrPtr = OS . g_malloc ( AtkAttribute . sizeof ) ;
long attrPtr = OS . g_malloc ( AtkAttribute . sizeof ) ;
long attrPtr = OS . g_malloc ( AtkAttribute . sizeof ) ;
long attrPtr = OS . g_malloc ( AtkAttribute . sizeof ) ;
long attrPtr = OS . g_malloc ( AtkAttribute . sizeof ) ;
long attrPtr = OS . g_malloc ( AtkAttribute . sizeof ) ;
static long atkObject_get_name ( long atkObject ) {
long parentResult = 0 ;
static long atkObject_get_n_children ( long atkObject ) {
long parentResult = 0 ;
static long atkObject_get_index_in_parent ( long atkObject ) {
long result = ATK . call ( objectClass . get_index_in_parent , atkObject ) ;
static long atkObject_get_parent ( long atkObject ) {
long parentResult = ATK . call ( objectClass . get_parent , atkObject ) ;
static long atkObject_get_role ( long atkObject ) {
static long atkObject_ref_child ( long atkObject , long index ) {
static long atkObject_ref_state_set ( long atkObject ) {
long parentResult = 0 ;
long set = parentResult ;
static AtkSelectionIface getSelectionIface ( long atkObject ) {
static long atkSelection_is_child_selected ( long atkObject , long index ) {
long parentResult = 0 ;
static long atkSelection_ref_selection ( long atkObject , long index ) {
long parentResult = 0 ;
static AtkTableIface getTableIface ( long atkObject ) {
static long atkTable_ref_at ( long atkObject , long row , long column ) {
long parentResult = 0 ;
static long atkTable_get_index_at ( long atkObject , long row , long column ) {
long parentResult = 0 ;
static long atkTable_get_column_at_index ( long atkObject , long index ) {
long result = event . count = = 0 ? - 1 : index % event . count ;
long parentResult = 0 ;
static long atkTable_get_row_at_index ( long atkObject , long index ) {
long result = event . count = = 0 ? - 1 : index / event . count ;
long parentResult = 0 ;
static long atkTable_get_n_columns ( long atkObject ) {
long parentResult = 0 ;
static long atkTable_get_n_rows ( long atkObject ) {
long parentResult = 0 ;
static long atkTable_get_column_extent_at ( long atkObject , long row , long column ) {
long parentResult = 0 ;
static long atkTable_get_row_extent_at ( long atkObject , long row , long column ) {
long parentResult = 0 ;
static long atkTable_get_caption ( long atkObject ) {
long parentResult = 0 ;
static long atkTable_get_summary ( long atkObject ) {
long parentResult = 0 ;
static long atkTable_get_column_description ( long atkObject , long column ) {
long parentResult = 0 ;
static long atkTable_get_column_header ( long atkObject , long column ) {
long parentResult = 0 ;
static long atkTable_get_row_description ( long atkObject , long row ) {
long parentResult = 0 ;
static long atkTable_get_row_header ( long atkObject , long row ) {
long parentResult = 0 ;
static long atkTable_get_selected_columns ( long atkObject , long selected ) {
long result = OS . g_malloc ( count * 4 ) ;
if ( selected ! = 0 ) OS . memmove ( selected , new long [ ] { result } , C . PTR_SIZEOF ) ;
long parentResult = 0 ;
static long atkTable_get_selected_rows ( long atkObject , long selected ) {
long result = OS . g_malloc ( count * 4 ) ;
if ( selected ! = 0 ) OS . memmove ( selected , new long [ ] { result } , C . PTR_SIZEOF ) ;
long parentResult = 0 ;
static long atkTable_is_column_selected ( long atkObject , long column ) {
long parentResult = 0 ;
static long atkTable_is_row_selected ( long atkObject , long row ) {
long parentResult = 0 ;
static long atkTable_is_selected ( long atkObject , long row , long column ) {
long parentResult = 0 ;
static long atkTable_add_row_selection ( long atkObject , long row ) {
long parentResult = 0 ;
static long atkTable_remove_row_selection ( long atkObject , long row ) {
long parentResult = 0 ;
static long atkTable_add_column_selection ( long atkObject , long column ) {
long parentResult = 0 ;
static long atkTable_remove_column_selection ( long atkObject , long column ) {
long parentResult = 0 ;
static AtkTextIface getTextIface ( long atkObject ) {
static long atkText_get_character_extents ( long atkObject , long offset , long x , long y , long width , long height , long coords ) {
static String getString ( long strPtr ) {
static long getStringPtr ( String str ) {
long ptr = OS . g_malloc ( buffer . length ) ;
static long atkText_get_range_extents ( long atkObject , long start_offset , long end_offset , long coord_type , long rect ) {
static long atkText_get_run_attributes ( long atkObject , long offset , long start_offset , long end_offset ) {
long result = 0 ;
long attrPtr = OS . g_malloc ( AtkAttribute . sizeof ) ;
long attrPtr = OS . g_malloc ( AtkAttribute . sizeof ) ;
long attrPtr = OS . g_malloc ( AtkAttribute . sizeof ) ;
long attrPtr = OS . g_malloc ( AtkAttribute . sizeof ) ;
long attrPtr = OS . g_malloc ( AtkAttribute . sizeof ) ;
long attrPtr = OS . g_malloc ( AtkAttribute . sizeof ) ;
long parentResult = 0 ;
static long atkText_get_offset_at_point ( long atkObject , long x , long y , long coords ) {
long parentResult = 0 ;
static long atkText_add_selection ( long atkObject , long start_offset , long end_offset ) {
long parentResult = 0 ;
static long atkText_remove_selection ( long atkObject , long selection_num ) {
long parentResult = 0 ;
static long atkText_set_caret_offset ( long atkObject , long offset ) {
static long atkText_set_selection ( long atkObject , long selection_num , long start_offset , long end_offset ) {
long parentResult = 0 ;
static long atkText_get_caret_offset ( long atkObject ) {
long parentResult = 0 ;
static long atkText_get_bounded_ranges ( long atkObject , long rect , long coord_type , long x_clip_type , long y_clip_type ) {
long result = OS . malloc ( size * AtkTextRange . sizeof ) ;
long parentResult = 0 ;
static long atkText_get_character_at_offset ( long atkObject , long offset ) {
static long atkText_get_character_count ( long atkObject ) {
static long atkText_get_n_selections ( long atkObject ) {
long parentResult = 0 ;
static long atkText_get_selection ( long atkObject , long selection_num , long start_offset , long end_offset ) {
long parentResult = 0 ;
static long atkText_get_text ( long atkObject , long start_offset , long end_offset ) {
static long atkText_get_text_after_offset ( long atkObject , long offset_value , long boundary_type , long start_offset , long end_offset ) {
long charCount = atkText_get_character_count ( atkObject ) ;
static long atkText_get_text_at_offset ( long atkObject , long offset_value , long boundary_type , long start_offset , long end_offset ) {
long charCount = atkText_get_character_count ( atkObject ) ;
static long atkText_get_text_before_offset ( long atkObject , long offset_value , long boundary_type , long start_offset , long end_offset ) {
long charCount = atkText_get_character_count ( atkObject ) ;
static void setGValue ( long value , Number number ) {
static AtkValueIface getValueIface ( long atkObject ) {
static long atkValue_get_current_value ( long atkObject , long value ) {
static long atkValue_get_maximum_value ( long atkObject , long value ) {
static long atkValue_get_minimum_value ( long atkObject , long value ) {
static long atkValue_set_current_value ( long atkObject , long value ) {
long parentResult = 0 ;
static AccessibleObject getAccessibleObject ( long atkObject ) {
long characterCount = ATK . call ( iface . get_character_count , handle ) ;
long parentResult = ATK . call ( iface . get_text , handle , 0 , characterCount ) ;
static long gObjectClass_finalize ( long atkObject ) {
public nsISeekableStream ( long address ) {
static long callJava ( long cx , long argc , long vp ) {
long argsPtr = vp + 2 * jsval_sizeof ;
long [ ] result = new long [ 1 ] ;
long tokenVariant = result [ 0 ] ;
long argsVariant = result [ 0 ] ;
long jsVal = memory . Alloc ( jsval_sizeof ) ;
long globalObject = XPCOM . JS_GetGlobalObject ( Mozilla . getJSLibPathBytes ( ) , cx ) ;
long returnValue = XPCOM . JS_FALSE ;
long doubleReturn = C . malloc ( 8 ) ;
long [ ] wString = new long [ 1 ] ;
long iid = C . malloc ( nsID . sizeof ) ;
long [ ] ptr = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long [ ] arrayPtr = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long arrayPtr = C . malloc ( C . PTR_SIZEOF * length ) ;
C . memmove ( arrayPtr + C . PTR_SIZEOF * i , new long [ ] { currentVariant . getAddress ( ) } , C . PTR_SIZEOF ) ;
long [ ] ptr = new long [ 1 ] ;
long idPtr = C . malloc ( nsID . sizeof ) ;
static long invokeFunction ( int functionId , long tokenVariant , long args ) {
long [ ] result = new long [ 1 ] ;
long getAddress ( ) {
int QueryInterface ( long riid , long ppvObject ) {
XPCOM . memmove ( ppvObject , new long [ ] { supports . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { classInfo . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { securityCheckedComponent . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { external . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { scriptObjectOwner . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
long ptr = memory . Alloc ( bytes . length ) ;
C . memmove ( _retValue , new long [ ] { ptr } , C . PTR_SIZEOF ) ;
int getClassID ( long _retValue ) {
int getClassIDNoAlloc ( long _retValue ) {
int getContractID ( long _retValue ) {
int getFlags ( long flags ) {
int getImplementationLanguage ( long _retValue ) {
long securityCheckedComponentIID = memory . Alloc ( nsID . sizeof ) ;
long externalIID = memory . Alloc ( nsID . sizeof ) ;
long asdfIID = memory . Alloc ( nsID . sizeof ) ;
C . memmove ( ptrArray + 2 * C . PTR_SIZEOF , new long [ ] { asdfIID } , C . PTR_SIZEOF ) ;
C . memmove ( array , new long [ ] { ptrArray } , C . PTR_SIZEOF ) ;
int getScriptObject ( long aContext , long aScriptObject ) {
XPCOM . memmove ( aScriptObject , new long [ ] { newObject } , C . PTR_SIZEOF ) ;
int setScriptObject ( long aScriptObject ) {
long ptr = memory . Alloc ( bytes . length ) ;
C . memmove ( _retVal , new long [ ] { ptr } , C . PTR_SIZEOF ) ;
long ptr = memory . Alloc ( bytes . length ) ;
C . memmove ( _retVal , new long [ ] { ptr } , C . PTR_SIZEOF ) ;
long ptr = memory . Alloc ( bytes . length ) ;
C . memmove ( _retVal , new long [ ] { ptr } , C . PTR_SIZEOF ) ;
long ptr = memory . Alloc ( bytes . length ) ;
C . memmove ( _retVal , new long [ ] { ptr } , C . PTR_SIZEOF ) ;
long [ ] phkResult = new long [ 1 ] ;
long [ ] phkResult = new long [ 1 ] ;
long hHeap = OS . GetProcessHeap ( ) ;
long lpFile = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount ) ;
long lpDirectory = 0 ;
long hHeap = OS . GetProcessHeap ( ) ;
long lpCommandLine = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount ) ;
long [ ] phiconSmall = new long [ 1 ] , phiconLarge = null ;
public long pbData ;
long clientHandle , boxHandle , labelHandle , imageHandle ;
long gtk_activate ( long widget ) {
long gtk_button_press_event ( long widget , long event ) {
long gtk_focus_out_event ( long widget , long event ) {
long gtk_size_allocate ( long widget , long allocation ) {
long gtk_enter_notify_event ( long widget , long event ) {
void setFontDescription ( long font ) {
long pixbuf = imageList . getPixbuf ( imageIndex ) ;
long windowProc ( long handle , long user_data ) {
static native final long getAWTHandle ( Object canvas ) ;
long handle = parent . embeddedHandle ;
long awtHandle = getAWTHandle ( window ) ;
long handle = 0 ;
public long serial ;
public long display ;
public long window ;
public long message_type ;
public long [ ] data = new long [ 5 ] ;
public long psz ;
public long lParam ;
public NSSearchField ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_recentSearches ) ;
public static long cellClass ( ) {
public static void setCellClass ( long factoryId ) {
long gdkEventKey = 0 ;
long mark = OS . gtk_text_buffer_get_insert ( bufferHandle ) ;
long ptr = OS . gtk_entry_get_text ( handle ) ;
long ptr = OS . gtk_text_buffer_get_text ( bufferHandle , startIter , endIter , true ) ;
long ptr = OS . gtk_entry_get_text ( handle ) ;
long ptr = OS . gtk_text_buffer_get_text ( bufferHandle , startIter , endIter , true ) ;
long layout = OS . gtk_entry_get_layout ( handle ) ;
long layout = OS . gtk_widget_create_pango_layout ( handle , buffer ) ;
long style = OS . gtk_widget_get_style ( handle ) ;
long clipboard = OS . gtk_clipboard_get ( OS . GDK_NONE ) ;
long clipboard = OS . gtk_clipboard_get ( OS . GDK_NONE ) ;
long imContext = imContext ( ) ;
long layout = OS . gtk_entry_get_layout ( handle ) ;
long ptr = OS . pango_layout_get_text ( layout ) ;
long eventWindow ( ) {
boolean filterKey ( int keyval , long event ) {
long imContext = imContext ( ) ;
long imContext = imContext ( ) ;
long style = OS . gtk_widget_get_style ( handle ) ;
long mark = OS . gtk_text_buffer_get_insert ( bufferHandle ) ;
long layout = OS . gtk_entry_get_layout ( handle ) ;
long mark = OS . gtk_text_buffer_get_insert ( bufferHandle ) ;
long ptr = OS . gtk_entry_get_text ( handle ) ;
long mark = OS . gtk_text_buffer_get_insert ( bufferHandle ) ;
long ptr = OS . gtk_text_buffer_get_text ( bufferHandle , zero , position , true ) ;
long ptr = OS . gtk_entry_get_text ( handle ) ;
long ptr = OS . gtk_text_buffer_get_text ( bufferHandle , startIter , endIter , true ) ;
long layout = OS . gtk_entry_get_layout ( handle ) ;
long ptr = OS . pango_layout_get_text ( layout ) ;
long ptr = OS . gtk_text_buffer_get_text ( bufferHandle , zero , p , true ) ;
long ptr = OS . gtk_entry_get_text ( handle ) ;
long ptr = OS . gtk_text_buffer_get_text ( bufferHandle , zero , endIter , true ) ;
long layout = OS . gtk_widget_create_pango_layout ( handle , buffer ) ;
long gtk_activate ( long widget ) {
long gtk_changed ( long widget ) {
long eventPtr = OS . gtk_get_current_event ( ) ;
long ptr = OS . gtk_entry_get_text ( handle ) ;
long gtk_commit ( long imContext , long text ) {
long gtk_delete_range ( long widget , long iter1 , long iter2 ) {
long ptr = OS . gtk_text_buffer_get_text ( bufferHandle , zero , endIter , true ) ;
long gtk_delete_text ( long widget , long start_pos , long end_pos ) {
long ptr = OS . gtk_entry_get_text ( handle ) ;
long gtk_event_after ( long widget , long gdkEvent ) {
long settings = OS . gtk_settings_get_default ( ) ;
long gtk_expose_event ( long widget , long event ) {
long result = super . gtk_expose_event ( widget , event ) ;
long str = OS . gtk_entry_get_text ( handle ) ;
long window = paintWindow ( ) ;
long style = OS . gtk_widget_get_style ( handle ) ;
long cairo = OS . gdk_cairo_create ( window ) ;
long gc = OS . gdk_gc_new ( window ) ;
long gtk_focus_out_event ( long widget , long event ) {
long settings = OS . gtk_settings_get_default ( ) ;
long gtk_icon_release ( long widget , long icon_pos , long event ) {
long gtk_insert_text ( long widget , long new_text , long new_text_length , long position ) {
long ptr = OS . gtk_entry_get_text ( handle ) ;
long gtk_key_press_event ( long widget , long event ) {
long result = super . gtk_key_press_event ( widget , event ) ;
long gtk_populate_popup ( long widget , long menu ) {
long gtk_text_buffer_insert_text ( long widget , long iter , long text , long length ) {
long ptr = OS . gtk_text_buffer_get_text ( bufferHandle , zero , position , true ) ;
long imContext = imContext ( ) ;
long imContext ( ) {
long mark = OS . gtk_text_buffer_get_insert ( bufferHandle ) ;
long paintWindow ( ) {
long clipboard = OS . gtk_clipboard_get ( OS . GDK_NONE ) ;
long imContext = imContext ( ) ;
long clipboard = OS . gtk_clipboard_get ( OS . GDK_NONE ) ;
void setFontDescription ( long font ) {
long ptr = OS . gtk_entry_get_text ( handle ) ;
long ptr = OS . gtk_text_buffer_get_text ( bufferHandle , startIter , endIter , true ) ;
long mark = OS . gtk_text_buffer_get_insert ( bufferHandle ) ;
long ptr = OS . gtk_entry_get_text ( handle ) ;
long ptr = OS . gtk_text_buffer_get_text ( bufferHandle , startIter , endIter , true ) ;
long tabArray = OS . pango_tab_array_new ( 1 , false ) ;
long mark = OS . gtk_text_buffer_get_insert ( bufferHandle ) ;
long mark = OS . gtk_text_buffer_get_selection_bound ( bufferHandle ) ;
long imContext = imContext ( ) ;
long [ ] preeditString = new long [ 1 ] ;
long eventPtr = OS . gtk_get_current_event ( ) ;
long windowProc ( long handle , long user_data ) {
long windowProc ( long handle , long arg0 , long user_data ) {
long windowProc ( long handle , long arg0 , long arg1 , long user_data ) {
long windowProc ( long handle , long arg0 , long arg1 , long arg2 , long user_data ) {
public long target ;
public DOMEvent ( long id ) {
public nsISupportsWeakReference ( long address ) {
public int GetWeakReference ( long [ ] _retval ) {
public NSPrintInfo ( long id ) {
public long PMPrintSession ( ) {
public long PMPrintSettings ( ) {
long result = OS . objc_msgSend ( OS . class_NSPrintInfo , OS . sel_defaultPrinter ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_dictionary ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_initWithDictionary_ , attributes ! = null ? attributes . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_jobDisposition ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_printSettings ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_printer ) ;
long result = OS . objc_msgSend ( OS . class_NSPrintInfo , OS . sel_sharedPrintInfo ) ;
String parseAString ( long string ) {
long buffer = XPCOM . nsEmbedString_get ( string ) ;
long hTheme = OS . OpenThemeData ( 0 , getClassId ( ) ) ;
public IProvideClassInfo2 ( long address ) {
long handle = OS . objc_msgSend ( view . id , OS . sel_accessibleHandle ) ;
double fontSize = fontUsed . pointSize ( ) ;
public long internal_addRelationAttributes ( long defaultAttributes ) {
public long window ;
public long region ;
public long rgvarg ;
public long rgdispidNamedArgs ;
public long ref_at ;
public long get_index_at ;
public long get_column_at_index ;
public long get_row_at_index ;
public long get_n_columns ;
public long get_n_rows ;
public long get_column_extent_at ;
public long get_row_extent_at ;
public long get_caption ;
public long get_column_description ;
public long get_column_header ;
public long get_row_description ;
public long get_row_header ;
public long get_summary ;
public long set_caption ;
public long set_column_description ;
public long set_column_header ;
public long set_row_description ;
public long set_row_header ;
public long set_summary ;
public long get_selected_columns ;
public long get_selected_rows ;
public long is_column_selected ;
public long is_row_selected ;
public long is_selected ;
public long add_row_selection ;
public long remove_row_selection ;
public long add_column_selection ;
public long remove_column_selection ;
public long row_inserted ;
public long column_inserted ;
public long row_deleted ;
public long column_deleted ;
public long row_reordered ;
public long column_reordered ;
public long model_changed ;
public NSOutlineView ( long id ) {
public NSRect frameOfOutlineCellAtRow ( long row ) {
public long levelForItem ( id item ) {
long result = OS . objc_msgSend ( this . id , OS . sel_outlineTableColumn ) ;
public long rowForItem ( id item ) {
public void setDropItem ( id item , long index ) {
public static long cellClass ( ) {
public static void setCellClass ( long factoryId ) {
public long hAccel ;
public long hbrBack ;
public long dwMenuData ;
long [ ] gdkEvents ;
long eventProc , filterProc , windowProc2 , windowProc3 , windowProc4 , windowProc5 ;
long [ ] closures ;
long preeditWindow , preeditLabel ;
long mouseHoverHandle , mouseHoverProc ;
long allChildrenProc , allChildren ;
long [ ] flushData = new long [ 1 ] ;
static long fixedClassInitProc , fixedMapProc , fixedSizeAllocateProc , oldFixedSizeAllocateProc ;
static long rendererClassInitProc , rendererRenderProc , rendererGetSizeProc ;
void addGdkEvent ( long event ) {
gdkEvents = new long [ length ] ;
long [ ] newEvents = new long [ length ] ;
long handle = OS . gtk_get_event_widget ( event ) ;
long allChildrenProc ( long widget , long recurse ) {
void addMouseHoverTimeout ( long handle ) {
void addWidget ( long handle , Widget widget ) {
long xDisplay = OS . gdk_x11_display_get_xdisplay ( OS . gdk_display_get_default ( ) ) ;
long cellDataProc ( long tree_column , long cell , long tree_model , long iter , long data ) {
long checkIfEventProc ( long display , long xEvent , long userData ) {
long window = 0 ;
long tempWindow = window ;
long handle = flushData [ 0 ] ;
if ( ! OS . gtk_init_check ( new long [ ] { 0 } , null ) ) {
long ptr = OS . gtk_check_version ( MAJOR , MINOR , MICRO ) ;
long atom = OS . XInternAtom ( xDisplay , atomName , false ) ;
long style = OS . gtk_widget_get_default_style ( ) ;
long pixbuf = OS . gtk_icon_set_render_icon (
long pixels = OS . gdk_pixbuf_get_pixels ( pixbuf ) ;
long emissionProc ( long ihint , long n_param_values , long param_values , long data ) {
long eventProc ( long event , long data ) {
public Widget findWidget ( long handle ) {
public Widget findWidget ( long handle , long id ) {
public Widget findWidget ( Widget widget , long id ) {
static long fixedClassInitProc ( long g_class , long class_data ) {
static long fixedMapProc ( long handle ) {
static long fixedSizeAllocateProc ( long handle , long allocation ) {
static long rendererClassInitProc ( long g_class , long class_data ) {
static long rendererGetSizeProc ( long cell , long handle , long cell_area , long x_offset , long y_offset , long width , long height ) {
static long rendererRenderProc ( long cell , long window , long handle , long background_area , long cell_area , long expose_area , long flags ) {
void flushExposes ( long window , boolean all ) {
long settings = OS . gtk_settings_get_default ( ) ;
long gdkWindow = 0 ;
static GtkBorder getEntryInnerBorder ( long handle ) {
long border = OS . gtk_entry_get_inner_border ( handle ) ;
long [ ] borderPtr = new long [ 1 ] ;
long filterProc ( long xEvent , long gdkEvent , long data ) {
long gtk_fixed_get_type ( ) {
long gtk_cell_renderer_text_get_type ( ) {
long gtk_cell_renderer_pixbuf_get_type ( ) {
long gtk_cell_renderer_toggle_get_type ( ) {
long settings = OS . gtk_settings_get_default ( ) ;
long settings = OS . gtk_settings_get_default ( ) ;
long atom = OS . gdk_atom_intern ( name , true ) ;
long [ ] actualType = new long [ 1 ] ;
long [ ] data = new long [ 1 ] ;
long screen = OS . gdk_screen_get_default ( ) ;
long tooltipShellHandle = OS . gtk_window_new ( OS . GTK_WINDOW_POPUP ) ;
long tooltipStyle = OS . gtk_widget_get_style ( tooltipShellHandle ) ;
long style = OS . gtk_widget_get_style ( shellHandle ) ;
Widget getWidget ( long handle ) {
long index = OS . g_object_get_qdata ( handle , SWT_OBJECT_INDEX ) - 1 ;
long idleProc ( long data ) {
closures = new long [ Widget . LAST_SIGNAL ] ;
long entry = OS . gtk_entry_new ( ) ;
long settings = OS . gtk_settings_get_default ( ) ;
long screen = OS . gdk_screen_get_default ( ) ;
long ptr2 = OS . gdk_x11_screen_get_window_manager_name ( screen ) ;
public long internal_new_GC ( GCData data ) {
long window = from . eventWindow ( ) ;
long window = to . eventWindow ( ) ;
long menuPositionProc ( long menu , long x , long y , long push_in , long user_data ) {
long window = from . eventWindow ( ) ;
long window = to . eventWindow ( ) ;
long mouseHoverProc ( long handle ) {
long xDisplay = OS . gdk_x11_display_get_xdisplay ( OS . gdk_display_get_default ( ) ) ;
long keysym = untranslateKey ( event . keyCode ) ;
long event = gdkEvents [ i ] ;
long removeGdkEvent ( ) {
long event = gdkEvents [ 0 ] ;
void removeMouseHoverTimeout ( long handle ) {
Widget removeWidget ( long handle ) {
long handle = ( ( LONG ) data [ 0 ] ) . value ;
long setDirectionProc ( long widget , long direction ) {
long submenu = OS . gtk_menu_item_get_submenu ( widget ) ;
long context = OS . g_main_context_default ( ) ;
long poll = OS . g_main_context_get_poll_func ( context ) ;
long timerProc ( long i ) {
long caretProc ( long clientData ) {
long sizeAllocateProc ( long handle , long arg0 , long user_data ) {
long sizeRequestProc ( long handle , long arg0 , long user_data ) {
long shellMapProc ( long handle , long arg0 , long user_data ) {
long signalProc ( long gobject , long arg1 , long user_data ) {
long atom = OS . gdk_x11_atom_to_xatom ( OS . gdk_atom_intern ( name , true ) ) ;
long [ ] type = new long [ 1 ] ;
long [ ] data = new long [ 1 ] ;
long windowProc ( long handle , long user_data ) {
long windowProc ( long handle , long arg0 , long user_data ) {
long windowProc ( long handle , long arg0 , long arg1 , long user_data ) {
long windowProc ( long handle , long arg0 , long arg1 , long arg2 , long user_data ) {
long windowTimerProc ( long handle ) {
public NSTabView ( long id ) {
public void insertTabViewItem ( NSTabViewItem tabViewItem , long index ) {
public void selectTabViewItemAtIndex ( long index ) {
long result = OS . objc_msgSend ( this . id , OS . sel_selectedTabViewItem ) ;
public void setControlSize ( long controlSize ) {
public void setTabViewType ( long tabViewType ) {
long result = OS . objc_msgSend ( this . id , OS . sel_tabViewItemAtPoint_ , point ) ;
public NSAppleEventDescriptor ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_initListDescriptor ) ;
public IWebPolicyDecisionListener ( long address ) {
public long hwndTrack ;
long handle = OS . gtk_color_selection_dialog_new ( buffer ) ;
long shellHandle = parent . topHandle ( ) ;
long pixbufs = OS . gtk_window_get_icon_list ( shellHandle ) ;
long group = OS . gtk_window_get_group ( 0 ) ;
long colors = OS . g_malloc ( GdkColor . sizeof * rgbs . length ) ;
long strPtr = OS . gtk_color_selection_palette_to_string ( colors , rgbs . length ) ;
long settings = OS . gtk_settings_get_default ( ) ;
long hookId = 0 ;
long settings = OS . gtk_settings_get_default ( ) ;
long [ ] ptr = new long [ 1 ] ;
long getAddress ( ) {
int QueryInterface ( long riid , long ppvObject ) {
XPCOM . memmove ( ppvObject , new long [ ] { supports . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { factory . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
int CreateInstance ( long aOuter , long iid , long result ) {
XPCOM . memmove ( result , new long [ ] { picker . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( result , new long [ ] { picker . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( result , new long [ ] { picker . getAddress ( ) } , C . PTR_SIZEOF ) ;
public nsICookie ( long address ) {
public int GetName ( long aName ) {
public int GetValue ( long aValue ) {
public int GetHost ( long aHost ) {
public int GetPath ( long aPath ) {
public int GetStatus ( long aStatus ) {
public int GetPolicy ( long aPolicy ) {
long [ ] phkResult = new long [ 1 ] ;
long [ ] phkResult = new long [ 1 ] ;
long hwndParent , hwndHeader , hAnchor , hInsert , hSelect ;
long hFirstIndexOf , hLastIndexOf ;
static final long TreeProc ;
static final long HeaderProc ;
TreeItem _getItem ( long hItem ) {
TreeItem _getItem ( long hItem , int id ) {
long borderHandle ( ) {
LRESULT CDDS_ITEMPOSTPAINT ( NMTVCUSTOMDRAW nmcd , long wParam , long lParam ) {
long hDC = nmcd . hdc ;
long hTheme = OS . OpenThemeData ( handle , Display . TREEVIEW ) ;
long hFont = item . fontHandle ( index ) ;
long hTheme = OS . OpenThemeData ( handle , Display . TREEVIEW ) ;
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_CARET , 0 ) ;
LRESULT CDDS_ITEMPREPAINT ( NMTVCUSTOMDRAW nmcd , long wParam , long lParam ) {
long hDC = nmcd . hdc ;
long hFont = item . fontHandle ( index ) ;
long hTheme = OS . OpenThemeData ( handle , Display . TREEVIEW ) ;
long hRgn = OS . CreateRectRgn ( clipRect . left , clipRect . top , clipRect . right , clipRect . bottom ) ;
LRESULT CDDS_POSTPAINT ( NMTVCUSTOMDRAW nmcd , long wParam , long lParam ) {
long hItem = 0 ;
long hDC = nmcd . hdc ;
long hItem = 0 ;
LRESULT CDDS_PREPAINT ( NMTVCUSTOMDRAW nmcd , long wParam , long lParam ) {
long callWindowProc ( long hwnd , int msg , long wParam , long lParam ) {
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_CARET , 0 ) ;
long hItem = 0 ;
long code = OS . CallWindowProc ( TreeProc , hwnd , msg , wParam , lParam ) ;
long hTopItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_FIRSTVISIBLE , 0 ) ;
boolean checkHandle ( long hwnd ) {
boolean checkScroll ( long hItem ) {
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_ROOT , 0 ) ;
void clear ( long hItem , TVITEM tvItem ) {
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_ROOT , 0 ) ;
void clearAll ( long hItem , TVITEM tvItem , boolean all ) {
long hFirstItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_CHILD , hItem ) ;
long CompareFunc ( long lParam1 , long lParam2 , long lParamSort ) {
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_ROOT , 0 ) ;
long hFont = OS . GetStockObject ( OS . SYSTEM_FONT ) ;
void createItem ( TreeItem item , long hParent , long hInsertAfter , long hItem ) {
long rgn = OS . CreateRectRgn ( 0 , 0 , 0 , 0 ) ;
long hIMC = OS . ImmGetContext ( handle ) ;
long hFont = OS . SendMessage ( handle , OS . WM_GETFONT , 0 , 0 ) ;
long hwndInsertAfter = OS . GetWindow ( handle , OS . GW_HWNDPREV ) ;
long hwndFocus = OS . GetFocus ( ) ;
void deselect ( long hItem , TVITEM tvItem , long hIgnoreItem ) {
long hFirstItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_CHILD , hItem ) ;
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_CARET , 0 ) ;
long oldProc = OS . GetWindowLongPtr ( handle , OS . GWLP_WNDPROC ) ;
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_ROOT , 0 ) ;
void destroyItem ( TreeItem item , long hItem ) {
long hParent = 0 ;
long hwndToolTip = OS . SendMessage ( handle , OS . TVM_GETTOOLTIPS , 0 , 0 ) ;
long hFont = item [ 0 ] . fontHandle ( order [ index [ 0 ] ] ) ;
int findIndex ( long hFirstItem , long hItem ) {
long hPrevItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_PREVIOUS , hLastIndexOf ) ;
long hNextItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_NEXT , hLastIndexOf ) ;
long hNextItem = hFirstItem ;
Widget findItem ( long hItem ) {
long findItem ( long hFirstItem , int index ) {
long hPrevItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_PREVIOUS , hLastIndexOf ) ;
long hNextItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_NEXT , hLastIndexOf ) ;
long hNextItem = hFirstItem ;
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_CARET , 0 ) ;
long hNextItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_NEXTVISIBLE , hItem ) ;
long hFirstItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_ROOT , 0 ) ;
long hItem = findItem ( hFirstItem , index ) ;
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_ROOT , 0 ) ;
int getItemCount ( long hItem ) {
long hFirstItem = hItem ;
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_ROOT , 0 ) ;
TreeItem [ ] getItems ( long hTreeItem ) {
long hItem = hTreeItem ;
long getNextSelection ( long hItem , TVITEM tvItem ) {
int getSelection ( long hItem , TVITEM tvItem , TreeItem [ ] selection , int index , int count , boolean bigSelection , boolean all ) {
long hFirstItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_CHILD , hItem ) ;
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_CARET , 0 ) ;
long oldProc = OS . GetWindowLongPtr ( handle , OS . GWLP_WNDPROC ) ;
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_ROOT , 0 ) ;
long hItem = item . handle ;
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_ROOT , 0 ) ;
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_CARET , 0 ) ;
long oldProc = OS . GetWindowLongPtr ( handle , OS . GWLP_WNDPROC ) ;
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_ROOT , 0 ) ;
long hItem = item . handle ;
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_FIRSTVISIBLE , 0 ) ;
boolean hitTestSelection ( long hItem , int x , int y ) {
long hFont = item . fontHandle ( order [ index [ 0 ] ] ) ;
long hImageList = headerImageList . getHandle ( ) ;
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_ROOT , 0 ) ;
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_CARET , 0 ) ;
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_FIRSTVISIBLE , 0 ) ;
void releaseItem ( long hItem , TVITEM tvItem , boolean release ) {
void releaseItems ( long hItem , TVITEM tvItem ) {
long hStateList = OS . SendMessage ( handle , OS . TVM_GETIMAGELIST , OS . TVSIL_STATE , 0 ) ;
long result = OS . SendMessage ( handle , OS . TVM_DELETEITEM , 0 , OS . TVI_ROOT ) ;
long hItem = 0 ;
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_ROOT , 0 ) ;
void setItemCount ( int count , long hParent , long hItem ) {
long scrolledHandle ( ) {
void select ( long hItem , TVITEM tvItem ) {
long hFirstItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_CHILD , hItem ) ;
long hItem = item . handle ;
long hThumb = OS . MAKELPARAM ( OS . SB_THUMBPOSITION , hInfo . nPos ) ;
long vThumb = OS . MAKELPARAM ( OS . SB_THUMBPOSITION , vInfo . nPos ) ;
long oldProc = OS . GetWindowLongPtr ( handle , OS . GWLP_WNDPROC ) ;
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_ROOT , 0 ) ;
Event sendMeasureItemEvent ( TreeItem item , int index , long hDC , int detail ) {
void setBackgroundImage ( long hBitmap ) {
long hCursor = cursor = = null ? OS . LoadCursor ( 0 , OS . IDC_ARROW ) : cursor . handle ;
long hDC = OS . GetDC ( handle ) ;
long hBrush = OS . CreateSolidBrush ( clrBackground ) ;
long oldFont = OS . SelectObject ( hDC , defaultFont ( ) ) ;
long hTheme = display . hButtonTheme ( ) ;
long hOldStateList = OS . SendMessage ( handle , OS . TVM_GETIMAGELIST , OS . TVSIL_STATE , 0 ) ;
long hItem = 0 ;
long hHeap = OS . GetProcessHeap ( ) ;
void setSelection ( long hItem , TVITEM tvItem , TreeItem [ ] selection ) {
long hFirstItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_CHILD , hItem ) ;
long hParent = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_PARENT , hNewItem ) ;
long oldProc = OS . GetWindowLongPtr ( handle , OS . GWLP_WNDPROC ) ;
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_ROOT , 0 ) ;
long hParent = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_PARENT , hItem ) ;
long hThumb = OS . MAKELPARAM ( OS . SB_THUMBPOSITION , hInfo . nPos ) ;
void showItem ( long hItem ) {
long hItem = 0 ;
long oldProc = OS . GetWindowLongPtr ( handle , OS . GWLP_WNDPROC ) ;
long hRoot = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_ROOT , 0 ) ;
void sort ( long hParent , boolean all ) {
long lpfnCompare = compareCallback . getAddress ( ) ;
long hwndToolTip = OS . SendMessage ( handle , OS . TVM_GETTOOLTIPS , 0 , 0 ) ;
long topHandle ( ) {
long hImageList = imageList . getHandle ( ) ;
long hImageListHeader = headerImageList . getHandle ( ) ;
long windowProc ( ) {
long windowProc ( long hwnd , int msg , long wParam , long lParam ) {
long code = callWindowProc ( hwnd , OS . WM_SIZE , wParam , lParam ) ;
long code = OS . SendMessage ( handle , OS . WM_VSCROLL , wParam , lParam ) ;
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_FIRSTVISIBLE , 0 ) ;
long hRgn = OS . CreateRectRgn ( rect . left , rect . top , rect . right , rect . bottom ) ;
long rectRgn = OS . CreateRectRgn ( itemRect . left , itemRect . top , itemRect . right , itemRect . bottom ) ;
long oldMemBitmap = OS . SelectObject ( memHdc , memDib ) ;
LRESULT WM_CHAR ( long wParam , long lParam ) {
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_CARET , 0 ) ;
long id = hItem ;
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_CARET , 0 ) ;
LRESULT WM_ERASEBKGND ( long wParam , long lParam ) {
LRESULT WM_GETOBJECT ( long wParam , long lParam ) {
LRESULT WM_HSCROLL ( long wParam , long lParam ) {
LRESULT WM_KEYDOWN ( long wParam , long lParam ) {
long code = callWindowProc ( handle , OS . WM_KEYDOWN , wParam = = OS . VK_RIGHT ? OS . VK_LEFT : OS . VK_RIGHT , lParam ) ;
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_CARET , 0 ) ;
long code = callWindowProc ( handle , OS . WM_KEYDOWN , wParam , lParam ) ;
long hNewItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_CARET , 0 ) ;
long hDeselectItem = hItem ;
long hSelectItem = hAnchor ;
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_CARET , 0 ) ;
long hNewItem = 0 ;
long hVisible = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_NEXTVISIBLE , hNewItem ) ;
long code = callWindowProc ( handle , OS . WM_KEYDOWN , wParam , lParam ) ;
LRESULT WM_KILLFOCUS ( long wParam , long lParam ) {
LRESULT WM_LBUTTONDBLCLK ( long wParam , long lParam ) {
long id = tvItem . hItem ;
LRESULT WM_LBUTTONDOWN ( long wParam , long lParam ) {
long hOldSelection = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_CARET , 0 ) ;
long hNext = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_NEXTVISIBLE , lpht . hItem ) ;
long hItem = hNext = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_NEXTVISIBLE , hNext ) ;
long code = callWindowProc ( handle , OS . WM_LBUTTONDOWN , wParam , lParam ) ;
long hNewSelection = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_CARET , 0 ) ;
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_CARET , 0 ) ;
long id = tvItem . hItem ;
long code = callWindowProc ( handle , OS . WM_LBUTTONDOWN , wParam , lParam ) ;
long hOldItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_CARET , 0 ) ;
long code = callWindowProc ( handle , OS . WM_LBUTTONDOWN , wParam , lParam ) ;
long hNewItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_CARET , 0 ) ;
long oldProc = OS . GetWindowLongPtr ( handle , OS . GWLP_WNDPROC ) ;
long hItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_ROOT , 0 ) ;
long hItem = tvItem . hItem = hAnchor ;
LRESULT WM_MOUSEMOVE ( long wParam , long lParam ) {
LRESULT WM_MOUSEWHEEL ( long wParam , long lParam ) {
LRESULT WM_MOVE ( long wParam , long lParam ) {
LRESULT WM_RBUTTONDOWN ( long wParam , long lParam ) {
LRESULT WM_PAINT ( long wParam , long lParam ) {
long paintDC = 0 ;
long hDC = OS . CreateCompatibleDC ( paintDC ) ;
LRESULT WM_PRINTCLIENT ( long wParam , long lParam ) {
long code = callWindowProc ( handle , OS . WM_PRINTCLIENT , wParam , lParam ) ;
LRESULT WM_SETCURSOR ( long wParam , long lParam ) {
LRESULT WM_SETFOCUS ( long wParam , long lParam ) {
LRESULT WM_SETFONT ( long wParam , long lParam ) {
LRESULT WM_SETREDRAW ( long wParam , long lParam ) {
long code = OS . DefWindowProc ( handle , OS . WM_SETREDRAW , wParam , lParam ) ;
LRESULT WM_SIZE ( long wParam , long lParam ) {
LRESULT WM_SYSCOLORCHANGE ( long wParam , long lParam ) {
LRESULT WM_VSCROLL ( long wParam , long lParam ) {
long bits = OS . SendMessage ( handle , OS . TVM_GETEXTENDEDSTYLE , 0 , 0 ) ;
LRESULT wmColorChild ( long wParam , long lParam ) {
LRESULT wmNotify ( NMHDR hdr , long wParam , long lParam ) {
LRESULT wmNotifyChild ( NMHDR hdr , long wParam , long lParam ) {
long hFirstItem = OS . SendMessage ( handle , OS . TVM_GETNEXTITEM , OS . TVGN_CHILD , tvItem . hItem ) ;
LRESULT wmNotifyHeader ( NMHDR hdr , long wParam , long lParam ) {
LRESULT wmNotifyToolTip ( NMHDR hdr , long wParam , long lParam ) {
LRESULT wmNotifyToolTip ( NMTTCUSTOMDRAW nmcd , long lParam ) {
long oldFont = OS . SelectObject ( hDC , hFont ) ;
public long handle ;
long hDC = drawable . internal_new_GC ( data ) ;
long gdipGraphics = data . gdipGraphics ;
long pen = data . gdipPen ;
long color = Gdip . Color_new ( data . alpha < < 24 | rgb ) ;
long brush = Gdip . Brush_Clone ( data . gdipBrush ) ;
long color = Gdip . Color_new ( data . alpha < < 24 | rgb ) ;
long brush = Gdip . SolidBrush_new ( color ) ;
long matrix = Gdip . Matrix_new ( 1 , 0 , 0 , 1 , 0 , 0 ) ;
long newBrush = OS . CreateSolidBrush ( data . background ) ;
long hwnd = data . hwnd ;
long hrgn = OS . CreateRectRgn ( 0 , 0 , 0 , 0 ) ;
long family = 0 ;
static void destroyGdipBrush ( long brush ) {
long hNullBitmap = data . hNullBitmap ;
long gdipGraphics = data . gdipGraphics ;
long path = Gdip . GraphicsPath_new ( Gdip . FillModeAlternate ) ;
long matrix = Gdip . Matrix_new ( width , 0 , 0 , height , x , y ) ;
long hdc = handle ;
long gdipGraphics = data . gdipGraphics ;
long clipRgn = 0 ;
long rgn = Gdip . Region_new ( ) ;
long matrix = Gdip . Matrix_new ( 1 , 0 , 0 , 1 , 0 , 0 ) ;
long attrib = Gdip . ImageAttributes_new ( ) ;
long hHeap = OS . GetProcessHeap ( ) ;
long hBitmap = srcIconInfo . hbmColor ;
long srcColor = srcIconInfo . hbmColor ;
long oldSrcBitmap = OS . SelectObject ( srcHdc , srcColor ) ;
long oldDestBitmap = OS . SelectObject ( dstHdc , newIconInfo . hbmColor ) ;
long hIcon = OS . CreateIconIndirect ( newIconInfo ) ;
long hOldBitmap = OS . SelectObject ( memGC . handle , srcImage . handle ) ;
long memDib = Image . createDIB ( srcWidth , srcHeight , 32 ) ;
long oldMemBitmap = OS . SelectObject ( memHdc , memDib ) ;
long oldTempBitmap = OS . SelectObject ( tempHdc , tempDib ) ;
void drawBitmapTransparentByClipping ( long srcHdc , long maskHdc , int srcX , int srcY , int srcWidth , int srcHeight , int destX , int destY , int destWidth , int destHeight , boolean simple , int imgWidth , int imgHeight ) {
long rgn = OS . CreateRectRgn ( 0 , 0 , 0 , 0 ) ;
long tempRgn = OS . CreateRectRgn ( x , y , x + 1 , y + 1 ) ;
long tmpRgn = OS . ExtCreateRegion ( lpXform , nBytes , lpRgnData ) ;
long clip = OS . CreateRectRgn ( 0 , 0 , 0 , 0 ) ;
void drawBitmapMask ( Image srcImage , long srcColor , long srcMask , int srcX , int srcY , int srcWidth , int srcHeight , int destX , int destY , int destWidth , int destHeight , boolean simple , int imgWidth , int imgHeight , boolean offscreen ) {
long tempHdc = 0 , tempBitmap = 0 , oldTempBitmap = 0 ;
long gdipGraphics = data . gdipGraphics ;
long gdipGraphics = data . gdipGraphics ;
long gdipGraphics = data . gdipGraphics ;
long gdipGraphics = data . gdipGraphics ;
long gdipGraphics = data . gdipGraphics ;
long gdipGraphics = data . gdipGraphics ;
void drawRoundRectangleGdip ( long gdipGraphics , long pen , int x , int y , int width , int height , int arcWidth , int arcHeight ) {
long path = Gdip . GraphicsPath_new ( Gdip . FillModeAlternate ) ;
long gdipGraphics = data . gdipGraphics ;
long hBitmap = OS . CreateCompatibleBitmap ( handle , width , height ) ;
long gdipGraphics = data . gdipGraphics ;
long hBitmap = OS . CreateCompatibleBitmap ( handle , width , height ) ;
boolean useGDIP ( long hdc , char [ ] buffer ) {
void drawText ( long gdipGraphics , String string , int x , int y , int flags , Point size ) {
long oldFont = 0 ;
RectF drawText ( long gdipGraphics , char [ ] buffer , int start , int length , int x , int y , int flags , int mnemonicIndex , TEXTMETRIC lptm , boolean draw ) {
long oldFont = 0 ;
long brush = getFgBrush ( ) ;
long pen = Gdip . Pen_new ( brush , 1 ) ;
void drawTextGDIP ( long gdipGraphics , String string , int x , int y , int flags , boolean draw , Point size ) {
long format = Gdip . StringFormat_Clone ( Gdip . StringFormat_GenericTypographic ( ) ) ;
long brush = getFgBrush ( ) ;
long gdipGraphics = data . gdipGraphics ;
long fromGpColor = Gdip . Color_new ( data . alpha < < 24 | rgb ) ;
long toGpColor = Gdip . Color_new ( data . alpha < < 24 | rgb ) ;
long brush = Gdip . LinearGradientBrush_new ( p1 , p2 , fromGpColor , toGpColor ) ;
final long pVertex = pMesh + GRADIENT_RECT . sizeof ;
void fillRoundRectangleGdip ( long gdipGraphics , long brush , int x , int y , int width , int height , int arcWidth , int arcHeight ) {
long path = Gdip . GraphicsPath_new ( Gdip . FillModeAlternate ) ;
long hdc = Gdip . Graphics_GetHDC ( data . gdipGraphics ) ;
long gdipGraphics = data . gdipGraphics ;
long gdipGraphics = data . gdipGraphics ;
long rgn = Gdip . Region_new ( ) ;
long hRgn = Gdip . Region_GetHRGN ( rgn , data . gdipGraphics ) ;
long metaRgn = OS . CreateRectRgn ( 0 , 0 , 0 , 0 ) ;
long hwnd = data . hwnd ;
long sysRgn = OS . CreateRectRgn ( 0 , 0 , 0 , 0 ) ;
long newSysRgn = OS . ExtCreateRegion ( new float [ ] { - 1 , 0 , 0 , 1 , 0 , 0 } , nBytes , lpRgnData ) ;
long getFgBrush ( ) {
long gdipGraphics = data . gdipGraphics ;
long identity = identity ( ) ;
long gdipGraphics = data . gdipGraphics ;
long hRgn = OS . CreateRectRgn ( 0 , 0 , 0 , 0 ) ;
long matrix = identity ( ) ;
long identity ( ) {
long hwnd = OS . IsWinCE ? data . hwnd : OS . WindowFromDC ( handle ) ;
long hBitmap = OS . GetCurrentObject ( handle , OS . OBJ_BITMAP ) ;
void init ( Drawable drawable , GCData data , long hDC ) {
long hPalette = data . device . hPalette ;
long gdipGraphics = data . gdipGraphics ;
long rgn = Gdip . Region_new ( ) ;
long region = OS . CreateRectRgn ( 0 , 0 , 0 , 0 ) ;
float measureSpace ( long font , long format ) {
long region = Gdip . Region_new ( hRgn ) ;
long hRgn = OS . CreateRectRgn ( x , y , x + width , y + height ) ;
long identity = identity ( ) ;
long gdipGraphics = data . gdipGraphics ;
long gdipGraphics = data . gdipGraphics ;
long hDC = drawable . internal_new_GC ( data ) ;
public static GC win32_new ( long hDC , GCData data ) {
public nsIDOMDocument ( long address ) {
public int GetDoctype ( long [ ] aDoctype ) {
public int GetImplementation ( long [ ] aImplementation ) {
public int GetDocumentElement ( long [ ] aDocumentElement ) {
public int CreateElement ( long tagName , long [ ] _retval ) {
public int CreateDocumentFragment ( long [ ] _retval ) {
public int CreateTextNode ( long data , long [ ] _retval ) {
public int CreateComment ( long data , long [ ] _retval ) {
public int CreateCDATASection ( long data , long [ ] _retval ) {
public int CreateProcessingInstruction ( long target , long data , long [ ] _retval ) {
public int CreateAttribute ( long name , long [ ] _retval ) {
public int CreateEntityReference ( long name , long [ ] _retval ) {
public int GetElementsByTagName ( long tagname , long [ ] _retval ) {
public int ImportNode ( long importedNode , int deep , long [ ] _retval ) {
public int ImportNode ( long importedNode , int deep , int _argc , long [ ] _retval ) {
public int CreateElementNS ( long namespaceURI , long qualifiedName , long [ ] _retval ) {
public int CreateAttributeNS ( long namespaceURI , long qualifiedName , long [ ] _retval ) {
public int GetElementsByTagNameNS ( long namespaceURI , long localName , long [ ] _retval ) {
public int GetElementById ( long elementId , long [ ] _retval ) {
public int GetInputEncoding ( long aInputEncoding ) {
public int GetDocumentURI ( long aDocumentURI ) {
public int AdoptNode ( long source , long [ ] _retval ) {
public int CreateRange ( long [ ] _retval ) {
public int CreateNodeIterator ( long root , int whatToShow , long filter , int entityReferenceExpansion , long [ ] _retval ) {
public int CreateTreeWalker ( long root , int whatToShow , long filter , int entityReferenceExpansion , long [ ] _retval ) {
public int CreateEvent ( long eventType , long [ ] _retval ) {
public int GetDefaultView ( long [ ] aDefaultView ) {
public int GetCharacterSet ( long aCharacterSet ) {
public int GetDir ( long aDir ) {
public int SetDir ( long aDir ) {
public int GetLocation ( long [ ] aLocation ) {
public int GetTitle ( long aTitle ) {
public int SetTitle ( long aTitle ) {
public int GetReadyState ( long aReadyState ) {
public int GetLastModified ( long aLastModified ) {
public int GetReferrer ( long aReferrer ) {
public int GetActiveElement ( long [ ] aActiveElement ) {
public int GetElementsByClassName ( long classes , long [ ] _retval ) {
public int GetStyleSheets ( long [ ] aStyleSheets ) {
public int GetPreferredStyleSheetSet ( long aPreferredStyleSheetSet ) {
public int GetSelectedStyleSheetSet ( long aSelectedStyleSheetSet ) {
public int SetSelectedStyleSheetSet ( long aSelectedStyleSheetSet ) {
public int GetLastStyleSheetSet ( long aLastStyleSheetSet ) {
public int GetStyleSheetSets ( long [ ] aStyleSheetSets ) {
public int EnableStyleSheetsForSet ( long name ) {
public int ElementFromPoint ( float x , float y , long [ ] _retval ) {
public int GetContentType ( long aContentType ) {
public int GetCurrentScript ( long [ ] aCurrentScript ) {
public int MozSetImageElement ( long aImageElementId , long aImageElement ) {
public int GetMozFullScreenElement ( long [ ] aMozFullScreenElement ) {
public int GetOnreadystatechange ( long cx , long aOnreadystatechange ) {
public int SetOnreadystatechange ( long cx , long aOnreadystatechange ) {
public int GetOnmouseenter ( long cx , long aOnmouseenter ) {
public int SetOnmouseenter ( long cx , long aOnmouseenter ) {
public int GetOnmouseleave ( long cx , long aOnmouseleave ) {
public int SetOnmouseleave ( long cx , long aOnmouseleave ) {
public int GetMozVisibilityState ( long aMozVisibilityState ) {
long getAddress ( ) {
int QueryInterface ( long riid , long ppvObject ) {
XPCOM . memmove ( ppvObject , new long [ ] { supports . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { helperAppLauncherDialog . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
int Show ( long aLauncher , long aContext , int aReason ) {
int PromptForSaveToFile ( long aLauncher , long aWindowContext , long aDefaultFileName , long aSuggestedFileExtension , int aForcePrompt , long _retval ) {
long [ ] result = new long [ 1 ] ;
public nsIWebBrowser ( long address ) {
public int AddWebBrowserListener ( long aListener , nsID aIID ) {
public int RemoveWebBrowserListener ( long aListener , nsID aIID ) {
public int GetContainerWindow ( long [ ] aContainerWindow ) {
public int SetContainerWindow ( long aContainerWindow ) {
public int GetParentURIContentListener ( long [ ] aParentURIContentListener ) {
public int SetParentURIContentListener ( long aParentURIContentListener ) {
public int GetContentDOMWindow ( long [ ] aContentDOMWindow ) {
public nsICookieService ( long address ) {
public int GetCookieString ( long aURI , long aChannel , long [ ] _retval ) {
public int GetCookieStringFromHttp ( long aURI , long aFirstURI , long aChannel , long [ ] _retval ) {
public int SetCookieString ( long aURI , long aPrompt , byte [ ] aCookie , long aChannel ) {
public int SetCookieStringFromHttp ( long aURI , long aFirstURI , long aPrompt , byte [ ] aCookie , byte [ ] aServerTime , long aChannel ) {
public IServiceProvider ( long address ) {
public int QueryService ( GUID iid1 , GUID iid2 , long ppvObject [ ] ) {
public nsIBaseWindow ( long address ) {
public int InitWindow ( long parentNativeWindow , long parentWidget , int x , int y , int cx , int cy ) {
public int GetParentWidget ( long [ ] aParentWidget ) {
public int SetParentWidget ( long aParentWidget ) {
public int GetParentNativeWindow ( long [ ] aParentNativeWindow ) {
public int SetParentNativeWindow ( long aParentNativeWindow ) {
public int GetMainWidget ( long [ ] aMainWidget ) {
public int GetTitle ( long [ ] aTitle ) {
public long get_link ;
public long get_n_links ;
public long get_link_index ;
public long handle ;
long getAddress ( ) {
int QueryInterface ( long riid , long ppvObject ) {
XPCOM . memmove ( ppvObject , new long [ ] { supports . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { prompt . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
String getLabel ( int buttonFlag , int index , long buttonTitle ) {
void setParent ( long aParent ) {
int Alert ( long aDialogTitle , long aText ) {
int AlertCheck ( long aDialogTitle , long aText , long aCheckMsg , long aCheckState ) {
int Confirm ( long aDialogTitle , long aText , long _retval ) {
int ConfirmCheck ( long aDialogTitle , long aText , long aCheckMsg , long aCheckState , long _retval ) {
int ConfirmEx ( long aDialogTitle , long aText , int aButtonFlags , long aButton0Title , long aButton1Title , long aButton2Title , long aCheckMsg , long aCheckState , long _retval ) {
int Prompt ( long aDialogTitle , long aText , long aValue , long aCheckMsg , long aCheckState , long _retval ) {
long [ ] valueAddr = new long [ 1 ] ;
long [ ] result2 = new long [ 1 ] ;
long ptr = memory . Alloc ( size ) ;
XPCOM . memmove ( aValue , new long [ ] { ptr } , C . PTR_SIZEOF ) ;
int PromptAuth ( long aChannel , int level , long authInfo , long _retval ) {
long ptr = XPCOM . nsEmbedString_new ( ) ;
long buffer = XPCOM . nsEmbedString_get ( ptr ) ;
long [ ] uri = new long [ 1 ] ;
long host = XPCOM . nsEmbedCString_new ( ) ;
int PromptUsernameAndPassword ( long aDialogTitle , long aText , long aUsername , long aPassword , long aCheckMsg , long aCheckState , long _retval ) {
long [ ] userAddr = new long [ 1 ] ;
long [ ] passAddr = new long [ 1 ] ;
long [ ] userAddr = new long [ 1 ] ;
long [ ] passAddr = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long ptr = C . malloc ( size ) ;
XPCOM . memmove ( aUsername , new long [ ] { ptr } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( aPassword , new long [ ] { ptr } , C . PTR_SIZEOF ) ;
int PromptPassword ( long aDialogTitle , long aText , long aPassword , long aCheckMsg , long aCheckState , long _retval ) {
int Select ( long aDialogTitle , long aText , int aCount , long aSelectList , long aOutSelection , long _retval ) {
public long method5 ( long [ ] args ) { return QueryGetData ( args [ 0 ] ) ; }
private int EnumFormatEtc ( int dwDirection , long ppenumFormatetc ) {
OS . MoveMemory ( ppenumFormatetc , new long [ ] { enumFORMATETC . getAddress ( ) } , OS . PTR_SIZEOF ) ;
private int GetData ( long pFormatetc , long pmedium ) {
private int QueryGetData ( long pFormatetc ) {
private int QueryInterface ( long riid , long ppvObject ) {
OS . MoveMemory ( ppvObject , new long [ ] { iDropSource . getAddress ( ) } , OS . PTR_SIZEOF ) ;
OS . MoveMemory ( ppvObject , new long [ ] { iDataObject . getAddress ( ) } , OS . PTR_SIZEOF ) ;
OS . MoveMemory ( ppvObject , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
private int SetData ( long pFormatetc , long pmedium , int fRelease ) {
long [ ] ptrEffect = new long [ 1 ] ;
long drawable = gc . getGCData ( ) . drawable ;
long rendered = OS . gtk_style_render_icon ( gtkStyle , source , OS . GTK_TEXT_DIR_NONE , state_type , - 1 , buttonHandle , null ) ;
long layout = OS . gtk_widget_create_pango_layout ( widget , buffer ) ;
long getTextHandle ( Theme theme ) {
long widget = getTextHandle ( theme ) ;
long layout = OS . gtk_widget_create_pango_layout ( widget , buffer ) ;
static long proc2Args , proc3Args , proc6Args ;
long cls = OS . object_getClass ( control . view . id ) ;
long procPtr = OS . class_getMethodImplementation ( cls , OS . sel_draggingEntered_ ) ;
long imageView = 0 ;
void addDragHandlers ( long cls ) {
long dndCallSuper ( long id , long sel , long arg0 ) {
int draggingEntered ( long id , long sel , NSObject sender ) {
void draggingExited ( long id , long sel , NSObject sender ) {
int draggingUpdated ( long id , long sel , NSObject sender ) {
static long dropTargetProc ( long id , long sel ) {
static long dropTargetProc ( long id , long sel , long arg0 ) {
static long dropTargetProc ( long id , long sel , long arg0 , long arg1 , long arg2 , long arg3 ) {
long modifiers = currEvent . modifierFlags ( ) ;
int osOpToOp ( long osOperation ) {
boolean performDragOperation ( long id , long sel , NSObject sender ) {
boolean outlineView_acceptDrop_item_childIndex ( long id , long sel , long outlineView , long info , long item , long index ) {
long outlineView_validateDrop_proposedItem_proposedChildIndex ( long id , long sel , long outlineView , long info , long item , long index ) {
long allowedActions = draggingState . draggingSourceOperationMask ( ) ;
long draggedTypeCount = draggedTypes . count ( ) ;
boolean tableView_acceptDrop_row_dropOperation ( long id , long sel , long tableView , long info , long row , long operation ) {
int tableView_validateDrop_proposedRow_proposedDropOperation ( long id , long sel , long tableView , long info , long row , long operation ) {
long hitRow = widget . rowAtPoint ( pt ) ;
boolean wantsPeriodicDraggingUpdates ( long id , long sel ) {
public NSAttributedString ( long id ) {
long result = OS . objc_msgSend ( OS . class_NSAttributedString , OS . sel_attributedStringWithAttachment_ , attachment ! = null ? attachment . id : 0 ) ;
public NSRect boundingRectWithSize ( NSSize size , long options ) {
public NSRange doubleClickAtIndex ( long location ) {
public long nextWordFromIndex ( long location , boolean isForward ) {
long result = OS . objc_msgSend ( this . id , OS . sel_attributedSubstringFromRange_ , range ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_initWithString_ , str ! = null ? str . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_initWithString_attributes_ , str ! = null ? str . id : 0 , attrs ! = null ? attrs . id : 0 ) ;
public long length ( ) {
long result = OS . objc_msgSend ( this . id , OS . sel_string ) ;
static final long TabFolderProc ;
long lpszClassName = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount ) ;
long callWindowProc ( long hwnd , int msg , long wParam , long lParam ) {
long hwndToolTip = OS . SendMessage ( handle , OS . TCM_GETTOOLTIPS , 0 , 0 ) ;
void drawThemeBackground ( long hDC , long hwnd , RECT rect ) {
long hImageList = imageList . getHandle ( ) ;
long hwndToolTip = OS . SendMessage ( handle , OS . TCM_GETTOOLTIPS , 0 , 0 ) ;
long hwndChild = OS . GetWindow ( handle , OS . GW_CHILD ) ;
long hImageList = imageList . getHandle ( ) ;
long windowProc ( ) {
LRESULT WM_GETDLGCODE ( long wParam , long lParam ) {
LRESULT WM_GETOBJECT ( long wParam , long lParam ) {
LRESULT WM_KEYDOWN ( long wParam , long lParam ) {
long code = callWindowProc ( handle , OS . WM_KEYDOWN , wParam = = OS . VK_RIGHT ? OS . VK_LEFT : OS . VK_RIGHT , lParam ) ;
LRESULT WM_MOUSELEAVE ( long wParam , long lParam ) {
long hwndToolTip = OS . SendMessage ( handle , OS . TCM_GETTOOLTIPS , 0 , 0 ) ;
LRESULT WM_NCHITTEST ( long wParam , long lParam ) {
long hittest = OS . DefWindowProc ( handle , OS . WM_NCHITTEST , wParam , lParam ) ;
LRESULT WM_NOTIFY ( long wParam , long lParam ) {
LRESULT WM_PARENTNOTIFY ( long wParam , long lParam ) {
long hwnd = lParam ;
LRESULT WM_SIZE ( long wParam , long lParam ) {
LRESULT WM_WINDOWPOSCHANGING ( long wParam , long lParam ) {
LRESULT wmNotifyChild ( NMHDR hdr , long wParam , long lParam ) {
long getAddress ( ) {
int QueryInterface ( long riid , long ppvObject ) {
XPCOM . memmove ( ppvObject , new long [ ] { inputStream . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { inputStream . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
int Available ( long _retval ) {
int Read ( long aBuf , int aCount , long _retval ) {
int ReadSegments ( long aWriter , long aClosure , int aCount , long _retval ) {
long rc = XPCOM . Call ( aWriter , getAddress ( ) , aClosure , buffer , index , cnt , aWriteCount ) ;
int IsNonBlocking ( long _retval ) {
public nsIDownload_1_8 ( long address ) {
public int GetTargetFile ( long [ ] aTargetFile ) {
public int GetAmountTransferred ( long aAmountTransferred ) {
public int GetSize ( long aSize ) {
public int GetSource ( long [ ] aSource ) {
public int GetTarget ( long [ ] aTarget ) {
public int GetCancelable ( long [ ] aCancelable ) {
public int GetDisplayName ( long [ ] aDisplayName ) {
public int GetMIMEInfo ( long [ ] aMIMEInfo ) {
public long handle ;
long family = OS . pango_font_description_get_family ( handle ) ;
long fontString = OS . pango_font_description_to_string ( handle ) ;
public static Font gtk_new ( Device device , long handle ) {
public long className ;
public long parentClass ;
public long staticValues ;
public long staticFunctions ;
public long initialize ;
public long finalize ;
public long hasProperty ;
public long getProperty ;
public long setProperty ;
public long deleteProperty ;
public long getPropertyNames ;
public long callAsFunction ;
public long callAsConstructor ;
public long hasInstance ;
public long convertToType ;
public NSTextView ( long id ) {
public long characterIndexForInsertionAtPoint ( NSPoint point ) {
long result = OS . objc_msgSend ( this . id , OS . sel_defaultParagraphStyle ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_layoutManager ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_linkTextAttributes ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_markedTextAttributes ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_selectedTextAttributes ) ;
public void setBaseWritingDirection ( long writingDirection , NSRange range ) {
long result = OS . objc_msgSend ( this . id , OS . sel_textContainer ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_textStorage ) ;
public long himl ;
public IOleObject ( long address ) {
public int Advise ( long pAdvSink , int [ ] pdwConnection ) {
public int DoVerb ( int iVerb , MSG lpmsg , long pActiveSite , int lindex , long hwndParent , RECT lprcPosRect ) {
public int GetClientSite ( long [ ] ppvClientSite ) {
public int SetClientSite ( long pClientSite ) {
public NSPrintOperation ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_context ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_createContext ) ;
long result = OS . objc_msgSend ( OS . class_NSPrintOperation , OS . sel_printOperationWithView_printInfo_ , view ! = null ? view . id : 0 , printInfo ! = null ? printInfo . id : 0 ) ;
public NSBundle ( long id ) {
public static boolean loadNibFile ( NSString fileName , NSDictionary context , long zone ) {
long result = OS . objc_msgSend ( this . id , OS . sel_bundleIdentifier ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_bundlePath ) ;
long result = OS . objc_msgSend ( OS . class_NSBundle , OS . sel_bundleWithIdentifier_ , identifier ! = null ? identifier . id : 0 ) ;
long result = OS . objc_msgSend ( OS . class_NSBundle , OS . sel_bundleWithPath_ , path ! = null ? path . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_infoDictionary ) ;
long result = OS . objc_msgSend ( OS . class_NSBundle , OS . sel_mainBundle ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_objectForInfoDictionaryKey_ , key ! = null ? key . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_pathForResource_ofType_ , name ! = null ? name . id : 0 , ext ! = null ? ext . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_pathForResource_ofType_inDirectory_forLocalization_ , name ! = null ? name . id : 0 , ext ! = null ? ext . id : 0 , subpath ! = null ? subpath . id : 0 , localizationName ! = null ? localizationName . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_resourcePath ) ;
public long font ;
public long function ;
public long tile ;
public long stipple ;
public long clip_mask ;
long [ ] value = new long [ 1 ] ;
boolean acceptsFirstResponder ( long id , long sel ) {
long superValue = super . accessibilityAttributeValue ( id , sel , arg0 ) ;
NSSize cellSize ( long id , long sel ) {
long [ ] outValue = new long [ 1 ] ;
long rowIndex = outValue [ 0 ] ;
long tableColumn = outValue [ 0 ] ;
boolean canDragRowsWithIndexes_atPoint ( long id , long sel , long rowIndexes , NSPoint mouseDownPoint ) {
long columnAtPoint ( long id , long sel , NSPoint point ) {
long cls = NSButton . cellClass ( ) ;
void deselectAll ( long id , long sel , long sender ) {
void deselectRow ( long id , long sel , long index ) {
long columnId = array . objectAtIndex ( i ) . id ;
void drawBackgroundInClipRect ( long id , long sel , NSRect rect ) {
void drawInteriorWithFrame_inView ( long id , long sel , NSRect rect , long view ) {
long [ ] outValue = new long [ 1 ] ;
long rowIndex = outValue [ 0 ] ;
double offsetX = 0 , offsetY = 0 ;
double [ ] colorRGB = background . handle ;
double [ ] color = userForeground . handle ;
void drawWithExpansionFrame_inView ( long id , long sel , NSRect cellFrame , long view ) {
NSRect expansionFrameWithFrame_inView ( long id , long sel , NSRect cellRect , long view ) {
long index = headerView . columnAtPoint ( pt ) ;
long [ ] indexBuffer = new long [ count ] ;
long [ ] result = new long [ count ] ;
long [ ] indices = new long [ count ] ;
NSRect headerRectOfColumn ( long id , long sel , long column ) {
void highlightSelectionInClipRect ( long id , long sel , long rect ) {
long hitTestForEvent ( long id , long sel , long event , NSRect rect , long controlView ) {
NSRect imageRectForBounds ( long id , long sel , NSRect cellFrame ) {
void keyDown ( long id , long sel , long theEvent ) {
long menuForEvent ( long id , long sel , long theEvent ) {
long row = table . rowAtPoint ( mousePoint ) ;
void mouseDown ( long id , long sel , long theEvent ) {
void mouseDownSuper ( long id , long sel , long theEvent ) {
boolean needsPanelToBecomeKey ( long id , long sel ) {
long nextState ( long id , long sel ) {
long numberOfRowsInTableView ( long id , long sel , long aTableView ) {
void scrollClipViewToPoint ( long id , long sel , long clipView , NSPoint point ) {
void setImage ( long id , long sel , long arg0 ) {
void setShouldScrollClipView ( long id , long sel , boolean shouldScroll ) {
void selectRowIndexes_byExtendingSelection ( long id , long sel , long indexes , boolean extend ) {
void tableViewColumnDidMove ( long id , long sel , long aNotification ) {
void tableViewColumnDidResize ( long id , long sel , long aNotification ) {
void tableViewSelectionDidChange ( long id , long sel , long aNotification ) {
void tableViewSelectionIsChanging ( long id , long sel , long aNotification ) {
void tableView_didClickTableColumn ( long id , long sel , long tableView , long tableColumn ) {
long tableView_objectValueForTableColumn_row ( long id , long sel , long aTableView , long aTableColumn , long rowIndex ) {
boolean tableView_shouldReorderColumn_toColumn ( long id , long sel , long aTableView , long currentColIndex , long newColIndex ) {
boolean tableView_shouldTrackCell_forTableColumn_row ( long id , long sel , long table , long cell , long tableColumn , long rowIndex ) {
void tableView_setObjectValue_forTableColumn_row ( long id , long sel , long aTableView , long anObject , long aTableColumn , long rowIndex ) {
void tableView_willDisplayCell_forTableColumn_row ( long id , long sel , long aTableView , long cell , long tableColumn , long rowIndex ) {
boolean tableView_writeRowsWithIndexes_toPasteboard ( long id , long sel , long arg0 , long arg1 , long arg2 ) {
long [ ] indexBuffer = new long [ count ] ;
NSRect titleRectForBounds ( long id , long sel , NSRect cellFrame ) {
public long lpstrSchema ;
public long tdescAlias_unionField ;
public nsIDOMSerializer ( long address ) {
public int SerializeToString ( long root , long [ ] _retval ) {
public int SerializeToStream ( long root , long stream , byte [ ] charset ) {
public long lpText ;
public long hwndChild ;
public long hbmBack ;
public long lParam ;
public nsIInterfaceRequestor ( long address ) {
public int GetInterface ( nsID uuid , long [ ] result ) {
long accessibleHandle ( ) {
long accessibilityActionDescription ( long id , long sel , long arg0 ) {
long accessibilityActionNames ( long id , long sel ) {
long accessibilityAttributeNames ( long id , long sel ) {
long accessibilityAttributeValue ( long id , long sel , long arg0 ) {
long accessibilityAttributeValue_forParameter ( long id , long sel , long arg0 , long arg1 ) {
long accessibilityFocusedUIElement ( long id , long sel ) {
long accessibilityHitTest ( long id , long sel , NSPoint point ) {
boolean accessibilityIsAttributeSettable ( long id , long sel , long arg0 ) {
boolean accessibilityIsIgnored ( long id , long sel ) {
long accessibilityParameterizedAttributeNames ( long id , long sel ) {
void accessibilityPerformAction ( long id , long sel , long arg0 ) {
void accessibilitySetValue_forAttribute ( long id , long sel , long arg0 , long arg1 ) {
long attributedSubstringFromRange ( long id , long sel , long range ) {
void callSuper ( long id , long sel ) {
void callSuper ( long id , long sel , long arg0 ) {
void callSuper ( long id , long sel , NSRect arg0 ) {
void callSuper ( long id , long sel , long arg0 , long arg1 ) {
void callSuper ( long id , long sel , NSRect arg0 , long arg1 ) {
long callSuper ( long id , long sel , long arg0 , NSRect arg1 , long arg2 ) {
boolean callSuperBoolean ( long id , long sel ) {
boolean canBecomeKeyWindow ( long id , long sel ) {
boolean needsPanelToBecomeKey ( long id , long sel ) {
void cancelOperation ( long id , long sel , long arg0 ) {
NSSize cellSize ( long id , long sel ) {
NSSize cellSizeForBounds ( long id , long sel , NSRect cellFrame ) {
boolean callSuperBoolean ( long id , long sel , long arg0 ) {
boolean callSuperBoolean ( long id , long sel , NSRange range , long arg1 ) {
long callSuperObject ( long id , long sel ) {
long callSuperObject ( long id , long sel , long arg0 ) {
long callSuperObject ( long id , long sel , long arg0 , long arg1 ) {
NSRect callSuperRect ( long id , long sel , long arg0 ) {
boolean canDragRowsWithIndexes_atPoint ( long id , long sel , long rowIndexes , NSPoint mouseDownPoint ) {
long characterIndexForPoint ( long id , long sel , long point ) {
long columnAtPoint ( long id , long sel , NSPoint point ) {
boolean acceptsFirstMouse ( long id , long sel , long theEvent ) {
boolean acceptsFirstResponder ( long id , long sel ) {
boolean becomeFirstResponder ( long id , long sel ) {
void becomeKeyWindow ( long id , long sel ) {
boolean resignFirstResponder ( long id , long sel ) {
boolean canBecomeKeyView ( long id , long sel ) {
void clearDeferFlushing ( long id , long sel ) {
boolean textView_clickOnLink_atIndex ( long id , long sel , long textView , long link , long charIndex ) {
void collapseItem_collapseChildren ( long id , long sel , long item , boolean children ) {
void comboBoxSelectionDidChange ( long id , long sel , long notification ) {
void comboBoxWillDismiss ( long id , long sel , long notification ) {
void comboBoxWillPopUp ( long id , long sel , long notification ) {
void deselectAll ( long id , long sel , long sender ) {
void deselectRow ( long id , long sel , long index ) {
void doCommandBySelector ( long id , long sel , long aSelector ) {
boolean dragSelectionWithEvent ( long id , long sel , long arg0 , long arg1 , long arg2 ) {
void drawBackground ( long id , NSGraphicsContext context , NSRect rect ) {
void drawBackgroundInClipRect ( long id , long sel , NSRect rect ) {
void drawImageWithFrameInView ( long id , long sel , long image , NSRect rect , long view ) {
NSRect drawTitleWithFrameInView ( long id , long sel , long title , NSRect rect , long view ) {
void drawInteriorWithFrame_inView ( long id , long sel , NSRect cellFrame , long view ) {
void drawLabelInRect ( long id , long sel , boolean shouldTruncateLabel , NSRect rect ) {
void drawViewBackgroundInRect ( long id , long sel , NSRect rect ) {
void drawWithExpansionFrame_inView ( long id , long sel , NSRect cellFrame , long view ) {
void drawRect ( long id , long sel , NSRect rect ) {
void _drawThemeProgressArea ( long id , long sel , long arg0 ) {
void drawWidget ( long id , NSGraphicsContext context , NSRect rect ) {
long imageView ( ) {
void redrawWidget ( NSView view , long x , long y , long width , long height , boolean children ) {
void expandItem_expandChildren ( long id , long sel , long item , boolean children ) {
NSRect expansionFrameWithFrame_inView ( long id , long sel , NSRect cellRect , long view ) {
NSRect firstRectForCharacterRange ( long id , long sel , long range ) {
boolean hasMarkedText ( long id , long sel ) {
NSRect headerRectOfColumn ( long id , long sel , long column ) {
void helpRequested ( long id , long sel , long theEvent ) {
void highlightSelectionInClipRect ( long id , long sel , long rect ) {
long hitTest ( long id , long sel , NSPoint point ) {
long hitTestForEvent ( long id , long sel , long event , NSRect rect , long controlView ) {
long image ( long id , long sel ) {
NSRect imageRectForBounds ( long id , long sel , NSRect cellFrame ) {
boolean insertText ( long id , long sel , long string ) {
boolean isFlipped ( long id , long sel ) {
boolean isOpaque ( long id , long sel ) {
void flagsChanged ( long id , long sel , long theEvent ) {
void keyDown ( long id , long sel , long theEvent ) {
void keyUp ( long id , long sel , long theEvent ) {
void mouseDown ( long id , long sel , long theEvent ) {
boolean mouseDownCanMoveWindow ( long id , long sel ) {
void mouseDownSuper ( long id , long sel , long theEvent ) {
void mouseUp ( long id , long sel , long theEvent ) {
void mouseMoved ( long id , long sel , long theEvent ) {
void mouseDragged ( long id , long sel , long theEvent ) {
void mouseEntered ( long id , long sel , long theEvent ) {
void mouseExited ( long id , long sel , long theEvent ) {
void cursorUpdate ( long id , long sel , long theEvent ) {
void rightMouseDown ( long id , long sel , long theEvent ) {
void rightMouseUp ( long id , long sel , long theEvent ) {
void rightMouseDragged ( long id , long sel , long theEvent ) {
void otherMouseDown ( long id , long sel , long theEvent ) {
void otherMouseUp ( long id , long sel , long theEvent ) {
void otherMouseDragged ( long id , long sel , long theEvent ) {
boolean shouldDelayWindowOrderingForEvent ( long id , long sel , long theEvent ) {
boolean menuHasKeyEquivalent_forEvent_target_action ( long id , long sel , long menu , long event , long target , long action ) {
long menuForEvent ( long id , long sel , long theEvent ) {
void menuNeedsUpdate ( long id , long sel , long menu ) {
boolean makeFirstResponder ( long id , long sel , long notification ) {
NSRange markedRange ( long id , long sel ) {
void menu_willHighlightItem ( long id , long sel , long menu , long item ) {
void menuDidClose ( long id , long sel , long menu ) {
void menuWillOpen ( long id , long sel , long menu ) {
void noResponderFor ( long id , long sel , long selector ) {
long numberOfRowsInTableView ( long id , long sel , long aTableView ) {
long outlineView_child_ofItem ( long id , long sel , long outlineView , long index , long item ) {
void outlineView_didClickTableColumn ( long id , long sel , long outlineView , long tableColumn ) {
long outlineView_objectValueForTableColumn_byItem ( long id , long sel , long outlineView , long tableColumn , long item ) {
boolean outlineView_isItemExpandable ( long id , long sel , long outlineView , long item ) {
long outlineView_numberOfChildrenOfItem ( long id , long sel , long outlineView , long item ) {
boolean outlineView_shouldExpandItem_item ( long id , long sel , long outlineView , long item ) {
boolean outlineView_shouldReorderColumn_toColumn ( long id , long sel , long aTableView , long columnIndex , long newColumnIndex ) {
boolean outlineView_shouldEditTableColumn_row ( long id , long sel , long aTableView , long aTableColumn , long item ) {
boolean outlineView_shouldTrackCell_forTableColumn_item ( long id , long sel , long table , long cell , long tableColumn , long item ) {
void outlineView_willDisplayCell_forTableColumn_item ( long id , long sel , long outlineView , long cell , long tableColumn , long item ) {
void outlineViewColumnDidMove ( long id , long sel , long aNotification ) {
void outlineViewColumnDidResize ( long id , long sel , long aNotification ) {
void outlineViewSelectionDidChange ( long id , long sel , long notification ) {
void outlineViewSelectionIsChanging ( long id , long sel , long notification ) {
void outlineView_setObjectValue_forTableColumn_byItem ( long id , long sel , long outlineView , long object , long tableColumn , long item ) {
boolean outlineView_writeItems_toPasteboard ( long id , long sel , long arg0 , long arg1 , long arg2 ) {
void pageDown ( long id , long sel , long sender ) {
void pageUp ( long id , long sel , long sender ) {
void reflectScrolledClipView ( long id , long sel , long aClipView ) {
void scrollClipViewToPoint ( long id , long sel , long clipView , NSPoint point ) {
void selectRowIndexes_byExtendingSelection ( long id , long sel , long indexes , boolean extend ) {
void scrollWheel ( long id , long sel , long theEvent ) {
NSRange selectedRange ( long id , long sel ) {
long nextValidKeyView ( long id , long sel ) {
long previousValidKeyView ( long id , long sel ) {
void setFrameOrigin ( long id , long sel , NSPoint point ) {
void setFrameSize ( long id , long sel , NSSize size ) {
void setImage ( long id , long sel , long arg0 ) {
long modifierFlags = nsEvent . modifierFlags ( ) ;
long cgEvent = nsEvent . CGEvent ( ) ;
boolean setMarkedText_selectedRange ( long id , long sel , long string , long range ) {
void setNeedsDisplay ( long id , long sel , boolean flag ) {
void setNeedsDisplayInRect ( long id , long sel , long arg0 ) {
void setObjectValue ( long id , long sel , long arg0 ) {
void setShouldExpandItem ( long id , long sel , boolean shouldExpand ) {
void setShouldScrollClipView ( long id , long sel , boolean shouldScroll ) {
boolean shouldChangeTextInRange_replacementString ( long id , long sel , long arg0 , long arg1 ) {
NSSize sizeOfLabel ( long id , long sel , boolean shouldTruncateLabel ) {
void superKeyDown ( long id , long sel , long theEvent ) {
void superKeyUp ( long id , long sel , long theEvent ) {
void tableViewColumnDidMove ( long id , long sel , long aNotification ) {
void tableViewColumnDidResize ( long id , long sel , long aNotification ) {
void tableViewSelectionDidChange ( long id , long sel , long aNotification ) {
void tableViewSelectionIsChanging ( long id , long sel , long aNotification ) {
void tableView_didClickTableColumn ( long id , long sel , long tableView , long tableColumn ) {
long tableView_objectValueForTableColumn_row ( long id , long sel , long aTableView , long aTableColumn , long rowIndex ) {
boolean tableView_shouldSelectRow ( long id , long sel , long tableView , long index ) {
void tableView_setObjectValue_forTableColumn_row ( long id , long sel , long aTableView , long anObject , long aTableColumn , long rowIndex ) {
boolean tableView_shouldReorderColumn_toColumn ( long id , long sel , long aTableView , long columnIndex , long newColumnIndex ) {
boolean tableView_shouldEditTableColumn_row ( long id , long sel , long aTableView , long aTableColumn , long rowIndex ) {
boolean tableView_shouldTrackCell_forTableColumn_row ( long id , long sel , long table , long cell , long tableColumn , long rowIndex ) {
void tableView_willDisplayCell_forTableColumn_row ( long id , long sel , long aTableView , long aCell , long aTableColumn , long rowIndex ) {
void textViewDidChangeSelection ( long id , long sel , long aNotification ) {
void textDidChange ( long id , long sel , long aNotification ) {
void textDidEndEditing ( long id , long sel , long aNotification ) {
NSRange textView_willChangeSelectionFromCharacterRange_toCharacterRange ( long id , long sel , long aTextView , long oldSelectedCharRange , long newSelectedCharRange ) {
NSRect titleRectForBounds ( long id , long sel , NSRect cellFrame ) {
long toolbar_itemForItemIdentifier_willBeInsertedIntoToolbar ( long id , long sel , long toolbar , long itemID , boolean flag ) {
long toolbarAllowedItemIdentifiers ( long id , long sel , long toolbar ) {
long toolbarDefaultItemIdentifiers ( long id , long sel , long toolbar ) {
long toolbarSelectableItemIdentifiers ( long id , long sel , long toolbar ) {
void touchesBeganWithEvent ( long id , long sel , long event ) {
void touchesCancelledWithEvent ( long id , long sel , long event ) {
void touchesEndedWithEvent ( long id , long sel , long event ) {
void touchesMovedWithEvent ( long id , long sel , long event ) {
void beginGestureWithEvent ( long id , long sel , long event ) {
void endGestureWithEvent ( long id , long sel , long event ) {
void magnifyWithEvent ( long id , long sel , long event ) {
void rotateWithEvent ( long id , long sel , long event ) {
void swipeWithEvent ( long id , long sel , long event ) {
void resetCursorRects ( long id , long sel ) {
void updateTrackingAreas ( long id , long sel ) {
long validAttributesForMarkedText ( long id , long sel ) {
void tabView_didSelectTabViewItem ( long id , long sel , long tabView , long tabViewItem ) {
void tabView_willSelectTabViewItem ( long id , long sel , long tabView , long tabViewItem ) {
boolean tableView_writeRowsWithIndexes_toPasteboard ( long id , long sel , long arg0 , long arg1 , long arg2 ) {
boolean validateMenuItem ( long id , long sel , long menuItem ) {
long view_stringForToolTip_point_userData ( long id , long sel , long view , long tag , long point , long userData ) {
void viewDidMoveToWindow ( long id , long sel ) {
void viewWillMoveToWindow ( long id , long sel , long arg0 ) {
void windowDidMove ( long id , long sel , long notification ) {
void windowDidResize ( long id , long sel , long notification ) {
void windowDidResignKey ( long id , long sel , long notification ) {
void windowDidBecomeKey ( long id , long sel , long notification ) {
void windowDidMiniturize ( long id , long sel , long notification ) {
void windowDidDeminiturize ( long id , long sel , long notification ) {
void windowSendEvent ( long id , long sel , long event ) {
boolean windowShouldClose ( long id , long sel , long window ) {
void windowWillClose ( long id , long sel , long notification ) {
long nextState ( long id , long sel ) {
void updateOpenGLContext ( long id , long sel , long notification ) {
boolean shouldDrawInsertionPoint ( long id , long sel ) {
boolean readSelectionFromPasteboard ( long id , long sel , long pasteboard ) {
long validRequestorForSendType ( long id , long sel , long sendType , long returnType ) {
boolean writeSelectionToPasteboard ( long id , long sel , long pasteboard , long types ) {
long list = 0 ;
long current = list ;
long utf8Ptr = 0 ;
long path = OS . gtk_file_chooser_get_filename ( handle ) ;
long filter = OS . gtk_file_chooser_get_filter ( handle ) ;
long filterNamePtr = OS . gtk_file_filter_get_name ( filter ) ;
long shellHandle = parent . topHandle ( ) ;
long group = OS . gtk_window_get_group ( 0 ) ;
long pixbufs = OS . gtk_window_get_icon_list ( shellHandle ) ;
long hookId = 0 ;
long ptr = OS . realpath ( buffer , null ) ;
long ptr = OS . realpath ( buffer , null ) ;
long initialFilter = 0 ;
long filter = OS . gtk_file_filter_new ( ) ;
public nsIWebNavigationInfo ( long address ) {
public int IsTypeSupported ( long aType , long aWebNav , int [ ] _retval ) {
public long lParam ;
public long pszText ;
public long points ;
public IOleDocumentView ( long address ) {
public int SetInPlaceSite ( long pIPSite ) {
public NSStatusItem ( long id ) {
public void setLength ( double length ) {
public long handle ;
long gdkGC = drawable . internal_new_GC ( data ) ;
static void addCairoString ( long cairo , String string , float x , float y , Font font ) {
long layout = OS . pango_cairo_create_layout ( cairo ) ;
public static GC gtk_new ( long handle , GCData data ) {
long gdkGC = drawable . internal_new_GC ( data ) ;
long cairo = data . cairo ;
long newPattern = Cairo . cairo_pattern_create_for_surface ( pattern . surface ) ;
long [ ] rects = new long [ 1 ] ;
long polyRgn = OS . gdk_region_polygon ( pointArray , pointArray . length / 2 , OS . GDK_EVEN_ODD_RULE ) ;
long cairo = Cairo . cairo_create ( image . surface ) ;
long gdkGC = OS . gdk_gc_new ( image . pixmap ) ;
long drawable = data . drawable ;
long visibleRegion = OS . gdk_drawable_get_visible_region ( drawable ) ;
long copyRegion = OS . gdk_region_rectangle ( srcRect ) ;
long invalidateRegion = OS . gdk_region_rectangle ( srcRect ) ;
long context = OS . gdk_pango_context_get ( ) ;
long layout = OS . pango_layout_new ( context ) ;
long cairo = data . cairo ;
long clipRgn = data . clipRgn ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long pattern = Cairo . cairo_pattern_create_for_surface ( srcImage . surface ) ;
long newPattern = Cairo . cairo_pattern_create_for_surface ( surface ) ;
long pixbuf = scale ( srcImage . pixmap , srcX , srcY , srcWidth , srcHeight , destWidth , destHeight ) ;
long pixbuf = OS . gdk_pixbuf_new ( OS . GDK_COLORSPACE_RGB , true , 8 , srcWidth , srcHeight ) ;
long colormap = OS . gdk_colormap_get_system ( ) ;
long pixels = OS . gdk_pixbuf_get_pixels ( pixbuf ) ;
long scaledPixbuf = OS . gdk_pixbuf_scale_simple ( pixbuf , destWidth , destHeight , OS . GDK_INTERP_BILINEAR ) ;
long maskPixmap = srcImage . mask ;
long pixbuf = OS . gdk_pixbuf_new ( OS . GDK_COLORSPACE_RGB , true , 8 , srcWidth , srcHeight ) ;
long colormap = OS . gdk_colormap_get_system ( ) ;
long maskPixbuf = OS . gdk_pixbuf_new ( OS . GDK_COLORSPACE_RGB , false , 8 , srcWidth , srcHeight ) ;
long pixels = OS . gdk_pixbuf_get_pixels ( pixbuf ) ;
long maskPixels = OS . gdk_pixbuf_get_pixels ( maskPixbuf ) ;
long offset = pixels + ( y * stride ) ;
long maskOffset = maskPixels + ( y * maskStride ) ;
long scaledPixbuf = OS . gdk_pixbuf_scale_simple ( pixbuf , destWidth , destHeight , OS . GDK_INTERP_BILINEAR ) ;
long mask = OS . gdk_bitmap_create_from_data ( 0 , maskData , newWidth , newHeight ) ;
long gc = OS . gdk_gc_new ( mask ) ;
void drawImageXRender ( Image srcImage , int srcX , int srcY , int srcWidth , int srcHeight , int destX , int destY , int destWidth , int destHeight , boolean simple , int imgWidth , int imgHeight , long maskPixmap , int maskType ) {
long drawable = data . drawable ;
long [ ] real_drawable = new long [ 1 ] ;
long srcPict = OS . XRenderCreatePicture ( xDisplay , OS . gdk_x11_drawable_get_xid ( srcImage . pixmap ) , format , 0 , null ) ;
long clipping = data . clipRgn ;
long [ ] rects = new long [ 1 ] ;
long colormap = OS . gdk_colormap_get_system ( ) ;
long scaledPixbuf = OS . gdk_pixbuf_scale_simple ( pixbuf , destWidth , destHeight , OS . GDK_INTERP_BILINEAR ) ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long copy = Cairo . cairo_copy_path ( path . handle ) ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long cairo = data . cairo ;
void drawPolyline ( long cairo , int [ ] pointArray , boolean close ) {
long cairo = data . cairo ;
long cairo = data . cairo ;
long drawable = data . drawable ;
long cairo = data . cairo ;
long layout = data . layout ;
long pixmap = OS . gdk_pixmap_new ( OS . gdk_get_default_root_window ( ) , data . stringWidth , data . stringHeight , - 1 ) ;
long gdkGC = OS . gdk_gc_new ( pixmap ) ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long drawable = data . drawable ;
long rgn = OS . gdk_region_new ( ) ;
long clipping = region . handle ;
long rgn = convertRgn ( clipRgn , data . clippingTransform ) ;
long rgn = convertRgn ( clipping , matrix ) ;
long cairo = data . cairo ;
long surface = Cairo . cairo_get_target ( handle ) ;
long options = Cairo . cairo_font_options_create ( ) ;
long options = OS . pango_cairo_context_get_font_options ( data . context ) ;
long cairo = data . cairo ;
void init ( Drawable drawable , GCData data , long gdkGC ) {
long cairo = data . cairo = handle ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long drawable = data . drawable ;
long [ ] real_drawable = new long [ 1 ] ;
long surface = Cairo . cairo_xlib_surface_create ( xDisplay , xDrawable , xVisual , width , height ) ;
long cairo = data . cairo ;
long cairo = data . cairo ;
static void setCairoFont ( long cairo , Font font ) {
static void setCairoRegion ( long cairo , long rgn ) {
long [ ] rects = new long [ 1 ] ;
static void setCairoPatternColor ( long pattern , int offset , Color c , int alpha ) {
long clipping = data . damageRgn ! = 0 ? data . damageRgn : 0 ;
long clipping = clipRgn ;
long clipRgn = OS . gdk_region_new ( ) ;
long cairo = data . cairo ;
long layout = data . layout ;
long options = Cairo . cairo_font_options_create ( ) ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long cairo = data . cairo ;
long hTheme = OS . OpenThemeData ( 0 , getClassId ( ) ) ;
public NSButton ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_attributedTitle ) ;
public void setBezelStyle ( long bezelStyle ) {
public void setButtonType ( long aType ) {
public void setImagePosition ( long aPosition ) {
public void setState ( long value ) {
public long state ( ) {
public static long cellClass ( ) {
public static void setCellClass ( long factoryId ) {
public long pbData ;
public NSURLRequest ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_URL ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_initWithURL_ , URL ! = null ? URL . id : 0 ) ;
long result = OS . objc_msgSend ( OS . class_NSURLRequest , OS . sel_requestWithURL_ , URL ! = null ? URL . id : 0 ) ;
long boxHandle , labelHandle , imageHandle , arrowHandle , groupHandle ;
static GtkBorder getBorder ( byte [ ] border , long handle , int defaultBorder ) {
long [ ] borderPtr = new long [ 1 ] ;
long style = OS . gtk_widget_get_style ( handle ) ;
long labelLayout = OS . gtk_label_get_layout ( labelHandle ) ;
long fontHandle ( ) {
long gtk_clicked ( long widget ) {
long labelLayout = OS . gtk_label_get_layout ( labelHandle ) ;
void setFontDescription ( long font ) {
long pixbuf = imageList . getPixbuf ( imageIndex ) ;
public long create_accessible ;
public long invalidate ;
public long get_accessible_type ;
public long handle ;
long display = 0 ;
long pixbuf = OS . gdk_pixbuf_new ( OS . GDK_COLORSPACE_RGB , true , 8 , width , height ) ;
long data = OS . gdk_pixbuf_get_pixels ( pixbuf ) ;
public static Cursor gtk_new ( Device device , long handle ) {
public long elpHatch ;
long list = OS . gtk_container_get_children ( result ) ;
long temp = list ;
long widget = OS . g_list_data ( temp ) ;
long callWindowProc ( long hwnd , int msg , long wParam , long lParam ) {
long hwndTrack = parent . handle ;
long windowProc ( ) {
LRESULT WM_ERASEBKGND ( long wParam , long lParam ) {
LRESULT WM_KEYDOWN ( long wParam , long lParam ) {
long hwndTrack = parent . handle ;
LRESULT WM_GETDLGCODE ( long wParam , long lParam ) {
LRESULT WM_LBUTTONDOWN ( long wParam , long lParam ) {
long hwndTrack = parent . handle ;
LRESULT WM_LBUTTONUP ( long wParam , long lParam ) {
LRESULT WM_MOUSEMOVE ( long wParam , long lParam ) {
long hwndTrack = parent . handle ;
LRESULT WM_SETCURSOR ( long wParam , long lParam ) {
long hCursor = 0 ;
public nsILocalFile ( long address ) {
public int InitWithPath ( long filePath ) {
public int InitWithNativePath ( long filePath ) {
public int InitWithFile ( long aFile ) {
public int OpenNSPRFileDesc ( int flags , int mode , long [ ] _retval ) {
public int OpenANSIFileDesc ( byte [ ] mode , long [ ] _retval ) {
public int Load ( long [ ] _retval ) {
public int AppendRelativePath ( long relativeFilePath ) {
public int AppendRelativeNativePath ( long relativeFilePath ) {
public int GetPersistentDescriptor ( long aPersistentDescriptor ) {
public int SetPersistentDescriptor ( long aPersistentDescriptor ) {
public int GetRelativeDescriptor ( long fromFile , long _retval ) {
public int SetRelativeDescriptor ( long fromFile , long relativeDesc ) {
public NSAffineTransform ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_initWithTransform_ , transform ! = null ? transform . id : 0 ) ;
public void rotateByDegrees ( double angle ) {
public void scaleXBy ( double scaleX , double scaleY ) {
long result = OS . objc_msgSend ( OS . class_NSAffineTransform , OS . sel_transform ) ;
public void translateXBy ( double deltaX , double deltaY ) {
public IDataObject ( long address ) {
public int EnumFormatEtc ( int dwDirection , long [ ] ppenumFormatetc ) {
public long children ;
public nsICertOverrideService ( long address ) {
public int RememberValidityOverride ( long aHostName , int aPort , long aCert , int aOverrideBits , int aTemporary ) {
public int HasMatchingOverride ( long aHostName , int aPort , long aCert , int [ ] aOverrideBits , int [ ] aIsTemporary , int [ ] _retval ) {
public int GetValidityOverride ( long aHostName , int aPort , long aHashAlg , long aFingerprint , int [ ] aOverrideBits , int [ ] aIsTemporary , int [ ] _retval ) {
public int ClearValidityOverride ( long aHostName , int aPort ) {
public int GetAllOverrideHostsWithPorts ( int [ ] aCount , long [ ] aHostsWithPortsArray ) {
public int IsCertUsedForOverrides ( long aCert , int aCheckTemporaries , int aCheckPermanents , int [ ] _retval ) {
public static void addLanguageListener ( long hwnd , Runnable runnable ) {
static long EnumSystemLanguageGroupsProc ( long lpLangGrpId , long lpLangGrpIdString , long lpLangGrpName , long options , long lParam ) {
long hHeap = OS . GetProcessHeap ( ) ;
long hHeap = OS . GetProcessHeap ( ) ;
long layout = OS . GetKeyboardLayout ( 0 ) ;
static long [ ] getKeyboardLanguageList ( ) {
long [ ] tempList = new long [ maxSize ] ;
long [ ] list = new long [ size ] ;
static boolean isBidiLang ( long lang ) {
long lpEnumSystemLanguageGroupsProc = callback . getAddress ( ) ;
long [ ] list = getKeyboardLanguageList ( ) ;
public static void removeLanguageListener ( long hwnd ) {
long [ ] list = getKeyboardLanguageList ( ) ;
public static boolean setOrientation ( long hwnd , int orientation ) {
static void subclass ( long hwnd ) {
long oldProc = OS . GetWindowLongPtr ( hwnd , OS . GWLP_WNDPROC ) ;
static void unsubclass ( long hwnd ) {
static long windowProc ( long hwnd , long msg , long wParam , long lParam ) {
public NSHTTPCookie ( long id ) {
long result = OS . objc_msgSend ( OS . class_NSHTTPCookie , OS . sel_cookiesWithResponseHeaderFields_forURL_ , headerFields ! = null ? headerFields . id : 0 , URL ! = null ? URL . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_name ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_value ) ;
public IPersistStorage ( long address ) {
public int InitNew ( long pStg ) {
public int Load ( long pStg ) {
public int Save ( long pStgSave , boolean fSameAsLoad ) {
public int SaveCompleted ( long pStgNew ) {
long traits = manager . traitsOfFont ( handle ) ;
static native final long getAWTHandle ( Canvas canvas ) ;
final long handle = parent . view . id ;
long handle = 0 ;
public WebFrame ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_DOMDocument ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_dataSource ) ;
public long globalContext ( ) {
public IWebFrame ( long address ) {
public int loadRequest ( long request ) {
public int loadHTMLString ( long string , long baseURL ) {
public int dataSource ( long [ ] source ) {
public long globalContext ( ) {
public NSURLDownload ( long id ) {
long newPtr = OS . GlobalAlloc ( COM . GMEM_FIXED | COM . GMEM_ZEROINIT , DROPFILES . sizeof + byteCount ) ;
public nsIHelperAppLauncherDialog ( long address ) {
public int Show ( long aLauncher , long aContext ) {
public int PromptForSaveToFile ( long aWindowContext , char [ ] aDefaultFile , char [ ] aSuggestedFileExtension , long [ ] _retval ) {
public int ShowProgressDialog ( long aLauncher , long aContext ) {
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hwndHeader = OS . SendMessage ( hwnd , OS . LVM_GETHEADER , 0 , 0 ) ;
long hwndHeader = OS . SendMessage ( hwnd , OS . LVM_GETHEADER , 0 , 0 ) ;
long hFont = item . fontHandle ( index ) ;
long hImageList = OS . SendMessage ( hwnd , OS . LVM_GETIMAGELIST , OS . LVSIL_SMALL , 0 ) ;
long hStateList = OS . SendMessage ( hwnd , OS . LVM_GETIMAGELIST , OS . LVSIL_STATE , 0 ) ;
long hwnd = parent . handle ;
long hwndHeader = OS . SendMessage ( hwnd , OS . LVM_GETHEADER , 0 , 0 ) ;
long hwnd = parent . handle ;
long hwndHeader = OS . SendMessage ( hwnd , OS . LVM_GETHEADER , 0 , 0 ) ;
long hwnd = parent . handle ;
long hHeap = OS . GetProcessHeap ( ) ;
long pszText = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount ) ;
long result = OS . SendMessage ( hwnd , OS . LVM_SETCOLUMN , index , lvColumn ) ;
long hwndHeaderToolTip = parent . headerToolTipHandle ;
long hwnd = parent . handle ;
long hwndHeaderToolTip = parent . headerToolTipHandle ;
public long set_run_attributes ;
public long set_text_contents ;
public long insert_text ;
public long copy_text ;
public long cut_text ;
public long delete_text ;
public long paste_text ;
public NSClipView ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_documentCursor ) ;
long shellHandle = parent . topHandle ( ) ;
long handle = 0 ;
long group = OS . gtk_window_get_group ( 0 ) ;
long pixbufs = OS . gtk_window_get_icon_list ( shellHandle ) ;
long ptr = OS . realpath ( buffer , null ) ;
long box = 0 ;
long label = OS . gtk_label_new ( buffer ) ;
long hookId = 0 ;
long path = OS . gtk_file_chooser_get_filename ( handle ) ;
long utf8Ptr = OS . g_filename_to_utf8 ( path , - 1 , null , null , null ) ;
public long hwnd ;
public long lpVerb ;
public long lpParameters ;
public long lpDirectory ;
public long hInstApp ;
public long lpIDList ;
public long lpClass ;
public long hkeyClass ;
public long hIcon ;
public long hProcess ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hwndAbove = 0 ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
long hwnd = parent . handle ;
public NSText ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_delegate ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_font ) ;
public void setAlignment ( long mode ) {
public void setBaseWritingDirection ( long writingDirection ) {
long result = OS . objc_msgSend ( this . id , OS . sel_string ) ;
public NSComboBox ( long id ) {
public void deselectItemAtIndex ( long index ) {
public long indexOfSelectedItem ( ) {
public void insertItemWithObjectValue ( id object , long index ) {
public long numberOfItems ( ) {
public long numberOfVisibleItems ( ) {
public void removeItemAtIndex ( long index ) {
public void selectItemAtIndex ( long index ) {
public void setNumberOfVisibleItems ( long visibleItems ) {
public static long cellClass ( ) {
public static void setCellClass ( long factoryId ) {
long [ ] result = new long [ 1 ] ;
public nsIDOMMouseEvent ( long address ) {
public int GetRelatedTarget ( long [ ] aRelatedTarget ) {
public int InitMouseEvent ( long typeArg , int canBubbleArg , int cancelableArg , long viewArg , int detailArg , int screenXArg , int screenYArg , int clientXArg , int clientYArg , int ctrlKeyArg , int altKeyArg , int shiftKeyArg , int metaKeyArg , short buttonArg , long relatedTargetArg ) {
public int InitNSMouseEvent ( long typeArg , int canBubbleArg , int cancelableArg , long viewArg , int detailArg , int screenXArg , int screenYArg , int clientXArg , int clientYArg , int ctrlKeyArg , int altKeyArg , int shiftKeyArg , int metaKeyArg , short buttonArg , long relatedTargetArg , float pressure , short inputSourceArg ) {
long buttonHandle , entryHandle , textRenderer , cellHandle , popupHandle , menuHandle ;
long gdkEventKey = 0 ;
long layout = OS . gtk_entry_get_layout ( entryHandle ) ;
long style = OS . gtk_widget_get_style ( entryHandle ) ;
long listParent = OS . gtk_bin_get_child ( popupHandle ) ;
long oldList = OS . gtk_window_list_toplevels ( ) ;
long imContext = imContext ( ) ;
boolean filterKey ( int keyval , long event ) {
long imContext = imContext ( ) ;
long newToplevel = OS . g_list_data ( newFromList ) ;
long oldToplevel = OS . g_list_data ( oldFromList ) ;
long findButtonHandle ( ) {
long result = 0 ;
long list = display . allChildren ;
long widget = OS . g_list_data ( list ) ;
long findMenuHandle ( ) {
long result = 0 ;
long list = display . allChildren ;
long widget = OS . g_list_data ( list ) ;
void fixModal ( long group , long modalGroup ) {
long imContext = imContext ( ) ;
long fontHandle ( ) {
long focusHandle ( ) {
hookEvents ( new long [ ] { buttonHandle , entryHandle , menuHandle } ) ;
long imContext = imContext ( ) ;
void hookEvents ( long [ ] handles ) {
long eventHandle = handles [ i ] ;
long imContext ( ) {
long layout = OS . gtk_entry_get_layout ( entryHandle ) ;
long ptr = OS . pango_layout_get_text ( layout ) ;
long enterExitHandle ( ) {
long eventWindow ( ) {
long layout = OS . gtk_entry_get_layout ( entryHandle ) ;
long ptr = OS . gtk_entry_get_text ( entryHandle ) ;
long ptr = OS . gtk_entry_get_text ( entryHandle ) ;
long str = OS . gtk_entry_get_text ( entryHandle ) ;
long gtk_activate ( long widget ) {
long gtk_button_press_event ( long widget , long event ) {
long gtk_changed ( long widget ) {
long eventPtr = OS . gtk_get_current_event ( ) ;
long gtk_commit ( long imContext , long text ) {
long gtk_delete_text ( long widget , long start_pos , long end_pos ) {
long ptr = OS . gtk_entry_get_text ( entryHandle ) ;
long gtk_event_after ( long widget , long gdkEvent ) {
long gtk_focus_out_event ( long widget , long event ) {
long gtk_insert_text ( long widget , long new_text , long new_text_length , long position ) {
long ptr = OS . gtk_entry_get_text ( entryHandle ) ;
long gtk_populate_popup ( long widget , long menu ) {
long gtk_selection_done ( long menushell ) {
long gtk_style_set ( long widget , long previousStyle ) {
long window = gtk_widget_get_window ( childHandle ) ;
long children = OS . gdk_window_get_children ( window ) ;
long parentingHandle ( ) {
long imContext = imContext ( ) ;
void setButtonHandle ( long widget ) {
hookEvents ( new long [ ] { buttonHandle } ) ;
void setMenuHandle ( long widget ) {
hookEvents ( new long [ ] { menuHandle } ) ;
void setFontDescription ( long font ) {
long ptr = OS . gtk_entry_get_text ( entryHandle ) ;
long ptr = OS . gtk_entry_get_text ( entryHandle ) ;
long imContext = imContext ( ) ;
long [ ] preeditString = new long [ 1 ] ;
long eventPtr = OS . gtk_get_current_event ( ) ;
long hTheme = OS . OpenThemeData ( 0 , getClassId ( ) ) ;
long hTheme = OS . OpenThemeData ( 0 , getClassId ( ) ) ;
long hTheme = OS . OpenThemeData ( 0 , getClassId ( ) ) ;
long hTheme = OS . OpenThemeData ( 0 , getClassId ( ) ) ;
long getSiteWindow ( ) {
static native final long getAWTHandle ( Canvas canvas ) ;
final long handle = parent . handle ;
long handle = 0 ;
public IStream ( long address ) {
long [ ] ppstm
public int Read ( long pv , int cb , int [ ] pcbWritten ) {
public int Write ( long pv , int cb , int [ ] pcbWritten ) {
public nsIHelperAppLauncher_8 ( long address ) {
public int GetMIMEInfo ( long [ ] aMIMEInfo ) {
public int GetSource ( long [ ] aSource ) {
public int GetSuggestedFileName ( long aSuggestedFileName ) {
public int SaveToDisk ( long aNewFileLocation , int aRememberThisPreference ) {
public int LaunchWithApplication ( long aApplication , int aRememberThisPreference ) {
public int SetWebProgressListener ( long aWebProgressListener ) {
public int GetTargetFile ( long [ ] aTargetFile ) {
public int GetTimeDownloadStarted ( long aTimeDownloadStarted ) {
public int GetContentLength ( long aContentLength ) {
public long hIcon ;
public nsIDOMSerializer_1_7 ( long address ) {
public int SerializeToString ( long root , long _retval ) {
public int SerializeToStream ( long root , long stream , long charset ) {
long webView , webViewData , scrolledWindow ;
static long ExternalClass , PostString , WebViewType ;
long cookies = WebKitGTK . soup_cookie_jar_all_cookies ( jar ) ;
long current = cookies ;
long uri = WebKitGTK . soup_uri_new ( bytes ) ;
long cookies = WebKitGTK . soup_cookie_jar_get_cookies ( jar , uri , 0 ) ;
long uri = WebKitGTK . soup_uri_new ( bytes ) ;
long cookie = WebKitGTK . soup_cookie_parse ( bytes , uri ) ;
static Browser FindBrowser ( long webView ) {
long parent = OS . gtk_widget_get_parent ( webView ) ;
static long JSObjectCallAsFunctionProc ( long ctx , long function , long thisObject , long argumentCount , long arguments , long exception ) {
static long JSObjectGetPropertyProc ( long ctx , long object , long propertyName , long exception ) {
static long JSObjectHasPropertyProc ( long ctx , long object , long propertyName ) {
static long JSDOMEventProc ( long arg0 , long event , long user_data ) {
static long Proc ( long handle , long user_data ) {
static long Proc ( long handle , long arg0 , long arg1 , long user_data ) {
static long Proc ( long handle , long arg0 , long arg1 , long arg2 , long arg3 , long user_data ) {
long sessionProc ( long session , long msg , long auth , long retrying , long user_data ) {
long webFrameProc ( long handle , long arg0 , long user_data ) {
long webViewProc ( long handle , long user_data ) {
long webViewProc ( long handle , long arg0 , long user_data ) {
long webViewProc ( long handle , long arg0 , long arg1 , long user_data ) {
long webViewProc ( long handle , long arg0 , long arg1 , long arg2 , long user_data ) {
long webViewProc ( long handle , long arg0 , long arg1 , long arg2 , long arg3 , long user_data ) {
long classDefinitionPtr = C . malloc ( JSClassDefinition . sizeof ) ;
C . memmove ( webViewData , new long [ ] { webView } , C . PTR_SIZEOF ) ;
long settings = WebKitGTK . webkit_web_view_get_settings ( webView ) ;
long uri = WebKitGTK . soup_uri_new ( bytes ) ;
void addEventHandlers ( long web_view , boolean top ) {
long domDocument = WebKitGTK . webkit_web_view_get_dom_document ( web_view ) ;
long scriptString = WebKitGTK . JSStringCreateWithUTF8CString ( bytes ) ;
long urlString = WebKitGTK . JSStringCreateWithUTF8CString ( bytes ) ;
long result = WebKitGTK . JSEvaluateScript ( context , scriptString , 0 , urlString , 0 , null ) ;
long data = WebKitGTK . webkit_web_data_source_get_data ( source ) ;
long encoding = WebKitGTK . webkit_web_data_source_get_encoding ( source ) ;
long string = OS . GString_str ( data ) ;
long uri = WebKitGTK . webkit_web_view_get_uri ( webView ) ;
boolean handleDOMEvent ( long event , int type ) {
long handleLoadCommitted ( long uri , boolean top ) {
long handleLoadFinished ( long uri , boolean top ) {
void openDownloadWindow ( final long webkitDownload ) {
long name = WebKitGTK . webkit_download_get_suggested_filename ( webkitDownload ) ;
long url = WebKitGTK . webkit_download_get_uri ( webkitDownload ) ;
long settings = WebKitGTK . webkit_web_view_get_settings ( webView ) ;
long webframe_notify_load_status ( long web_frame , long pspec ) {
long uri = WebKitGTK . webkit_web_frame_get_uri ( web_frame ) ;
long parentFrame = WebKitGTK . webkit_web_frame_get_parent ( web_frame ) ;
long uri = WebKitGTK . webkit_web_frame_get_uri ( web_frame ) ;
long webkit_close_web_view ( long web_view ) {
long webkit_console_message ( long web_view , long message , long line , long source_id ) {
long webkit_create_web_view ( long web_view , long frame ) {
final long request = WebKitGTK . webkit_download_get_network_request ( download ) ;
long newDownload = WebKitGTK . webkit_download_new ( request ) ;
long webkit_hovering_over_link ( long web_view , long title , long uri ) {
long webkit_mime_type_policy_decision_requested ( long web_view , long frame , long request , long mimetype , long policy_decision ) {
long webkit_navigation_policy_decision_requested ( long web_view , long frame , long request , long navigation_action , long policy_decision ) {
long uri = WebKitGTK . webkit_network_request_get_uri ( request ) ;
long settings = WebKitGTK . webkit_web_view_get_settings ( webView ) ;
long mainFrame = WebKitGTK . webkit_web_view_get_main_frame ( webView ) ;
long webkit_notify_load_status ( long web_view , long pspec ) {
long uri = WebKitGTK . webkit_web_view_get_uri ( webView ) ;
long uri = WebKitGTK . webkit_web_view_get_uri ( webView ) ;
long webkit_notify_progress ( long web_view , long pspec ) {
long webkit_populate_popup ( long web_view , long webkit_menu ) {
long item = OS . g_list_data ( current ) ;
long item = OS . g_list_data ( current ) ;
long webkit_resource_request_starting ( long web_view , long web_frame , long web_resource , long request , long response ) {
long message = WebKitGTK . webkit_network_request_get_message ( request ) ;
long body = WebKitGTK . SoupMessage_request_body ( message ) ;
long data = C . malloc ( bytes . length ) ;
long requestHeaders = WebKitGTK . SoupMessage_request_headers ( message ) ;
long webkit_status_bar_text_changed ( long web_view , long text ) {
long webkit_web_view_ready ( long web_view ) {
long settings = WebKitGTK . webkit_web_view_get_window_features ( webView ) ;
long name = WebKitGTK . JSStringCreateWithUTF8CString ( bytes ) ;
long mainFrame = WebKitGTK . webkit_web_view_get_main_frame ( webView ) ;
long callJava ( long ctx , long func , long thisObject , long argumentCount , long arguments , long exception ) {
long [ ] result = new long [ 1 ] ;
long convertToJS ( long ctx , Object value ) {
long [ ] arguments = new long [ length ] ;
long jsObject = convertToJS ( ctx , javaObject ) ;
Object convertToJava ( long ctx , long value ) {
long string = WebKitGTK . JSValueToStringCopy ( ctx , value , null ) ;
long length = WebKitGTK . JSStringGetMaximumUTF8CStringSize ( string ) ;
long current = WebKitGTK . JSObjectGetPropertyAtIndex ( ctx , value , i , null ) ;
public long handle ;
long polyRgn = OS . CreatePolygonRgn ( pointArray , pointArray . length / 2 , OS . ALTERNATE ) ;
long rectRgn = OS . CreateRectRgn ( x , y , x + width , y + height ) ;
long rectRgn = OS . CreateRectRgn ( x , y , x + width , y + height ) ;
long polyRgn = OS . CreatePolygonRgn ( pointArray , pointArray . length / 2 , OS . ALTERNATE ) ;
long rectRgn = OS . CreateRectRgn ( x , y , x + width , y + height ) ;
public long hdc ;
long getAddress ( ) {
int QueryInterface ( long riid , long ppvObject ) {
XPCOM . memmove ( ppvObject , new long [ ] { supports . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { windowCreator . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { windowCreator2 . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
int CreateChromeWindow ( long parent , int chromeFlags , long _retval ) {
int CreateChromeWindow2 ( long parent , int chromeFlags , int contextFlags , long uri , long cancel , long _retval ) {
long [ ] aWebBrowser = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long [ ] aParentNativeWindow = new long [ 1 ] ;
long aSpec = XPCOM . nsEmbedCString_new ( ) ;
long buffer = XPCOM . nsEmbedCString_get ( aSpec ) ;
long chromePtr = mozilla . webBrowserChrome . getAddress ( ) ;
XPCOM . memmove ( _retval , new long [ ] { chromePtr } , C . PTR_SIZEOF ) ;
public long hwndFrame ;
public long haccel ;
public long pszText ;
public long hbm ;
public long lParam ;
public long pvFilter ;
public nsIUploadChannel ( long address ) {
public int SetUploadStream ( long aStream , long aContentType , int aContentLength ) {
public int GetUploadStream ( long [ ] aUploadStream ) {
public long data ;
long layoutText = 0 , layoutMessage = 0 ;
long screen = OS . gdk_screen_get_default ( ) ;
long rgn = OS . gdk_region_polygon ( polyline , polyline . length / 2 , OS . GDK_EVEN_ODD_RULE ) ;
long window = gtk_widget_get_window ( handle ) ;
long tipWindow = OS . GTK_TOOLTIPS_TIP_WINDOW ( handle ) ;
long topHandle = topHandle ( ) ;
long itemHandle = item . handle ;
long window = gtk_widget_get_window ( itemHandle ) ;
long tipWindow = OS . GTK_TOOLTIPS_TIP_WINDOW ( handle ) ;
long gtk_button_press_event ( long widget , long event ) {
long gtk_expose_event ( long widget , long eventPtr ) {
long window = gtk_widget_get_window ( handle ) ;
long cairo = OS . gdk_cairo_create ( window ) ;
long gdkGC = OS . gdk_gc_new ( window ) ;
long gtk_size_allocate ( long widget , long allocation ) {
long screen = OS . gdk_screen_get_default ( ) ;
long tipWindow = OS . GTK_TOOLTIPS_TIP_WINDOW ( handle ) ;
long tipWindow = OS . GTK_TOOLTIPS_TIP_WINDOW ( handle ) ;
long tipWindow = OS . GTK_TOOLTIPS_TIP_WINDOW ( handle ) ;
long boldAttr = OS . pango_attr_weight_new ( OS . PANGO_WEIGHT_BOLD ) ;
long attrList = OS . pango_attr_list_new ( ) ;
long vboxHandle = parent . vboxHandle ;
long data = OS . gtk_tooltips_data_get ( vboxHandle ) ;
long vboxHandle = parent . vboxHandle ;
long timerProc ( long widget ) {
long tipWindow = OS . GTK_TOOLTIPS_TIP_WINDOW ( handle ) ;
public nsIRequest ( long address ) {
public int GetName ( long aName ) {
public int GetStatus ( long [ ] aStatus ) {
public int GetLoadGroup ( long [ ] aLoadGroup ) {
public int SetLoadGroup ( long aLoadGroup ) {
public int GetLoadFlags ( long [ ] aLoadFlags ) {
long hAdjustment = OS . gtk_adjustment_new ( 0 , 0 , 100 , 1 , 10 , 0 ) ;
long hAdjustment = OS . gtk_range_get_adjustment ( handle ) ;
long hAdjustment = OS . gtk_range_get_adjustment ( handle ) ;
long hAdjustment = OS . gtk_range_get_adjustment ( handle ) ;
long hAdjustment = OS . gtk_range_get_adjustment ( handle ) ;
long hAdjustment = OS . gtk_range_get_adjustment ( handle ) ;
long gtk_value_changed ( long adjustment ) {
public long hItem ;
public long lParam ;
public IWebDownload ( long address ) {
public int setDestination ( long path , int allowOverwrite ) {
public IWebIBActions ( long address ) {
public int stopLoading ( long sender ) {
public int reload ( long sender ) {
public int canGoBack ( long sender , int [ ] result ) {
public int canGoForward ( long sender , int [ ] result ) {
static final long ToolBarProc ;
long callWindowProc ( long hwnd , int msg , long wParam , long lParam ) {
long hFont = OS . GetStockObject ( OS . SYSTEM_FONT ) ;
long result = OS . SendMessage ( handle , OS . TB_GETBUTTON , index , lpButton ) ;
long hFont = OS . SendMessage ( handle , OS . WM_GETFONT , 0 , 0 ) ;
long size = OS . SendMessage ( handle , OS . TB_GETBUTTONSIZE , 0 , 0 ) ;
long padding = OS . SendMessage ( handle , OS . TB_GETPADDING , 0 , 0 ) ;
void setBackgroundImage ( long hBitmap ) {
long hImageList = 0 ;
long hImageList = 0 ;
long hImageList = 0 ;
long hwndParent = parent . handle ;
long hwndToolTip = OS . SendMessage ( handle , OS . TB_GETTOOLTIPS , 0 , 0 ) ;
long windowProc ( ) {
LRESULT WM_CAPTURECHANGED ( long wParam , long lParam ) {
LRESULT WM_CHAR ( long wParam , long lParam ) {
long code = OS . SendMessage ( handle , OS . TB_GETBUTTON , index , lpButton ) ;
LRESULT WM_COMMAND ( long wParam , long lParam ) {
LRESULT WM_ERASEBKGND ( long wParam , long lParam ) {
LRESULT WM_GETDLGCODE ( long wParam , long lParam ) {
LRESULT WM_KEYDOWN ( long wParam , long lParam ) {
LRESULT WM_KILLFOCUS ( long wParam , long lParam ) {
long code = OS . SendMessage ( handle , OS . TB_GETBUTTON , index , lpButton ) ;
LRESULT WM_LBUTTONDOWN ( long wParam , long lParam ) {
LRESULT WM_LBUTTONUP ( long wParam , long lParam ) {
LRESULT WM_MOUSELEAVE ( long wParam , long lParam ) {
long hwndToolTip = OS . SendMessage ( handle , OS . TB_GETTOOLTIPS , 0 , 0 ) ;
LRESULT WM_MOUSEMOVE ( long wParam , long lParam ) {
LRESULT WM_NOTIFY ( long wParam , long lParam ) {
LRESULT WM_SETFOCUS ( long wParam , long lParam ) {
LRESULT WM_SIZE ( long wParam , long lParam ) {
long code = callWindowProc ( handle , OS . WM_SIZE , wParam , lParam ) ;
LRESULT WM_WINDOWPOSCHANGING ( long wParam , long lParam ) {
LRESULT wmCommandChild ( long wParam , long lParam ) {
LRESULT wmNotifyChild ( NMHDR hdr , long wParam , long lParam ) {
public long name ;
public long value ;
public long pszText ;
public long lParam ;
public long puColumns ;
long textLength = attrStr . length ( ) ;
long numberOfGlyphs = layoutManager . numberOfGlyphs ( ) ;
double [ ] fg = gc . data . foreground ;
path . setLineDash ( new double [ ] { 1 , 3f } , 2 , 0 ) ;
double lineBottom = pt . y + rect . y + rect . height ;
double squigglyY = Math . min ( underlineY - squigglyHeight / 2 , lineBottom - squigglyHeight - 1 ) ;
double [ ] color = null ;
double [ ] lengths = null ;
lengths = new double [ dashes . length ] ;
double right = - 1 ;
long glyphOffset = layoutManager . glyphIndexForCharacterAtIndex ( offset ) ;
long glyphIndex = layoutManager . glyphIndexForCharacterAtIndex ( offset ) ;
long result = layoutManager . getGlyphsInRange ( range , 0 , 0 , 0 , 0 , bidiLevels ) ;
long proc2 = textLayoutCallback2 . getAddress ( ) ;
long cls = OS . objc_allocateClassPair ( OS . class_NSCell , className , 0 ) ;
long result = OS . malloc ( NSSize . sizeof ) ;
long result = OS . malloc ( NSPoint . sizeof ) ;
public nsIPromptFactory ( long address ) {
public int getPrompt ( long aParent , nsID iid , long [ ] result ) {
public long dshSection ;
public NSURL ( long id ) {
long result = OS . objc_msgSend ( OS . class_NSURL , OS . sel_URLFromPasteboard_ , pasteBoard ! = null ? pasteBoard . id : 0 ) ;
long result = OS . objc_msgSend ( OS . class_NSURL , OS . sel_URLWithString_ , URLString ! = null ? URLString . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_absoluteString ) ;
long result = OS . objc_msgSend ( OS . class_NSURL , OS . sel_fileURLWithPath_ , path ! = null ? path . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_host ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_path ) ;
public NSURLCredential ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_password ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_user ) ;
static final long ScrollBarProc ;
long callWindowProc ( long hwnd , int msg , long wParam , long lParam ) {
boolean SetScrollInfo ( long hwnd , int flags , SCROLLINFO info , boolean fRedraw ) {
long windowProc ( ) {
LRESULT WM_KEYDOWN ( long wParam , long lParam ) {
long code = callWindowProc ( handle , OS . WM_KEYDOWN , key , lParam ) ;
LRESULT WM_LBUTTONDBLCLK ( long wParam , long lParam ) {
LRESULT WM_LBUTTONDOWN ( long wParam , long lParam ) {
LRESULT WM_SETFOCUS ( long wParam , long lParam ) {
LRESULT wmScrollChild ( long wParam , long lParam ) {
public IProvideClassInfo ( long address ) {
public int GetClassInfo ( long [ ] ppTI ) {
public long hParent ;
public long lpfnCompare ;
public long lParam ;
long psc = 0 ;
long hHeap = OS . GetProcessHeap ( ) ;
long [ ] ppv = new long [ 1 ] ;
long hHeap = OS . GetProcessHeap ( ) ;
long hHeap = OS . GetProcessHeap ( ) ;
long createGdipBrush ( int pixel , int alpha ) {
long createGdipBrush ( Color color , int alpha ) {
long hdc = gc . handle ;
long gdipGraphics = data . gdipGraphics ;
long hFont = getItemFont ( run ) ;
long oldFont = OS . SelectObject ( hdc , hFont ) ;
long gdipFg = gdipForeground ;
RECT drawBorder ( long hdc , int x , int y , int lineHeight , StyleItem [ ] line , int index , int color , int selectionColor , RECT clipRect , RECT pRect , int selectionStart , int selectionEnd , Rectangle drawClip ) {
long oldBrush = OS . SelectObject ( hdc , OS . GetStockObject ( OS . NULL_BRUSH ) ) ;
long selPen = OS . ExtCreatePen ( lineStyle | OS . PS_GEOMETRIC , lineWidth , logBrush , 0 , null ) ;
RECT drawBorderGDIP ( long graphics , int x , int y , int lineHeight , StyleItem [ ] line , int index , long color , long selectionColor , RECT clipRect , RECT pRect , int selectionStart , int selectionEnd , int alpha , Rectangle drawClip ) {
long brush = color ;
long pen = Gdip . Pen_new ( brush , lineWidth ) ;
long selPen = Gdip . Pen_new ( selectionColor , lineWidth ) ;
void drawRunBackground ( StyleItem run , long hdc , RECT rect , int selectionStart , int selectionEnd , long selBrush , boolean hasSelection ) {
void drawRunBackgroundGDIP ( StyleItem run , long graphics , RECT rect , int selectionStart , int selectionEnd , int alpha , long selBrush , boolean hasSelection ) {
long brush = createGdipBrush ( run . style . background , alpha ) ;
RECT drawRunText ( long hdc , StyleItem run , RECT rect , int baseline , int color , int selectionColor , int selectionStart , int selectionEnd ) {
long hFont = getItemFont ( run ) ;
RECT drawRunTextGDIP ( long graphics , StyleItem run , RECT rect , long gdipFont , int baseline , long color , long selectionColor , int selectionStart , int selectionEnd , int alpha ) {
long brush = color ;
long rgn = Gdip . Region_new ( ) ;
long matrix = Gdip . Matrix_new ( 1 , 0 , 0 , 1 , 0 , 0 ) ;
long hdc = Gdip . Graphics_GetHDC ( graphics ) ;
RECT drawStrikeout ( long hdc , int x , int baseline , StyleItem [ ] line , int index , int color , int selectionColor , RECT clipRect , RECT pRect , int selectionStart , int selectionEnd , Rectangle drawClip ) {
long brush = OS . CreateSolidBrush ( color ) ;
long selBrush = OS . CreateSolidBrush ( selectionColor ) ;
RECT drawStrikeoutGDIP ( long graphics , int x , int baseline , StyleItem [ ] line , int index , long color , long selectionColor , RECT clipRect , RECT pRect , int selectionStart , int selectionEnd , int alpha , Rectangle drawClip ) {
long brush = color ;
RECT drawUnderline ( long hdc , int x , int baseline , int lineUnderlinePos , int lineBottom , StyleItem [ ] line , int index , int color , int selectionColor , RECT clipRect , RECT pRect , int selectionStart , int selectionEnd , Rectangle drawClip ) {
long brush = OS . CreateSolidBrush ( color ) ;
long selBrush = OS . CreateSolidBrush ( selectionColor ) ;
RECT drawUnderlineGDIP ( long graphics , int x , int baseline , int lineUnderlinePos , int lineBottom , StyleItem [ ] line , int index , long color , long selectionColor , RECT clipRect , RECT pRect , int selectionStart , int selectionEnd , int alpha , Rectangle drawClip ) {
long brush = color ;
long pen = Gdip . Pen_new ( brush , squigglyThickness ) ;
long selPen = Gdip . Pen_new ( selectionColor , squigglyThickness ) ;
long pen = Gdip . Pen_new ( brush , 1 ) ;
long selPen = Gdip . Pen_new ( brush , 1 ) ;
long advances = run . justify ! = 0 ? run . justify : run . advances ;
long advances = run . justify ! = 0 ? run . justify : run . advances ;
long getItemFont ( StyleItem item ) {
long advances = run . justify ! = 0 ? run . justify : run . advances ;
long advances = run . justify ! = 0 ? run . justify : run . advances ;
long advances = run . justify ! = 0 ? run . justify : run . advances ;
StyleItem [ ] merge ( long items , int itemCount ) {
boolean shape ( long hdc , StyleItem run , char [ ] chars , int [ ] glyphCount , int maxGlyphs , SCRIPT_PROPERTIES sp ) {
OS . MoveMemory ( run . psc , new long [ 1 ] , OS . PTR_SIZEOF ) ;
OS . MoveMemory ( run . psc , new long [ 1 ] , OS . PTR_SIZEOF ) ;
void shape ( final long hdc , final StyleItem run ) {
long hHeap = OS . GetProcessHeap ( ) ;
long metaFile = OS . CloseEnhMetaFile ( metaFileDc ) ;
long metaFileEnumProc ( long hDC , long table , long record , long nObj , long lpData ) {
long address = callback . getAddress ( ) ;
long pFont = getItemFont ( pRun ) ;
long nFont = getItemFont ( nRun ) ;
long [ ] hNewFont = new long [ 1 ] ;
long accessibleHandle ( ) {
boolean accessibilityIsIgnored ( long id , long sel ) {
double lineWidth = ( ( NSBox ) view ) . borderWidth ( ) ;
double lineWidth = widget . borderWidth ( ) ;
void drawBackground ( long id , NSGraphicsContext context , NSRect rect ) {
long imageView ( ) {
void setForeground ( double [ ] color ) {
double scaleFactor = screen . userSpaceScaleFactor ( ) ;
long familyCount = families . count ( ) ;
double systemFontSize = smallFonts ? NSFont . smallSystemFontSize ( ) : NSFont . systemFontSize ( ) ;
public abstract long internal_new_GC ( GCData data ) ;
public abstract void internal_dispose_GC ( long hDC , GCData data ) ;
long fsRepresentation = nsPath . fileSystemRepresentation ( ) ;
public NSView ( long id ) {
public void addSubview ( NSView aView , long place , NSView otherView ) {
public long addToolTipRect ( NSRect aRect , id anObject , long data ) {
long result = OS . objc_msgSend ( this . id , OS . sel_hitTest_ , aPoint ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_initWithFrame_ , frameRect ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_menuForEvent_ , event ! = null ? event . id : 0 ) ;
public void removeToolTip ( long tag ) {
public void setAutoresizingMask ( long mask ) {
public void setBoundsRotation ( double angle ) {
public void setFocusRingType ( long focusRingType ) {
long result = OS . objc_msgSend ( this . id , OS . sel_subviews ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_superview ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_trackingAreas ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_window ) ;
public long dispatch_child_properties_changed ;
public long show ;
public long show_all ;
public long hide ;
public long hide_all ;
public long map ;
public long unmap ;
public long realize ;
public long unrealize ;
public long size_request ;
public long size_allocate ;
public long state_changed ;
public long parent_set ;
public long hierarchy_changed ;
public long style_set ;
public long direction_changed ;
public long grab_notify ;
public long child_notify ;
public long mnemonic_activate ;
public long grab_focus ;
public long focus ;
public long event ;
public long button_press_event ;
public long button_release_event ;
public long scroll_event ;
public long motion_notify_event ;
public long delete_event ;
public long destroy_event ;
public long expose_event ;
public long key_press_event ;
public long key_release_event ;
public long enter_notify_event ;
public long leave_notify_event ;
public long configure_event ;
public long focus_in_event ;
public long focus_out_event ;
public long map_event ;
public long unmap_event ;
public long property_notify_event ;
public long selection_clear_event ;
public long selection_request_event ;
public long selection_notify_event ;
public long proximity_in_event ;
public long proximity_out_event ;
public long visibility_notify_event ;
public long client_event ;
public long no_expose_event ;
public long window_state_event ;
public long selection_get ;
public long selection_received ;
public long drag_begin ;
public long drag_end ;
public long drag_data_get ;
public long drag_data_delete ;
public long drag_leave ;
public long drag_motion ;
public long drag_drop ;
public long drag_data_received ;
public long popup_menu ;
public long show_help ;
public long get_accessible ;
public long screen_changed ;
public long pIDataObject ;
long newPtr = OS . GlobalAlloc ( OS . GMEM_FIXED | OS . GMEM_ZEROINIT , size ) ;
long hMem = stgmedium . unionField ;
long ptr = OS . GlobalLock ( hMem ) ;
public static final native void memmove ( GnomeVFSMimeApplication dest , long src , long count ) ;
public long alpha_map ;
public long clip_mask ;
public long dither ;
public NSNotificationCenter ( long id ) {
public void addObserver ( id observer , long aSelector , NSString aName , id anObject ) {
long result = OS . objc_msgSend ( OS . class_NSNotificationCenter , OS . sel_defaultCenter ) ;
public long ppVtable ;
long [ ] callbackAddresses = new long [ argCounts . length ] ;
long pVtable = OS . GlobalAlloc ( COM . GMEM_FIXED | COM . GMEM_ZEROINIT , OS . PTR_SIZEOF * argCounts . length ) ;
COM . MoveMemory ( ppVtable , new long [ ] { pVtable } , OS . PTR_SIZEOF ) ;
static long callback0 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback1 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback2 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback3 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback4 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback5 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback6 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback7 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback8 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback9 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback10 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback11 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback12 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback13 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback14 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback15 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback16 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback17 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback18 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback19 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback20 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback21 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback22 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback23 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback24 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback25 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback26 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback27 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback28 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback29 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback30 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback31 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback32 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback33 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback34 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback35 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback36 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback37 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback38 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback39 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback40 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback41 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback42 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback43 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback44 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback45 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback46 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback47 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback48 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback49 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback50 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback51 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback52 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback53 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback54 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback55 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback56 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback57 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback58 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback59 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback60 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback61 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback62 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback63 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback64 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback65 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback66 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback67 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback68 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback69 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback70 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback71 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback72 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback73 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback74 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback75 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback76 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback77 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback78 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback79 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
long [ ] pVtable = new long [ 1 ] ;
public long getAddress ( ) {
public long method0 ( long [ ] args ) {
public long method1 ( long [ ] args ) {
public long method2 ( long [ ] args ) {
public long method3 ( long [ ] args ) {
public long method4 ( long [ ] args ) {
public long method5 ( long [ ] args ) {
public long method6 ( long [ ] args ) {
public long method7 ( long [ ] args ) {
public long method8 ( long [ ] args ) {
public long method9 ( long [ ] args ) {
public long method10 ( long [ ] args ) {
public long method11 ( long [ ] args ) {
public long method12 ( long [ ] args ) {
public long method13 ( long [ ] args ) {
public long method14 ( long [ ] args ) {
public long method15 ( long [ ] args ) {
public long method16 ( long [ ] args ) {
public long method17 ( long [ ] args ) {
public long method18 ( long [ ] args ) {
public long method19 ( long [ ] args ) {
public long method20 ( long [ ] args ) {
public long method21 ( long [ ] args ) {
public long method22 ( long [ ] args ) {
public long method23 ( long [ ] args ) {
public long method24 ( long [ ] args ) {
public long method25 ( long [ ] args ) {
public long method26 ( long [ ] args ) {
public long method27 ( long [ ] args ) {
public long method28 ( long [ ] args ) {
public long method29 ( long [ ] args ) {
public long method30 ( long [ ] args ) {
public long method31 ( long [ ] args ) {
public long method32 ( long [ ] args ) {
public long method33 ( long [ ] args ) {
public long method34 ( long [ ] args ) {
public long method35 ( long [ ] args ) {
public long method36 ( long [ ] args ) {
public long method37 ( long [ ] args ) {
public long method38 ( long [ ] args ) {
public long method39 ( long [ ] args ) {
public long method40 ( long [ ] args ) {
public long method41 ( long [ ] args ) {
public long method42 ( long [ ] args ) {
public long method43 ( long [ ] args ) {
public long method44 ( long [ ] args ) {
public long method45 ( long [ ] args ) {
public long method46 ( long [ ] args ) {
public long method47 ( long [ ] args ) {
public long method48 ( long [ ] args ) {
public long method49 ( long [ ] args ) {
public long method50 ( long [ ] args ) {
public long method51 ( long [ ] args ) {
public long method52 ( long [ ] args ) {
public long method53 ( long [ ] args ) {
public long method54 ( long [ ] args ) {
public long method55 ( long [ ] args ) {
public long method56 ( long [ ] args ) {
public long method57 ( long [ ] args ) {
public long method58 ( long [ ] args ) {
public long method59 ( long [ ] args ) {
public long method60 ( long [ ] args ) {
public long method61 ( long [ ] args ) {
public long method62 ( long [ ] args ) {
public long method63 ( long [ ] args ) {
public long method64 ( long [ ] args ) {
public long method65 ( long [ ] args ) {
public long method66 ( long [ ] args ) {
public long method67 ( long [ ] args ) {
public long method68 ( long [ ] args ) {
public long method69 ( long [ ] args ) {
public long method70 ( long [ ] args ) {
public long method71 ( long [ ] args ) {
public long method72 ( long [ ] args ) {
public long method73 ( long [ ] args ) {
public long method74 ( long [ ] args ) {
public long method75 ( long [ ] args ) {
public long method76 ( long [ ] args ) {
public long method77 ( long [ ] args ) {
public long method78 ( long [ ] args ) {
public long method79 ( long [ ] args ) {
public NSHTTPCookieStorage ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_cookies ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_cookiesForURL_ , URL ! = null ? URL . id : 0 ) ;
long result = OS . objc_msgSend ( OS . class_NSHTTPCookieStorage , OS . sel_sharedHTTPCookieStorage ) ;
public nsIURI ( long address ) {
public int GetSpec ( long aSpec ) {
public int SetSpec ( long aSpec ) {
public int GetPrePath ( long aPrePath ) {
public int GetScheme ( long aScheme ) {
public int SetScheme ( long aScheme ) {
public int GetUserPass ( long aUserPass ) {
public int SetUserPass ( long aUserPass ) {
public int GetUsername ( long aUsername ) {
public int SetUsername ( long aUsername ) {
public int GetPassword ( long aPassword ) {
public int SetPassword ( long aPassword ) {
public int GetHostPort ( long aHostPort ) {
public int SetHostPort ( long aHostPort ) {
public int GetHost ( long aHost ) {
public int SetHost ( long aHost ) {
public int GetPath ( long aPath ) {
public int SetPath ( long aPath ) {
public int Equals ( long other , int [ ] _retval ) {
public int Clone ( long [ ] _retval ) {
public int Resolve ( long relativePath , long _retval ) {
public int GetAsciiSpec ( long aAsciiSpec ) {
public int GetAsciiHost ( long aAsciiHost ) {
public int GetOriginCharset ( long aOriginCharset ) {
public int GetRef ( long aRef ) {
public int SetRef ( long aRef ) {
public int EqualsExceptRef ( long other , int [ ] _retval ) {
public int CloneIgnoringRef ( long [ ] _retval ) {
public int GetSpecIgnoringRef ( long aSpecIgnoringRef ) {
public static final native long CGDisplayCreateImage ( int displayID ) ;
public nsICancelable ( long address ) {
public IClassFactory2 ( long address ) {
public int CreateInstanceLic ( long pUnkOuter , long pUnkReserved , GUID riid , long bstrKey , long ppvObject [ ] ) {
public int RequestLicKey ( int dwReserved , long [ ] pBstrKey ) {
public long hwnd ;
public long lpVerb ;
public long lpFile ;
public long lpParameters ;
public long lpDirectory ;
public long hInstApp ;
public long lpIDList ;
public long lpClass ;
public long hkeyClass ;
public long hIcon ;
public long hProcess ;
public NSNumberFormatter ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_decimalSeparator ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_maximum ) ;
public long maximumFractionDigits ( ) {
public long maximumIntegerDigits ( ) {
long result = OS . objc_msgSend ( this . id , OS . sel_minimum ) ;
public void setMaximumFractionDigits ( long number ) {
public void setMaximumIntegerDigits ( long number ) {
public void setMinimumFractionDigits ( long number ) {
public void setMinimumIntegerDigits ( long number ) {
public void setNumberStyle ( long style ) {
public nsIDOMElement ( long address ) {
public int GetTagName ( long aTagName ) {
public int GetAttribute ( long name , long _retval ) {
public int SetAttribute ( long name , long value ) {
public int RemoveAttribute ( long name ) {
public int GetAttributeNode ( long name , long [ ] _retval ) {
public int SetAttributeNode ( long newAttr , long [ ] _retval ) {
public int RemoveAttributeNode ( long oldAttr , long [ ] _retval ) {
public int GetElementsByTagName ( long name , long [ ] _retval ) {
public int GetAttributeNS ( long namespaceURI , long localName , long _retval ) {
public int SetAttributeNS ( long namespaceURI , long qualifiedName , long value ) {
public int RemoveAttributeNS ( long namespaceURI , long localName ) {
public int GetAttributeNodeNS ( long namespaceURI , long localName , long [ ] _retval ) {
public int SetAttributeNodeNS ( long newAttr , long [ ] _retval ) {
public int GetElementsByTagNameNS ( long namespaceURI , long localName , long [ ] _retval ) {
public int HasAttribute ( long name , int [ ] _retval ) {
public int HasAttributeNS ( long namespaceURI , long localName , int [ ] _retval ) {
public int GetOnmouseenter ( long cx , long aOnmouseenter ) {
public int SetOnmouseenter ( long cx , long aOnmouseenter ) {
public int GetOnmouseleave ( long cx , long aOnmouseleave ) {
public int SetOnmouseleave ( long cx , long aOnmouseleave ) {
public NSTableColumn ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_dataCell ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_headerCell ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_initWithIdentifier_ , identifier ! = null ? identifier . id : 0 ) ;
public long resizingMask ( ) {
public void setMinWidth ( double minWidth ) {
public void setResizingMask ( long resizingMask ) {
public void setWidth ( double width ) {
long topHandle = topHandle ( ) ;
long topHandle = topHandle ( ) ;
long topHandle = topHandle ( ) ;
long gtk_button_press_event ( long widget , long event ) {
long result = parent . gtk_button_press_event ( widget , event ) ;
long gtk_button_release_event ( long widget , long event ) {
long result = parent . gtk_button_release_event ( widget , event ) ;
long gtk_clicked ( long widget ) {
long eventPtr = OS . gtk_get_current_event ( ) ;
long topHandle = topHandle ( ) ;
long gtk_create_menu_proxy ( long widget ) {
long pixbuf = imageList . getPixbuf ( index ) ;
long settings = OS . gtk_settings_get_default ( ) ;
long property = OS . g_object_class_find_property ( OS . G_OBJECT_GET_CLASS ( settings ) , OS . gtk_menu_images ) ;
long gtk_enter_notify_event ( long widget , long event ) {
long pixbuf = imageList . getPixbuf ( index ) ;
long gtk_event_after ( long widget , long gdkEvent ) {
long gtk_focus_in_event ( long widget , long event ) {
long gtk_focus_out_event ( long widget , long event ) {
long gtk_leave_notify_event ( long widget , long event ) {
long pixbuf = imageList . getPixbuf ( index ) ;
long gtk_map ( long widget ) {
long gtk_mnemonic_activate ( long widget , long arg1 ) {
long list = OS . gtk_container_get_children ( eventHandle ) ;
long topHandle = topHandle ( ) ;
long topHandle = topHandle ( ) ;
void setFontDescription ( long font ) {
long pixbuf = imageList . getPixbuf ( imageIndex ) ;
long child = OS . gtk_bin_get_child ( handle ) ;
long list = OS . gtk_container_get_children ( child ) ;
static final long TrackBarProc ;
long lpszClassName = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount ) ;
long callWindowProc ( long hwnd , int msg , long wParam , long lParam ) {
void setBackgroundImage ( long hImage ) {
long windowProc ( ) {
LRESULT WM_KEYDOWN ( long wParam , long lParam ) {
long code = callWindowProc ( handle , OS . WM_KEYDOWN , wParam = = OS . VK_RIGHT ? OS . VK_LEFT : OS . VK_RIGHT , lParam ) ;
LRESULT WM_MOUSEWHEEL ( long wParam , long lParam ) {
long code = callWindowProc ( handle , OS . WM_MOUSEWHEEL , wParam , lParam ) ;
LRESULT WM_PAINT ( long wParam , long lParam ) {
LRESULT WM_SIZE ( long wParam , long lParam ) {
LRESULT wmScrollChild ( long wParam , long lParam ) {
public long name ;
public nsISimpleEnumerator ( long address ) {
public int GetNext ( long [ ] _retval ) {
long [ ] pixmaps = new long [ count ] ;
long path = OS . g_list_nth_data ( list , i ) ;
public NSPrintPanel ( long id ) {
public void beginSheetWithPrintInfo ( NSPrintInfo printInfo , NSWindow docWindow , id delegate , long didEndSelector , long contextInfo ) {
public long options ( ) {
long result = OS . objc_msgSend ( OS . class_NSPrintPanel , OS . sel_printPanel ) ;
public long runModalWithPrintInfo ( NSPrintInfo printInfo ) {
public void setOptions ( long options ) {
public IPropertyBag ( long address ) {
public int Read ( long pszPropName , long pVar , long [ ] pErrorLog ) {
long hTheme = OS . OpenThemeData ( 0 , getClassId ( ) ) ;
long hTheme = OS . OpenThemeData ( 0 , getClassId ( ) ) ;
long hTheme = OS . OpenThemeData ( 0 , getClassId ( ) ) ;
static final long ButtonProc ;
long hBitmap = OS . LoadBitmap ( 0 , OS . OBM_CHECKBOXES ) ;
long hImage = 0 ;
long callWindowProc ( long hwnd , int msg , long wParam , long lParam ) {
long flags = OS . SendMessage ( handle , OS . BM_GETCHECK , 0 , 0 ) ;
long hwndShell = menuShell ( ) . handle ;
long flags = OS . SendMessage ( handle , OS . BM_GETCHECK , 0 , 0 ) ;
long windowProc ( ) {
LRESULT WM_ERASEBKGND ( long wParam , long lParam ) {
LRESULT WM_GETDLGCODE ( long wParam , long lParam ) {
LRESULT WM_GETOBJECT ( long wParam , long lParam ) {
LRESULT WM_KILLFOCUS ( long wParam , long lParam ) {
LRESULT WM_LBUTTONDOWN ( long wParam , long lParam ) {
LRESULT WM_LBUTTONUP ( long wParam , long lParam ) {
LRESULT WM_SETFOCUS ( long wParam , long lParam ) {
LRESULT WM_SIZE ( long wParam , long lParam ) {
LRESULT WM_SYSCOLORCHANGE ( long wParam , long lParam ) {
LRESULT WM_UPDATEUISTATE ( long wParam , long lParam ) {
long code = OS . DefWindowProc ( handle , OS . WM_UPDATEUISTATE , wParam , lParam ) ;
LRESULT wmCommandChild ( long wParam , long lParam ) {
LRESULT wmColorChild ( long wParam , long lParam ) {
LRESULT wmDrawChild ( long wParam , long lParam ) {
public NSScrollView ( long id ) {
public static NSSize contentSizeForFrameSize ( NSSize fSize , boolean hFlag , boolean vFlag , long aType ) {
long result = OS . objc_msgSend ( this . id , OS . sel_contentView ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_documentView ) ;
public static NSSize frameSizeForContentSize ( NSSize cSize , boolean hFlag , boolean vFlag , long aType ) {
public void setBorderType ( long aType ) {
public NSNotification ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_object ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_userInfo ) ;
public nsIScriptSecurityManager ( long address ) {
public int CheckConnect ( long aJSContext , long aTargetURI , byte [ ] aClassName , byte [ ] aProperty ) {
public int CheckLoadURIFromScript ( long cx , long uri ) {
public int CheckLoadURIWithPrincipal ( long aPrincipal , long uri , int flags ) {
public int CheckLoadURI ( long from , long uri , int flags ) {
public int CheckLoadURIStrWithPrincipal ( long aPrincipal , long uri , int flags ) {
public int CheckLoadURIStr ( long from , long uri , int flags ) {
public int CheckFunctionAccess ( long cx , long funObj , long targetObj ) {
public int CanExecuteScripts ( long cx , long principal , int [ ] _retval ) {
public int GetSubjectPrincipal ( long [ ] _retval ) {
public int GetSystemPrincipal ( long [ ] _retval ) {
public int GetCodebasePrincipal ( long aURI , long [ ] _retval ) {
public int GetObjectPrincipal ( long cx , long obj , long [ ] _retval ) {
public int CheckSameOrigin ( long aJSContext , long aTargetURI ) {
public int CheckSameOriginURI ( long aSourceURI , long aTargetURI , int reportError ) {
public int GetPrincipalFromContext ( long cx , long [ ] _retval ) {
public int GetChannelPrincipal ( long aChannel , long [ ] _retval ) {
public int IsSystemPrincipal ( long aPrincipal , int [ ] _retval ) {
public int PushContextPrincipal ( long cx , long fp , long principal ) {
public int PopContextPrincipal ( long cx ) {
long accessibleHandle ( ) {
long accessibilityActionNames ( long id , long sel ) {
long returnValue = super . accessibilityActionNames ( id , sel ) ;
long accessibilityAttributeNames ( long id , long sel ) {
long returnValue = super . accessibilityAttributeNames ( id , sel ) ;
long accessibilityAttributeValue ( long id , long sel , long arg0 ) {
long description = OS . NSAccessibilityRoleDescription ( roleText . id , 0 ) ;
boolean accessibilityIsIgnored ( long id , long sel ) {
void drawImageWithFrameInView ( long id , long sel , long image , NSRect rect , long view ) {
long cgContext = NSGraphicsContext . currentContext ( ) . graphicsPort ( ) ;
NSRect drawTitleWithFrameInView ( long id , long sel , long title , NSRect titleRect , long view ) {
void drawWidget ( long id , NSGraphicsContext context , NSRect rect ) {
long menuForEvent ( long id , long sel , long theEvent ) {
void mouseDown ( long id , long sel , long theEvent ) {
boolean mouseDownCanMoveWindow ( long id , long sel ) {
void mouseUp ( long id , long sel , long theEvent ) {
void mouseDragged ( long id , long sel , long theEvent ) {
void rightMouseDown ( long id , long sel , long theEvent ) {
void rightMouseUp ( long id , long sel , long theEvent ) {
void rightMouseDragged ( long id , long sel , long theEvent ) {
void otherMouseDown ( long id , long sel , long theEvent ) {
void otherMouseUp ( long id , long sel , long theEvent ) {
void otherMouseDragged ( long id , long sel , long theEvent ) {
boolean validateMenuItem ( long id , long sel , long menuItem ) {
long lastCursor , window ;
long window = OS . gdk_get_default_root_window ( ) ;
long gc = OS . gdk_gc_new ( window ) ;
long colormap = OS . gdk_colormap_get_system ( ) ;
long cursor = this . cursor ! = null ? this . cursor . handle : 0 ;
long gtk_button_release_event ( long widget , long event ) {
long gtk_mouse ( int eventType , long widget , long eventPtr ) {
long widget = OS . gtk_get_event_widget ( eventPtr ) ;
public long get_name ;
public long get_description ;
public long get_parent ;
public long get_n_children ;
public long ref_child ;
public long get_index_in_parent ;
public long ref_relation_set ;
public long get_role ;
public long get_layer ;
public long get_mdi_zorder ;
public long ref_state_set ;
public long set_name ;
public long set_description ;
public long set_parent ;
public long set_role ;
public long connect_property_change_handler ;
public long remove_property_change_handler ;
public long initialize ;
public long children_changed ;
public long focus_event ;
public long property_change ;
public long state_change ;
public long visible_data_changed ;
public long get_attributes ;
long [ ] ppv = new long [ 1 ] ;
long createShellLink ( MenuItem item , String directory ) {
long [ ] ppv = new long [ 1 ] ;
long pLink = ppv [ 0 ] ;
OS . MoveMemory ( pv + 8 , new long [ ] { titlePtr } , OS . PTR_SIZEOF ) ;
long pPropStore = ppv [ 0 ] ;
long createShellLinkArray ( MenuItem [ ] items , String directory ) {
long [ ] ppv = new long [ 1 ] ;
long pObjColl = ppv [ 0 ] ;
long pLink = createShellLink ( items [ i ] , directory ) ;
long poa = ppv [ 0 ] ;
long [ ] ppv = new long [ 1 ] ;
long psiRoot = ppv [ 0 ] ;
long pfo = ppv [ 0 ] ;
long psiAppDir = getDirectory ( psiRoot , pfo , appDir , false ) ;
long psiIcoDir = getDirectory ( psiAppDir , pfo , ICO_DIR , true ) ;
long wstr = ppv [ 0 ] ;
long [ ] ppv = new long [ 1 ] ;
long pDestList = ppv [ 0 ] ;
long poa = createShellLinkArray ( items , directory ) ;
long pRemovedItems = ppv [ 0 ] ;
long poa2 = createShellLinkArray ( subItems , directory ) ;
public NSError ( long id ) {
public long code ( ) {
long result = OS . objc_msgSend ( this . id , OS . sel_localizedDescription ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_userInfo ) ;
long [ ] pProfiles = new long [ 1 ] ;
long [ ] pProvider = new long [ 1 ] ;
long [ ] pEnum = new long [ 1 ] ;
long [ ] pDispInfo = new long [ 1 ] ;
long layout = OS . GetKeyboardLayout ( 0 ) ;
LRESULT WM_IME_COMPOSITION ( long wParam , long lParam ) {
long layout = OS . GetKeyboardLayout ( 0 ) ;
LRESULT WM_IME_COMPOSITION_START ( long wParam , long lParam ) {
LRESULT WM_IME_ENDCOMPOSITION ( long wParam , long lParam ) {
LRESULT WM_KILLFOCUS ( long wParam , long lParam ) {
LRESULT WM_LBUTTONDOWN ( long wParam , long lParam ) {
long imeWnd = OS . ImmGetDefaultIMEWnd ( hwnd ) ;
long param = OS . MAKEWPARAM ( OS . MAKEWORD ( OS . IMEMOUSE_LDOWN , trailing ) , offset ) ;
long labelHandle , imageHandle , pageHandle ;
long gtk_enter_notify_event ( long widget , long event ) {
long gtk_mnemonic_activate ( long widget , long arg1 ) {
void setFontDescription ( long font ) {
long pixbuf = imageList . getPixbuf ( imageIndex ) ;
public nsIPrompt ( long address ) {
long hTheme = OS . OpenThemeData ( 0 , getClassId ( ) ) ;
long hTheme = OS . OpenThemeData ( 0 , getClassId ( ) ) ;
public double x ;
public double y ;
public double width ;
public double height ;
public NSToolbarItem ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_initWithItemIdentifier_ , itemIdentifier ! = null ? itemIdentifier . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_itemIdentifier ) ;
public void setAction ( long action ) {
boolean acceptsFirstResponder ( long id , long sel ) {
long superValue = super . accessibilityAttributeValue ( id , sel , arg0 ) ;
NSSize cellSize ( long id , long sel ) {
long [ ] outValue = new long [ 1 ] ;
long tableColumn = outValue [ 0 ] ;
boolean canDragRowsWithIndexes_atPoint ( long id , long sel , long rowIndexes , NSPoint mouseDownPoint ) {
void collapseItem_collapseChildren ( long id , long sel , long itemID , boolean children ) {
long columnAtPoint ( long id , long sel , NSPoint point ) {
long cls = NSButton . cellClass ( ) ;
void deselectAll ( long id , long sel , long sender ) {
void deselectRow ( long id , long sel , long index ) {
long row = widget . rowForItem ( item . handle ) ;
long columnId = array . objectAtIndex ( i ) . id ;
void drawBackgroundInClipRect ( long id , long sel , NSRect rect ) {
void drawInteriorWithFrame_inView ( long id , long sel , NSRect rect , long view ) {
long [ ] outValue = new long [ 1 ] ;
long rowIndex = widget . rowForItem ( item . handle ) ;
double offsetX = 0 , offsetY = 0 ;
double [ ] colorRGB = background . handle ;
double [ ] color = userForeground . handle ;
void drawWithExpansionFrame_inView ( long id , long sel , NSRect cellFrame , long view ) {
void expandItem_expandChildren ( long id , long sel , long itemID , boolean children ) {
NSRect expansionFrameWithFrame_inView ( long id , long sel , NSRect cellRect , long view ) {
long index = headerView . columnAtPoint ( pt ) ;
long [ ] indexBuffer = new long [ count ] ;
long index = outlineView . rowAtPoint ( point ) ;
NSRect headerRectOfColumn ( long id , long sel , long column ) {
void highlightSelectionInClipRect ( long id , long sel , long rect ) {
long hitTestForEvent ( long id , long sel , long event , NSRect rect , long controlView ) {
NSRect imageRectForBounds ( long id , long sel , NSRect cellFrame ) {
void keyDown ( long id , long sel , long theEvent ) {
long menuForEvent ( long id , long sel , long theEvent ) {
long row = tree . rowAtPoint ( mousePoint ) ;
void mouseDown ( long id , long sel , long theEvent ) {
void mouseDownSuper ( long id , long sel , long theEvent ) {
boolean needsPanelToBecomeKey ( long id , long sel ) {
long nextState ( long id , long sel ) {
long outlineView_child_ofItem ( long id , long sel , long outlineView , long index , long itemID ) {
void outlineView_didClickTableColumn ( long id , long sel , long outlineView , long tableColumn ) {
long outlineView_objectValueForTableColumn_byItem ( long id , long sel , long outlineView , long tableColumn , long itemID ) {
boolean outlineView_isItemExpandable ( long id , long sel , long outlineView , long item ) {
long outlineView_numberOfChildrenOfItem ( long id , long sel , long outlineView , long item ) {
boolean outlineView_shouldExpandItem_item ( long id , long sel , long arg0 , long arg1 ) {
boolean outlineView_shouldReorderColumn_toColumn ( long id , long sel , long aTableView , long currentColIndex , long newColIndex ) {
boolean outlineView_shouldTrackCell_forTableColumn_item ( long id , long sel , long table , long cell , long tableColumn , long item ) {
long rowIndex = widget . rowForItem ( new id ( item ) ) ;
void outlineView_willDisplayCell_forTableColumn_item ( long id , long sel , long outlineView , long cell , long tableColumn , long itemID ) {
void outlineViewColumnDidMove ( long id , long sel , long aNotification ) {
void outlineViewColumnDidResize ( long id , long sel , long aNotification ) {
void scrollClipViewToPoint ( long id , long sel , long clipView , NSPoint point ) {
void outlineViewSelectionDidChange ( long id , long sel , long notification ) {
void outlineViewSelectionIsChanging ( long id , long sel , long notification ) {
void outlineView_setObjectValue_forTableColumn_byItem ( long id , long sel , long outlineView , long object , long tableColumn , long itemID ) {
boolean outlineView_writeItems_toPasteboard ( long id , long sel , long arg0 , long arg1 , long arg2 ) {
void setImage ( long id , long sel , long arg0 ) {
long row = outlineView . rowForItem ( item . handle ) ;
void selectRowIndexes_byExtendingSelection ( long id , long sel , long indexes , boolean extend ) {
long [ ] indexBuffer = new long [ count ] ;
NSRect titleRectForBounds ( long id , long sel , NSRect cellFrame ) {
void setShouldExpandItem ( long id , long sel , boolean shouldExpand ) {
void setShouldScrollClipView ( long id , long sel , boolean shouldScroll ) {
long row = widget . rowForItem ( item . handle ) ;
public NSTabViewItem ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_initWithIdentifier_ , identifier ! = null ? identifier . id : 0 ) ;
long callWindowProc ( long hwnd , int msg , long wParam , long lParam ) {
long DeferWindowPos ( long hWinPosInfo , long hWnd , long hWndInsertAfter , int X , int Y , int cx , int cy , int uFlags ) {
boolean dragDetect ( long hwnd , int x , int y , boolean filter , boolean [ ] detect , boolean [ ] consume ) {
Widget findItem ( long id ) {
void mapEvent ( long hwnd , Event event ) {
boolean sendKeyEvent ( int type , int msg , long wParam , long lParam ) {
boolean sendKeyEvent ( int type , int msg , long wParam , long lParam , Event event ) {
boolean sendMouseEvent ( int type , int button , long hwnd , int msg , long wParam , long lParam ) {
boolean sendMouseEvent ( int type , int button , int count , int detail , boolean send , long hwnd , int msg , long wParam , long lParam ) {
boolean sendMouseWheelEvent ( int type , long hwnd , long wParam , long lParam ) {
boolean setKeyState ( Event event , int type , long wParam , long lParam ) {
int setLocationMask ( Event event , int type , long wParam , long lParam ) {
boolean SetWindowPos ( long hWnd , long hWndInsertAfter , int X , int Y , int cx , int cy , int uFlags ) {
LRESULT wmCaptureChanged ( long hwnd , long wParam , long lParam ) {
LRESULT wmChar ( long hwnd , long wParam , long lParam ) {
LRESULT wmContextMenu ( long hwnd , long wParam , long lParam ) {
LRESULT wmIMEChar ( long hwnd , long wParam , long lParam ) {
LRESULT wmKeyDown ( long hwnd , long wParam , long lParam ) {
LRESULT wmKeyUp ( long hwnd , long wParam , long lParam ) {
LRESULT wmKillFocus ( long hwnd , long wParam , long lParam ) {
long code = callWindowProc ( hwnd , OS . WM_KILLFOCUS , wParam , lParam ) ;
LRESULT wmLButtonDblClk ( long hwnd , long wParam , long lParam ) {
LRESULT wmLButtonDown ( long hwnd , long wParam , long lParam ) {
LRESULT wmLButtonUp ( long hwnd , long wParam , long lParam ) {
LRESULT wmMButtonDblClk ( long hwnd , long wParam , long lParam ) {
LRESULT wmMButtonDown ( long hwnd , long wParam , long lParam ) {
LRESULT wmMButtonUp ( long hwnd , long wParam , long lParam ) {
LRESULT wmMouseHover ( long hwnd , long wParam , long lParam ) {
LRESULT wmMouseLeave ( long hwnd , long wParam , long lParam ) {
LRESULT wmMouseMove ( long hwnd , long wParam , long lParam ) {
LRESULT wmMouseWheel ( long hwnd , long wParam , long lParam ) {
LRESULT wmMouseHWheel ( long hwnd , long wParam , long lParam ) {
LRESULT wmNCPaint ( long hwnd , long wParam , long lParam ) {
LRESULT wmPaint ( long hwnd , long wParam , long lParam ) {
long result = 0 ;
long rgn = OS . CreateRectRgn ( 0 , 0 , 0 , 0 ) ;
long hDC = gc . handle ;
LRESULT wmPrint ( long hwnd , long wParam , long lParam ) {
long code = callWindowProc ( hwnd , OS . WM_PRINT , wParam , lParam ) ;
LRESULT wmRButtonDblClk ( long hwnd , long wParam , long lParam ) {
LRESULT wmRButtonDown ( long hwnd , long wParam , long lParam ) {
LRESULT wmRButtonUp ( long hwnd , long wParam , long lParam ) {
LRESULT wmSysChar ( long hwnd , long wParam , long lParam ) {
long result = callWindowProc ( hwnd , OS . WM_SYSCHAR , wParam , lParam ) ;
LRESULT wmSysKeyDown ( long hwnd , long wParam , long lParam ) {
long hwndShell = hwnd ;
LRESULT wmSysKeyUp ( long hwnd , long wParam , long lParam ) {
LRESULT wmXButtonDblClk ( long hwnd , long wParam , long lParam ) {
LRESULT wmXButtonDown ( long hwnd , long wParam , long lParam ) {
LRESULT wmXButtonUp ( long hwnd , long wParam , long lParam ) {
long [ ] address = new long [ 1 ] ;
long clientSite = isICAClient ( ) ? 0 : iOleClientSite . getAddress ( ) ;
long [ ] address = new long [ 1 ] ;
long [ ] address = new long [ 1 ] ;
long [ ] address = new long [ 1 ] ;
address = new long [ 1 ] ;
long pv = COM . CoTaskMemAlloc ( count ) ;
long [ ] ppv = new long [ 1 ] ;
ppv = new long [ 1 ] ;
long [ ] ppvObject = new long [ 1 ] ;
ppvObject = new long [ 1 ] ;
ppvObject = new long [ 1 ] ;
long [ ] ppvClientSite = new long [ 1 ] ;
ppvObject = new long [ 1 ] ;
long [ ] ppmk = new long [ 1 ] ;
public long method14 ( long [ ] args ) { return OnPosRectChange ( args [ 0 ] ) ; }
long [ ] tempStorage = new long [ 1 ] ;
long [ ] address = new long [ 1 ] ;
long inAddress = 0 ;
long outAddress = 0 ;
long [ ] ppvObject = new long [ 1 ] ;
private int GetContainer ( long ppContainer ) {
COM . MoveMemory ( ppContainer , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
long [ ] lplpszProgID = new long [ 1 ] ;
long hMem = lplpszProgID [ 0 ] ;
long ptr = OS . GlobalLock ( hMem ) ;
int ActivateMe ( long pViewToActivate ) {
long [ ] ppvObject = new long [ 1 ] ;
protected int GetWindow ( long phwnd ) {
COM . MoveMemory ( phwnd , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( phwnd , new long [ ] { handle } , OS . PTR_SIZEOF ) ;
private int GetWindowContext ( long ppFrame , long ppDoc , long lprcPosRect , long lprcClipRect , long lpFrameInfo ) {
if ( ppDoc ! = 0 ) COM . MoveMemory ( ppDoc , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
long hwnd = shell . handle ;
long hAccel = OS . SendMessage ( hwnd , OS . WM_APP + 1 , 0 , 0 ) ;
long [ ] address = new long [ 1 ] ;
long focusHwnd = OS . GetFocus ( ) ;
long [ ] phwnd = new long [ 1 ] ;
private int OnDataChange ( long pFormatetc , long pStgmed ) {
long [ ] ppvObject = new long [ 1 ] ;
long [ ] phwnd = new long [ 1 ] ;
long [ ] ppvObject = new long [ 1 ] ;
private int OnPosRectChange ( long lprcPosRect ) {
long pArea = OS . GlobalAlloc ( COM . GMEM_FIXED | COM . GMEM_ZEROINIT , RECT . sizeof ) ;
long [ ] phwnd = new long [ 1 ] ;
long shellHandle = shell . handle ;
protected int QueryInterface ( long riid , long ppvObject ) {
COM . MoveMemory ( ppvObject , new long [ ] { iUnknown . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { iAdviseSink . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { iOleClientSite . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { iOleInPlaceSite . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { iOleDocumentSite . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
long [ ] address = new long [ 1 ] ;
private boolean saveFromContents ( long address , File file ) {
long pv = COM . CoTaskMemAlloc ( increment ) ;
private boolean saveFromOle10Native ( long address , File file ) {
long pv = COM . CoTaskMemAlloc ( 4 ) ;
long [ ] ppv = new long [ 1 ] ;
long [ ] address = new long [ 1 ] ;
long [ ] address = new long [ 1 ] ;
address = new long [ 1 ] ;
long [ ] address = new long [ 1 ] ;
private int Scroll_64 ( long scrollExtent ) {
long [ ] ppvObject = new long [ 1 ] ;
result = COM . OleCreatePropertyFrame ( frame . handle , 10 , 10 , chTitle , 1 , new long [ ] { objIUnknown . getAddress ( ) } , caGUID . cElems , caGUID . pElems , COM . LOCALE_USER_DEFAULT , 0 , 0 ) ;
long [ ] ppv = new long [ 1 ] ;
long hDC = OS . GetDC ( 0 ) ;
long hDC = OS . GetDC ( 0 ) ;
static final long LinkProc ;
long lpszClassName = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount ) ;
long callWindowProc ( long hwnd , int msg , long wParam , long lParam ) {
long windowProc ( ) {
LRESULT WM_CHAR ( long wParam , long lParam ) {
long code = callWindowProc ( handle , OS . WM_KEYDOWN , wParam , lParam ) ;
LRESULT WM_GETDLGCODE ( long wParam , long lParam ) {
long code = 0 ;
LRESULT WM_GETFONT ( long wParam , long lParam ) {
long code = callWindowProc ( handle , OS . WM_GETFONT , wParam , lParam ) ;
LRESULT WM_KEYDOWN ( long wParam , long lParam ) {
LRESULT WM_KILLFOCUS ( long wParam , long lParam ) {
LRESULT WM_LBUTTONDOWN ( long wParam , long lParam ) {
LRESULT WM_LBUTTONUP ( long wParam , long lParam ) {
LRESULT WM_NCHITTEST ( long wParam , long lParam ) {
LRESULT WM_MOUSEMOVE ( long wParam , long lParam ) {
LRESULT WM_PAINT ( long wParam , long lParam ) {
LRESULT WM_PRINTCLIENT ( long wParam , long lParam ) {
LRESULT WM_SETFOCUS ( long wParam , long lParam ) {
LRESULT WM_SETFONT ( long wParam , long lParam ) {
LRESULT WM_SIZE ( long wParam , long lParam ) {
LRESULT wmColorChild ( long wParam , long lParam ) {
long hBrush = findBrush ( backPixel , OS . BS_SOLID ) ;
LRESULT wmNotifyChild ( NMHDR hdr , long wParam , long lParam ) {
public NSOpenGLContext ( long id ) {
long result = OS . objc_msgSend ( OS . class_NSOpenGLContext , OS . sel_currentContext ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_initWithFormat_shareContext_ , format ! = null ? format . id : 0 , share ! = null ? share . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_view ) ;
long url = OS . CFURLCreateFromFSRef ( OS . kCFAllocatorDefault ( ) , fsRef ) ;
long ptr = OS . CFURLCreateStringByAddingPercentEscapes ( 0 , fullPath . id , unescapedStr . id , 0 , OS . kCFStringEncodingUTF8 ) ;
long ptr = OS . malloc ( 1 ) ;
public NSApplication ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_applicationIconImage ) ;
public void beginSheet ( NSWindow sheet , NSWindow docWindow , id modalDelegate , long didEndSelector , long contextInfo ) {
long result = OS . objc_msgSend ( this . id , OS . sel_currentEvent ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_dockTile ) ;
public void endSheet ( NSWindow sheet , long returnCode ) {
long result = OS . objc_msgSend ( this . id , OS . sel_keyWindow ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_mainMenu ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_mainWindow ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_orderedWindows ) ;
public void replyToOpenOrPrint ( long reply ) {
public long runModalForWindow ( NSWindow theWindow ) {
public boolean sendAction ( long theAction , id theTarget , id sender ) {
long result = OS . objc_msgSend ( OS . class_NSApplication , OS . sel_sharedApplication ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_windows ) ;
long share = data . shareContext ! = null ? data . shareContext . context : 0 ;
public Protocol ( long id ) {
public long pbCertEncoded ;
public long pCertInfo ;
public long hCertStore ;
public NSImage ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_TIFFRepresentation ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_bestRepresentationForDevice_ , deviceDescription ! = null ? deviceDescription . id : 0 ) ;
public void drawAtPoint ( NSPoint point , NSRect fromRect , long op , double delta ) {
public void drawInRect ( NSRect rect , NSRect fromRect , long op , double delta ) {
long result = OS . objc_msgSend ( OS . class_NSImage , OS . sel_imageNamed_ , name ! = null ? name . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_initByReferencingFile_ , fileName ! = null ? fileName . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_initWithContentsOfFile_ , fileName ! = null ? fileName . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_initWithData_ , data ! = null ? data . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_initWithSize_ , aSize ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_representations ) ;
public void setCacheMode ( long mode ) {
TreeItem ( Tree parent , long parentIter , int style , int index , boolean create ) {
long [ ] ptr = new long [ 1 ] ;
long [ ] ptr = new long [ 1 ] ;
long [ ] ptr = new long [ 1 ] ;
long [ ] ptr = new long [ 1 ] ;
long [ ] ptr = new long [ 1 ] ;
long [ ] ptr = new long [ 1 ] ;
OS . gtk_tree_store_set ( parent . modelHandle , handle , i , ( long ) 0 , - 1 ) ;
long path = OS . gtk_tree_model_get_path ( parent . modelHandle , handle ) ;
long path = OS . gtk_tree_model_get_path ( parent . modelHandle , handle ) ;
long path = OS . gtk_tree_model_get_path ( parent . modelHandle , handle ) ;
long pixbufRenderer = parent . getPixbufRenderer ( column ) ;
long path = OS . gtk_tree_model_get_path ( parent . modelHandle , handle ) ;
long path = OS . gtk_tree_model_get_path ( parent . modelHandle , handle ) ;
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long path = OS . gtk_tree_model_get_path ( parent . modelHandle , handle ) ;
long path = OS . gtk_tree_model_get_path ( parent . modelHandle , item . handle ) ;
long indices = OS . gtk_tree_path_get_indices ( path ) ;
long parentHandle = parent . handle ;
long path = OS . gtk_tree_model_get_path ( parent . modelHandle , handle ) ;
long window = OS . gtk_tree_view_get_bin_window ( parentHandle ) ;
long modelHandle = parent . modelHandle ;
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long selection = OS . gtk_tree_view_get_selection ( parent . handle ) ;
long path = OS . gtk_tree_model_get_path ( parent . modelHandle , handle ) ;
long fontHandle = font ! = null ? font . handle : 0 ;
long fontHandle = font ! = null ? font . handle : 0 ;
long pixbuf = 0 ;
long pixbufRenderer = parent . getPixbufRenderer ( column ) ;
long style = OS . gtk_widget_get_modifier_style ( parentHandle ) ;
public long handle ;
long surface = Cairo . cairo_image_surface_create ( Cairo . CAIRO_FORMAT_ARGB32 , 1 , 1 ) ;
long surface = Cairo . cairo_image_surface_create ( Cairo . CAIRO_FORMAT_ARGB32 , 1 , 1 ) ;
long copy = Cairo . cairo_copy_path ( path . handle ) ;
long copy = Cairo . cairo_copy_path ( handle ) ;
long offset = path . data + i * cairo_path_data_t . sizeof ;
long copy = Cairo . cairo_copy_path ( handle ) ;
long offset = path . data + i * cairo_path_data_t . sizeof ;
int Show ( long aLauncher , long aContext , int aReason ) {
int PromptForSaveToFile ( long aLauncher , long aWindowContext , long aDefaultFileName , long aSuggestedFileExtension , int aForcePrompt , long _retval ) {
long [ ] result = new long [ 1 ] ;
public nsIClassInfo ( long address ) {
public int GetInterfaces ( int [ ] count , long [ ] array ) {
public int GetHelperForLanguage ( int language , long [ ] _retval ) {
public int GetContractID ( long [ ] aContractID ) {
public int GetClassDescription ( long [ ] aClassDescription ) {
public int GetClassID ( long aClassID ) {
public int GetClassIDNoAlloc ( long aClassIDNoAlloc ) {
long OFNHookProc ( long hdlg , long uiMsg , long wParam , long lParam ) {
long hHeap = OS . GetProcessHeap ( ) ;
long lpstrTitle = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount3 ) ;
long lpstrFilter = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount4 ) ;
long lpstrFile = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount ) ;
long lpstrInitialDir = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount5 ) ;
long lpfnHook = callback . getAddress ( ) ;
long lpstrDefExt = 0 ;
public long getAddress ( ) {
public int QueryInterface ( GUID riid , long [ ] ppvObject ) {
public long hwndOwner ;
public long hInstance ;
public long lpCustColors ;
public long lCustData ;
public long lpfnHook ;
public long lpTemplateName ;
public DOMMouseEvent ( long id ) {
public long clipRgn ;
static long EditProc , ListProc ;
static final long ComboProc ;
long callWindowProc ( long hwnd , int msg , long wParam , long lParam ) {
long result = OS . CallWindowProc ( ComboProc , hwnd , msg , wParam , lParam ) ;
long hwndText = OS . GetDlgItem ( handle , CBID_EDIT ) ;
long hHeap = OS . GetProcessHeap ( ) ;
long pszText = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount ) ;
long code = OS . CallWindowProc ( EditProc , hwndText , msg , wParam , pszText ) ;
long hwndList = OS . GetDlgItem ( handle , CBID_LIST ) ;
long CBTProc ( long nCode , long wParam , long lParam ) {
boolean checkHandle ( long hwnd ) {
long hwndText = OS . GetDlgItem ( handle , CBID_EDIT ) ;
long margins = OS . SendMessage ( hwndText , OS . EM_GETMARGINS , 0 , 0 ) ;
long cbtProc = cbtCallback . getAddress ( ) ;
long hwndText = OS . GetDlgItem ( handle , CBID_EDIT ) ;
long hwndList = OS . GetDlgItem ( handle , CBID_LIST ) ;
long hmonitor = OS . MonitorFromWindow ( handle , OS . MONITOR_DEFAULTTONEAREST ) ;
long hwndText = OS . GetDlgItem ( handle , CBID_EDIT ) ;
long hwndList = OS . GetDlgItem ( handle , CBID_LIST ) ;
boolean dragDetect ( long hwnd , int x , int y , boolean filter , boolean [ ] detect , boolean [ ] consume ) {
long hwndText = OS . GetDlgItem ( handle , CBID_EDIT ) ;
long lParam = OS . MAKELPARAM ( x , y ) ;
long hwndText = OS . GetDlgItem ( handle , CBID_EDIT ) ;
long endPos = OS . SendMessage ( hwndText , OS . EM_POSFROMCHAR , end [ 0 ] , 0 ) ;
long startPos = OS . SendMessage ( hwndText , OS . EM_POSFROMCHAR , start [ 0 ] , 0 ) ;
long hwndText = OS . GetDlgItem ( handle , CBID_EDIT ) ;
long hwndFocus = OS . GetFocus ( ) ;
long hwndText = OS . GetDlgItem ( handle , CBID_EDIT ) ;
long hwndList = OS . GetDlgItem ( handle , CBID_LIST ) ;
long hwndText = OS . GetDlgItem ( handle , CBID_EDIT ) ;
long hwndText = OS . GetDlgItem ( handle , CBID_EDIT ) ;
long hwndList = OS . GetDlgItem ( handle , CBID_LIST ) ;
long hDC = 0 , oldFont = 0 , newFont = 0 ;
boolean sendKeyEvent ( int type , int msg , long wParam , long lParam , Event event ) {
long hwndText = OS . GetDlgItem ( handle , CBID_EDIT ) ;
void setBackgroundImage ( long hBitmap ) {
long hwndText = OS . GetDlgItem ( handle , CBID_EDIT ) ;
long hwndList = OS . GetDlgItem ( handle , CBID_LIST ) ;
long hwndText = OS . GetDlgItem ( handle , CBID_EDIT ) ;
long hwndList = OS . GetDlgItem ( handle , CBID_LIST ) ;
long hwndText = OS . GetDlgItem ( handle , CBID_EDIT ) ;
long hwndList = OS . GetDlgItem ( handle , CBID_LIST ) ;
long hDC = 0 , oldFont = 0 , newFont = 0 ;
long hmonitor = OS . MonitorFromWindow ( handle , OS . MONITOR_DEFAULTTONEAREST ) ;
long bits = OS . MAKELPARAM ( start , end ) ;
long hwndText = OS . GetDlgItem ( handle , CBID_EDIT ) ;
long hwndList = OS . GetDlgItem ( handle , CBID_LIST ) ;
long hwndText = OS . GetDlgItem ( handle , CBID_EDIT ) ;
long hwndList = OS . GetDlgItem ( handle , CBID_LIST ) ;
long hwndText = 0 , hwndList = 0 ;
long hwndText = OS . GetDlgItem ( handle , CBID_EDIT ) ;
long windowProc ( ) {
long windowProc ( long hwnd , int msg , long wParam , long lParam ) {
LRESULT WM_CTLCOLOR ( long wParam , long lParam ) {
LRESULT WM_KILLFOCUS ( long wParam , long lParam ) {
LRESULT WM_LBUTTONDOWN ( long wParam , long lParam ) {
LRESULT WM_SETFOCUS ( long wParam , long lParam ) {
LRESULT WM_SIZE ( long wParam , long lParam ) {
long hwndText = OS . GetDlgItem ( handle , CBID_EDIT ) ;
long hwndList = OS . GetDlgItem ( handle , CBID_LIST ) ;
LRESULT WM_UPDATEUISTATE ( long wParam , long lParam ) {
LRESULT WM_WINDOWPOSCHANGING ( long wParam , long lParam ) {
long rgn1 = OS . CreateRectRgn ( rect . left , rect . top , rect . right , rect . bottom ) ;
long rgn2 = OS . CreateRectRgn ( rect . left , rect . top , rect . right , rect . bottom ) ;
LRESULT wmChar ( long hwnd , long wParam , long lParam ) {
LRESULT wmClipboard ( long hwndText , int msg , long wParam , long lParam ) {
long hHeap = OS . GetProcessHeap ( ) ;
long pszText = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount ) ;
long code = OS . CallWindowProc ( EditProc , hwndText , msg , wParam , pszText ) ;
LRESULT wmCommandChild ( long wParam , long lParam ) {
long hwnd = lParam ;
LRESULT wmIMEChar ( long hwnd , long wParam , long lParam ) {
long result = callWindowProc ( hwnd , OS . WM_IME_CHAR , wParam , lParam ) ;
LRESULT wmKeyDown ( long hwnd , long wParam , long lParam ) {
LRESULT wmSysKeyDown ( long hwnd , long wParam , long lParam ) {
long code = callWindowProc ( hwnd , OS . WM_SYSKEYDOWN , wParam , lParam ) ;
public nsIFilePicker ( long address ) {
public int Init ( long parent , char [ ] title , int mode ) {
public int GetDefaultString ( long [ ] aDefaultString ) {
public int GetDefaultExtension ( long [ ] aDefaultExtension ) {
public int GetDisplayDirectory ( long [ ] aDisplayDirectory ) {
public int SetDisplayDirectory ( long aDisplayDirectory ) {
public int GetFile ( long [ ] aFile ) {
public int GetFileURL ( long [ ] aFileURL ) {
public int GetFiles ( long [ ] aFiles ) {
public int Show ( long _retval ) {
long hAdjustment = OS . gtk_adjustment_new ( 0 , 0 , 100 , 1 , 10 , 10 ) ;
long gtk_change_value ( long widget , long scroll , long value1 , long value2 ) {
long gtk_value_changed ( long adjustment ) {
long gtk_event_after ( long widget , long gdkEvent ) {
long hAdjustment = OS . gtk_range_get_adjustment ( handle ) ;
long hAdjustment = OS . gtk_range_get_adjustment ( handle ) ;
long hAdjustment = OS . gtk_range_get_adjustment ( handle ) ;
long hAdjustment = OS . gtk_range_get_adjustment ( handle ) ;
long hAdjustment = OS . gtk_range_get_adjustment ( handle ) ;
long hAdjustment = OS . gtk_range_get_adjustment ( handle ) ;
long hAdjustment = OS . gtk_range_get_adjustment ( handle ) ;
long hAdjustment = OS . gtk_range_get_adjustment ( handle ) ;
long hAdjustment = OS . gtk_range_get_adjustment ( handle ) ;
long hAdjustment = OS . gtk_range_get_adjustment ( handle ) ;
long hAdjustment = OS . gtk_range_get_adjustment ( handle ) ;
long hAdjustment = OS . gtk_range_get_adjustment ( handle ) ;
long localePtr = OS . g_filename_from_utf8 ( utf8Ptr , - 1 , null , null , error ) ;
long uriPtr = OS . g_filename_to_uri ( localePtr , 0 , error ) ;
long ptr = OS . g_malloc ( buffer . length + 1 ) ;
long [ ] files = new long [ 0 ] ;
long file = OS . g_malloc ( size + 1 ) ;
long [ ] newFiles = new long [ files . length + 1 ] ;
long file = OS . g_malloc ( size + 1 ) ;
long [ ] newFiles = new long [ files . length + 1 ] ;
long utf8Ptr = OS . g_filename_to_utf8 ( localePtr , - 1 , null , null , null ) ;
public NSCalendarDate ( long id ) {
long result = OS . objc_msgSend ( OS . class_NSCalendarDate , OS . sel_calendarDate ) ;
public long dayOfMonth ( ) {
public long hourOfDay ( ) {
public long minuteOfHour ( ) {
public long monthOfYear ( ) {
public long secondOfMinute ( ) {
long result = OS . objc_msgSend ( this . id , OS . sel_timeZone ) ;
public long yearOfCommonEra ( ) {
long result = OS . objc_msgSend ( OS . class_NSCalendarDate , OS . sel_dateWithTimeIntervalSinceNow_ , secs ) ;
long result = OS . objc_msgSend ( OS . class_NSCalendarDate , OS . sel_distantFuture ) ;
public long lpszDocName ;
public long lpszOutput ;
public long lpszDatatype ;
public long handle ;
long hDC = device . internal_new_GC ( null ) ;
long hOldDest = OS . SelectObject ( hdcDest , handle ) ;
long bitmap = Gdip . Bitmap_new ( chars , false ) ;
long [ ] hicon = new long [ 1 ] ;
long lockedBitmapData = Gdip . BitmapData_new ( ) ;
long pixels = bitmapData . Scan0 ;
long createDIBFromDDB ( long hDC , long hBitmap , int width , int height ) {
long [ ] createGdipImage ( ) {
long oldMemBitmap = OS . SelectObject ( memHdc , memDib ) ;
return new long [ ] { Gdip . Bitmap_new ( imgWidth , imgHeight , dibBM . bmWidthBytes , Gdip . PixelFormat32bppARGB , pixels ) , pixels } ;
return new long [ ] { Gdip . Bitmap_new ( handle , 0 ) , 0 } ;
long hBitmap = iconInfo . hbmColor ;
long img = 0 , pixels = 0 ;
long oldMemBitmap = OS . SelectObject ( memHdc , memDib ) ;
long hHeap = OS . GetProcessHeap ( ) ;
return new long [ ] { img , pixels } ;
long hDC = device . internal_new_GC ( null ) ;
long hBitmap = info . hbmColor ;
long hBitmap = info . hbmColor ;
long hDC = device . internal_new_GC ( null ) ;
long oldPalette = 0 ;
long hPalette = device . hPalette ;
long hDC = device . internal_new_GC ( null ) ;
long handle = this . handle ;
long hOldBitmap = OS . SelectObject ( memGC . handle , this . handle ) ;
long oldPalette = 0 ;
long hPalette = device . hPalette ;
long hDC = device . internal_new_GC ( null ) ;
static long createDIB ( int width , int height , int depth ) {
long [ ] pBits = new long [ 1 ] ;
long [ ] result = init ( image . device , null , image . data ) ;
static long [ ] init ( Device device , Image image , ImageData i ) {
long [ ] result = null ;
long hDC = device . internal_new_GC ( null ) ;
long hdcSrc = OS . CreateCompatibleDC ( hDC ) ;
long hBitmap = OS . CreateCompatibleBitmap ( hDC , i . width , i . height ) ;
long hdcDest = OS . CreateCompatibleDC ( hDC ) ;
long hMask = OS . CreateBitmap ( i . width , i . height , 1 , 1 , maskData ) ;
result = new long [ ] { hBitmap , hMask } ;
long hIcon = OS . CreateIconIndirect ( info ) ;
result = new long [ ] { hDib } ;
static long [ ] init ( Device device , Image image , ImageData source , ImageData mask ) {
public long internal_new_GC ( GCData data ) {
public void internal_dispose_GC ( long hDC , GCData data ) {
long hDC = device . internal_new_GC ( null ) ;
long hdcMem = OS . CreateCompatibleDC ( hDC ) ;
public static Image win32_new ( Device device , int type , long handle ) {
long frameHandle , labelHandle , imageHandle ;
long labelLayout = OS . gtk_label_get_layout ( labelHandle ) ;
long style = OS . gtk_widget_get_style ( frameHandle ) ;
long eventHandle ( ) {
void setFontDescription ( long font ) {
long pixbuf = imageList . getPixbuf ( imageIndex ) ;
public NSMenu ( long id ) {
public long indexOfItemWithTarget ( id target , long actionSelector ) {
long result = OS . objc_msgSend ( this . id , OS . sel_initWithTitle_ , aTitle ! = null ? aTitle . id : 0 ) ;
public void insertItem ( NSMenuItem newItem , long index ) {
long result = OS . objc_msgSend ( this . id , OS . sel_itemArray ) ;
public long numberOfItems ( ) {
public void removeItemAtIndex ( long index ) {
long getAddress ( ) {
int QueryInterface ( long riid , long ppvObject ) {
XPCOM . memmove ( ppvObject , new long [ ] { supports . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { filePicker . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { filePicker . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { filePicker . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
Browser getBrowser ( long aDOMWindow ) {
String parseAString ( long string ) {
int Init ( long parent , long title , short mode ) {
int Show ( long _retval ) {
int GetFiles ( long aFiles ) {
int GetFileURL ( long aFileURL ) {
int GetFile ( long aFile ) {
long [ ] file = new long [ 1 ] ;
int SetDisplayDirectory ( long aDisplayDirectory ) {
long pathname = XPCOM . nsEmbedString_new ( ) ;
long buffer = XPCOM . nsEmbedString_get ( pathname ) ;
int GetDisplayDirectory ( long aDisplayDirectory ) {
long [ ] file = new long [ 1 ] ;
int GetFilterIndex ( long aFilterIndex ) {
int SetDefaultExtension ( long aDefaultExtension ) {
int GetDefaultExtension ( long aDefaultExtension ) {
int SetDefaultString ( long aDefaultString ) {
int GetDefaultString ( long aDefaultString ) {
int AppendFilter ( long title , long filter ) {
long shellHandle = parent . topHandle ( ) ;
long pixbufs = OS . gtk_window_get_icon_list ( shellHandle ) ;
long group = OS . gtk_window_get_group ( 0 ) ;
long fontName = OS . pango_font_description_to_string ( font . handle ) ;
long hookId = 0 ;
long fontName = OS . gtk_font_selection_dialog_get_font_name ( handle ) ;
long fontDesc = OS . pango_font_description_from_string ( buffer ) ;
public nsIAuthPrompt2 ( long address ) {
public int PromptAuth ( long aParent , long aChannel , int level , long authInfo , char [ ] checkboxLabel , int [ ] checkValue , int [ ] _retval ) {
public int AsyncPromptAuth ( long aParent , long aChannel , long aCallback , long aContext , int level , long authInfo , char [ ] checkboxLabel , int [ ] checkValue , long [ ] _retval ) {
long focusHandle ( ) {
long gtk_day_selected ( long widget ) {
long gtk_day_selected_double_click ( long widget ) {
long gtk_month_changed ( long widget ) {
public IWebURLAuthenticationChallengeSender ( long address ) {
public int cancelAuthenticationChallenge ( long challenge ) {
public int useCredential ( long credential , long challenge ) {
public long handle ;
Region ( Device device , long handle ) {
long polyRgn = OS . gdk_region_polygon ( pointArray , pointArray . length / 2 , OS . GDK_EVEN_ODD_RULE ) ;
public static Region gtk_new ( Device device , long handle ) {
long rectRgn = OS . gdk_region_rectangle ( gdkRect ) ;
long polyRgn = OS . gdk_region_polygon ( pointArray , pointArray . length / 2 , OS . GDK_EVEN_ODD_RULE ) ;
long rectRgn = OS . gdk_region_rectangle ( gdkRect ) ;
long hTheme = OS . OpenThemeData ( 0 , getClassId ( ) ) ;
long hTheme = OS . OpenThemeData ( 0 , getClassId ( ) ) ;
public long pElems ;
public long bstrSource ;
public long bstrDescription ;
public long bstrHelpFile ;
public long pvReserved ;
public long pfnDeferredFillIn ;
public static final native int ChoosePixelFormat ( long hdc , PIXELFORMATDESCRIPTOR ppfd ) ;
public static final native int DescribePixelFormat ( long hdc , int iPixelFormat , int nBytes , PIXELFORMATDESCRIPTOR ppfd ) ;
public static final native int GetPixelFormat ( long hdc ) ;
public static final native boolean SetPixelFormat ( long hdc , int iPixelFormat , PIXELFORMATDESCRIPTOR ppfd ) ;
public static final native boolean SwapBuffers ( long hdc ) ;
public static final native boolean wglCopyContext ( long hglrcSrc , long hglrcDst , int mask ) ;
public static final native long wglCreateContext ( long hdc ) ;
public static final native long wglCreateLayerContext ( long hdc , int iLayerPlane ) ;
public static final native boolean wglMakeCurrent ( long hdc , long hglrc ) ;
public static final native boolean wglShareLists ( long hglrc1 , long hglrc2 ) ;
public static final native boolean wglDescribeLayerPlane ( long hdc , int iPixelFormat , int iLayerPlane , int nBytes , LAYERPLANEDESCRIPTOR plpd ) ;
public static final native int wglSetLayerPaletteEntries ( long hdc , int iLayerPlane , int iStart , int cEntries , int [ ] pcr ) ;
public static final native int wglGetLayerPaletteEntries ( long hdc , int iLayerPlane , int iStart , int cEntries , int [ ] pcr ) ;
public static final native boolean wglRealizeLayerPalette ( long hdc , int iLayerPlane , boolean bRealize ) ;
public static final native boolean wglSwapLayerBuffers ( long hdc , int fuPlanes ) ;
long gtk_expose_event ( long widget , long eventPtr ) {
void setFontDescription ( long font ) {
public long constructor ;
public long set_property ;
public long get_property ;
public long dispose ;
public long finalize ;
public long dispatch_properties_changed ;
public long notify ;
double defaultFlatness = NSBezierPath . defaultFlatness ( ) ;
long points = OS . malloc ( 3 * NSPoint . sizeof ) ;
long pixel = OS . malloc ( 4 ) ;
long path = GC . createCGPathRef ( handle ) ;
long points = OS . malloc ( 3 * NSPoint . sizeof ) ;
public NSFont ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_displayName ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_familyName ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_fontName ) ;
public NSOpenGLPixelFormat ( long id ) {
public void getValues ( long [ ] vals , int attrib , int screen ) {
long result = OS . objc_msgSend ( this . id , OS . sel_initWithAttributes_ , attribs ) ;
public ITypeInfo ( long address ) {
public int GetFuncDesc ( int index , long [ ] ppFuncDesc ) {
long pName = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , buffer . length * 2 ) ;
COM . MoveMemory ( ppNames + OS . PTR_SIZEOF * i , new long [ ] { pName } , OS . PTR_SIZEOF ) ;
long [ ] rgBstrNames = new long [ nameSize ] ;
public int GetRefTypeInfo ( int hRefType , long [ ] ppTInfo ) {
public int GetTypeAttr ( long [ ] ppTypeAttr ) {
public int GetVarDesc ( int index , long [ ] ppVarDesc ) {
public int ReleaseFuncDesc ( long pFuncDesc ) {
public int ReleaseTypeAttr ( long pTypeAttr ) {
public int ReleaseVarDesc ( long pVarDesc ) {
public long lpOutString ;
public long lpOrder ;
public long lpDx ;
public long lpCaretPos ;
public long lpClass ;
public long lpGlyphs ;
void _drawThemeProgressArea ( long id , long sel , long arg0 ) {
long visibleRegion = getVisibleRegion ( ) ;
void viewDidMoveToWindow ( long id , long sel ) {
double [ ] color1 , color2 ;
public long pixmap ;
public long mask ;
public long surface ;
long imageSurface = srcImage . surface ;
long cairo = Cairo . cairo_create ( surface ) ;
long data = Cairo . cairo_image_surface_get_data ( surface ) ;
long mask = OS . gdk_pixmap_new ( 0 , width , height , 1 ) ;
long gdkGC = OS . gdk_gc_new ( mask ) ;
long pixmap = OS . gdk_pixmap_new ( OS . gdk_get_default_root_window ( ) , width , height , - 1 ) ;
long gdkGC = OS . gdk_gc_new ( pixmap ) ;
long pixbuf = OS . gdk_pixbuf_new ( OS . GDK_COLORSPACE_RGB , false , 8 , width , height ) ;
long colormap = OS . gdk_colormap_get_system ( ) ;
long pixels = OS . gdk_pixbuf_get_pixels ( pixbuf ) ;
long pixbuf = OS . gdk_pixbuf_new_from_file ( buffer , null ) ;
long gc = OS . gdk_gc_new ( mask ) ;
long imagePtr = OS . gdk_drawable_get_image ( mask , 0 , 0 , width , height ) ;
void createFromPixbuf ( int type , long pixbuf ) {
long pixels = OS . gdk_pixbuf_get_pixels ( pixbuf ) ;
long data = Cairo . cairo_image_surface_get_data ( surface ) ;
long pixels = OS . gdk_pixbuf_get_pixels ( pixbuf ) ;
long [ ] pixmap_return = new long [ 1 ] ;
long surfaceData = Cairo . cairo_image_surface_get_data ( surface ) ;
long createMask ( ImageData image , boolean copy ) {
long pixbuf = OS . gdk_pixbuf_new ( OS . GDK_COLORSPACE_RGB , true , 8 , width , height ) ;
long colormap = OS . gdk_colormap_get_system ( ) ;
long pixels = OS . gdk_pixbuf_get_pixels ( pixbuf ) ;
long maskPixbuf = OS . gdk_pixbuf_new ( OS . GDK_COLORSPACE_RGB , false , 8 , width , height ) ;
long maskPixels = OS . gdk_pixbuf_get_pixels ( maskPixbuf ) ;
long offset = pixels , maskOffset = maskPixels ;
long offset = pixels ;
long offset = pixels ;
long offset = pixels ;
long data = Cairo . cairo_image_surface_get_data ( surface ) ;
long surface = ImageList . convertSurface ( this ) ;
long surfaceData = Cairo . cairo_image_surface_get_data ( surface ) ;
long pixbuf = OS . gdk_pixbuf_new ( OS . GDK_COLORSPACE_RGB , false , 8 , width , height ) ;
long colormap = OS . gdk_colormap_get_system ( ) ;
long pixels = OS . gdk_pixbuf_get_pixels ( pixbuf ) ;
long gdkImagePtr = OS . gdk_drawable_get_image ( mask , 0 , 0 , width , height ) ;
public static Image gtk_new ( Device device , int type , long pixmap , long mask ) {
public static Image gtk_new_from_pixbuf ( Device device , int type , long pixbuf ) {
long cairo = Cairo . cairo_create ( surface ) ;
long colormap = OS . gdk_colormap_get_system ( ) ;
long gdkGC = OS . gdk_gc_new ( pixmap ) ;
long data = Cairo . cairo_image_surface_get_data ( surface ) ;
long pixbuf = OS . gdk_pixbuf_new ( OS . GDK_COLORSPACE_RGB , false , 8 , width , height ) ;
long data = OS . gdk_pixbuf_get_pixels ( pixbuf ) ;
long pixmap = OS . gdk_pixmap_new ( OS . gdk_get_default_root_window ( ) , width , height , - 1 ) ;
long gdkGC = OS . gdk_gc_new ( pixmap ) ;
long mask = createMask ( image , isIcon ) ;
public long internal_new_GC ( GCData data ) {
long messageProc ( long hwnd , int msg , long wParam , long lParam ) {
long hIcon = 0 ;
public nsIComponentRegistrar ( long address ) {
public int AutoRegister ( long aSpec ) {
public int AutoUnregister ( long aSpec ) {
public int RegisterFactory ( nsID aClass , byte [ ] aClassName , byte [ ] aContractID , long aFactory ) {
public int UnregisterFactory ( nsID aClass , long aFactory ) {
public int RegisterFactoryLocation ( nsID aClass , byte [ ] aClassName , byte [ ] aContractID , long aFile , byte [ ] aLoaderStr , byte [ ] aType ) {
public int UnregisterFactoryLocation ( nsID aClass , long aFile ) {
public int EnumerateCIDs ( long [ ] _retval ) {
public int EnumerateContractIDs ( long [ ] _retval ) {
public int CIDToContractID ( nsID aClass , long [ ] _retval ) {
public int ContractIDToCID ( byte [ ] aContractID , long _retval ) {
public NSParagraphStyle ( long id ) {
public long alignment ( ) {
long result = OS . objc_msgSend ( this . id , OS . sel_tabStops ) ;
private long ppVtable ;
long [ ] callbackAddresses = new long [ argCounts . length + OS_OFFSET ] ;
long pVtable = C . malloc ( C . PTR_SIZEOF * ( argCounts . length + OS_OFFSET ) ) ;
XPCOM . memmove ( ppVtable , new long [ ] { pVtable } , C . PTR_SIZEOF ) ;
static long callback0 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback1 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback10 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback11 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback12 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback13 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback14 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback15 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback16 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback17 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback18 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback19 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback2 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback20 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback21 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback22 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback23 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback24 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback25 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback26 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback27 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback28 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback29 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback3 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback30 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback31 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback32 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback33 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback34 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback35 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback36 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback37 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback38 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback39 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback4 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback40 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback41 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback42 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback43 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback44 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback45 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback46 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback47 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback48 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback49 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback5 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback50 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback51 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback52 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback53 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback54 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback55 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback56 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback57 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback58 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback59 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback6 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback60 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback61 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback62 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback63 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback64 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback65 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback66 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback67 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback68 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback69 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback7 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback70 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback71 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback72 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback73 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback74 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback75 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback76 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback77 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback78 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback79 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback8 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
static long callback9 ( long [ ] callbackArgs ) {
long address = callbackArgs [ 0 ] ;
long [ ] args = new long [ callbackArgs . length - 1 ] ;
long [ ] pVtable = new long [ 1 ] ;
public long getAddress ( ) {
public long method0 ( long [ ] args ) {
public long method1 ( long [ ] args ) {
public long method10 ( long [ ] args ) {
public long method11 ( long [ ] args ) {
public long method12 ( long [ ] args ) {
public long method13 ( long [ ] args ) {
public long method14 ( long [ ] args ) {
public long method15 ( long [ ] args ) {
public long method16 ( long [ ] args ) {
public long method17 ( long [ ] args ) {
public long method18 ( long [ ] args ) {
public long method19 ( long [ ] args ) {
public long method2 ( long [ ] args ) {
public long method20 ( long [ ] args ) {
public long method21 ( long [ ] args ) {
public long method22 ( long [ ] args ) {
public long method23 ( long [ ] args ) {
public long method24 ( long [ ] args ) {
public long method25 ( long [ ] args ) {
public long method26 ( long [ ] args ) {
public long method27 ( long [ ] args ) {
public long method28 ( long [ ] args ) {
public long method29 ( long [ ] args ) {
public long method3 ( long [ ] args ) {
public long method30 ( long [ ] args ) {
public long method31 ( long [ ] args ) {
public long method32 ( long [ ] args ) {
public long method33 ( long [ ] args ) {
public long method34 ( long [ ] args ) {
public long method35 ( long [ ] args ) {
public long method36 ( long [ ] args ) {
public long method37 ( long [ ] args ) {
public long method38 ( long [ ] args ) {
public long method39 ( long [ ] args ) {
public long method4 ( long [ ] args ) {
public long method40 ( long [ ] args ) {
public long method41 ( long [ ] args ) {
public long method42 ( long [ ] args ) {
public long method43 ( long [ ] args ) {
public long method44 ( long [ ] args ) {
public long method45 ( long [ ] args ) {
public long method46 ( long [ ] args ) {
public long method47 ( long [ ] args ) {
public long method48 ( long [ ] args ) {
public long method49 ( long [ ] args ) {
public long method5 ( long [ ] args ) {
public long method50 ( long [ ] args ) {
public long method51 ( long [ ] args ) {
public long method52 ( long [ ] args ) {
public long method53 ( long [ ] args ) {
public long method54 ( long [ ] args ) {
public long method55 ( long [ ] args ) {
public long method56 ( long [ ] args ) {
public long method57 ( long [ ] args ) {
public long method58 ( long [ ] args ) {
public long method59 ( long [ ] args ) {
public long method6 ( long [ ] args ) {
public long method60 ( long [ ] args ) {
public long method61 ( long [ ] args ) {
public long method62 ( long [ ] args ) {
public long method63 ( long [ ] args ) {
public long method64 ( long [ ] args ) {
public long method65 ( long [ ] args ) {
public long method66 ( long [ ] args ) {
public long method67 ( long [ ] args ) {
public long method68 ( long [ ] args ) {
public long method69 ( long [ ] args ) {
public long method7 ( long [ ] args ) {
public long method70 ( long [ ] args ) {
public long method71 ( long [ ] args ) {
public long method72 ( long [ ] args ) {
public long method73 ( long [ ] args ) {
public long method74 ( long [ ] args ) {
public long method75 ( long [ ] args ) {
public long method76 ( long [ ] args ) {
public long method77 ( long [ ] args ) {
public long method78 ( long [ ] args ) {
public long method79 ( long [ ] args ) {
public long method8 ( long [ ] args ) {
public long method9 ( long [ ] args ) {
long labelHandle , imageHandle , buttonHandle ;
long gtk_clicked ( long widget ) {
long eventPtr = OS . gtk_get_current_event ( ) ;
long gtk_event_after ( long widget , long gdkEvent ) {
long gtk_mnemonic_activate ( long widget , long arg1 ) {
long gtk_size_allocate ( long widget , long allocation ) {
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
void setFontDescription ( long font ) {
long pixbuf = headerImageList . getPixbuf ( imageIndex ) ;
long window = OS . gtk_widget_get_parent_window ( buttonHandle ) ;
long windowList = OS . gdk_window_get_children ( window ) ;
long child = OS . g_list_data ( windows ) ;
public long window ;
public long subwindow ;
public nsIPrefBranch ( long address ) {
public int GetRoot ( long [ ] aRoot ) {
public int GetCharPref ( byte [ ] aPrefName , long [ ] _retval ) {
public int GetComplexValue ( byte [ ] aPrefName , nsID aType , long [ ] aValue ) {
public int SetComplexValue ( byte [ ] aPrefName , nsID aType , long aValue ) {
public int GetChildList ( byte [ ] aStartingAt , int [ ] aCount , long [ ] aChildArray ) {
public static final native void memmove ( XVisualInfo dest , long src , int size ) ;
public nsIFocusManager ( long address ) {
public int GetActiveWindow ( long [ ] aActiveWindow ) {
public int SetActiveWindow ( long aActiveWindow ) {
public int GetFocusedWindow ( long [ ] aFocusedWindow ) {
public int SetFocusedWindow ( long aFocusedWindow ) {
public int GetFocusedElement ( long [ ] aFocusedElement ) {
public int GetLastFocusMethod ( long window , int [ ] _retval ) {
public int SetFocus ( long aElement , int aFlags ) {
public int MoveFocus ( long aWindow , long aStartElement , int aType , int aFlags , long [ ] _retval ) {
public int ClearFocus ( long aWindow ) {
public int GetFocusedElementForWindow ( long aWindow , int aDeep , long [ ] aFocusedWindow , long [ ] _retval ) {
public int MoveCaretToFocus ( long aWindow ) {
public int WindowRaised ( long aWindow ) {
public int WindowLowered ( long aWindow ) {
public int ContentRemoved ( long aDocument , long aElement ) {
public int WindowShown ( long aWindow ) {
public int WindowHidden ( long aWindow ) {
public int FireDelayedEvents ( long aDocument ) {
public int FocusPlugin ( long aPlugin ) {
public IWebURLAuthenticationChallenge ( long address ) {
public int proposedCredential ( long [ ] result ) {
public int protectionSpace ( long [ ] result ) {
public int sender ( long [ ] sender ) {
public NSTableView ( long id ) {
public long clickedColumn ( ) {
public long clickedRow ( ) {
public long columnAtPoint ( NSPoint point ) {
long result = OS . objc_msgSend ( this . id , OS . sel_columnIndexesInRect_ , rect ) ;
public long columnWithIdentifier ( NSString identifier ) {
public void deselectRow ( long row ) {
public NSRect frameOfCellAtColumn ( long column , long row ) {
long result = OS . objc_msgSend ( this . id , OS . sel_headerView ) ;
public boolean isRowSelected ( long row ) {
public void moveColumn ( long column , long newIndex ) {
public long numberOfColumns ( ) {
public long numberOfRows ( ) {
public long numberOfSelectedRows ( ) {
public NSRect rectOfColumn ( long column ) {
public NSRect rectOfRow ( long row ) {
public long rowAtPoint ( NSPoint point ) {
public void scrollColumnToVisible ( long column ) {
public void scrollRowToVisible ( long row ) {
public long selectedRow ( ) {
long result = OS . objc_msgSend ( this . id , OS . sel_selectedRowIndexes ) ;
public void setColumnAutoresizingStyle ( long style ) {
public void setDoubleAction ( long aSelector ) {
public void setDropRow ( long row , long op ) {
public void setGridStyleMask ( long gridStyle ) {
public void setRowHeight ( double rowHeight ) {
long result = OS . objc_msgSend ( this . id , OS . sel_tableColumns ) ;
public static long cellClass ( ) {
public static void setCellClass ( long factoryId ) {
long hPal = device . hPalette ;
long hPal = device . hPalette ;
long [ ] pixbufs ;
pixbufs = new long [ 4 ] ;
long cairo = Cairo . cairo_create ( newSurface ) ;
long surface = convertSurface ( image ) ;
long pixels = OS . gdk_pixbuf_get_pixels ( pixbuf ) ;
long surfaceData = Cairo . cairo_image_surface_get_data ( surface ) ;
long colormap = OS . gdk_colormap_get_system ( ) ;
long maskPixbuf = OS . gdk_pixbuf_new ( OS . GDK_COLORSPACE_RGB , false , 8 , w [ 0 ] , h [ 0 ] ) ;
long pixels = OS . gdk_pixbuf_get_pixels ( pixbuf ) ;
long maskPixels = OS . gdk_pixbuf_get_pixels ( maskPixbuf ) ;
long offset = pixels + ( y * stride ) ;
long maskOffset = maskPixels + ( y * maskStride ) ;
long pixels = OS . gdk_pixbuf_get_pixels ( pixbuf ) ;
long offset = pixels + ( y * stride ) ;
long [ ] newPixbufs = new long [ pixbufs . length + 4 ] ;
public long getPixbuf ( int index ) {
public int indexOf ( long pixbuf ) {
long pixbuf = createPixbuf ( image ) ;
long scaledPixbuf = OS . gdk_pixbuf_scale_simple ( pixbuf , width , height , OS . GDK_INTERP_BILINEAR ) ;
long oldPixbuf = pixbufs [ index ] ;
long lpMultiByteStr = OS . GlobalAlloc ( COM . GMEM_FIXED | COM . GMEM_ZEROINIT , cchMultiByte ) ;
long hMem = stgmedium . unionField ;
long lpMultiByteStr = OS . GlobalLock ( hMem ) ;
long getAddress ( ) {
int QueryInterface ( long riid , long ppvObject ) {
XPCOM . memmove ( ppvObject , new long [ ] { supports . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { factory . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
int CreateInstance ( long aOuter , long iid , long result ) {
XPCOM . memmove ( result , new long [ ] { external . getAddress ( ) } , C . PTR_SIZEOF ) ;
public NSCoder ( long id ) {
public long hMenu ;
public long hwndMenu ;
public static final native long class_getClassMethod ( long aClass , long aSelector ) ;
public static final native double objc_msgSend_fpret ( long id , long sel ) ;
public static final native void objc_msgSend_stret ( NSPoint result , long id , long sel ) ;
public IEnum ( long address ) {
public int Clone ( long [ ] ppenum ) {
public int Next ( int celt , long rgelt , int [ ] pceltFetched ) {
public nsIDOMEvent ( long address ) {
public int GetType ( long aType ) {
public int GetTarget ( long [ ] aTarget ) {
public int GetCurrentTarget ( long [ ] aCurrentTarget ) {
public int GetTimeStamp ( long aTimeStamp ) {
public int InitEvent ( long eventTypeArg , int canBubbleArg , int cancelableArg ) {
public long window ;
public long handle ;
long lpInitData = 0 ;
long hHeap = OS . GetProcessHeap ( ) ;
long [ ] hPrinter = new long [ 1 ] ;
public long internal_new_GC ( GCData data ) {
public void internal_dispose_GC ( long hDC , GCData data ) {
long lpszOutput = 0 ;
public nsIWebProgress ( long address ) {
public int AddProgressListener ( long listener , int aNotifyMask ) {
public int RemoveProgressListener ( long listener ) {
public int GetDOMWindow ( long [ ] aDOMWindow ) {
public nsIAppShell ( long address ) {
public int Create ( long argc , long [ ] argv ) {
public int ListenToEventQueue ( long aQueue , int aListen ) {
public int GetNativeEvent ( long aRealEvent , long [ ] aEvent ) {
public int DispatchNativeEvent ( int aRealEvent , long aEvent ) {
public nsIDirectoryServiceProvider2 ( long address ) {
public int GetFiles ( byte [ ] prop , long [ ] _retval ) {
void drawInteriorWithFrame_inView ( long id , long sel , NSRect cellRect , long view ) {
public long lower ;
public long upper ;
public long lParam ;
public long lParamNM ;
public NSWorkspace ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_fullPathForApplication_ , appName ! = null ? appName . id : 0 ) ;
public boolean getInfoForFile ( NSString fullPath , long appName , long type ) {
long result = OS . objc_msgSend ( this . id , OS . sel_iconForFile_ , fullPath ! = null ? fullPath . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_iconForFileType_ , fileType ! = null ? fileType . id : 0 ) ;
public boolean openURLs ( NSArray urls , NSString bundleIdentifier , long options , NSAppleEventDescriptor descriptor , long identifiers ) {
long result = OS . objc_msgSend ( OS . class_NSWorkspace , OS . sel_sharedWorkspace ) ;
public NSFontManager ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_availableFontFamilies ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_availableFonts ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_availableMembersOfFontFamily_ , fam ! = null ? fam . id : 0 ) ;
long result = OS . objc_msgSend ( OS . class_NSFontManager , OS . sel_sharedFontManager ) ;
public long traitsOfFont ( NSFont fontObj ) {
public long weightOfFont ( NSFont fontObj ) {
long jniRef = 0 ;
void panelDidEnd_returnCode_contextInfo ( long id , long sel , long alert , long returnCode , long contextInfo ) {
public IViewObject2 ( long address ) {
public int SetAdvise ( int dwAspects , int dwAdvf , long pIAdviseSink ) {
long getAddress ( ) {
int QueryInterface ( long riid , long ppvObject ) {
XPCOM . memmove ( ppvObject , new long [ ] { supports . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { promptService . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { promptService2 . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
Browser getBrowser ( long aDOMWindow ) {
String getLabel ( int buttonFlag , int index , long buttonTitle ) {
int Alert ( long aParent , long aDialogTitle , long aText ) {
int AlertCheck ( long aParent , long aDialogTitle , long aText , long aCheckMsg , long aCheckState ) {
int AsyncPromptAuth ( long aParent , long aChannel , long aCallback , long aContext , int level , long authInfo , long checkboxLabel , long checkValue , long _retval ) {
int Confirm ( long aParent , long aDialogTitle , long aText , long _retval ) {
int ConfirmCheck ( long aParent , long aDialogTitle , long aText , long aCheckMsg , long aCheckState , long _retval ) {
int ConfirmEx ( long aParent , long aDialogTitle , long aText , int aButtonFlags , long aButton0Title , long aButton1Title , long aButton2Title , long aCheckMsg , long aCheckState , long _retval ) {
int Prompt ( long aParent , long aDialogTitle , long aText , long aValue , long aCheckMsg , long aCheckState , long _retval ) {
long [ ] valueAddr = new long [ 1 ] ;
long [ ] result2 = new long [ 1 ] ;
long ptr = memory . Alloc ( size ) ;
XPCOM . memmove ( aValue , new long [ ] { ptr } , C . PTR_SIZEOF ) ;
int PromptAuth ( long aParent , long aChannel , int level , long authInfo , long checkboxLabel , long checkboxValue , long _retval ) {
long ptr = XPCOM . nsEmbedString_new ( ) ;
long buffer = XPCOM . nsEmbedString_get ( ptr ) ;
long [ ] uri = new long [ 1 ] ;
long host = XPCOM . nsEmbedCString_new ( ) ;
int PromptUsernameAndPassword ( long aParent , long aDialogTitle , long aText , long aUsername , long aPassword , long aCheckMsg , long aCheckState , long _retval ) {
long [ ] userAddr = new long [ 1 ] ;
long [ ] passAddr = new long [ 1 ] ;
long [ ] userAddr = new long [ 1 ] ;
long [ ] passAddr = new long [ 1 ] ;
long [ ] result = new long [ 1 ] ;
long ptr = C . malloc ( size ) ;
XPCOM . memmove ( aUsername , new long [ ] { ptr } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( aPassword , new long [ ] { ptr } , C . PTR_SIZEOF ) ;
int PromptPassword ( long aParent , long aDialogTitle , long aText , long aPassword , long aCheckMsg , long aCheckState , long _retval ) {
int Select ( long aParent , long aDialogTitle , long aText , int aCount , long aSelectList , long aOutSelection , long _retval ) {
int decidePolicyForMIMEType ( long webView , long type , long request , long frame , long listener ) {
int decidePolicyForNavigationAction ( long webView , long actionInformation , long request , long frame , long listener ) {
long [ ] result = new long [ 1 ] ;
int decidePolicyForNewWindowAction ( long webView , long actionInformation , long request , long frameName , long listener ) {
long getAddress ( ) {
int QueryInterface ( long riid , long ppvObject ) {
COM . MoveMemory ( ppvObject , new long [ ] { iWebPolicyDelegate . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { iWebPolicyDelegate . getAddress ( ) } , OS . PTR_SIZEOF ) ;
COM . MoveMemory ( ppvObject , new long [ ] { 0 } , OS . PTR_SIZEOF ) ;
int unableToImplementPolicyWithError ( long webView , long error , long frame ) {
long [ ] result = new long [ 1 ] ;
TouchSource ( long handle , boolean direct , Rectangle bounds ) {
public IWebURLRequest ( long address ) {
public int HTTPMethod ( long [ ] result ) {
public int URL ( long [ ] result ) {
public int mutableCopy ( long [ ] result ) {
long hwndText , hwndUpDown ;
static final long EditProc ;
static final long UpDownProc ;
long callWindowProc ( long hwnd , int msg , long wParam , long lParam ) {
boolean checkHandle ( long hwnd ) {
long hInstance = OS . GetModuleHandle ( null ) ;
long hIMC = OS . ImmGetContext ( handle ) ;
long borderHandle ( ) {
long margins = OS . SendMessage ( hwndText , OS . EM_GETMARGINS , 0 , 0 ) ;
long hwndFocus = OS . GetFocus ( ) ;
boolean sendKeyEvent ( int type , int msg , long wParam , long lParam , Event event ) {
void setBackgroundImage ( long hBitmap ) {
long hHeap = OS . GetProcessHeap ( ) ;
long udaccels = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , UDACCEL . sizeof * count ) ;
long offset = udaccels + ( i * UDACCEL . sizeof ) ;
long newProc = display . windowProc ;
long windowProc ( long hwnd , int msg , long wParam , long lParam ) {
LRESULT WM_ERASEBKGND ( long wParam , long lParam ) {
LRESULT WM_KILLFOCUS ( long wParam , long lParam ) {
LRESULT WM_SETFOCUS ( long wParam , long lParam ) {
LRESULT WM_SETFONT ( long wParam , long lParam ) {
LRESULT WM_SIZE ( long wParam , long lParam ) {
LRESULT wmIMEChar ( long hwnd , long wParam , long lParam ) {
long result = callWindowProc ( hwnd , OS . WM_IME_CHAR , wParam , lParam ) ;
LRESULT wmChar ( long hwnd , long wParam , long lParam ) {
LRESULT wmClipboard ( long hwndText , int msg , long wParam , long lParam ) {
long hHeap = OS . GetProcessHeap ( ) ;
long pszText = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount ) ;
long code = OS . CallWindowProc ( EditProc , hwndText , msg , wParam , pszText ) ;
LRESULT wmCommandChild ( long wParam , long lParam ) {
LRESULT wmKeyDown ( long hwnd , long wParam , long lParam ) {
LRESULT wmKillFocus ( long hwnd , long wParam , long lParam ) {
LRESULT wmNotifyChild ( NMHDR hdr , long wParam , long lParam ) {
LRESULT wmScrollChild ( long wParam , long lParam ) {
public NSMenuItem ( long id ) {
public long action ( ) {
long result = OS . objc_msgSend ( this . id , OS . sel_attributedTitle ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_image ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_keyEquivalent ) ;
public long keyEquivalentModifierMask ( ) {
long result = OS . objc_msgSend ( OS . class_NSMenuItem , OS . sel_separatorItem ) ;
public void setAction ( long aSelector ) {
public void setKeyEquivalentModifierMask ( long mask ) {
public void setState ( long state ) {
public void setTag ( long anInt ) {
public long state ( ) {
long result = OS . objc_msgSend ( this . id , OS . sel_submenu ) ;
public long tag ( ) {
long result = OS . objc_msgSend ( this . id , OS . sel_target ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_title ) ;
public long otmpFamilyName ;
public long otmpFaceName ;
public long otmpStyleName ;
public long otmpFullName ;
long hMem = pd . hDevMode ;
long ptr = OS . GlobalLock ( hMem ) ;
void mouseDown ( long id , long sel , long theEvent ) {
void mouseDragged ( long id , long sel , long theEvent ) {
void mouseUp ( long id , long sel , long theEvent ) {
void rightMouseDown ( long id , long sel , long theEvent ) {
void rightMouseUp ( long id , long sel , long theEvent ) {
void rightMouseDragged ( long id , long sel , long theEvent ) {
void drawRect ( long id , long sel , NSRect rect ) {
double width = 0 ;
public long hwndOwner ;
public long hDevMode ;
public long hDevNames ;
public long hDC ;
public long lpfnPrintHook ;
public long lpfnSetupHook ;
public long lpPrintTemplateName ;
public long lpSetupTemplateName ;
public long hPrintTemplate ;
public long hSetupTemplate ;
public nsITransfer ( long address ) {
public int Init ( long aSource , long aTarget , long aDisplayName , long aMIMEInfo , long startTime , long aTempFile , long aCancelable ) {
public long pszObjId ;
public long add_selection ;
public long clear_selection ;
public long ref_selection ;
public long get_selection_count ;
public long is_child_selected ;
public long remove_selection ;
public long select_all_selection ;
public long selection_changed ;
public IEnumFORMATETC ( long address ) {
public long receiver ;
public long super_class ;
public nsISerializable ( long address ) {
public int Read ( long aInputStream ) {
public int Write ( long aOutputStream ) {
public long pwszName ;
public long pAuthInfo ;
public NSUndoManager ( long id ) {
public long pwcsName ;
public NSControl ( long id ) {
public long action ( ) {
long result = OS . objc_msgSend ( this . id , OS . sel_cell ) ;
public static long cellClass ( ) {
long result = OS . objc_msgSend ( this . id , OS . sel_currentEditor ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_font ) ;
public boolean sendAction ( long theAction , id theTarget ) {
public void setAction ( long aSelector ) {
public void setAlignment ( long mode ) {
public void setBaseWritingDirection ( long writingDirection ) {
public static void setCellClass ( long factoryId ) {
long result = OS . objc_msgSend ( this . id , OS . sel_stringValue ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_target ) ;
public long hSource ;
public long dwExtraInfo ;
public NSTypesetter ( long id ) {
long temp = list ;
long handle = OS . g_list_data ( temp ) ;
long childStyle ( ) {
long vadj = OS . gtk_adjustment_new ( 0 , 0 , 100 , 1 , 10 , 10 ) ;
long hadj = OS . gtk_adjustment_new ( 0 , 0 , 100 , 1 , 10 , 10 ) ;
long cairo = data . cairo ;
long surface = control . backgroundImage . surface ;
long pattern = Cairo . cairo_pattern_create_for_surface ( surface ) ;
long gdkGC = gc . handle ;
void fixModal ( long group , long modalGroup ) {
long windows = windowList ;
long window = OS . g_list_data ( windows ) ;
long focusHandle ( ) {
boolean forceFocus ( long focusHandle ) {
long list = OS . gtk_container_get_children ( handle ) ;
long clientHandle = clientHandle ( ) ;
long gtk_expose_event ( long widget , long eventPtr ) {
long [ ] rectangles = new long [ 1 ] ;
long damageRgn = OS . gdk_region_new ( ) ;
long gtk_focus ( long widget , long directionType ) {
long gtk_map ( long widget ) {
long window = gtk_widget_get_window ( paintHandle ( ) ) ;
long gtk_scroll_child ( long widget , long scrollType , long horizontal ) {
long window = gtk_widget_get_window ( paintHandle ( ) ) ;
long imHandle ( ) {
void moveAbove ( long child , long sibling ) {
long parentHandle = parentingHandle ( ) ;
long children = fixed . children ;
void moveBelow ( long child , long sibling ) {
long parentHandle = parentingHandle ( ) ;
long children = fixed . children ;
long topHandle = child . topHandle ( ) ;
long parentingHandle ( ) {
void printWidget ( GC gc , long drawable , int depth , int x , int y ) {
public NSImageRep ( long id ) {
public long bitsPerSample ( ) {
long result = OS . objc_msgSend ( this . id , OS . sel_colorSpaceName ) ;
public long pixelsHigh ( ) {
public long pixelsWide ( ) {
public nsIWebBrowserSetup ( long address ) {
public NSResponder ( long id ) {
public void doCommandBySelector ( long aSelector ) {
public void noResponderFor ( long eventSelector ) {
long result = OS . objc_msgSend ( this . id , OS . sel_undoManager ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_validRequestorForSendType_returnType_ , sendType ! = null ? sendType . id : 0 , returnType ! = null ? returnType . id : 0 ) ;
public IWebViewPrivate ( long address ) {
public int viewWindow ( long [ ] window ) {
public NSColorPanel ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_color ) ;
long result = OS . objc_msgSend ( OS . class_NSColorPanel , OS . sel_sharedColorPanel ) ;
public static long windowNumberAtPoint ( NSPoint point , long windowNumber ) {
public static final native void memmove ( long dest , JSClassDefinition src , long size ) ;
public long title ;
public long visual ;
public long colormap ;
public long cursor ;
public long wmclass_name ;
public long wmclass_class ;
public long value ;
public LONG ( long value ) {
public long pvData ;
public nsIJSContextStack ( long address ) {
public int Peek ( long [ ] _retval ) {
public int Pop ( long [ ] _retval ) {
public int Push ( long cx ) {
long window = gtk_widget_get_window ( parent . paintHandle ( ) ) ;
long window = gtk_widget_get_window ( widget ) ;
long window = gtk_widget_get_window ( handle ) ;
long gdkCursor = cursor ! = null ? cursor . handle : defaultCursor ;
long gtk_realize ( long widget ) {
void setCursor ( long cursor ) {
long getAddress ( ) {
int QueryInterface ( long riid , long ppvObject ) {
XPCOM . memmove ( ppvObject , new long [ ] { supports . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { factory . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
int CreateInstance ( long aOuter , long iid , long result ) {
XPCOM . memmove ( result , new long [ ] { download . getAddress ( ) } , C . PTR_SIZEOF ) ;
long accessibilityAttributeValue ( long id , long sel , long arg0 ) {
void drawLabelInRect ( long id , long sel , boolean shouldTruncateLabel , NSRect rect ) {
NSSize sizeOfLabel ( long id , long sel , boolean shouldTruncateLabel ) {
double [ ] foreground = parent . foreground ;
public nsIHelperAppLauncherDialog_1_9 ( long address ) {
public int Show ( long aLauncher , long aWindowContext , int aReason ) {
public int PromptForSaveToFile ( long aLauncher , long aWindowContext , char [ ] aDefaultFileName , char [ ] aSuggestedFileExtension , int aForcePrompt , long [ ] _retval ) {
public long selection ;
public long target ;
public long type ;
public long data ;
public long property ;
public long value ;
static native final long getAWTHandle ( Object canvas ) ;
long handle = parent . embeddedHandle ;
long handle = 0 ;
public long lbHatch ;
public ISpecifyPropertyPages ( long address ) {
public NSTextStorage ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_paragraphs ) ;
long result = OS . objc_msgSend ( OS . class_NSTextStorage , OS . sel_attributedStringWithAttachment_ , attachment ! = null ? attachment . id : 0 ) ;
long method = Cocoa . class_getClassMethod ( Cocoa . C_NSURLRequest , Cocoa . S_setAllowsAnyHTTPSCertificate ) ;
int callRunBeforeUnloadConfirmPanelWithMessage ( long messageID , long arg ) {
long callJava ( long index , long token , long args , long arg1 ) {
long handle = tree . handle ;
long handle = tree . handle ;
long hItem = lpht . hItem ;
long gnome = OS . XInternAtom ( xDisplay , gnomeName , true ) ;
long icon_theme = GNOME . gnome_icon_theme_new ( ) ;
long libgnomevfs = OS . dlopen ( buffer , OS . RTLD_LAZY ) ;
long gnome_vfs_url_show = OS . dlsym ( libgnomevfs , buffer ) ;
long cde = OS . XInternAtom ( xDisplay , cdeName , true ) ;
long attrValue = CDE . DtDtsDataTypeToAttributeValue ( dataTypeBuf , attrNameBuf , optNameBuf ) ;
long dataTypeList = CDE . DtDtsDataTypeNames ( ) ;
long [ ] dataType = new long [ 1 ] ;
long ptr = GNOME . gnome_vfs_mime_get_default_application ( mimeTypeBuffer ) ;
long uri = GNOME . gnome_vfs_make_uri_from_input_with_dirs ( fileNameBuffer , GNOME . GNOME_VFS_MAKE_URI_DIR_CURRENT ) ;
long uri = GNOME . gnome_vfs_make_uri_from_input ( fileNameBuffer ) ;
long mimePtr = mimeData [ 0 ] ;
long extensionList = GNOME . gnome_vfs_mime_get_extensions_list ( mimePtr ) ;
long extensionElement = extensionList ;
long extensionPtr = extensionData [ 0 ] ;
long typeName = GNOME . gnome_vfs_mime_type_from_name ( extensionBuffer ) ;
long ptr = GNOME . gnome_vfs_mime_get_default_application ( mimeTypeBuffer ) ;
long icon_name = GNOME . gnome_icon_lookup ( iconThemeValue , 0 , null , buffer , 0 , mimeTypeBuffer ,
long path = 0 ;
public NSSearchFieldCell ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_cancelButtonCell ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_searchButtonCell ) ;
public long lpSource ;
public long lpAssemblyDirectory ;
public long lpResourceName ;
public long lpApplicationName ;
public long hModule ;
public long internal_new_GC ( GCData data ) ;
public void internal_dispose_GC ( long handle , GCData data ) ;
public long type ;
public long pValue ;
public long handle ;
long path = Gdip . GraphicsPath_new ( Gdip . FillModeAlternate ) ;
long matrix = Gdip . Matrix_new ( width , 0 , 0 , height , x , y ) ;
long ptr = OS . malloc ( NSPoint . sizeof ) ;
public long hbmpDragImage ;
void changeFont ( long id , long sel , long arg0 ) {
long jniRef = OS . NewGlobalRef ( this ) ;
void setColor_forAttribute ( long id , long sel , long colorArg , long attribute ) {
double [ ] handle = display . getNSColorRGB ( color ) ;
int validModesForFontPanel ( long id , long sel , long arg0 ) {
void windowWillClose ( long id , long sel , long sender ) {
long getAddress ( ) {
int QueryInterface ( long riid , long ppvObject ) {
XPCOM . memmove ( ppvObject , new long [ ] { supports . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { simpleEnumerator . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
int HasMoreElements ( long _retval ) {
int GetNext ( long _retval ) {
XPCOM . memmove ( _retval , new long [ ] { value . getAddress ( ) } , C . PTR_SIZEOF ) ;
static final long EditProc ;
long callWindowProc ( long hwnd , int msg , long wParam , long lParam ) {
long paintDC = 0 ;
long hDC = paintDC , hBitmap = 0 , hOldBitmap = 0 ;
long margins = OS . SendMessage ( handle , OS . EM_GETMARGINS , 0 , 0 ) ;
long code = OS . CallWindowProc ( EditProc , hwnd , msg , wParam , lParam ) ;
long undo = OS . SendMessage ( handle , OS . EM_CANUNDO , 0 , 0 ) ;
long undo = OS . SendMessage ( handle , OS . EM_CANUNDO , 0 , 0 ) ;
long margins = OS . SendMessage ( handle , OS . EM_GETMARGINS , 0 , 0 ) ;
boolean dragDetect ( long hwnd , int x , int y , boolean filter , boolean [ ] detect , boolean [ ] consume ) {
long lParam = OS . MAKELPARAM ( x , y ) ;
long caretPos = OS . SendMessage ( handle , OS . EM_POSFROMCHAR , position , 0 ) ;
long endPos = OS . SendMessage ( handle , OS . EM_POSFROMCHAR , end [ 0 ] , 0 ) ;
long startPos = OS . SendMessage ( handle , OS . EM_POSFROMCHAR , start [ 0 ] , 0 ) ;
long lParam = OS . MAKELPARAM ( point . x , point . y ) ;
long oldFont = 0 ;
long code = OS . SendMessage ( handle , OS . EM_GETSCROLLPOS , 0 , buffer ) ;
boolean sendKeyEvent ( int type , int msg , long wParam , long lParam , Event event ) {
long margins = OS . SendMessage ( handle , OS . EM_GETMARGINS , 0 , 0 ) ;
long margins = OS . SendMessage ( handle , OS . EM_GETMARGINS , 0 , 0 ) ;
long windowProc ( ) {
long windowProc ( long hwnd , int msg , long wParam , long lParam ) {
LRESULT WM_CHAR ( long wParam , long lParam ) {
LRESULT WM_CLEAR ( long wParam , long lParam ) {
LRESULT WM_CUT ( long wParam , long lParam ) {
LRESULT WM_ERASEBKGND ( long wParam , long lParam ) {
LRESULT WM_GETDLGCODE ( long wParam , long lParam ) {
long code = callWindowProc ( handle , OS . WM_GETDLGCODE , wParam , lParam ) ;
LRESULT WM_GETOBJECT ( long wParam , long lParam ) {
LRESULT WM_IME_CHAR ( long wParam , long lParam ) {
long result = callWindowProc ( handle , OS . WM_IME_CHAR , wParam , lParam ) ;
LRESULT WM_LBUTTONDBLCLK ( long wParam , long lParam ) {
LRESULT WM_LBUTTONDOWN ( long wParam , long lParam ) {
LRESULT WM_PASTE ( long wParam , long lParam ) {
LRESULT WM_UNDO ( long wParam , long lParam ) {
LRESULT wmClipboard ( int msg , long wParam , long lParam ) {
LRESULT wmColorChild ( long wParam , long lParam ) {
LRESULT wmCommandChild ( long wParam , long lParam ) {
LRESULT wmKeyDown ( long hwnd , long wParam , long lParam ) {
long code = 0 ;
long hwndShell = shell . handle ;
long hMenu = parent . handle ;
long hwndCB = parent . hwndCB ;
long hMenu = parent . handle ;
long hMenu = parent . handle ;
long hwndCB = parent . hwndCB ;
long hMenu = parent . handle ;
long hwndCB = parent . hwndCB ;
long hMenu = parent . handle ;
long hMenu = parent . handle ;
long hHeap = OS . GetProcessHeap ( ) ;
long pszText = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount ) ;
long uIDNewItem = id ;
long hMenu = parent . handle ;
long hMenu = parent . handle ;
long hwndCB = parent . hwndCB ;
long hMenu = parent . handle ;
LRESULT wmCommandChild ( long wParam , long lParam ) {
LRESULT wmDrawChild ( long wParam , long lParam ) {
LRESULT wmMeasureChild ( long wParam , long lParam ) {
long hMenu = parent . handle ;
long response = panel . runModalForDirectory ( dir , null ) ;
static final long LabelProc ;
long callWindowProc ( long hwnd , int msg , long wParam , long lParam ) {
long windowProc ( ) {
LRESULT WM_ERASEBKGND ( long wParam , long lParam ) {
LRESULT WM_SIZE ( long wParam , long lParam ) {
LRESULT WM_UPDATEUISTATE ( long wParam , long lParam ) {
long code = OS . DefWindowProc ( handle , OS . WM_UPDATEUISTATE , wParam , lParam ) ;
LRESULT wmColorChild ( long wParam , long lParam ) {
LRESULT WM_PAINT ( long wParam , long lParam ) {
LRESULT wmDrawChild ( long wParam , long lParam ) {
public long handle ;
long hHeap = OS . GetProcessHeap ( ) ;
long foreColor = Gdip . Color_new ( ( alpha1 & 0xFF ) < < 24 | rgb ) ;
long backColor = Gdip . Color_new ( ( alpha2 & 0xFF ) < < 24 | rgb ) ;
long [ ] pixmaps = new long [ count ] ;
long path = OS . g_list_nth_data ( list , i ) ;
long getAddress ( ) {
int QueryInterface ( long riid , long ppvObject ) {
XPCOM . memmove ( ppvObject , new long [ ] { supports . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { factory . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
int CreateInstance ( long aOuter , long iid , long result ) {
XPCOM . memmove ( result , new long [ ] { download . getAddress ( ) } , C . PTR_SIZEOF ) ;
public long base_init ;
public long base_finalize ;
public long class_init ;
public long class_finalize ;
public long class_data ;
public long instance_init ;
public long value_table ;
public long handle ;
long borderHandle ( ) {
boolean checkHandle ( long hwnd ) {
long hwndParent = widgetParent ( ) ;
long hIMC = OS . ImmGetContext ( hwndParent ) ;
long defaultFont ( ) {
long hwnd = topHandle ( ) ;
long lParam = OS . MAKELPARAM ( x , y ) ;
void drawBackground ( long hDC ) {
void drawBackground ( long hDC , RECT rect ) {
void drawBackground ( long hDC , RECT rect , int pixel , int tx , int ty ) {
void drawImageBackground ( long hDC , long hwnd , long hBitmap , RECT rect , int tx , int ty ) {
long hBrush = findBrush ( hBitmap , OS . BS_PATTERN ) ;
long hOldBrush = OS . SelectObject ( hDC , hBrush ) ;
void drawThemeBackground ( long hDC , long hwnd , RECT rect ) {
void fillBackground ( long hDC , int pixel , RECT rect ) {
long hPalette = display . hPalette ;
void fillImageBackground ( long hDC , Control control , RECT rect , int tx , int ty ) {
void fillThemeBackground ( long hDC , Control control , RECT rect ) {
long findBrush ( long value , int lbStyle ) {
long borderHandle = borderHandle ( ) ;
long hwndParent = parent = = null ? 0 : parent . handle ;
long hFont = OS . SendMessage ( handle , OS . WM_GETFONT , 0 , 0 ) ;
long hMem = OS . GetClipboardData ( OS . IsUnicode ? OS . CF_UNICODETEXT : OS . CF_TEXT ) ;
long ptr = OS . GlobalLock ( hMem ) ;
long hFont = OS . SendMessage ( handle , OS . WM_GETFONT , 0 , 0 ) ;
long hwndParent = parent = = null ? 0 : parent . handle ;
long hmonitor = OS . MonitorFromWindow ( handle , OS . MONITOR_DEFAULTTONEAREST ) ;
long hwndFocus = OS . GetFocus ( ) ;
public long internal_new_GC ( GCData data ) {
long hwnd = handle ;
long hDC = 0 ;
public void internal_dispose_GC ( long hDC , GCData data ) {
long hwnd = handle ;
long code = OS . SendMessage ( handle , OS . WM_GETDLGCODE , 0 , 0 ) ;
void mapEvent ( long hwnd , Event event ) {
long topHandle = topHandle ( ) , hwndAbove = OS . HWND_TOP ;
long hwnd = control . topHandle ( ) ;
long topHandle = topHandle ( ) , hwndAbove = OS . HWND_BOTTOM ;
long hwndParent = parent . handle , hwnd = hwndParent ;
long gdipGraphics = gc . getGCData ( ) . gdipGraphics ;
long clipRgn = 0 ;
long rgn = Gdip . Region_new ( ) ;
long matrix = Gdip . Matrix_new ( 1 , 0 , 0 , 1 , 0 , 0 ) ;
void printWidget ( long hwnd , long hdc , GC gc ) {
long hwndInsertAfter = OS . GetWindow ( hwnd , OS . GW_HWNDPREV ) ;
long topHandle = topHandle ( ) ;
void setBackgroundImage ( long hBitmap ) {
long topHandle = topHandle ( ) ;
long lParam = OS . MAKELPARAM ( OS . HTCLIENT , OS . WM_MOUSEMOVE ) ;
long hCursor = cursor ! = null ? cursor . handle : 0 ;
long hwndCursor = OS . GetCapture ( ) ;
long hwnd = hwndCursor = OS . WindowFromPoint ( pt ) ;
long hFont = display . getSystemFont ( ) . handle ;
long hFont = 0 ;
long topHandle = topHandle ( ) ;
long topHandle = topHandle ( ) ;
long hRegion = 0 ;
long topHandle ( ) {
long hwnd = msg . hwnd ;
long code = OS . SendMessage ( hwnd , OS . WM_GETDLGCODE , 0 , 0 ) ;
long hwnd = msg . hwnd ;
long code = OS . SendMessage ( hwnd , OS . WM_GETDLGCODE , 0 , 0 ) ;
long code = OS . SendMessage ( hwnd , OS . WM_GETDLGCODE , 0 , 0 ) ;
long code = OS . SendMessage ( hwnd , OS . WM_GETDLGCODE , 0 , 0 ) ;
long code = OS . SendMessage ( hwnd , OS . WM_GETDLGCODE , 0 , 0 ) ;
long code = OS . SendMessage ( hwnd , OS . WM_GETDLGCODE , 0 , 0 ) ;
long widgetParent ( ) {
long topHandle = topHandle ( ) ;
abstract long windowProc ( ) ;
long windowProc ( long hwnd , int msg , long wParam , long lParam ) {
LRESULT WM_ACTIVATE ( long wParam , long lParam ) {
LRESULT WM_CAPTURECHANGED ( long wParam , long lParam ) {
LRESULT WM_CHANGEUISTATE ( long wParam , long lParam ) {
LRESULT WM_CHAR ( long wParam , long lParam ) {
LRESULT WM_CLEAR ( long wParam , long lParam ) {
LRESULT WM_CLOSE ( long wParam , long lParam ) {
LRESULT WM_COMMAND ( long wParam , long lParam ) {
LRESULT WM_CONTEXTMENU ( long wParam , long lParam ) {
LRESULT WM_CUT ( long wParam , long lParam ) {
LRESULT WM_DESTROY ( long wParam , long lParam ) {
LRESULT WM_DRAWITEM ( long wParam , long lParam ) {
LRESULT WM_ENDSESSION ( long wParam , long lParam ) {
LRESULT WM_ENTERIDLE ( long wParam , long lParam ) {
LRESULT WM_ERASEBKGND ( long wParam , long lParam ) {
LRESULT WM_GESTURE ( long wParam , long lParam ) {
LRESULT WM_GETDLGCODE ( long wParam , long lParam ) {
LRESULT WM_GETFONT ( long wParam , long lParam ) {
LRESULT WM_GETOBJECT ( long wParam , long lParam ) {
long result = accessible . internal_WM_GETOBJECT ( wParam , lParam ) ;
LRESULT WM_GETMINMAXINFO ( long wParam , long lParam ) {
LRESULT WM_HOTKEY ( long wParam , long lParam ) {
LRESULT WM_HELP ( long wParam , long lParam ) {
long hwndShell = shell . handle ;
LRESULT WM_HSCROLL ( long wParam , long lParam ) {
LRESULT WM_IME_CHAR ( long wParam , long lParam ) {
LRESULT WM_IME_COMPOSITION ( long wParam , long lParam ) {
LRESULT WM_IME_COMPOSITION_START ( long wParam , long lParam ) {
LRESULT WM_IME_ENDCOMPOSITION ( long wParam , long lParam ) {
LRESULT WM_UNINITMENUPOPUP ( long wParam , long lParam ) {
LRESULT WM_INITMENUPOPUP ( long wParam , long lParam ) {
LRESULT WM_INPUTLANGCHANGE ( long wParam , long lParam ) {
LRESULT WM_KEYDOWN ( long wParam , long lParam ) {
LRESULT WM_KEYUP ( long wParam , long lParam ) {
LRESULT WM_KILLFOCUS ( long wParam , long lParam ) {
LRESULT WM_LBUTTONDBLCLK ( long wParam , long lParam ) {
LRESULT WM_LBUTTONDOWN ( long wParam , long lParam ) {
LRESULT WM_LBUTTONUP ( long wParam , long lParam ) {
LRESULT WM_MBUTTONDBLCLK ( long wParam , long lParam ) {
LRESULT WM_MBUTTONDOWN ( long wParam , long lParam ) {
LRESULT WM_MBUTTONUP ( long wParam , long lParam ) {
LRESULT WM_MEASUREITEM ( long wParam , long lParam ) {
long hwnd = OS . GetDlgItem ( handle , struct . CtlID ) ;
LRESULT WM_MENUCHAR ( long wParam , long lParam ) {
LRESULT WM_MENUSELECT ( long wParam , long lParam ) {
LRESULT WM_MOUSEACTIVATE ( long wParam , long lParam ) {
LRESULT WM_MOUSEHOVER ( long wParam , long lParam ) {
LRESULT WM_MOUSELEAVE ( long wParam , long lParam ) {
LRESULT WM_MOUSEMOVE ( long wParam , long lParam ) {
LRESULT WM_MOUSEWHEEL ( long wParam , long lParam ) {
LRESULT WM_MOUSEHWHEEL ( long wParam , long lParam ) {
LRESULT WM_MOVE ( long wParam , long lParam ) {
LRESULT WM_NCACTIVATE ( long wParam , long lParam ) {
LRESULT WM_NCCALCSIZE ( long wParam , long lParam ) {
LRESULT WM_NCHITTEST ( long wParam , long lParam ) {
LRESULT WM_NCLBUTTONDOWN ( long wParam , long lParam ) {
LRESULT WM_NCPAINT ( long wParam , long lParam ) {
LRESULT WM_NOTIFY ( long wParam , long lParam ) {
LRESULT WM_PAINT ( long wParam , long lParam ) {
LRESULT WM_PALETTECHANGED ( long wParam , long lParam ) {
LRESULT WM_PARENTNOTIFY ( long wParam , long lParam ) {
LRESULT WM_PASTE ( long wParam , long lParam ) {
LRESULT WM_PRINT ( long wParam , long lParam ) {
LRESULT WM_PRINTCLIENT ( long wParam , long lParam ) {
LRESULT WM_QUERYENDSESSION ( long wParam , long lParam ) {
LRESULT WM_QUERYNEWPALETTE ( long wParam , long lParam ) {
LRESULT WM_QUERYOPEN ( long wParam , long lParam ) {
LRESULT WM_RBUTTONDBLCLK ( long wParam , long lParam ) {
LRESULT WM_RBUTTONDOWN ( long wParam , long lParam ) {
LRESULT WM_RBUTTONUP ( long wParam , long lParam ) {
LRESULT WM_SETCURSOR ( long wParam , long lParam ) {
LRESULT WM_SETFOCUS ( long wParam , long lParam ) {
LRESULT WM_SETTINGCHANGE ( long wParam , long lParam ) {
LRESULT WM_SETFONT ( long wParam , long lParam ) {
LRESULT WM_SETREDRAW ( long wParam , long lParam ) {
LRESULT WM_SHOWWINDOW ( long wParam , long lParam ) {
LRESULT WM_SIZE ( long wParam , long lParam ) {
LRESULT WM_SYSCHAR ( long wParam , long lParam ) {
LRESULT WM_SYSCOLORCHANGE ( long wParam , long lParam ) {
LRESULT WM_SYSCOMMAND ( long wParam , long lParam ) {
long hwndShell = menuShell ( ) . handle ;
LRESULT WM_SYSKEYDOWN ( long wParam , long lParam ) {
LRESULT WM_SYSKEYUP ( long wParam , long lParam ) {
LRESULT WM_TABLET_FLICK ( long wParam , long lParam ) {
long [ ] source = new long [ 1 ] ;
LRESULT WM_TOUCH ( long wParam , long lParam ) {
LRESULT WM_TIMER ( long wParam , long lParam ) {
LRESULT WM_UNDO ( long wParam , long lParam ) {
LRESULT WM_UPDATEUISTATE ( long wParam , long lParam ) {
LRESULT WM_VSCROLL ( long wParam , long lParam ) {
LRESULT WM_WINDOWPOSCHANGED ( long wParam , long lParam ) {
long code = callWindowProc ( handle , OS . WM_WINDOWPOSCHANGED , wParam , lParam ) ;
LRESULT WM_WINDOWPOSCHANGING ( long wParam , long lParam ) {
long hwndParent = parent = = null ? 0 : parent . handle ;
LRESULT WM_XBUTTONDBLCLK ( long wParam , long lParam ) {
LRESULT WM_XBUTTONDOWN ( long wParam , long lParam ) {
LRESULT WM_XBUTTONUP ( long wParam , long lParam ) {
LRESULT wmColorChild ( long wParam , long lParam ) {
long hBrush = findBrush ( hBitmap , OS . BS_PATTERN ) ;
long hOldBrush = OS . SelectObject ( wParam , hBrush ) ;
long hBrush = findBrush ( backPixel , OS . BS_SOLID ) ;
long hOldBrush = OS . SelectObject ( wParam , hBrush ) ;
LRESULT wmCommandChild ( long wParam , long lParam ) {
LRESULT wmDrawChild ( long wParam , long lParam ) {
LRESULT wmMeasureChild ( long wParam , long lParam ) {
LRESULT wmNotify ( NMHDR hdr , long wParam , long lParam ) {
LRESULT wmNotifyChild ( NMHDR hdr , long wParam , long lParam ) {
LRESULT wmScrollChild ( long wParam , long lParam ) {
long hIMC , hwndMDIClient , lpstrTip , toolTipHandle , balloonTipHandle ;
long [ ] brushes ;
Shell ( Display display , Shell parent , int style , long handle , boolean embedded ) {
public static Shell win32_new ( Display display , long handle ) {
public static Shell internal_new ( Display display , long handle ) {
long balloonTipHandle ( ) {
long callWindowProc ( long hwnd , int msg , long wParam , long lParam ) {
long findBrush ( long value , int lbStyle ) {
if ( brushes = = null ) brushes = new long [ BRUSHES_SIZE ] ;
long hBrush = brushes [ i ] ;
long hBrush = brushes [ - - length ] ;
long hwndParent = OS . GetParent ( handle ) ;
ToolTip getCurrentToolTip ( long hwndToolTip ) {
long hIMC = OS . ImmGetContext ( handle ) ;
long hwndMDIClient ( ) {
long hHeap = OS . GetProcessHeap ( ) ;
boolean sendKeyEvent ( int type , int msg , long wParam , long lParam , Event event ) {
long hIMC = OS . ImmGetContext ( handle ) ;
long hkl = OS . GetKeyboardLayout ( 0 ) ;
long hMenu = OS . GetSystemMenu ( handle , false ) ;
void setToolTipText ( long hwnd , String text ) {
long hwndToolTip = toolTipHandle ( ) ;
long hHeap = OS . GetProcessHeap ( ) ;
long hHeap = OS . GetProcessHeap ( ) ;
void setToolTipTitle ( long hwndToolTip , String text , int icon ) {
long hwndShell = OS . GetActiveWindow ( ) ;
long hwndParent = parent . handle ;
long newProc = display . windowProc ;
long toolTipHandle ( ) {
long widgetParent ( ) {
long windowProc ( ) {
long windowProc ( long hwnd , int msg , long wParam , long lParam ) {
LRESULT WM_ACTIVATE ( long wParam , long lParam ) {
long hwnd = fActive ! = 0 ? handle : 0 ;
LRESULT WM_COMMAND ( long wParam , long lParam ) {
long hwndCB = menuBar . hwndCB ;
long hwndChild = OS . GetWindow ( hwndCB , OS . GW_CHILD ) ;
LRESULT WM_DESTROY ( long wParam , long lParam ) {
LRESULT WM_ERASEBKGND ( long wParam , long lParam ) {
LRESULT WM_ENTERIDLE ( long wParam , long lParam ) {
LRESULT WM_GETMINMAXINFO ( long wParam , long lParam ) {
LRESULT WM_MOUSEACTIVATE ( long wParam , long lParam ) {
long hwnd = OS . WindowFromPoint ( pt ) ;
long code = callWindowProc ( handle , OS . WM_MOUSEACTIVATE , wParam , lParam ) ;
LRESULT WM_MOVE ( long wParam , long lParam ) {
LRESULT WM_NCHITTEST ( long wParam , long lParam ) {
long hittest = callWindowProc ( handle , OS . WM_NCHITTEST , wParam , lParam ) ;
long hittest = callWindowProc ( handle , OS . WM_NCHITTEST , wParam , lParam ) ;
LRESULT WM_NCLBUTTONDOWN ( long wParam , long lParam ) {
long hwndActive = 0 ;
long code = callWindowProc ( handle , OS . WM_NCLBUTTONDOWN , wParam , lParam ) ;
LRESULT WM_PALETTECHANGED ( long wParam , long lParam ) {
long hPalette = display . hPalette ;
LRESULT WM_SETCURSOR ( long wParam , long lParam ) {
long hwndModal = modalShell . handle ;
long hwndPopup = OS . GetLastActivePopup ( handle ) ;
LRESULT WM_SETTINGCHANGE ( long wParam , long lParam ) {
LRESULT WM_SHOWWINDOW ( long wParam , long lParam ) {
LRESULT WM_SYSCOMMAND ( long wParam , long lParam ) {
LRESULT WM_WINDOWPOSCHANGING ( long wParam , long lParam ) {
public WebUndefined ( long id ) {
long result = OS . objc_msgSend ( OS . class_WebUndefined , OS . sel_undefined ) ;
long accessibilityAttributeValue ( long id , long sel , long arg0 ) {
long roleDescription = OS . NSAccessibilityRoleDescription ( role . id , 0 ) ;
boolean accessibilityIsIgnored ( long id , long sel ) {
void drawBackground ( long id , NSGraphicsContext context , NSRect rect ) {
long toolbar_itemForItemIdentifier_willBeInsertedIntoToolbar ( long id , long sel , long toolbar , long itemIdentifier , boolean flag ) {
long toolbarAllowedItemIdentifiers ( long id , long sel , long toolbar ) {
long toolbarDefaultItemIdentifiers ( long id , long sel , long toolbar ) {
long toolbarSelectableItemIdentifiers ( long id , long sel , long toolbar ) {
public nsIPrefService ( long address ) {
public int ReadUserPrefs ( long aFile ) {
public int SavePrefFile ( long aFile ) {
public int GetBranch ( byte [ ] aPrefRoot , long [ ] _retval ) {
public int GetDefaultBranch ( byte [ ] aPrefRoot , long [ ] _retval ) {
public WebFrameView ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_printOperationWithPrintInfo_ , printInfo ! = null ? printInfo . id : 0 ) ;
void drawBackground ( long id , NSGraphicsContext context , NSRect rect ) {
boolean isEventView ( long id ) {
boolean isFlipped ( long id , long sel ) {
void keyDown ( long id , long sel , long theEvent ) {
void setForeground ( double [ ] color ) {
public nsIWebProgressListener ( long address ) {
public int OnStateChange ( long aWebProgress , long aRequest , int aStateFlags , int aStatus ) {
public int OnProgressChange ( long aWebProgress , long aRequest , int aCurSelfProgress , int aMaxSelfProgress , int aCurTotalProgress , int aMaxTotalProgress ) {
public int OnLocationChange ( long aWebProgress , long aRequest , long location ) {
public int OnStatusChange ( long aWebProgress , long aRequest , int aStatus , char [ ] aMessage ) {
public int OnSecurityChange ( long aWebProgress , long aRequest , int state ) {
public long pszText ;
public long lParam ;
public long puColumns ;
public long visual ;
long contextId = drawable . internal_new_GC ( data ) ;
long context = drawable . internal_new_GC ( data ) ;
long applierFunc ( long info , long elementPtr ) {
double userSpaceScaleFactor = view . window ( ) . userSpaceScaleFactor ( ) ;
double [ ] color = data . foreground ;
double [ ] color = data . foreground ;
double [ ] color = data . background ;
double [ ] lengths = new double [ dashes . length ] ;
double scaling = size . width ;
double strokeWidth = data . lineWidth * scaling ;
long contextID = OS . objc_msgSend ( NSApplication . sharedApplication ( ) . id , OS . sel_contextID ) ;
long displays = OS . malloc ( 4 * displayCount ) , countPtr = OS . malloc ( 4 ) ;
void copyArea ( Image image , int x , int y , long srcImage ) {
long cgPath = OS . CGPathCreateMutable ( ) ;
long points = OS . malloc ( NSPoint . sizeof * 3 ) ;
double [ ] pt = new double [ 6 ] ;
double [ ] color = data . foreground ;
NSBezierPath createNSBezierPath ( long cgPath ) {
long proc = callback . getAddress ( ) ;
double xOffset = data . drawXOffset , yOffset = data . drawYOffset ;
double xOffset = data . drawXOffset , yOffset = data . drawYOffset ;
double xOffset = data . drawXOffset , yOffset = data . drawYOffset ;
double [ ] color = data . background ;
double xOffset = data . drawXOffset , yOffset = data . drawYOffset ;
double [ ] color = pattern . color1 ;
double startx , starty , endx , endy ;
double x2 = ( b - b2 ) / ( m2 - m ) ;
long points = OS . malloc ( NSPoint . sizeof ) ;
void init ( Drawable drawable , GCData data , long context ) {
void initCGContext ( long cgContext ) {
public nsIWritableVariant ( long address ) {
public int SetAsID ( long aValue ) {
public int SetAsAString ( long aValue ) {
public int SetAsDOMString ( long aValue ) {
public int SetAsACString ( long aValue ) {
public int SetAsAUTF8String ( long aValue ) {
public int SetAsISupports ( long aValue ) {
public int SetAsInterface ( nsID iid , long iface ) {
public int SetAsArray ( short type , long iid , int count , long ptr ) {
public int SetFromVariant ( long aValue ) {
long eventHandle ( ) {
long enterExitHandle ( ) {
boolean forceFocus ( long focusHandle ) {
long childHandle = handle ;
long list = OS . gtk_container_get_children ( handle ) ;
long list = OS . gtk_container_get_children ( handle ) ;
long data = OS . g_list_nth_data ( list , i ) ;
long gtk_key_press_event ( long widget , long eventPtr ) {
long result = super . gtk_key_press_event ( widget , eventPtr ) ;
long topHandle = currentFocusItem . topHandle ( ) ;
long gtk_focus ( long widget , long directionType ) {
static long MenuItemSelectedProc ( long widget , long user_data ) {
long menuItemSelected ( long widget , ToolItem item ) {
long labelHandle = items [ i ] . labelHandle ;
long labelHandle = items [ i ] . labelHandle ;
void setFontDescription ( long font ) {
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long [ ] types = new long [ ] { OS . G_TYPE_STRING ( ) } ;
long textRenderer = OS . gtk_cell_renderer_text_new ( ) ;
long columnHandle = OS . gtk_tree_view_column_new ( ) ;
long selectionHandle = OS . gtk_tree_view_get_selection ( handle ) ;
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long [ ] path = new long [ 1 ] ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long eventWindow ( ) {
long [ ] path = new long [ 1 ] ;
long indices = OS . gtk_tree_path_get_indices ( path [ 0 ] ) ;
long column = OS . gtk_tree_view_get_column ( handle , 0 ) ;
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long [ ] ptr = new long [ 1 ] ;
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long [ ] path = new long [ 1 ] ;
long indices = OS . gtk_tree_path_get_indices ( path [ 0 ] ) ;
long gtk_changed ( long widget ) {
long gtk_event_after ( long widget , long gdkEvent ) {
long [ ] path = new long [ 1 ] ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long [ ] path = new long [ 1 ] ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long gtk_row_activated ( long tree , long path , long column ) {
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long path = OS . gtk_tree_path_new_from_string ( buffer ) ;
long paintWindow ( ) {
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long path = OS . gtk_tree_model_get_path ( modelHandle , iter ) ;
long path = OS . gtk_tree_model_get_path ( modelHandle , iter ) ;
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long path = OS . gtk_tree_model_get_path ( modelHandle , iter ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long selection = OS . gtk_tree_view_get_selection ( handle ) ;
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long path = OS . gtk_tree_model_get_path ( modelHandle , iter ) ;
long iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ;
long path = OS . gtk_tree_model_get_path ( modelHandle , iter ) ;
long newPtr = OS . GlobalAlloc ( COM . GMEM_FIXED | COM . GMEM_ZEROINIT , byteCount ) ;
long lpMultiByteStr = OS . GlobalAlloc ( OS . GMEM_FIXED | OS . GMEM_ZEROINIT , cchMultiByte ) ;
long hMem = stgmedium . unionField ;
long ptr = OS . GlobalLock ( hMem ) ;
long lpMultiByteStr = OS . GlobalLock ( hMem ) ;
public IWebCookieManager ( long address ) {
public int cookieStorage ( long [ ] storage ) {
long hIcon = 0 ;
long hdc = OS . GetDC ( 0 ) ;
long oldBrush = OS . SelectObject ( maskHdc , OS . GetStockObject ( OS . BLACK_BRUSH ) ) ;
long brush = OS . CreateSolidBrush ( OS . GetSysColor ( OS . COLOR_HIGHLIGHT ) ) ;
long hFont = 0 , oldHFont = 0 ;
long hIcon = OS . CreateIconIndirect ( iconInfo ) ;
public WebDocumentRepresentation ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_documentSource ) ;
double screenHeight = display . getPrimaryFrame ( ) . height ;
long modifierFlags = nsEvent . modifierFlags ( ) ;
public long lpfnWndProc ;
public long hInstance ;
public long hIcon ;
public long hCursor ;
public long hbrBackground ;
public long lpszMenuName ;
public long lpszClassName ;
public long alpha_map ;
public long clip_mask ;
public long dither ;
public nsIWindowWatcher ( long address ) {
public int OpenWindow ( long aParent , byte [ ] aUrl , byte [ ] aName , byte [ ] aFeatures , long aArguments , long [ ] _retval ) {
public int RegisterNotification ( long aObserver ) {
public int UnregisterNotification ( long aObserver ) {
public int GetWindowEnumerator ( long [ ] _retval ) {
public int GetNewPrompter ( long aParent , long [ ] _retval ) {
public int GetNewAuthPrompter ( long aParent , long [ ] _retval ) {
public int SetWindowCreator ( long creator ) {
public int GetChromeForWindow ( long aWindow , long [ ] _retval ) {
public int GetWindowByName ( char [ ] aTargetName , long aCurrentWindow , long [ ] _retval ) {
public int GetActiveWindow ( long [ ] aActiveWindow ) {
public int SetActiveWindow ( long aActiveWindow ) {
public long id ;
public id ( long id ) {
public long objc_getClass ( ) {
public long dwExtraInfo ;
public long handle ;
long hBrush , hwndCB ;
Menu ( Decorations parent , int style , long handle ) {
long hwndParent = parent . handle ;
long hFocus = OS . GetFocus ( ) ;
long hwndShell = parent . handle ;
long hMenu = OS . SendMessage ( hwndCB , OS . SHCMBM_GETSUBMENU , 0 , ID_SPSOFTKEY0 ) ;
long hMenu = OS . SendMessage ( hwndCB , OS . SHCMBM_GETSUBMENU , 0 , ID_SPSOFTKEY1 ) ;
long lParam = OS . MAKELPARAM ( dwMask , dwMask ) ;
long hwndShell = parent . handle ;
long hHeap = OS . GetProcessHeap ( ) ;
long pszText = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount ) ;
long hMenu = handle , hCB = hwndCB ;
long hwndShell = parent . handle ;
long result = OS . SendMessage ( hwndCB , OS . TB_GETBUTTON , index , lpButton ) ;
int GetMenuItemCount ( long handle ) {
long hImageList = imageList . getHandle ( ) ;
public long window ;
public NSEvent ( long id ) {
public long CGEvent ( ) {
public long buttonNumber ( ) {
long result = OS . objc_msgSend ( this . id , OS . sel_characters ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_charactersIgnoringModifiers ) ;
public long clickCount ( ) {
public long modifierFlags ( ) {
public long type ( ) {
long result = OS . objc_msgSend ( this . id , OS . sel_window ) ;
public long hwndActive ;
public long hwndFocus ;
public long hwndCapture ;
public long hwndMenuOwner ;
public long hwndMoveSize ;
public long hwndCaret ;
public long handle ;
public static Font win32_new ( Device device , long handle ) {
static final long ListProc ;
long callWindowProc ( long hwnd , int msg , long wParam , long lParam ) {
long code = OS . CallWindowProc ( ListProc , hwnd , msg , wParam , lParam ) ;
long hDC = 0 , oldFont = 0 , newFont = 0 ;
long hDC = 0 , oldFont = 0 , newFont = 0 ;
long oldProc = OS . GetWindowLongPtr ( handle , OS . GWLP_WNDPROC ) ;
long hDC = 0 , oldFont = 0 , newFont = 0 ;
long windowProc ( ) {
LRESULT WM_CHAR ( long wParam , long lParam ) {
LRESULT WM_KEYDOWN ( long wParam , long lParam ) {
LRESULT WM_SETREDRAW ( long wParam , long lParam ) {
LRESULT WM_SIZE ( long wParam , long lParam ) {
LRESULT wmCommandChild ( long wParam , long lParam ) {
long getAddress ( ) {
int QueryInterface ( long riid , long ppvObject ) {
XPCOM . memmove ( ppvObject , new long [ ] { supports . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { factory . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( ppvObject , new long [ ] { 0 } , C . PTR_SIZEOF ) ;
int GetPrompt ( long aParent , long iid , long result ) {
XPCOM . memmove ( result , new long [ ] { prompter . getAddress ( ) } , C . PTR_SIZEOF ) ;
XPCOM . memmove ( result , new long [ ] { promptAuth . getAddress ( ) } , C . PTR_SIZEOF ) ;
public nsIComponentManager ( long address ) {
public int GetClassObject ( nsID aClass , nsID aIID , long [ ] result ) {
public int GetClassObjectByContractID ( byte [ ] aContractID , nsID aIID , long [ ] result ) {
public int CreateInstance ( nsID aClass , long aDelegate , nsID aIID , long [ ] result ) {
public int CreateInstanceByContractID ( byte [ ] aContractID , long aDelegate , nsID aIID , long [ ] result ) {
public long visual ;
public long mem ;
public long colormap ;
public long windowing_data ;
public NSPasteboard ( long id ) {
public long addTypes ( NSArray newTypes , id newOwner ) {
long result = OS . objc_msgSend ( this . id , OS . sel_availableTypeFromArray_ , types ! = null ? types . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_dataForType_ , dataType ! = null ? dataType . id : 0 ) ;
public long declareTypes ( NSArray newTypes , id newOwner ) {
long result = OS . objc_msgSend ( OS . class_NSPasteboard , OS . sel_generalPasteboard ) ;
long result = OS . objc_msgSend ( OS . class_NSPasteboard , OS . sel_pasteboardWithName_ , name ! = null ? name . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_propertyListForType_ , dataType ! = null ? dataType . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_stringForType_ , dataType ! = null ? dataType . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_types ) ;
long EnumLocalesProc ( long lpLocaleString ) {
long lpEnumLocalesProc = callback . getAddress ( ) ;
public nsIDOMWindow ( long address ) {
public int GetWindow ( long [ ] aWindow ) {
public int GetSelf ( long [ ] aSelf ) {
public int GetDocument ( long [ ] aDocument ) {
public int GetParent ( long [ ] aParent ) {
public int GetTop ( long [ ] aTop ) {
public int GetScrollbars ( long [ ] aScrollbars ) {
public int GetFrames ( long [ ] aFrames ) {
public int GetName ( long aName ) {
public int SetName ( long aName ) {
public int GetLocation ( long [ ] aLocation ) {
public int GetHistory ( long [ ] aHistory ) {
public int GetLocationbar ( long [ ] aLocationbar ) {
public int GetMenubar ( long [ ] aMenubar ) {
public int GetPersonalbar ( long [ ] aPersonalbar ) {
public int GetSelection ( long [ ] _retval ) {
public int GetStatusbar ( long [ ] aStatusbar ) {
public int GetToolbar ( long [ ] aToolbar ) {
public int GetStatus ( long aStatus ) {
public int SetStatus ( long aStatus ) {
public int GetOpener ( long [ ] aOpener ) {
public int SetOpener ( long aOpener ) {
public int GetFrameElement ( long [ ] aFrameElement ) {
public int GetNavigator ( long [ ] aNavigator ) {
public int GetApplicationCache ( long [ ] aApplicationCache ) {
public int Alert ( long text ) {
public int Confirm ( long text , int [ ] _retval ) {
public int Prompt ( long aMessage , long aInitial , long _retval ) {
public int ShowModalDialog ( long aURI , long aArgs , long aOptions , long [ ] _retval ) {
public int PostMessageMoz ( long message , long targetOrigin , long cx ) {
public int Atob ( long aAsciiString , long _retval ) {
public int Btoa ( long aBase64Data , long _retval ) {
public int GetSessionStorage ( long [ ] aSessionStorage ) {
public int GetLocalStorage ( long [ ] aLocalStorage ) {
public int MatchMedia ( long media_query_list , long [ ] _retval ) {
public int GetScreen ( long [ ] aScreen ) {
public int GetComputedStyle ( long elt , long pseudoElt , long [ ] _retval ) {
public int GetWindowRoot ( long [ ] aWindowRoot ) {
public int GetContent ( long [ ] aContent ) {
public int GetPrompter ( long [ ] aPrompter ) {
public int GetCrypto ( long [ ] aCrypto ) {
public int GetPkcs11 ( long [ ] aPkcs11 ) {
public int GetControllers ( long [ ] aControllers ) {
public int GetDefaultStatus ( long aDefaultStatus ) {
public int SetDefaultStatus ( long aDefaultStatus ) {
public int Open ( long url , long name , long options , long [ ] _retval ) {
public int OpenDialog ( long url , long name , long options , long aExtraArgument , long [ ] _retval ) {
public int UpdateCommands ( long action ) {
public int Find ( long str , int caseSensitive , int backwards , int wrapAround , int wholeWord , int searchInFrames , int showDialog , int [ ] _retval ) {
public int GetMozPaintCount ( long aMozPaintCount ) {
public int MozRequestAnimationFrame ( long aListener ) {
public int GetURL ( long [ ] aURL ) {
public int GetGlobalStorage ( long [ ] aGlobalStorage ) {
public int GetOnafterprint ( long cx , long aOnafterprint ) {
public int SetOnafterprint ( long cx , long aOnafterprint ) {
public int GetOnbeforeprint ( long cx , long aOnbeforeprint ) {
public int SetOnbeforeprint ( long cx , long aOnbeforeprint ) {
public int GetOnbeforeunload ( long cx , long aOnbeforeunload ) {
public int SetOnbeforeunload ( long cx , long aOnbeforeunload ) {
public int GetOnhashchange ( long cx , long aOnhashchange ) {
public int SetOnhashchange ( long cx , long aOnhashchange ) {
public int GetOnmessage ( long cx , long aOnmessage ) {
public int SetOnmessage ( long cx , long aOnmessage ) {
public int GetOnoffline ( long cx , long aOnoffline ) {
public int SetOnoffline ( long cx , long aOnoffline ) {
public int GetOnonline ( long cx , long aOnonline ) {
public int SetOnonline ( long cx , long aOnonline ) {
public int GetOnpopstate ( long cx , long aOnpopstate ) {
public int SetOnpopstate ( long cx , long aOnpopstate ) {
public int GetOnpagehide ( long cx , long aOnpagehide ) {
public int SetOnpagehide ( long cx , long aOnpagehide ) {
public int GetOnpageshow ( long cx , long aOnpageshow ) {
public int SetOnpageshow ( long cx , long aOnpageshow ) {
public int GetOnresize ( long cx , long aOnresize ) {
public int SetOnresize ( long cx , long aOnresize ) {
public int GetOnunload ( long cx , long aOnunload ) {
public int SetOnunload ( long cx , long aOnunload ) {
public int GetOndevicemotion ( long cx , long aOndevicemotion ) {
public int SetOndevicemotion ( long cx , long aOndevicemotion ) {
public int GetOndeviceorientation ( long cx , long aOndeviceorientation ) {
public int SetOndeviceorientation ( long cx , long aOndeviceorientation ) {
public int GetOnmouseenter ( long cx , long aOnmouseenter ) {
public int SetOnmouseenter ( long cx , long aOnmouseenter ) {
public int GetOnmouseleave ( long cx , long aOnmouseleave ) {
public int SetOnmouseleave ( long cx , long aOnmouseleave ) {
public static final native int CFArrayGetCount ( long theArray ) ;
public static final native long CFArrayGetValueAtIndex ( long theArray , int idx ) ;
public static final native long CFDataCreate ( long allocator , byte [ ] bytes , int length ) ;
public static final native long CFDataGetBytePtr ( long theData ) ;
public static final native int CFDataGetLength ( long theData ) ;
public static final native long CFDictionaryCreate ( long allocator , long [ ] keys , long [ ] values , int numValues , long keyCallBacks , long valueCallBacks ) ;
public static final native long CFHTTPCookieCreateWithResponseHeaderFields ( long inAllocator , long headerFields , long inURL ) ;
public static final native int CFHTTPCookieGetFlags ( long inCookie ) ;
public static final native long CFHTTPCookieGetName ( long inCookie ) ;
public static final native long CFHTTPCookieGetValue ( long inCookie ) ;
public static final native long CFHTTPCookieStorageCopyCookies ( long inCookieStorage ) ;
public static final native long CFHTTPCookieStorageCopyCookiesForURL ( long inCookieStorage , long inURL , boolean sendSecureCookies ) ;
public static final native void CFHTTPCookieStorageDeleteCookie ( long inCookieStorage , long inCookie ) ;
public static final native void CFHTTPCookieStorageSetCookie ( long inCookieStorage , long inCookie ) ;
public static final native void CFRelease ( long cf ) ;
public static final native int CFStringCreateWithCharacters ( long alloc , char [ ] chars , int numChars ) ;
public static final native char CFStringGetCharacterAtIndex ( long theString , int idx ) ;
public static final native long CFStringGetCharactersPtr ( long theString ) ;
public static final native int CFStringGetLength ( long theString ) ;
public static final native long CFURLCreateWithString ( long allocator , long URLString , long baseURL ) ;
public static final native long CFURLRequestCreateMutableCopy ( long alloc , long origRequest ) ;
public static final native long CFURLRequestCopyHTTPRequestBody ( long request ) ;
public static final native void CFURLRequestSetHTTPRequestBody ( long mutableHTTPRequest , long httpBody ) ;
public static final native void CFURLRequestSetURL ( long mutableRequest , long url ) ;
public static final native long JSClassCreate ( long definition ) ;
public static final native long JSClassRetain ( long jsClass ) ;
public static final native long JSContextGetGlobalObject ( long ctx ) ;
public static final native long JSEvaluateScript ( long ctx , long script , long thisObject , long sourceURL , int startingLineNumber , long [ ] exception ) ;
public static final native int JSGlobalContextRetain ( long ctx ) ;
public static final native long JSObjectGetPrivate ( long object ) ;
public static final native long JSObjectGetProperty ( long ctx , long object , long propertyName , long [ ] exception ) ;
public static final native long JSObjectGetPropertyAtIndex ( long ctx , long object , int propertyIndex , long [ ] exception ) ;
public static final native int JSObjectMake ( long ctx , long jsClass , long data ) ;
public static final native long JSObjectMakeArray ( long ctx , long argumentCount , long [ ] arguments , long [ ] exception ) ;
public static final native int JSObjectMakeFunctionWithCallback ( long ctx , long name , long callAsFunction ) ;
public static final native void JSObjectSetProperty ( long ctx , long object , long propertyName , long value , long attributes , long [ ] exception ) ;
public static final native long JSStringCreateWithUTF8CString ( byte [ ] string ) ;
public static final native int JSStringGetLength ( long string ) ;
public static final native long JSStringGetMaximumUTF8CStringSize ( long string ) ;
public static final native int JSStringGetUTF8CString ( long string , byte [ ] buffer , long bufferSize ) ;
public static final native int JSStringIsEqualToUTF8CString ( long a , byte [ ] b ) ;
public static final native void JSStringRelease ( long string ) ;
public static final native int JSValueGetType ( long ctx , long value ) ;
public static final native int JSValueIsObjectOfClass ( long ctx , long value , long jsClass ) ;
public static final native long JSValueMakeBoolean ( long ctx , long b ) ;
public static final native long JSValueMakeNull ( long ctx ) ;
public static final native long JSValueMakeNumber ( long ctx , double number ) ;
public static final native long JSValueMakeString ( long ctx , long string ) ;
public static final native long JSValueMakeUndefined ( long ctx ) ;
public static final native double JSValueToNumber ( long ctx , long value , long [ ] exception ) ;
public static final native long JSValueToStringCopy ( long ctx , long value , long [ ] exception ) ;
public static final native long kCFCopyStringDictionaryKeyCallBacks ( ) ;
public static final native long kCFTypeDictionaryValueCallBacks ( ) ;
public static final native void memmove ( long dest , JSClassDefinition src , long size ) ;
public static final native long JSObjectCallAsFunctionProc_CALLBACK ( long func ) ;
public static final native long JSObjectGetPropertyProc_CALLBACK ( long func ) ;
public static final native long JSObjectHasPropertyProc_CALLBACK ( long func ) ;
public static final native long willPerformClientRedirectToURL_CALLBACK ( long func ) ;
public WebPreferences ( long id ) {
long result = OS . objc_msgSend ( OS . class_WebPreferences , OS . sel_standardPreferences ) ;
public IWebErrorPrivate ( long address ) {
public int sslPeerCertificate ( long [ ] result ) {
public long hProcess ;
public long hThread ;
public nsIProgressDialog ( long address ) {
public int Open ( long aParent ) {
public int GetDialog ( long [ ] aDialog ) {
public int SetDialog ( long aDialog ) {
public IEnumVARIANT ( long address ) {
public long item ;
public long glyphs ;
public nsIDataType ( long address ) {
public IDropTargetHelper ( long address ) {
public int DragEnter ( long hwndTarget , long pDataObject , POINT ppt , int dwEffect ) {
public int Drop ( long pDataObject , POINT ppt , int dwEffect ) {
public NSSegmentedCell ( long id ) {
public void setEnabled ( boolean enabled , long segment ) {
public void setImage ( NSImage image , long segment ) {
public void setLabel ( NSString label , long segment ) {
public void setMenu ( NSMenu menu , long segment ) {
public void setSegmentCount ( long count ) {
public void setSegmentStyle ( long segmentStyle ) {
public void setSelected ( boolean selected , long segment ) {
public void setSelectedSegment ( long selectedSegment ) {
public void setTag ( long tag , long segment ) {
public void setToolTip ( NSString toolTip , long segment ) {
public void setTrackingMode ( long trackingMode ) {
public void setWidth ( double width , long segment ) {
public long sibling ;
public long pvImData ;
long viewport = OS . gtk_bin_get_child ( scrolledHandle ) ;
long eventHandle ( ) {
boolean forceFocus ( long focusHandle ) {
long gtk_key_press_event ( long widget , long event ) {
long result = super . gtk_key_press_event ( widget , event ) ;
long parentingHandle ( ) {
void setFontDescription ( long font ) {
long adjustmentHandle = OS . gtk_scrolled_window_get_vadjustment ( scrolledHandle ) ;
long vHandle = 0 ;
void drawBackground ( long id , NSGraphicsContext context , NSRect rect ) {
void setForeground ( double [ ] color ) {
void tabView_willSelectTabViewItem ( long id , long sel , long tabView , long tabViewItem ) {
void tabView_didSelectTabViewItem ( long id , long sel , long tabView , long tabViewItem ) {
public NSObject ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_accessibilityAttributeValue_forParameter_ , attribute ! = null ? attribute . id : 0 , parameter ! = null ? parameter . id : 0 ) ;
public void draggedImage ( NSImage image , NSPoint screenPoint , long operation ) {
long result = OS . objc_msgSend ( this . id , OS . sel_draggingDestinationWindow ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_draggingPasteboard ) ;
public long draggingSourceOperationMask ( ) {
public boolean outlineView ( NSOutlineView outlineView , long columnIndex , long newColumnIndex ) {
public boolean tableView ( NSTableView tableView , long columnIndex , long newColumnIndex ) {
public boolean tableView ( NSTableView tableView , long row ) {
public boolean tableView ( NSTableView tableView , NSCell cell , NSTableColumn tableColumn , long row ) {
long result = OS . objc_msgSend ( this . id , OS . sel_autorelease ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_className ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_copy ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_description ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_init ) ;
public boolean isKindOfClass ( long aClass ) {
long result = OS . objc_msgSend ( this . id , OS . sel_mutableCopy ) ;
public void performSelector ( long aSelector , id anArgument , double delay , NSArray modes ) {
public void performSelectorOnMainThread ( long aSelector , id arg , boolean wait ) {
public boolean respondsToSelector ( long aSelector ) {
long result = OS . objc_msgSend ( this . id , OS . sel_retain ) ;
public long retainCount ( ) {
public long superclass ( ) {
long result = OS . objc_msgSend ( this . id , OS . sel_valueForKey_ , key ! = null ? key . id : 0 ) ;
public nsIWeakReference ( long address ) {
public int QueryReferent ( nsID uuid , long [ ] result ) {
public nsIChannel ( long address ) {
public int GetOriginalURI ( long [ ] aOriginalURI ) {
public int SetOriginalURI ( long aOriginalURI ) {
public int GetURI ( long [ ] aURI ) {
public int GetOwner ( long [ ] aOwner ) {
public int SetOwner ( long aOwner ) {
public int GetNotificationCallbacks ( long [ ] aNotificationCallbacks ) {
public int SetNotificationCallbacks ( long aNotificationCallbacks ) {
public int GetSecurityInfo ( long [ ] aSecurityInfo ) {
public int GetContentType ( long aContentType ) {
public int SetContentType ( long aContentType ) {
public int GetContentCharset ( long aContentCharset ) {
public int SetContentCharset ( long aContentCharset ) {
public int Open ( long [ ] _retval ) {
public int AsyncOpen ( long aListener , long aContext ) {
public int GetContentDispositionFilename ( long aContentDispositionFilename ) {
public int GetContentDispositionHeader ( long aContentDispositionHeader ) {
long ptr = OS . malloc ( 4 ) ;
public static final long AnyPropertyType = 0 ;
public static final native long localeconv_decimal_point ( ) ;
public static final native long realpath ( byte [ ] path , byte [ ] realPath ) ;
public static final native long G_OBJECT_CLASS_CONSTRUCTOR ( long object_class ) ;
public static final native void G_OBJECT_CLASS_SET_CONSTRUCTOR ( long object_class , long constructor ) ;
public static final native int GTK_WIDGET_HEIGHT ( long widget ) ;
public static final native int GTK_WIDGET_WIDTH ( long widget ) ;
public static final native long GTK_WIDGET_WINDOW ( long widget ) ;
public static final native int GTK_WIDGET_X ( long widget ) ;
public static final native int GTK_WIDGET_Y ( long widget ) ;
public static final native int GTK_RANGE_SLIDER_START ( long widget ) ;
public static final native int GTK_RANGE_SLIDER_END ( long widget ) ;
public static final native long GTK_SCROLLED_WINDOW_HSCROLLBAR ( long widget ) ;
public static final native long GTK_SCROLLED_WINDOW_VSCROLLBAR ( long widget ) ;
public static final native int GTK_SCROLLED_WINDOW_SCROLLBAR_SPACING ( long widget ) ;
public static final native void GTK_ACCEL_LABEL_SET_ACCEL_STRING ( long acce_label , long string ) ;
public static final native long GTK_ACCEL_LABEL_GET_ACCEL_STRING ( long acce_label ) ;
public static final native long GTK_ENTRY_IM_CONTEXT ( long widget ) ;
public static final native long GTK_TEXTVIEW_IM_CONTEXT ( long widget ) ;
public static final native long GTK_TOOLTIPS_TIP_WINDOW ( long widget ) ;
public static final native void GTK_TOOLTIPS_SET_ACTIVE ( long widget , long data ) ;
public static final native long GTK_TOOLTIPS_GET_TIP_TEXT ( long data ) ;
public static final native void GTK_WIDGET_SET_X ( long widget , int x ) ;
public static final native void GTK_WIDGET_SET_Y ( long widget , int y ) ;
public static final native int GTK_WIDGET_REQUISITION_WIDTH ( long widget ) ;
public static final native int GTK_WIDGET_REQUISITION_HEIGHT ( long widget ) ;
public static final native int GDK_EVENT_TYPE ( long event ) ;
public static final native long GDK_EVENT_WINDOW ( long event ) ;
public static final native int X_EVENT_TYPE ( long xevent ) ;
public static final native long X_EVENT_WINDOW ( long xevent ) ;
public static final long NoEventMask = 0 ;
public static final native void memmove ( long dest , XClientMessageEvent src , long size ) ;
public static final native void memmove ( long dest , XExposeEvent src , long size ) ;
public static final native void memmove ( XExposeEvent dest , long src , long size ) ;
public static final native void memmove ( XFocusChangeEvent dest , long src , long size ) ;
public static final native void memmove ( XVisibilityEvent dest , long src , long size ) ;
public static final native long pangoLayoutNewProc_CALLBACK ( long func ) ;
public static final native long G_TYPE_BOOLEAN ( ) ;
public static final native long G_TYPE_DOUBLE ( ) ;
public static final native long G_TYPE_FLOAT ( ) ;
public static final native long G_TYPE_INT ( ) ;
public static final native void g_main_context_wakeup ( long context ) ;
public static final native long g_value_init ( long value , long type ) ;
public static final native int g_value_get_int ( long value ) ;
public static final native void g_value_set_int ( long value , int v ) ;
public static final native double g_value_get_double ( long value ) ;
public static final native void g_value_set_double ( long value , double v ) ;
public static final native float g_value_get_float ( long value ) ;
public static final native void g_value_set_float ( long value , float v ) ;
public static final native long g_value_get_int64 ( long value ) ;
public static final native void g_value_set_int64 ( long value , long v ) ;
public static final native void g_value_unset ( long value ) ;
public static final native void gdk_threads_set_lock_functions ( long enter_fn , long leave_fn ) ;
public static final native void memmove ( long dest , GInterfaceInfo src , int size ) ;
public static final native void memmove ( long dest , GObjectClass src ) ;
public static final native void memmove ( long dest , GTypeInfo src , int size ) ;
public static final native void memmove ( long dest , GtkTargetEntry src , long size ) ;
public static final native void memmove ( long dest , GtkAdjustment src ) ;
public static final native void memmove ( long dest , GdkColor src , long size ) ;
public static final native void memmove ( long dest , GdkEventButton src , long size ) ;
public static final native void memmove ( long dest , GdkEventExpose src , long size ) ;
public static final native void memmove ( long dest , GdkEventMotion src , long size ) ;
public static final native void memmove ( long dest , GtkWidgetClass src ) ;
public static final native void memmove ( long dest , PangoAttribute src , long size ) ;
public static final native void memmove ( GObjectClass dest , long src ) ;
public static final native void memmove ( GTypeQuery dest , long src , long size ) ;
public static final native void memmove ( GtkColorSelectionDialog dest , long src ) ;
public static final native void memmove ( GdkEventProperty dest , long src ) ;
public static final native void memmove ( GdkDragContext dest , long src , long size ) ;
public static final native void memmove ( GtkSelectionData dest , long src , long size ) ;
public static final native void memmove ( GtkWidgetClass dest , long src ) ;
public static final native void memmove ( GtkTargetPair dest , long src , long size ) ;
public static final native void memmove ( GtkAdjustment dest , long src ) ;
public static final native void memmove ( GtkBorder dest , long src , long size ) ;
public static final native void memmove ( GdkColor dest , long src , long size ) ;
public static final native void memmove ( GdkEvent dest , long src , long size ) ;
public static final native void memmove ( GdkEventAny dest , long src , long size ) ;
public static final native void memmove ( GdkEventButton dest , long src , long size ) ;
public static final native void memmove ( GdkEventCrossing dest , long src , long size ) ;
public static final native void memmove ( GdkEventExpose dest , long src , long size ) ;
public static final native void memmove ( GdkEventFocus dest , long src , long size ) ;
public static final native void memmove ( GdkEventKey dest , long src , long size ) ;
public static final native void memmove ( GdkEventMotion dest , long src , long size ) ;
public static final native void memmove ( GdkEventScroll dest , long src , long size ) ;
public static final native void memmove ( GdkEventVisibility dest , long src , long size ) ;
public static final native void memmove ( GtkFixed dest , long src ) ;
public static final native void memmove ( long dest , GtkFixed src ) ;
public static final native void memmove ( GdkVisual dest , long src ) ;
public static final native void memmove ( GdkImage dest , long src ) ;
public static final native void memmove ( GdkRectangle dest , long src , long size ) ;
public static final native void memmove ( PangoAttribute dest , long src , long size ) ;
public static final native void memmove ( PangoAttrColor dest , long src , long size ) ;
public static final native void memmove ( PangoAttrInt dest , long src , long size ) ;
public static final native void memmove ( PangoItem dest , long src , long size ) ;
public static final native void memmove ( PangoLayoutLine dest , long src , long size ) ;
public static final native void memmove ( PangoLayoutRun dest , long src , long size ) ;
public static final native void memmove ( PangoLogAttr dest , long src , long size ) ;
public static final native int strcmp ( long s1 , byte [ ] s2 ) ;
public IDragSourceHelper ( long address ) {
public int InitializeFromBitmap ( SHDRAGIMAGE pshdi , long pDataObject ) {
public int InitializeFromWindow ( long hwnd , POINT ppt , long pDataObject ) {
public nsIFactory ( long address ) {
public int CreateInstance ( long aOuter , nsID iid , long [ ] result ) {
long ivar = OS . object_setInstanceVariable ( view . id , SWT_OBJECT , widget . jniRef ) ;
double scaleFactor = screen . userSpaceScaleFactor ( ) ;
long ptr = getApplicationName ( ) . UTF8String ( ) ;
long proc2 = applicationCallback2 . getAddress ( ) ;
long proc3 = applicationCallback3 . getAddress ( ) ;
long proc4 = applicationCallback4 . getAddress ( ) ;
long proc6 = applicationCallback6 . getAddress ( ) ;
long appProc3 = applicationCallback3 . getAddress ( ) ;
long appProc4 = applicationCallback4 . getAddress ( ) ;
long cursorSetProc ( long id , long sel ) {
public Widget findWidget ( long handle ) {
public Widget findWidget ( long handle , int id ) {
double y = frame . height - ( visibleFrame . y + visibleFrame . height ) ;
double [ ] getWidgetColorRGB ( int id ) {
case SWT . COLOR_INFO_BACKGROUND : return new double [ ] { .984f , .988f , 0.773f , 1 } ;
double [ ] getNSColorRGB ( NSColor color ) {
double [ ] components = new double [ ( int ) color . numberOfComponents ( ) ] ;
return new double [ ] { components [ 0 ] , components [ 1 ] , components [ 2 ] , components [ 3 ] } ;
long iconRef [ ] = new long [ 1 ] ;
long nsCount = nsAppMenu . numberOfItems ( ) ;
Widget getWidget ( long id ) {
static Widget GetWidget ( long id ) {
long count = windows . count ( ) ;
long currDelegatePtr = OS . objc_msgSend ( OS . class_JRSAppKitAWT , OS . sel_awtAppDelegate ) ;
long observerProc = observerCallback . getAddress ( ) ;
long cls = OS . objc_lookUpClass ( "str" ) ;
long mode = OS . objc_msgSend ( cls , OS . sel_javaRunLoopMode ) ;
long cursorSetProc = cursorSetCallback . getAddress ( ) ;
long method = OS . class_getInstanceMethod ( OS . class_NSCursor , OS . sel_set ) ;
void addEventMethods ( long cls , long proc2 , long proc3 , long drawRectProc , long hitTestProc , long needsDisplayInRectProc ) {
void addFrameMethods ( long cls , long setFrameOriginProc , long setFrameSizeProc ) {
void addAccessibilityMethods ( long cls , long proc2 , long proc3 , long proc4 , long accessibilityHitTestProc ) {
long registerCellSubclass ( long cellClass , int size , int align , byte [ ] types ) {
long cls = OS . objc_allocateClassPair ( cellClass , "str" + cellClassName , 0 ) ;
long proc2 = windowCallback2 . getAddress ( ) ;
long dialogProc3 = dialogCallback3 . getAddress ( ) ;
long dialogProc4 = dialogCallback4 . getAddress ( ) ;
long dialogProc5 = dialogCallback5 . getAddress ( ) ;
long proc3 = windowCallback3 . getAddress ( ) ;
long proc2 = windowCallback2 . getAddress ( ) ;
long proc4 = windowCallback4 . getAddress ( ) ;
long proc5 = windowCallback5 . getAddress ( ) ;
long proc6 = windowCallback6 . getAddress ( ) ;
long metaClass = OS . objc_getMetaClass ( className ) ;
long nsSecureTextViewClass = OS . objc_lookUpClass ( "str" ) ;
colors = new double [ SWT . COLOR_TITLE_INACTIVE_BACKGROUND_GRADIENT + 1 ] [ ] ;
public long internal_new_GC ( GCData data ) {
public void internal_dispose_GC ( long hDC , GCData data ) {
double scaleFactor = fromWindow . userSpaceScaleFactor ( ) ;
double scaleFactor = toWindow . userSpaceScaleFactor ( ) ;
double scaleFactor = fromWindow . userSpaceScaleFactor ( ) ;
double scaleFactor = toWindow . userSpaceScaleFactor ( ) ;
long observerProc ( long observer , long activity , long info ) {
long method = OS . class_getInstanceMethod ( OS . class_NSCursor , OS . sel_set ) ;
long count = menubar . numberOfItems ( ) ;
long count = needsDisplay . count ( ) ;
long count = needsDisplayInRect . count ( ) ;
long ptr = OS . getenv ( ascii ( "str" + pid ) ) ;
long count = menubar . numberOfItems ( ) ;
long timerProc ( long id , long sel , long timerID ) {
long quitIndex = sm . indexOfItemWithTarget ( applicationDelegate , OS . sel_applicationShouldTerminate_ ) ;
long hitWindowNumber = 0 ;
void finishLaunching ( long id , long sel ) {
void applicationDidBecomeActive ( long id , long sel , long notification ) {
void applicationDidResignActive ( long id , long sel , long notification ) {
long applicationNextEventMatchingMask ( long id , long sel , long mask , long expiration , long mode , long dequeue ) {
long result = OS . objc_msgSendSuper ( super_struct , sel , mask , expiration , mode , dequeue ! = 0 ) ;
void applicationSendEvent ( long id , long sel , long event ) {
void applicationWillFinishLaunching ( long id , long sel , long notification ) {
long outMenu [ ] = new long [ 1 ] ;
long newTag = 0 ;
long quitIndex = sm . indexOfItemWithTarget ( applicationDelegate , OS . sel_terminate_ ) ;
static long applicationProc ( long id , long sel ) {
static long applicationProc ( long id , long sel , long arg0 ) {
static long applicationProc ( long id , long sel , long arg0 , long arg1 ) {
long count = files . count ( ) ;
static long applicationProc ( long id , long sel , long arg0 , long arg1 , long arg2 , long arg3 ) {
static Widget LookupWidget ( long id , long sel ) {
static long windowProc ( long id , long sel ) {
long result = OS . malloc ( NSRange . sizeof ) ;
long result = OS . malloc ( NSRange . sizeof ) ;
long result = OS . malloc ( NSSize . sizeof ) ;
static long windowProc ( long id , long sel , long arg0 ) {
long result = OS . malloc ( NSRect . sizeof ) ;
long result = OS . malloc ( NSRect . sizeof ) ;
long result = OS . malloc ( NSRect . sizeof ) ;
long result = OS . malloc ( NSRect . sizeof ) ;
long result = OS . malloc ( NSSize . sizeof ) ;
long result = OS . malloc ( NSSize . sizeof ) ;
static long windowProc ( long id , long sel , long arg0 , long arg1 ) {
long result = OS . malloc ( NSRect . sizeof ) ;
static long windowProc ( long id , long sel , long arg0 , long arg1 , long arg2 ) {
long result = OS . malloc ( NSRange . sizeof ) ;
long result = OS . malloc ( NSRect . sizeof ) ;
static long windowProc ( long id , long sel , long arg0 , long arg1 , long arg2 , long arg3 ) {
public long lpszText ;
public long hinst ;
public long lParam ;
public NSTimer ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_userInfo ) ;
double thickness = widget . knobThickness ( ) ;
public IConnectionPointContainer ( long address ) {
public int FindConnectionPoint ( GUID riid , long [ ] ppCP ) {
public NSAlert ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_addButtonWithTitle_ , title ! = null ? title . id : 0 ) ;
public void beginSheetModalForWindow ( NSWindow window , id delegate , long didEndSelector , long contextInfo ) {
public long runModal ( ) {
public void setAlertStyle ( long style ) {
long result = OS . objc_msgSend ( this . id , OS . sel_window ) ;
long hwndToolTip = hwndToolTip ( ) ;
long hwndToolTip ( ) {
long hwndToolTip = hwndToolTip ( ) ;
long hwnd = parent . handle ;
long hwndToolTip = hwndToolTip ( ) ;
long hmonitor = OS . MonitorFromWindow ( hwnd , OS . MONITOR_DEFAULTTONEAREST ) ;
long lParam = OS . MAKELPARAM ( nX , nY ) ;
long hCursor = OS . GetCursor ( ) ;
long cairo = data . cairo ;
long surface = Cairo . cairo_xlib_surface_create ( xDisplay , xDrawable , xVisual , w [ 0 ] , h [ 0 ] ) ;
long pattern = Cairo . cairo_pattern_create_for_surface ( surface ) ;
public NSDictionary ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_allKeys ) ;
public long count ( ) {
long result = OS . objc_msgSend ( OS . class_NSDictionary , OS . sel_dictionaryWithObject_forKey_ , object ! = null ? object . id : 0 , key ! = null ? key . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_objectEnumerator ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_objectForKey_ , aKey ! = null ? aKey . id : 0 ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_valueForKey_ , key ! = null ? key . id : 0 ) ;
public IWebError ( long address ) {
public int localizedDescription ( long [ ] result ) {
public int failingURL ( long [ ] result ) {
public NSTrackingArea ( long id ) {
long result = OS . objc_msgSend ( this . id , OS . sel_owner ) ;
long result = OS . objc_msgSend ( this . id , OS . sel_userInfo ) ;
public nsIProgressDialog_1_8 ( long address ) {
public int Open ( long aParent ) {
public int GetObserver ( long [ ] aObserver ) {
public int SetObserver ( long aObserver ) {
public int GetDialog ( long [ ] aDialog ) {
public int SetDialog ( long aDialog ) {
public NSMutableDictionary ( long id ) {
long result = OS . objc_msgSend ( OS . class_NSMutableDictionary , OS . sel_dictionaryWithObject_forKey_ , object ! = null ? object . id : 0 , key ! = null ? key . id : 0 ) ;
static long XErrorProc , XIOErrorProc , XNullErrorProc , XNullIOErrorProc ;
long libcairo = OS . dlopen ( buffer , flags ) ;
static synchronized Device findDevice ( long xDisplay ) {
long [ ] faces = new long [ 1 ] ;
long context = OS . gdk_pango_context_get ( ) ;
long familyName = OS . pango_font_family_get_name ( family [ 0 ] ) ;
long fontDesc = OS . pango_font_face_describe ( face [ 0 ] ) ;
public abstract long internal_new_GC ( GCData data ) ;
public abstract void internal_dispose_GC ( long hDC , GCData data ) ;
long logProc ( long log_domain , long log_level , long message , long user_data ) {
long colormap = OS . gdk_colormap_get_system ( ) ;
static long XErrorProc ( long xDisplay , long xErrorEvent ) {
static long XIOErrorProc ( long xDisplay ) {
public long hwnd ;
public long source_window ;
public long dest_window ;
public long targets ;
public nsITooltipListener ( long address ) {
public IDispatch ( long address ) {
long pName = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , buffer . length * 2 ) ;
COM . MoveMemory ( ppNames + OS . PTR_SIZEOF * i , new long [ ] { pName } , OS . PTR_SIZEOF ) ;
public int GetTypeInfo ( int iTInfo , int lcid , long [ ] ppTInfo ) {
public int Invoke ( int dispIdMember , GUID riid , int lcid , int dwFlags , DISPPARAMS pDispParams , long pVarResult , EXCEPINFO pExcepInfo , int [ ] pArgErr ) {
public nsIHttpHeaderVisitor ( long address ) {
public int VisitHeader ( long aHeader , long aValue ) {
int result = gdk_pointer_grab ( window , OS . GDK_OWNERSHIP_NONE , false , OS . GDK_POINTER_MOTION_MASK | OS . GDK_BUTTON_RELEASE_MASK , window , cursor , OS . GDK_CURRENT_TIME ) ;
int ptrGrabResult = gdk_pointer_grab ( window , OS . GDK_OWNERSHIP_NONE , false , grabMask , window , gdkCursor , OS . GDK_CURRENT_TIME ) ;
if ( window ! = 0 ) {
window = OS . gdk_get_default_root_window ( ) ;
return OS . gdk_device_grab ( pointer , window , grab_ownership , owner_events , event_mask , cursor , time_ ) ;
return OS . gdk_pointer_grab ( window , owner_events , event_mask , confine_to , cursor , time_ ) ;
OS . gdk_pixmap_get_size ( srcImage . pixmap , w , h ) ;
if ( ! gtk_widget_get_realized ( handle ) ) return ;
if ( ( style & SWT . PUSH ) ! = 0 & & OS . gtk_widget_has_default ( handle ) ) {
pos [ 0 ] = ( int ) OS . g_utf16_offset_to_utf8_offset ( ptr , pos [ 0 ] ) ;
int undo = OS . SendMessage ( handle , OS . EM_CANUNDO , 0 , 0 ) ;
int undo = OS . SendMessage ( handle , OS . EM_CANUNDO , 0 , 0 ) ;
switch ( ( int ) wParam ) {
while ( ( hr = OS . VtblCall ( 4 , pEnum [ 0 ] , 1 , pDispInfo , ( int [ ] ) null ) ) = = OS . S_OK ) {
if ( partialFraction [ 0 ] > = 0.5 ) {
boolean outlineView_shouldExpandItem_item ( int id , int sel , int arg0 , int arg1 ) {
void scrollClipViewToPoint ( int id , int sel , int clipView , NSPoint point ) {
public static final int sel_setShouldScrollClipView_ = sel_registerName ( "str" ) ;
int hwndHeader = OS . SendMessage ( handle , OS . LVM_GETHEADER , 0 , 0 ) ;
int hMenu = parent . handle ;
LRESULT WM_KEYDOWN ( int wParam , int lParam ) {
switch ( ( int ) wParam ) {
int code = callWindowProc ( handle , OS . WM_KEYDOWN , wParam = = OS . VK_RIGHT ? OS . VK_LEFT : OS . VK_RIGHT , lParam ) ;
int code = callWindowProc ( handle , OS . WM_KEYDOWN , wParam = = OS . VK_RIGHT ? OS . VK_LEFT : OS . VK_RIGHT , lParam ) ;
LRESULT WM_KEYDOWN ( int wParam , int lParam ) {
switch ( ( int ) wParam ) {
int code = callWindowProc ( handle , OS . WM_KEYDOWN , wParam = = OS . VK_RIGHT ? OS . VK_LEFT : OS . VK_RIGHT , lParam ) ;
if ( width < = 0 ) width = DEFAULT_SEPARATOR_WIDTH ;
if ( height < = 0 ) height = DEFAULT_SEPARATOR_WIDTH ;
if ( movementListener = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ;
COM . MoveMemory ( ppHyperlink , new int [ ] { accessible . getAddress ( ) } , OS . PTR_SIZEOF ) ;
int imageView = 0 ;
static int MAJOR_VERSION = 3 ;
static int MAJOR_VERSION = 3 ;
return new String ( bytes , 0 , ( int ) length - 1 , CHARSET_UTF8 ) ;
browser . addLocationListener ( new LocationAdapter ( ) {
int lastEventTime , visibleCount = 30 ;
doit = true ;
doit = true ;
doit = true ;
doit = true ;
doit = true ;
int [ ] ppv = new int [ 1 ] ;
parent . drawBackground ( gc , 0 , y , clientArea . width , itemHeight , 0 , 0 ) ;
parent . drawBackground ( gc , cellBounds . x , cellBounds . y , fillWidth , cellBounds . height , 0 , 0 ) ;
drawBackground ( gc , 0 , bottomY , clientArea . width , fillHeight , 0 , 0 ) ;
drawBackground ( gc , rightX , 0 , clientArea . width - rightX , clientArea . height - fillHeight , 0 , 0 ) ;
parent . drawBackground ( gc , 0 , y , clientArea . width , itemHeight , 0 , 0 ) ;
parent . drawBackground ( gc , cellBounds . x , cellBounds . y , fillWidth , cellBounds . height , 0 , 0 ) ;
drawBackground ( gc , 0 , bottomY , clientArea . width , fillHeight , 0 , 0 ) ;
drawBackground ( gc , rightX , 0 , clientArea . width - rightX , clientArea . height - fillHeight , 0 , 0 ) ;
CookieName = name ; CookieUrl = url ; CookieValue = null ;
if ( CookieValue = = null & & MozillaGetCookie ! = null ) MozillaGetCookie . run ( ) ;
if ( text ! = null & & text . length ( ) > offset ) return text . charAt ( ( int ) offset ) ;
Rectangle getBlockSelectionPosition ( ) {
Rectangle rect = getBlockSelectionPosition ( ) ;
Rectangle rect = getBlockSelectionPosition ( ) ;
Rectangle rect = getBlockSelectionPosition ( ) ;
Rectangle rect = getBlockSelectionPosition ( ) ;
Rectangle rect = getBlockSelectionPosition ( ) ;
public int startPage = 1 ;
public int endPage = 1 ;
if ( window ! = 0 ) OS . gdk_window_set_back_pixmap ( window , pixmap , false ) ;
display . lastAscii = ( int ) wParam ;
if ( v2 . vt = = COM . VT_I4 ) osRole = v2 . lVal ;
if ( isSelected ) event . detail | = SWT . SELECTED ;
if ( isSelected ) event . detail | = SWT . SELECTED ;
styledText . setText ( "str" ) ;
styledText . setText ( "str" ) ;
int [ ] ppvObject = new int [ 1 ] ;
byte [ ] contentCharsetBuffer = MozillaDelegate . wcsToMbcs ( null , "str" , false ) ;
byte [ ] contentTypeBuffer = MozillaDelegate . wcsToMbcs ( null , "str" , false ) ;
byte [ ] contentTypeBuffer = MozillaDelegate . wcsToMbcs ( null , "str" , false ) ;
byte [ ] bytes = MozillaDelegate . wcsToMbcs ( null , contentType , false ) ;
int gtk_icon_release ( int widget , int icon_pos , int event ) {
int gtk_icon_release ( int widget , int icon_pos , int event ) {
parent . setItemCount ( this , 0 ) ;
if ( view . window ( ) . firstResponder ( ) . id = = id ) {
if ( view . window ( ) . firstResponder ( ) . id = = id ) {
if ( view . window ( ) . firstResponder ( ) . id = = id ) {
if ( view . window ( ) . firstResponder ( ) . id = = id ) {
if ( view . window ( ) . firstResponder ( ) . id = = id ) {
if ( view . window ( ) . firstResponder ( ) . id = = id ) {
boolean focused = ( view . id = = view . window ( ) . firstResponder ( ) . id ) ;
boolean hasFocus = ( this . control . view . window ( ) . firstResponder ( ) = = control . view ) ;
if ( hasFocus ( ) ) {
if ( hasFocus ( ) ) {
if ( hasFocus ( ) ) {
if ( hasFocus ( ) ) {
if ( hasFocus ( ) ) {
if ( hasFocus ( ) ) {
boolean focused = hasFocus ( ) ;
boolean hasFocus = control . isFocusControl ( ) ;
if ( i = = 132 | | i = = 133 | | i = = 292 | | i = = 318 ) continue ;
OS . free ( pixel ) ;
if ( lineRunCount = = 1 & & ( i = = allRuns . length - 1 | | ! run . softBreak ) ) {
int max = renderer . getHeight ( ) - verticalScrollOffset - clientAreaHeight ;
int max = renderer . getWidth ( ) - horizontalScrollOffset - clientAreaWidth ;
rect . height = getLinePixel ( rect . height + 1 ) - rect . y ;
gc . drawRectangle ( rect . x , rect . y , Math . max ( 1 , rect . width - 1 ) , Math . max ( 1 , rect . height - 1 ) ) ;
if ( ( event . stateMask & SWT . CTRL ) ! = 0 & & event . character < = 31 ) {
window . setFrame ( frame , false ) ;
gc . setBackground ( gc . getDevice ( ) . getSystemColor ( SWT . COLOR_YELLOW ) ) ;
if ( ( style & SWT . CHECK ) = = 0 ) return false ;
redrawWidget ( topView ( ) , true ) ;
int count = ( int ) cookies . count ( ) ;
boolean checkData ( TreeItem item ) {
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( ! parent . checkData ( this ) ) error ( SWT . ERROR_WIDGET_DISPOSED ) ;
if ( nextItemIndex < itemCount & & ch = = "str" & & segmentsText . charAt ( itemLimit ) = = "str" ) {
static boolean COMMAND_LINK = false ;
style = checkBits ( style , SWT . PUSH , SWT . ARROW , SWT . CHECK , SWT . RADIO , SWT . TOGGLE , COMMAND_LINK ? SWT . COMMAND : 0 ) ;
static boolean IMAGE_AND_TEXT = false ;
boolean drawText = IMAGE_AND_TEXT & & text . length ( ) ! = 0 ;
static boolean IS_64 = 0x1FFFFFFFFL = = ( int ) 0x1FFFFFFFFL ;
public static final int gtk_entry_get_inner_border ( int entry ) {
int [ ] borderPtr = new int [ 1 ] ;
style = checkBits ( style , SWT . PUSH , SWT . ARROW , SWT . CHECK , SWT . RADIO , SWT . TOGGLE , 0 ) ;
mozillaProc = OS . GetWindowLongPtr ( hwndChild , OS . GWL_WNDPROC ) ;
OS . SetWindowLongPtr ( hwndChild , OS . GWL_WNDPROC , subclassProc . getAddress ( ) ) ;
OS . SetWindowLongPtr ( hwndChild , OS . GWL_WNDPROC , mozillaProc ) ;
switch ( ( int ) msg ) {
return OS . CallWindowProc ( mozillaProc , hwnd , ( int ) msg , wParam , lParam ) ;
if ( OS . GTK_WIDGET_HAS_FOCUS ( focusHandle ) ) return true ;
pos = ( 100 - percents [ percents . length - 1 ] ) * height / 100 ;
info . hbmpItem = image ! = null ? OS . HBMMENU_CALLBACK : 0 ;
event . detail = position < hPosition ? SWT . PAGE_UP : SWT . PAGE_DOWN ;
strokePattern ( path , pattern ) ;
strokePattern ( path , pattern ) ;
strokePattern ( path , pattern ) ;
strokePattern ( drawPath , pattern ) ;
strokePattern ( path , pattern ) ;
strokePattern ( path , pattern ) ;
strokePattern ( path , pattern ) ;
strokePattern ( path , pattern ) ;
int applierFunc ( int info , int elementPtr ) {
if ( ! ( blockSelection & & blockXLocation ! = - 1 ) ) {
if ( updateCaret & & ! ( blockSelection & & blockXLocation ! = - 1 ) ) {
setSelection ( event . start + event . text . length ( ) , 0 , true , false ) ;
void setSelection ( int start , int length , boolean sendEvent , boolean doBlock ) {
if ( blockSelection & & doBlock ) {
setSelection ( start , length , false , true ) ;
setSelection ( startOffset + newLength , 0 , true , false ) ;
setSelection ( selection . x + newLength - replacedLength , selection . y - selection . x , true , false ) ;
x + = horizontalScrollOffset - leftMargin ;
int bottom = getLinePixel ( lastLine + 1 ) - 1 ;
int rangeEnd = Math . min ( rangeCount - 2 , getRangeIndex ( end , rangeStart - 1 , rangeCount ) ) ;
int rangeEnd = Math . min ( rangeCount - 2 , getRangeIndex ( end , rangeStart - 1 , rangeCount ) ) ;
super . setCursor ( display . getSystemCursor ( SWT . CURSOR_IBEAM ) ) ;
if ( cursor = = null ) {
int createGdipBrush ( Color color , int alpha ) {
int pLogFont = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , LOGFONTW . sizeof ) ;
if ( nsEvent . clickCount ( ) = = 1 & & ( control . state & Widget . DRAG_DETECT ) ! = 0 & & control . hooks ( SWT . DragDetect ) & & control . dragDetect ( ) ) {
return dragDetect ( ) ;
return dragDetect ( ) ;
boolean hasLocation , modified , closed , ignoreMatch ;
int index = ( ( NSOutlineView ) view ) . columnWithIdentifier ( oldSortColumn . nsColumn ) ;
int index = ( ( NSOutlineView ) view ) . columnWithIdentifier ( sortColumn . nsColumn ) ;
int index = ( ( NSOutlineView ) view ) . columnWithIdentifier ( sortColumn . nsColumn ) ;
int index = ( ( NSOutlineView ) parent . view ) . columnWithIdentifier ( nsColumn ) ;
int index = ( ( NSOutlineView ) parent . view ) . columnWithIdentifier ( nsColumn ) ;
int index = ( ( NSTableView ) view ) . columnWithIdentifier ( oldSortColumn . nsColumn ) ;
int index = ( ( NSTableView ) view ) . columnWithIdentifier ( sortColumn . nsColumn ) ;
int index = ( ( NSTableView ) view ) . columnWithIdentifier ( sortColumn . nsColumn ) ;
int index = ( ( NSTableView ) parent . view ) . columnWithIdentifier ( nsColumn ) ;
int index = ( ( NSTableView ) parent . view ) . columnWithIdentifier ( nsColumn ) ;
public class NSSecureTextField extends NSTextField {
int size = C . PTR_SIZEOF , align = C . PTR_SIZEOF = = 4 ? 2 : 3 ;
int size = C . PTR_SIZEOF , align = C . PTR_SIZEOF = = 4 ? 2 : 3 ;
public NSRect rectOfColumn ( int column ) {
OS . objc_msgSend_stret ( result , this . id , OS . sel_rectOfColumn_ , column ) ;
public NSRect rectOfRow ( int row ) {
OS . objc_msgSend_stret ( result , this . id , OS . sel_rectOfRow_ , row ) ;
int index = ( int ) headerView . columnAtPoint ( location ) ;
int index = ( int ) headerView . columnAtPoint ( location ) ;
super ( "str" ) ;
LRESULT WM_MOUSELEAVE ( int wParam , int lParam ) {
LRESULT WM_ERASEBKGND ( int wParam , int lParam ) {
int hwnd = isVista ? hwndOpaque : hwndTransparent ;
for ( int gap = count / 2 ; gap > 0 ; gap / = 2 ) {
( ( NSOutlineView ) view ) . reloadItem_reloadChildren_ ( parentItem ! = null ? parentItem . handle : null , true ) ;
return ( x > = this . x ) & & ( y > = this . y ) & & x < ( this . x + width ) & & y < ( this . y + height ) ;
( ( NSText ) view ) . copy ( view ) ;
System . arraycopy ( children , 0 , newItems , 0 , Math . min ( count , itemCount ) ) ;
url = PROTOCOL_FILE + url . replace ( "str" , "str" ) ;
url = PROTOCOL_FILE + url . replace ( "str" , "str" ) ;
state & = ~ ( RESIZE_OCCURRED | MOVE_OCCURRED ) ;
assertTrue ( style = = SWT . APPLICATION_MODAL ) ;
this ( parent , SWT . APPLICATION_MODAL ) ;
this ( parent , SWT . APPLICATION_MODAL ) ;
this ( parent , SWT . APPLICATION_MODAL ) ;
this ( parent , SWT . APPLICATION_MODAL ) ;
this ( parent , SWT . APPLICATION_MODAL ) ;
this ( parent , SWT . APPLICATION_MODAL ) ;
this ( parent , SWT . APPLICATION_MODAL ) ;
this ( parent , SWT . APPLICATION_MODAL ) ;
this ( parent , SWT . APPLICATION_MODAL ) ;
this ( parent , SWT . APPLICATION_MODAL ) ;
this ( parent , SWT . APPLICATION_MODAL ) ;
this ( parent , SWT . APPLICATION_MODAL ) ;
this ( parent , SWT . APPLICATION_MODAL ) ;
this ( parent , SWT . APPLICATION_MODAL ) ;
this ( parent , SWT . APPLICATION_MODAL ) ;
this ( parent , SWT . APPLICATION_MODAL ) ;
if ( code > = 0 & & ( wParam & OS . PM_REMOVE ) ! = 0 ) {
if ( code < 0 | | ( wParam & OS . PM_REMOVE ) = = 0 ) {
int gdipGraphics = data . gdipGraphics ;
int rgn = Gdip . Region_new ( ) ;
measureEvent = sendMeasureItemEvent ( item , ( int ) nmcd . dwItemSpec , nmcd . iSubItem , nmcd . hdc ) ;
measureEvent = sendMeasureItemEvent ( item , index , hDC ) ;
sendMeasureItemEvent ( item , ( int ) nmcd . dwItemSpec , nmcd . iSubItem , nmcd . hdc ) ;
if ( glyphs [ i ] = = fp . wgDefault ) break ;
code . append ( "str" ) ;
code . append ( "str" ) ;
code . append ( "str" ) ;
int emissionProc ( int ihint , int n_param_values , int param_values , int data ) {
final int hFont = OS . GetCurrentObject ( hdc , OS . OBJ_FONT ) ;
int newFont = OS . CreateFontIndirect ( cachedLogFont ) ;
int newFont = OS . CreateFontIndirect ( newLogFont ) ;
int address = callback . getAddress ( ) ;
int pszText = OS . HeapAlloc ( hHeap , OS . HEAP_ZERO_MEMORY , byteCount ) ;
TCHITTESTINFO pinfo = new TCHITTESTINFO ( ) ;
int index = ( int ) OS . SendMessage ( handle , OS . TCM_HITTEST , 0 , pinfo ) ;
return items [ index ] ;
int bits1 = OS . GetWindowLong ( hwnd , OS . GWL_STYLE ) ;
OS . ReleaseDC ( hwnd , hDC ) ;
public static GC cocoa_new ( Drawable drawable , GCData data ) {
GC gc = GC . cocoa_new ( this , data ) ;
transform . translateXBy ( 0 , - ( ( 2 * y ) + textStorage . size ( ) . height ) ) ;
int state = 0 ;
int scrolledHandle = scrolledHandle ( ) ;
int hwndScroll = shell . scrolledHandle ( ) ;
if ( children . length > 0 & & currentLayer ! = - 1 ) {
setTopControl ( currentLayer ) ;
void checkOpened ( ) {
int peaks = Compatibility . ceil ( right - left , width ) ;
coordinates [ length - 2 ] = left + ( width * peaks ) ;
if ( ( state & CANVAS ) ! = 0 ) {
super ( parent , style = checkStyle ( style ) ) ;
if ( ( state & CANVAS ) ! = 0 ) takeFocus = hooksKeys ( ) ;
if ( ( state & CANVAS ) ! = 0 ) {
if ( ( state & CANVAS ) ! = 0 ) takeFocus = hooksKeys ( ) ;
if ( ( state & CANVAS ) ! = 0 ) {
code . append ( "str" ) ;
if ( ! OS . CGPathIsEmpty ( handle ) ) OS . CGPathGetCurrentPoint ( handle , pt ) ;
if ( ! OS . CGPathIsEmpty ( handle ) ) OS . CGPathGetCurrentPoint ( handle , pt ) ;
if ( ! OS . CGPathIsEmpty ( handle ) ) OS . CGPathGetCurrentPoint ( handle , pt ) ;
if ( ! OS . CGPathIsEmpty ( handle ) ) OS . CGPathGetCurrentPoint ( handle , pt ) ;
if ( ! OS . IsWinCE & & OS . WIN32_VERSION > = OS . VERSION ( 6 , 0 ) ) {
int gtk_button_press_event ( int widget , int event ) {
int gtk_event_after ( int widget , int gdkEvent ) {
if ( rect . y > area . y + area . height ) break ;
RECT textRect = item . getBounds ( index , true , false , false , false , true , hDC ) ;
int result = 0 ;
int code = callWindowProc ( handle , OS . WM_NOTIFY , wParam , lParam ) ;
int result = OS . CallWindowProc ( ComboProc , hwnd , msg , wParam , lParam ) ;
return count = = 0 & & scrollWidth = = 0 ? handle : hwndParent ;
if ( page < = endPage & & paintY > clientArea . y ) {
public static GC gtk_new ( int handle , GCData data ) {
if ( columnIndex ! = columnCount | | columnCount = = 0 ) {
int [ ] real_drawable = new int [ 1 ] , x_offset = new int [ 1 ] , y_offset = new int [ 1 ] ;
int [ ] data = new int [ 1 ] ;
void printWidget ( int gc , int drawable , int depth , int x , int y ) {
void printWindow ( Control control , int gc , int drawable , int depth , int window , int x , int y ) {
if ( index + 1 > = line . length | | ! style . isAdherentBorder ( line [ index + 1 ] . style ) ) {
for ( int i = index ; i > 0 & & style . isAdherentBorder ( line [ i - 1 ] . style ) ; i - - ) {
int newPen = OS . ExtCreatePen ( lineStyle | OS . PS_GEOMETRIC , Math . max ( 1 , lineWidth ) , logBrush , 0 , null ) ;
int findPopupHandle ( int oldList ) {
int oldList = OS . gtk_window_list_toplevels ( ) ;
return new BufferedInputStream ( new InflaterInputStream ( stream ) ) ;
} catch ( Throwable ex ) { }
int lineHeight = lineY [ line + 1 ] - lineY [ line ] - lineSpacing ;
width = lineHeight / 3 ;
Gdip . Graphics_FillRectangle ( gdipGraphics , selBrush , drawX + lineWidth [ line ] , drawY , width , lineHeight ) ;
OS . PatBlt ( hdc , drawX + lineWidth [ line ] , drawY , width , lineHeight , OS . PATCOPY ) ;
Gdip . Graphics_FillRectangle ( gdipGraphics , selBrush , drawX , drawY , run . width , lineHeight ) ;
OS . PatBlt ( hdc , drawX , drawY , run . width , lineHeight , OS . PATCOPY ) ;
Gdip . Graphics_FillRectangle ( gdipGraphics , brush , drawX , drawY , run . width , lineHeight ) ;
OS . PatBlt ( hdc , drawX , drawY , run . width , lineHeight , OS . PATCOPY ) ;
rect . bottom = drawY + lineHeight ;
borderClip = drawBorder ( gdip , gdipGraphics , x , drawY , lineHeight , foregroundBrush , selBrushFg , fullSelection , borderClip , partialSelection ? rect : null , alpha , lineRuns , i , selectionStart , selectionEnd ) ;
borderClip = drawBorder ( gdip , hdc , x , drawY , lineHeight , foreground , selForeground , fullSelection , borderClip , partialSelection ? rect : null , alpha , lineRuns , i , selectionStart , selectionEnd ) ;
if ( childID > = 0 & & childID < items . length & & items [ childID ] . isShowing ( ) ) {
int result = ime . gtk_button_press_event ( widget , event ) ;
int result = ime . gtk_commit ( imcontext , text ) ;
int result = ime . gtk_preedit_changed ( imcontext ) ;
int code = callWindowProc ( handle , OS . WM_WINDOWPOSCHANGED , wParam , lParam ) ;
if ( ( style & ( SWT . PUSH | SWT . TOGGLE ) ) = = 0 ) {
int hDC = gc . handle ;
int hwndParent = OS . GetParent ( handle ) ;
int hwndShell = getShell ( ) . handle ;
int width = clientAreaWidth - leftMargin - rightMargin - getCaretWidth ( ) ;
Point pt = getParent ( ) . toDisplay ( location . x , location . y ) ;
public static final native int MAKEWORD ( int l , int h ) ;
int param = OS . MAKEWPARAM ( OS . MAKEWORD ( OS . IMEMOUSE_LDOWN , trailing ) , offset ) ;
int code = OS . CallWindowProc ( EditProc , hwnd , msg , wParam , lParam ) ;
int hIMC = OS . ImmGetContext ( handle ) ;
int hIMC = OS . ImmGetContext ( handle ) ;
int imeWnd = OS . ImmGetDefaultIMEWnd ( handle ) ;
static final String DOCKPANEL_PART_NAME = "str" ;
int dockPanelName = createDotNetString ( DOCKPANEL_PART_NAME , false ) ;
int cellContentNode = OS . gcnew_FrameworkElementFactory ( dockPanelType , dockPanelName ) ;
OS . GCHandle_Free ( dockPanelName ) ;
int stackPanelName = createDotNetString ( DOCKPANEL_PART_NAME , false ) ;
int panel = findPart ( index , Table . DOCKPANEL_PART_NAME ) ;
public int method11 ( int [ ] args ) { return SetFilterIndex ( ( int ) args [ 0 ] ) ; }
FilePickerFactory ( ) {
public int method4 ( int [ ] args ) { return LockFactory ( ( int ) args [ 0 ] ) ; }
int QueryInterface ( int riid , int ppvObject ) {
int CreateInstance ( int aOuter , int iid , int result ) {
int LockFactory ( int lock ) {
HelperAppLauncherDialog ( ) {
public int method3 ( int [ ] args ) { return Show ( args [ 0 ] , args [ 1 ] , ( int ) args [ 2 ] ) ; }
int QueryInterface ( int riid , int ppvObject ) {
int Show ( int aLauncher , int aContext , int aReason ) {
int PromptForSaveToFile ( int arg0 , int arg1 , int arg2 , int arg3 , int arg4 ) {
WindowCreator2 ( ) {
public int method3 ( int [ ] args ) { return CreateChromeWindow ( args [ 0 ] , ( int ) args [ 1 ] , args [ 2 ] ) ; }
int QueryInterface ( int riid , int ppvObject ) {
int CreateChromeWindow ( int parent , int chromeFlags , int _retval ) {
int CreateChromeWindow2 ( int parent , int chromeFlags , int contextFlags , int uri , int cancel , int _retval ) {
webBrowserChrome . SetChromeFlags ( chromeFlags ) ;
Download_1_8 ( ) {
public int method22 ( int [ ] args ) { return SetCancelDownloadOnClose ( ( int ) args [ 0 ] ) ; }
int QueryInterface ( int riid , int ppvObject ) {
int Init_32 ( int aSource , int aTarget , int aDisplayName , int aMIMEInfo , int startTime1 , int startTime2 , int aTempFile , int aCancelable ) {
int Init ( int aSource , int aTarget , int aDisplayName , int aMIMEInfo , long startTime , int aTempFile , int aCancelable ) {
int GetAmountTransferred ( int arg0 ) {
int GetCancelable ( int arg0 ) {
int GetDisplayName ( int aDisplayName ) {
int GetMIMEInfo ( int aMIMEInfo ) {
int GetPercentComplete ( int aPercentComplete ) {
int GetSize ( int arg0 ) {
int GetSource ( int aSource ) {
int GetStartTime ( int aStartTime ) {
int GetTarget ( int aTarget ) {
int GetTargetFile ( int arg0 ) {
int GetCancelDownloadOnClose ( int aCancelDownloadOnClose ) {
int GetDialog ( int aDialog ) {
int GetObserver ( int aObserver ) {
int Open ( int aParent ) {
int SetCancelDownloadOnClose ( int aCancelDownloadOnClose ) {
int SetDialog ( int aDialog ) {
int SetObserver ( int aObserver ) {
int OnLocationChange ( int aWebProgress , int aRequest , int aLocation ) {
int OnProgressChange ( int aWebProgress , int aRequest , int aCurSelfProgress , int aMaxSelfProgress , int aCurTotalProgress , int aMaxTotalProgress ) {
int OnProgressChange64_32 ( int aWebProgress , int aRequest , int aCurSelfProgress1 , int aCurSelfProgress2 , int aMaxSelfProgress1 , int aMaxSelfProgress2 , int aCurTotalProgress1 , int aCurTotalProgress2 , int aMaxTotalProgress1 , int aMaxTotalProgress2 ) {
int OnProgressChange64 ( int aWebProgress , int aRequest , long aCurSelfProgress , long aMaxSelfProgress , long aCurTotalProgress , long aMaxTotalProgress ) {
int OnSecurityChange ( int aWebProgress , int aRequest , int state ) {
int OnStateChange ( int aWebProgress , int aRequest , int aStateFlags , int aStatus ) {
int OnStatusChange ( int aWebProgress , int aRequest , int aStatus , int aMessage ) {
InputStream ( byte [ ] buffer ) {
int QueryInterface ( int riid , int ppvObject ) {
int Close ( ) {
int Available ( int _retval ) {
int IsNonBlocking ( int _retval ) {
SimpleEnumerator ( nsISupports [ ] values ) {
public int method0 ( int [ ] args ) { return QueryInterface ( args [ 0 ] , args [ 1 ] ) ; }
public int method0 ( int [ ] args ) { return QueryInterface ( args [ 0 ] , args [ 1 ] ) ; }
int QueryInterface ( int riid , int ppvObject ) {
DownloadFactory_1_8 ( ) {
public int method4 ( int [ ] args ) { return LockFactory ( ( int ) args [ 0 ] ) ; }
int QueryInterface ( int riid , int ppvObject ) {
int CreateInstance ( int aOuter , int iid , int result ) {
int LockFactory ( int lock ) {
AppFileLocProvider ( String path ) {
public int method0 ( int [ ] args ) { return QueryInterface ( args [ 0 ] , args [ 1 ] ) ; }
public int method0 ( int [ ] args ) { return QueryInterface ( args [ 0 ] , args [ 1 ] ) ; }
public int method0 ( int [ ] args ) { return QueryInterface ( args [ 0 ] , args [ 1 ] ) ; }
int QueryInterface ( int riid , int ppvObject ) {
Download ( ) {
public int method18 ( int [ ] args ) { return SetCancelDownloadOnClose ( ( int ) args [ 0 ] ) ; }
int QueryInterface ( int riid , int ppvObject ) {
int Init ( int aSource , int aTarget , int aDisplayName , int aMIMEInfo , int startTime1 , int startTime2 , int aPersist ) {
int GetSource ( int aSource ) {
int GetTarget ( int aTarget ) {
int GetPersist ( int aPersist ) {
int GetPercentComplete ( int aPercentComplete ) {
int GetDisplayName ( int aDisplayName ) {
int SetDisplayName ( int aDisplayName ) {
int GetStartTime ( int aStartTime ) {
int GetMIMEInfo ( int aMIMEInfo ) {
int GetListener ( int aListener ) {
int SetListener ( int aListener ) {
int GetObserver ( int aObserver ) {
int SetObserver ( int aObserver ) {
int Open ( int aParent ) {
int GetCancelDownloadOnClose ( int aCancelDownloadOnClose ) {
int SetCancelDownloadOnClose ( int aCancelDownloadOnClose ) {
int GetDialog ( int aDialog ) {
int SetDialog ( int aDialog ) {
int OnStateChange ( int aWebProgress , int aRequest , int aStateFlags , int aStatus ) {
int OnLocationChange ( int aWebProgress , int aRequest , int aLocation ) {
int OnStatusChange ( int aWebProgress , int aRequest , int aStatus , int aMessage ) {
int OnSecurityChange ( int aWebProgress , int aRequest , int state ) {
DownloadFactory ( ) {
public int method4 ( int [ ] args ) { return LockFactory ( ( int ) args [ 0 ] ) ; }
int QueryInterface ( int riid , int ppvObject ) {
int CreateInstance ( int aOuter , int iid , int result ) {
int LockFactory ( int lock ) {
PromptDialog ( Shell parent , int style ) {
PromptDialog ( Shell parent ) {
void alertCheck ( String title , String text , String check , final int [ ] checkValue ) {
void confirmEx ( String title , String text , String check , String button0 , String button1 , String button2 , int defaultIndex , final int [ ] checkValue , final int [ ] result ) {
void prompt ( String title , String text , String check , final String [ ] value , final int [ ] checkValue , final int [ ] result ) {
void promptUsernameAndPassword ( String title , String text , String check , final String [ ] user , final String [ ] pass , final int [ ] checkValue , final int [ ] result ) {
PromptService ( ) {
public int method7 ( int [ ] args ) { return ConfirmEx ( args [ 0 ] , args [ 1 ] , args [ 2 ] , ( int ) args [ 3 ] , args [ 4 ] , args [ 5 ] , args [ 6 ] , args [ 7 ] , args [ 8 ] , args [ 9 ] ) ; }
public int method11 ( int [ ] args ) { return Select ( args [ 0 ] , args [ 1 ] , args [ 2 ] , ( int ) args [ 3 ] , args [ 4 ] , args [ 5 ] , args [ 6 ] ) ; }
int QueryInterface ( int riid , int ppvObject ) {
int Alert ( int aParent , int aDialogTitle , int aText ) {
int AlertCheck ( int aParent , int aDialogTitle , int aText , int aCheckMsg , int aCheckState ) {
int Confirm ( int aParent , int aDialogTitle , int aText , int _retval ) {
int ConfirmCheck ( int aParent , int aDialogTitle , int aText , int aCheckMsg , int aCheckState , int _retval ) {
int ConfirmEx ( int aParent , int aDialogTitle , int aText , int aButtonFlags , int aButton0Title , int aButton1Title , int aButton2Title , int aCheckMsg , int aCheckState , int _retval ) {
int Prompt ( int aParent , int aDialogTitle , int aText , int aValue , int aCheckMsg , int aCheckState , int _retval ) {
int PromptUsernameAndPassword ( int aParent , int aDialogTitle , int aText , int aUsername , int aPassword , int aCheckMsg , int aCheckState , int _retval ) {
int PromptPassword ( int aParent , int aDialogTitle , int aText , int aPassword , int aCheckMsg , int aCheckState , int _retval ) {
int Select ( int aParent , int aDialogTitle , int aText , int aCount , int aSelectList , int aOutSelection , int _retval ) {
public int method3 ( int [ ] args ) { return SetStatus ( ( int ) args [ 0 ] , args [ 1 ] ) ; }
public int method7 ( int [ ] args ) { return SetChromeFlags ( ( int ) args [ 0 ] ) ; }
public int method9 ( int [ ] args ) { return SizeBrowserTo ( ( int ) args [ 0 ] , ( int ) args [ 1 ] ) ; }
public int method12 ( int [ ] args ) { return ExitModalEventLoop ( ( int ) args [ 0 ] ) ; }
public int method3 ( int [ ] args ) { return SetDimensions ( ( int ) args [ 0 ] , ( int ) args [ 1 ] , ( int ) args [ 2 ] , ( int ) args [ 3 ] , ( int ) args [ 4 ] ) ; }
public int method7 ( int [ ] args ) { return SetVisibility ( ( int ) args [ 0 ] ) ; }
public int method3 ( int [ ] args ) { return OnShowContextMenu ( ( int ) args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; }
public int method4 ( int [ ] args ) { return DoContent ( args [ 0 ] , ( int ) args [ 1 ] , args [ 2 ] , args [ 3 ] , args [ 4 ] ) ; }
public int method6 ( int [ ] args ) { return CanHandleContent ( args [ 0 ] , ( int ) args [ 1 ] , args [ 2 ] , args [ 3 ] ) ; }
public int method3 ( int [ ] args ) { return OnShowTooltip ( ( int ) args [ 0 ] , ( int ) args [ 1 ] , args [ 2 ] ) ; }
int QueryInterface ( int riid , int ppvObject ) {
int AddRef ( ) {
int Release ( ) {
int QueryReferent ( int riid , int ppvObject ) {
int GetInterface ( int riid , int ppvObject ) {
int GetWeakReference ( int ppvObject ) {
int OnStateChange ( int aWebProgress , int aRequest , int aStateFlags , int aStatus ) {
int OnProgressChange ( int aWebProgress , int aRequest , int aCurSelfProgress , int aMaxSelfProgress , int aCurTotalProgress , int aMaxTotalProgress ) {
int OnLocationChange ( int aWebProgress , int aRequest , int aLocation ) {
int OnStatusChange ( int aWebProgress , int aRequest , int aStatus , int aMessage ) {
int OnSecurityChange ( int aWebProgress , int aRequest , int state ) {
int SetStatus ( int statusType , int status ) {
int GetWebBrowser ( int aWebBrowser ) {
int SetWebBrowser ( int aWebBrowser ) {
int GetChromeFlags ( int aChromeFlags ) {
int DestroyBrowserWindow ( ) {
int ShowAsModal ( ) {
int IsWindowModal ( int retval ) {
int ExitModalEventLoop ( int aStatus ) {
int GetDimensions ( int flags , int x , int y , int cx , int cy ) {
int SetFocus ( ) {
int GetVisibility ( int aVisibility ) {
int SetVisibility ( int aVisibility ) {
int GetTitle ( int aTitle ) {
int SetTitle ( int aTitle ) {
int GetSiteWindow ( int aSiteWindow ) {
int FocusNextElement ( ) {
int FocusPrevElement ( ) {
int OnShowContextMenu ( int aContextFlags , int aEvent , int aNode ) {
int OnStartURIOpen ( int aURI , int retval ) {
int DoContent ( int aContentType , int aIsContentPreferred , int aRequest , int aContentHandler , int retval ) {
int IsPreferred ( int aContentType , int aDesiredContentType , int retval ) {
int CanHandleContent ( int aContentType , int aIsContentPreferred , int aDesiredContentType , int retval ) {
int GetLoadCookie ( int aLoadCookie ) {
int SetLoadCookie ( int aLoadCookie ) {
int GetParentContentListener ( int aParentContentListener ) {
int SetParentContentListener ( int aParentContentListener ) {
int OnShowTooltip ( int aXCoords , int aYCoords , int aTipText ) {
int OnHideTooltip ( ) {
int HandleEvent ( int event ) {
HelperAppLauncherDialogFactory ( ) {
public int method4 ( int [ ] args ) { return LockFactory ( ( int ) args [ 0 ] ) ; }
int QueryInterface ( int riid , int ppvObject ) {
int CreateInstance ( int aOuter , int iid , int result ) {
int LockFactory ( int lock ) {
public int method4 ( int [ ] args ) { return LockFactory ( ( int ) args [ 0 ] ) ; }
int CreateInstance ( int aOuter , int iid , int result ) {
FilePicker ( ) {
public int method11 ( int [ ] args ) { return SetFilterIndex ( ( int ) args [ 0 ] ) ; }
int QueryInterface ( int riid , int ppvObject ) {
int Init ( int parent , int title , short mode ) {
this . mode = mode ;
int Show ( int _retval ) {
int GetFiles ( int aFiles ) {
int GetFileURL ( int aFileURL ) {
int GetFile ( int aFile ) {
int SetDisplayDirectory ( int aDisplayDirectory ) {
int GetDisplayDirectory ( int aDisplayDirectory ) {
int SetFilterIndex ( int aFilterIndex ) {
int GetFilterIndex ( int aFilterIndex ) {
int SetDefaultExtension ( int aDefaultExtension ) {
int GetDefaultExtension ( int aDefaultExtension ) {
int SetDefaultString ( int aDefaultString ) {
int GetDefaultString ( int aDefaultString ) {
int AppendFilter ( int title , int filter ) {
int AppendFilters ( int filterMask ) {
switch ( filterMask ) {
PromptServiceFactory ( ) {
public int method4 ( int [ ] args ) { return LockFactory ( ( int ) args [ 0 ] ) ; }
int QueryInterface ( int riid , int ppvObject ) {
int CreateInstance ( int aOuter , int iid , int result ) {
int LockFactory ( int lock ) {
if ( ( int ) OS . SendMessage ( handle , OS . LVM_GETBKCOLOR , 0 , 0 ) = = OS . CLR_NONE ) {
if ( ( int ) OS . SendMessage ( handle , OS . LVM_GETBKCOLOR , 0 , 0 ) = = OS . CLR_NONE ) {
if ( ( int ) OS . SendMessage ( handle , OS . LVM_GETBKCOLOR , 0 , 0 ) = = OS . CLR_NONE ) {
if ( ( int ) OS . SendMessage ( handle , OS . LVM_GETBKCOLOR , 0 , 0 ) = = OS . CLR_NONE ) {
if ( ( int ) OS . SendMessage ( handle , OS . LVM_GETBKCOLOR , 0 , 0 ) = = OS . CLR_NONE ) {
if ( ( int ) OS . SendMessage ( handle , OS . LVM_GETBKCOLOR , 0 , 0 ) ! = OS . CLR_NONE ) {
if ( ( int ) OS . SendMessage ( handle , OS . LVM_GETBKCOLOR , 0 , 0 ) ! = OS . CLR_NONE ) {
if ( ( int ) OS . SendMessage ( handle , OS . LVM_GETBKCOLOR , 0 , 0 ) ! = OS . CLR_NONE ) {
if ( ( int ) OS . SendMessage ( hwnd , OS . LVM_GETBKCOLOR , 0 , 0 ) ! = OS . CLR_NONE ) {
itemRect . right + = EXPLORER_EXTRA + 1 ;
int flags = OS . DT_CALCRECT | OS . DT_NOPREFIX ;
gc . drawImage ( image , 0 , 0 , bounds . width , bounds . height , rect . left - inset + 1 , y , size . x , size . y ) ;
if ( ! OS . IsWinCE & & OS . WIN32_VERSION > = OS . VERSION ( 6 , 0 ) ) upDownHeight + = 7 ;
int enterExitHandle ( ) {
public void draw ( GC gc , int x , int y , int selectionStart , int selectionEnd , Color selectionForeground , Color selectionBackground , int flags ) {
public void draw ( GC gc , int x , int y , int selectionStart , int selectionEnd , Color selectionForeground , Color selectionBackground , int flags ) {
public void draw ( GC gc , int x , int y , int selectionStart , int selectionEnd , Color selectionForeground , Color selectionBackground , int flags ) {
if ( hasSelection | | ( flags & SWT . LAST_LINE_SELECTION ) ! = 0 ) {
if ( flags ! = 0 & & ( hasSelection | | ( flags & SWT . LAST_LINE_SELECTION ) ! = 0 ) ) {
if ( i = = lines . length - 1 & & ( flags & SWT . LAST_LINE_SELECTION ) ! = 0 ) {
if ( selectionStart < = lineEnd & & lineEnd < selectionEnd & & ( flags & SWT . FULL_SELECTION ) ! = 0 ) {
int extentWidth = ( flags & SWT . FULL_SELECTION ) ! = 0 ? 0x7ffffff : lineHeight / 3 ;
excelButton . setText ( "str" ) ;
System . out . println ( "str" + e . getMessage ( ) ) ;
System . out . println ( "str" + e . getMessage ( ) ) ;
System . out . println ( "str" + e . getMessage ( ) ) ;
System . out . println ( "str" + e . getMessage ( ) ) ;
System . out . println ( "str" + e . getMessage ( ) ) ;
System . out . println ( "str" + e . getMessage ( ) ) ;
System . out . println ( "str" + e . getMessage ( ) ) ;
System . out . println ( "str" + e . getMessage ( ) ) ;
System . out . println ( "str" + e . getMessage ( ) ) ;
if ( simple | | "str" . equals ( SWT . getPlatform ( ) ) | | "str" . equals ( SWT . getPlatform ( ) ) ) return ;
if ( IsXULRunner ) unhookDOMListeners ( ) ;
if ( enabled = = getEnabled ( ) ) return ;
int inset = 4 ;
colors [ SWT . COLOR_WIDGET_HIGHLIGHT_SHADOW ] = Color . wpf_new ( this , OS . SystemColors_ControlLightLightColor ( ) ) ;
inputs . mouseData = event . count * OS . WHEEL_DELTA / value [ 0 ] ;
OS . memcpy ( chars , charArray , chars . length * 2 ) ;
OS . memcpy ( buffer , chars , buffer . length * 2 ) ;
OS . memcpy ( chars , charArray , chars . length * 2 ) ;
OS . memcpy ( chars , charArray , chars . length * 2 ) ;
OS . memcpy ( chars , charArray , chars . length * 2 ) ;
OS . memcpy ( chars , charArray , chars . length * 2 ) ;
OS . memcpy ( chars , charArray , chars . length * 2 ) ;
OS . kEventClassClockView , OS . kEventClockDateOrTimeChanged ,
shell . setSize ( shell . computeSize ( size . x , size . y ) ) ;
static final int DRAG_DETECT = 1 < < 14 ;
return ( int ) ( adjustment . step_increment + 0.5 ) ;
return ( int ) ( adjustment . upper + 0.5 ) ;
return ( int ) ( adjustment . lower + 0.5 ) ;
return ( int ) ( adjustment . page_increment + 0.5 ) ;
return ( int ) ( adjustment . value + 0.5 ) ;
int dragStartX , dragStartY ;
if ( ! OS . IsWinCE & & OS . WIN32_VERSION > = OS . VERSION ( 5 , 1 ) ) lpWndClass . style | = OS . CS_DROPSHADOW ;
OS . GetClassInfo ( hInstance , windowClass , lpWndClass ) ;
OS . GetClassInfo ( hInstance , windowShadowClass , lpWndClass ) ;
int bits = ( start & 0xFFFF ) | ( ( end < < 16 ) & 0xFFFF0000 ) ;
int bits = ( start [ 0 ] & 0xFFFF ) | ( ( end [ 0 ] < < 16 ) & 0xFFFF0000 ) ;
int pt = ( x & 0xFFFF ) | ( ( y < < 16 ) & 0xFFFF0000 ) ;
int lParam = ( ( dropDown ? rect . right - 1 : rect . left ) & 0xFFFF ) | ( ( y < < 16 ) & 0xFFFF0000 ) ;
int lParam = ( nX & 0xFFFF ) | ( ( nY < < 16 ) & 0xFFFF0000 ) ;
lParam = ( pt . x & 0xFFFF ) | ( ( pt . y < < 16 ) & 0xFFFF0000 ) ;
import org . eclipse . swt . internal . cocoa . * ;
int deltaTime = Math . abs ( lastTime - getLastEventTime ( ) ) ;
lastTime = getLastEventTime ( ) ;
OS . SetRectRgn ( region . handle , rect . X , rect . Y , rect . X + rect . Width , rect . Y + rect . Height ) ;
if ( iconName = = null ) iconName = "str" ;
int str = OS . gtk_combo_box_get_active_text ( handle ) ;
length = ( int ) OS . g_utf8_strlen ( str , - 1 ) ;
OS . gtk_widget_realize ( entryHandle ) ;
data . right = new FormAttachment ( paste , - 5 ) ;
identifiers = OS . CFArrayCreateMutable ( OS . kCFAllocatorDefault , 0 , 0 ) ;
width = width - ( rightSize . x - banner . curve_indent + banner . curve_width - banner . curve_indent ) ;
x + = leftSize . x - banner . curve_indent + banner . curve_width - banner . curve_indent ;
byte [ ] [ ] data = new byte [ 0 ] [ ] ;
if ( styledText ! = null & & styledText . isFixedLineHeight ( ) ) {
int redrawY = y + Math . max ( 0 , clientArea . height - startY ) ;
if ( count ! = 0 & & ! printClient ) {
OS . gtk_tree_view_column_add_attribute ( columnHandle , textRenderer , OS . cell_background_gdk , BACKGROUND_COLUMN ) ;
OS . gtk_tree_view_column_add_attribute ( columnHandle , textRenderer , OS . cell_background_gdk , BACKGROUND_COLUMN ) ;
RECT clipRect = item . getBounds ( nmcd . dwItemSpec , nmcd . iSubItem , true , false , fullText , false , hDC ) ;
if ( OS . IsWinCE | | OS . WIN32_VERSION < OS . VERSION ( 4 , 10 ) ) {
if ( OS . IsWinCE | | OS . WIN32_VERSION < OS . VERSION ( 4 , 10 ) ) {
if ( findImageControl ( ) ! = null ) return ;
int [ ] pixmaps = new int [ count ] ;
int [ ] pixmaps = new int [ count ] ;
colorAndFontTable . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , true , true , 2 , 1 ) ) ;
qk [ i ] = reference [ ofs + i + 1 ] & 0xFF ;
while ( true ) {
while ( true ) {
int rendererRenderProc ( int cell , int window , int handle , int background_area , int cell_area , int expose_area , int flags ) {
int rendererRenderProc ( int cell , int window , int widget , int background_area , int cell_area , int expose_area , int flags ) {
static int rendererRenderProc ( int cell , int window , int handle , int background_area , int cell_area , int expose_area , int flags ) {
int rendererRenderProc ( int cell , int window , int widget , int background_area , int cell_area , int expose_area , int flags ) {
if ( fullText | | fullImage ) {
int context = OS . gtk_drag_begin ( control . handle , targetList , actions , 1 , 0 ) ;
int keyOperation = - 1 ;
static final String DROPTARGETID = "str" ;
effect = new TreeDragAndDropEffect ( ( Tree ) control ) ;
effect = new TableDragAndDropEffect ( ( Table ) control ) ;
effect = new NoDragAndDropEffect ( control ) ;
return COM . S_FALSE ;
effect . showDropTargetEffect ( event . feedback , event . x , event . y ) ;
effect . showDropTargetEffect ( DND . FEEDBACK_NONE , 0 , 0 ) ;
if ( iDataObject = = null ) return COM . S_FALSE ;
if ( iDataObject = = null ) return COM . S_FALSE ;
return COM . S_FALSE ;
effect . showDropTargetEffect ( event . feedback , event . x , event . y ) ;
effect . showDropTargetEffect ( DND . FEEDBACK_NONE , 0 , 0 ) ;
return COM . S_FALSE ;
int result = OS . call ( klass . get_size , cell , handle , cell_area , x_offset , y_offset , width , height ) ;
int adjustmentHandle = OS . gtk_scrolled_window_get_vadjustment ( scrolledHandle ) ;
int result = OS . call ( klass . get_size , cell , handle , cell_area , x_offset , y_offset , width , height ) ;
void setBackgroundPixmap ( int pixmap ) {
gc . fillRectangle ( ( int ) ( rect . x + pt . x ) , ( int ) ( rect . y + pt . y ) , ( int ) rect . width , ( int ) rect . height ) ;
static final TCHAR ButtonClass = new TCHAR ( 0 , "str" , true ) ;
int gdkGC = gc . handle ;
int result = super . gtk_style_set ( widget , previousStyle ) ;
int lineEnd = 0 ;
System . arraycopy ( ranges , modifyStart + 2 , ranges , modifyStart + 4 , rangeCount - ( modifyStart + 2 ) ) ;
System . arraycopy ( styles , modifyStart + 1 , styles , modifyStart + 2 , styleCount - ( modifyStart + 1 ) ) ;
VERSION = response [ 0 ] & 0xffff ;
boolean drawText = true ;
if ( text . length ( ) ! = 0 ) width + = MARGIN ;
OS . SetErrorMode ( oldErrorMode ) ;
if ( parentItem = = null | | ( parentItem . getExpanded ( ) & & parentItem . itemCount > 0 ) ) {
System . arraycopy ( ids , index + 1 , ids , index , ids . length - index - 1 ) ;
int underlineY = drawY + baseline + 1 - run . style . rise ;
int strikeoutY = drawRunY + run . leading + ( run . ascent - run . style . rise ) / 2 ;
int underlineY = drawY + baseline + 1 - run . style . rise ;
int strikeoutY = drawRunY + run . leading + ( run . ascent - run . style . rise ) / 2 ;
OS . HIViewConvertPoint ( pt , OS . HIViewGetSuperview ( handle ) , contentView [ 0 ] ) ;
boolean hasImage = image ! = null , hasText = true ;
result [ i ] = _getItem ( parent , i ) ;
OS . gtk_tree_store_set ( parent . modelHandle , handle , Tree . ID_COLUMN , - 1 , - 1 ) ;
void clear ( int parentIter , int index , boolean all ) {
void setItemCount ( int parentIter , int count ) {
void drawImageXRender ( Image srcImage , int srcX , int srcY , int srcWidth , int srcHeight , int destX , int destY , int destWidth , int destHeight , boolean simple , int imgWidth , int imgHeight , int maskPixmap , int maskType ) {
int [ ] contentProvided = new int [ ] { OS . kHMContentNotProvided } ;
display . helpString = OS . CFStringCreateWithCharacters ( OS . kCFAllocatorDefault , buffer , length ) ;
static int EditProc , ListProc ;
int [ ] model = OS . GTK_VERSION < OS . VERSION ( 2 , 2 , 4 ) ? new int [ 1 ] : null ;
int [ ] model = OS . GTK_VERSION < OS . VERSION ( 2 , 2 , 4 ) ? new int [ 1 ] : null ;
int [ ] model = OS . GTK_VERSION < OS . VERSION ( 2 , 2 , 4 ) ? new int [ 1 ] : null ;
int [ ] model = OS . GTK_VERSION < OS . VERSION ( 2 , 2 , 4 ) ? new int [ 1 ] : null ;
int [ ] model = OS . GTK_VERSION < OS . VERSION ( 2 , 2 , 4 ) ? new int [ 1 ] : null ;
int [ ] model = OS . GTK_VERSION < OS . VERSION ( 2 , 2 , 4 ) ? new int [ 1 ] : null ;
wrappedContent . wrapLines ( ) ;
super . redraw ( ) ;
lineCache = new ContentWidthCache ( this , content ) ;
lineCache = getLineCache ( content ) ;
lineCache = new WordWrapCache ( this , ( WrappedContent ) content ) ;
lineCache = new ContentWidthCache ( this , content ) ;
content = logicalContent ;
content = new WrappedContent ( renderer , logicalContent ) ;
content = logicalContent ;
return new Point ( width , rbBand . cyMaxChild ) ;
int imageIndex ( Image image , int index ) {
lptvdi . iImage = lptvdi . iSelectedImage = imageIndex ( image , index ) ;
hdItem . iImage = parent . imageIndex ( image , index ) ;
parent . imageIndex ( image , index ) ;
boolean firstColumn = index = = 0 ;
if ( ! getText ) rect . right = rect . left ;
return background = = - 1 ? parent . findThemeControl ( ) : null ;
public TableColumn getSortColumn ( ) {
public int getSortDirection ( ) {
public void setSortColumn ( TableColumn column ) {
public void setSortDirection ( int direction ) {
if ( direction ! = SWT . UP & & direction ! = SWT . DOWN & & direction ! = SWT . NONE ) return ;
ImageList getImageListToolBar ( int width , int height ) {
if ( imageList = = null ) imageList = display . getImageListToolBar ( bounds . width , bounds . height ) ;
imageList = display . getImageList ( bounds . width , bounds . height ) ;
handle = OS . ImageList_Create ( 32 , 32 , COLOR_FLAGS | OS . ILC_MASK | OS . ILC_MIRROR , 16 , 16 ) ;
imageList = display . getImageList ( bounds . width , bounds . height ) ;
imageList = display . getImageList ( bounds . width , bounds . height ) ;
ImageList getImageList ( int width , int height ) {
gc = new GC ( image , style & SWT . RIGHT_TO_LEFT ) ;
e . result = isDropped ( ) ? SWT . getMessage ( "str" ) : SWT . getMessage ( "str" ) ;
e . result = SWT . getMessage ( "str" ) ;
action = SWT . getMessage ( "str" ) ;
public void getChildCount ( AccessibleControlEvent e ) {
public void getRole ( AccessibleControlEvent e ) {
public void getState ( AccessibleControlEvent e ) {
if ( hasFocus ( ) ) e . detail | = ACC . STATE_FOCUSED ;
public void getDefaultAction ( AccessibleControlEvent e ) {
modelIndex = Tree . FIRST_COLUMN ;
modelIndex = Tree . FIRST_COLUMN ;
static int createPixbuf ( Image image ) {
int result = super . gtk_scroll_event ( widget , eventPtr ) ;
PointF currentPoint = new PointF ( ) , startPoint = new PointF ( ) ;
int length = OS . strlen ( preeditString [ 0 ] ) ;
if ( length ! = 0 ) return false ;
if ( ( OS . IsWin95 & & i . depth = = 1 & & i . getTransparencyType ( ) ! = SWT . TRANSPARENCY_MASK ) | | i . depth = = 2 ) {
transBlue = oldColors [ offset ] & 0xFF ;
transRed = oldColors [ offset + 2 ] & 0xFF ;
int address = gTypeInfo_base_init_factory . getAddress ( ) ;
int address = atkObjectFactoryCB_create_accessible . getAddress ( ) ;
InitActionIfaceCB = newCallback ( AccessibleFactory . class , "str" , 1 ) ;
InitComponentIfaceCB = newCallback ( AccessibleFactory . class , "str" , 1 ) ;
InitHypertextIfaceCB = newCallback ( AccessibleFactory . class , "str" , 1 ) ;
InitSelectionIfaceCB = newCallback ( AccessibleFactory . class , "str" , 1 ) ;
InitTextIfaceCB = newCallback ( AccessibleFactory . class , "str" , 1 ) ;
Class . forName ( "str" ) ;
Callback callback = new Callback ( this , "str" , 4 ) ;
if ( preferredSize . y > area . height + table . getHeaderHeight ( ) ) {
if ( memory > = 32 * 1024 * 1024 ) {
if ( memory > = 32 * 10024 * 1024 ) {
cellBounds . y + padding - ( parent . linesVisible ? 1 : 0 ) ,
cellBounds . height - 2 * ( padding - ( parent . linesVisible ? 1 : 0 ) ) ) ;
cellBounds . y + padding - ( parent . linesVisible ? 1 : 0 ) ,
cellBounds . height - 2 * ( padding - ( parent . linesVisible ? 1 : 0 ) ) ) ;
for ( int i = 0 ; i < newIndices . length ; i + + ) {
int handle = table . handle ;
fail ( "str" ) ;
fail ( "str" ) ;
fail ( "str" ) ;
fail ( "str" ) ;
fail ( "str" ) ;
fail ( "str" ) ;
fail ( "str" ) ;
fail ( "str" ) ;
else { style = new StyleRange ( i , 1 , range . foreground , range . background , range . fontStyle | SWT . BOLD ) ; }
else { style = new StyleRange ( i , 1 , range . foreground , range . background , range . fontStyle | SWT . ITALIC ) ; }
if ( OS . COMCTL32_MAJOR > = 6 ) lpWndClass . style | = OS . CS_DROPSHADOW ;
rect . right = Math . min ( rect . left + size . x , rect . right ) ;
if ( getImage ) rect . right = rect . left ;
if ( argList [ 1 ] = = ( end - start + 1 ) ) {
if ( ! ( 0 < = index & & index < columnCount ) ) error ( SWT . ERROR_INVALID_RANGE ) ;
if ( ! ( 0 < = index & & index < columnCount ) ) error ( SWT . ERROR_INVALID_RANGE ) ;
static final boolean DEBUG = false ;
if ( callbackAddresses [ i ] = = 0 ) SWT . error ( SWT . ERROR_NO_MORE_CALLBACKS ) ;
OS . gtk_menu_popup ( handle , 0 , 0 , address , 0 , 0 , display . getLastEventTime ( ) ) ;
int availableWidth = Math . max ( 0 , rect . width - 2 * hIndent ) ;
if ( ! simple & & borderRight > 0 & & ! showMax & & ! showMin ) rightEdge - = 2 ;
if ( ! simple & & borderRight > 0 & & ! showMax & & ! showMin ) rightEdge - = 2 ;
parent . sendMouseEvent ( SWT . MouseUp , button [ 0 ] , chord , ( short ) x , ( short ) y , modifiers , true ) ;
sendMouseEvent ( SWT . MouseUp , button [ 0 ] , chord , ( short ) x , ( short ) y , modifiers , true ) ;
Callbacks [ i ] [ argCounts [ i ] ] = new Callback ( this . getClass ( ) , "str" + i , argCounts [ i ] + 1 , true , COM . E_FAIL ) ;
static final int INTERNAL_SPACING = 4 ;
IEnumFORMATETC enumFormatetc = new IEnumFORMATETC ( ppFormatetc [ 0 ] ) ;
enumFormatetc . Release ( ) ;
IEnumFORMATETC enumFormatetc = new IEnumFORMATETC ( address [ 0 ] ) ;
enumFormatetc . Release ( ) ;
if ( lastOffset < start ) {
lastOffset = Math . max ( lastOffset , end ) ;
if ( lastOffset < length ) layout . setStyle ( null , lastOffset , length ) ;
return x + width + extra < = rightEdge ;
int shellHandle = shell . shellHandle ;
static final int MIN_RIGHT = 160 ;
static final int MIN_RIGHT = 180 ;
gc . fillRectangle ( x , pos , width , height - pos + 1 ) ;
popup = new Shell ( getDisplay ( ) , SWT . NO_TRIM | SWT . ON_TOP ) ;
if ( top ) y + = topHeight + verticalSpacing ;
static final String WindowName = "str" ;
static final String PACKAGE_PREFIX = "str" ;
TCHAR buffer1 = new TCHAR ( 0 , "str" , true ) ;
TCHAR buffer2 = new TCHAR ( 0 , "str" , true ) ;
Callback callback = new Callback ( this , "str" , 4 ) ;
embeddedCallback = new Callback ( this , "str" , 4 ) ;
Callback callback = new Callback ( this , "str" , 4 ) ;
windowCallback = new Callback ( this , "str" , 4 ) ;
messageCallback = new Callback ( this , "str" , 4 ) ;
msgFilterCallback = new Callback ( this , "str" , 3 ) ;
result . append ( "str" ) ;
if ( tdata . format < 8 | | tdata . format % 8 ! = 0 ) {
int minChars = 10 ;
public static final int gestaltSystemVersion = ( "str" < < 24 ) + ( "str" < < 16 ) + ( "str" < < 8 ) + "str" ;
int err = OS . Gestalt ( OS . gestaltSystemVersion , response ) ;
rgb = toRGBColor ( color ) ;
if ( ! updateTabHeight ( false ) ) updateItems ( ) ;
if ( fixedTabHeight = = SWT . DEFAULT ) tabHeight = 0 ;
if ( ! parent . updateTabHeight ( false ) ) {
if ( ! parent . updateTabHeight ( false ) ) {
rightSize = right . computeSize ( rightWidth = = SWT . DEFAULT ? SWT . DEFAULT : rightWidth - trim . x , rightWidth = = SWT . DEFAULT ? SWT . DEFAULT : height ) ;
rightSize = right . computeSize ( rightWidth = = SWT . DEFAULT ? SWT . DEFAULT : rightWidth - trim . x , rightWidth = = SWT . DEFAULT ? SWT . DEFAULT : height ) ;
item . closeRect . x = rightEdge - BUTTON_SIZE - item . marginRight ( true ) ;
item . closeRect . x = item . x + item . width - BUTTON_SIZE - item . marginRight ( i = = selectedIndex ) ;
item . closeRect . x = rightEdge - BUTTON_SIZE - item . marginRight ( true ) ;
item . closeRect . x = item . x + item . width - BUTTON_SIZE - item . marginRight ( false ) ;
if ( focusControl = = arrow | | focusControl = = list | | focusControl = = text ) return ;
if ( focusControl = = arrow | | focusControl = = list | | focusControl = = text ) return ;
if ( focusControl = = arrow | | focusControl = = list | | focusControl = = text ) return ;
parent . postEvent ( SWT . Selection , event ) ;
if ( e . doit = = false ) return e . width ;
boolean simple = true ;
boolean simple = true ;
System . arraycopy ( data , srcIndex , newData , destIndex , bpl ) ;
public static final native int WindowFromDC ( int hDC ) ;
shape [ index + + ] = y + height + 1 ;
shape [ index + + ] = y + height + 1 ;
int x = 0 ;
int imageY = ( size . y - imageSize . height ) / 2 ;
componentIdentifiers [ i ] = ci ;
compSpecParams [ ci ] = compParam ;
componentParameters [ cid ] = new int [ ] { dc , ac } ;
static final int [ ] TOP_LEFT_CORNER = new int [ ] { 0 , 5 , 1 , 4 , 1 , 3 , 2 , 2 , 3 , 1 , 4 , 1 , 5 , 0 } ;
return OS . GetDblTime ( ) * 1000 / 60 ;
static final TCHAR ComboClass = new TCHAR ( 0 , "str" , true ) ;
boolean isFocusAncestor ( ) {
convertedText = "str" ;
convertedText = "str" ;
convertedText = "str" ;
convertedText = "str" ;
clipboard . setContents ( new String [ ] { "str" } , new Transfer [ ] { transfer } ) ;
assertTrue ( "str" , text . getCharCount ( ) = = 1 ) ;
assertTrue ( "str" , text . getCharCount ( ) = = 2 ) ;
convertedText = "str" ;
convertedText = "str" ;
convertedText = "str" ;
convertedText = "str" ;
return new Point ( width , height ) ;
desktop = DESKTOP_GNOME ;
return atom_set ! = OS . None ? gnome_init ( ) : false ;
if ( ( style & SWT . PUSH | SWT . TOGGLE ) ! = 0 ) {
if ( ( style & ( SWT . CHECK | SWT . RADIO ) ) ! = 0 ) {
if ( ( style & SWT . PUSH | SWT . TOGGLE ) ! = 0 ) {
if ( ( style & ( SWT . CHECK | SWT . RADIO ) ) ! = 0 ) {
if ( ( style & SWT . PUSH | SWT . TOGGLE ) ! = 0 ) {
if ( ( style & ( SWT . CHECK | SWT . RADIO ) ) ! = 0 ) {
if ( ( style & SWT . PUSH | SWT . TOGGLE ) ! = 0 ) {
if ( ( style & ( SWT . CHECK | SWT . RADIO ) ) ! = 0 ) {
if ( imageList ! = null & & lvItem . iImage ! = - 1 ) {
if ( ( OS . WIN32_MAJOR < < 16 | OS . WIN32_MINOR ) > = ( 4 < < 16 | 10 ) ) {
if ( ( OS . WIN32_MAJOR < < 16 | OS . WIN32_MINOR ) > = ( 4 < < 16 | 10 ) ) {
SWT . error ( SWT . ERROR_NO_HANDLES ) ;
SWT . error ( SWT . ERROR_NO_HANDLES ) ;
SWT . error ( SWT . ERROR_NO_HANDLES ) ;
public int SASH_WIDTH = 4 ;
public void drawArc ( int x , int y , int width , int height , int startAngle , int arcAngle ) {
if ( width = = 0 | | height = = 0 | | arcAngle = = 0 ) {
if ( arcAngle > 0 ) {
arcAngle + = startAngle ;
newStartAngle = startAngle + 360 - Math . abs ( arcAngle ) ;
arcAngle = newStopAngle ;
arcAngle = ( int ) ( arcAngle * 65536 / 360 ) ;
OS . PgDrawArc ( center , radii , startAngle , arcAngle , OS . Pg_ARC | OS . Pg_DRAW_STROKE ) ;
public void fillArc ( int x , int y , int width , int height , int startAngle , int arcAngle ) {
if ( width = = 0 | | height = = 0 | | arcAngle = = 0 ) {
if ( arcAngle > 0 ) {
arcAngle + = startAngle ;
newStartAngle = startAngle + 360 - Math . abs ( arcAngle ) ;
arcAngle = newStopAngle ;
arcAngle = ( int ) ( arcAngle * 65536 / 360 ) ;
OS . PgDrawArc ( center , radii , startAngle , arcAngle , OS . Pg_ARC_PIE | OS . Pg_DRAW_FILL ) ;
public void drawArc ( int x , int y , int width , int height , int startAngle , int arcAngle ) {
if ( width = = 0 | | height = = 0 | | arcAngle = = 0 ) {
for ( int i = 0 ; i < = arcAngle ; i + + ) {
if ( arcAngle > = 360 | | arcAngle < = - 360 ) {
isNegative = arcAngle < 0 ;
arcAngle = arcAngle + startAngle ;
public void fillArc ( int x , int y , int width , int height , int startAngle , int arcAngle ) {
if ( width = = 0 | | height = = 0 | | arcAngle = = 0 ) {
int [ ] points = new int [ ( arcAngle + 1 ) * 2 + ( drawSegments ? 4 : 0 ) ] ;
for ( int i = 0 ; i < = arcAngle ; i + + ) {
if ( arcAngle > = 360 | | arcAngle < = - 360 ) {
isNegative = arcAngle < 0 ;
arcAngle = arcAngle + startAngle ;
public void drawArc ( int x , int y , int width , int height , int startAngle , int arcAngle ) {
if ( width = = 0 | | height = = 0 | | arcAngle = = 0 ) {
OS . XDrawArc ( data . display , data . drawable , handle , x , y , width , height , startAngle * 64 , arcAngle * 64 ) ;
public void fillArc ( int x , int y , int width , int height , int startAngle , int arcAngle ) {
if ( width = = 0 | | height = = 0 | | arcAngle = = 0 ) {
OS . XFillArc ( xDisplay , data . drawable , handle , x , y , width , height , startAngle * 64 , arcAngle * 64 ) ;
public void drawArc ( int x , int y , int width , int height , int startAngle , int arcAngle ) {
if ( width = = 0 | | height = = 0 | | arcAngle = = 0 ) {
OS . CGContextAddArc ( handle , 0 , 0 , 1 , - startAngle * ( float ) Math . PI / 180 , - ( startAngle + arcAngle ) * ( float ) Math . PI / 180 , true ) ;
public void fillArc ( int x , int y , int width , int height , int startAngle , int arcAngle ) {
if ( width = = 0 | | height = = 0 | | arcAngle = = 0 ) {
OS . CGContextAddArc ( handle , 0 , 0 , 1 , - startAngle * ( float ) Math . PI / 180 , - ( startAngle + arcAngle ) * ( float ) Math . PI / 180 , true ) ;
public static final int EMBEDDED = 1 < < 24 ;
public static final int CENTER = 1 < < 24 ;
OS . g_object_set ( pixbufRenderer , OS . mode , OS . GTK_CELL_RENDERER_MODE_ACTIVATABLE , 0 ) ;
OS . g_object_set ( pixbufRenderer , OS . mode , OS . GTK_CELL_RENDERER_MODE_ACTIVATABLE , 0 ) ;
OS . g_object_set ( pixbufRenderer , OS . xalign , 1f , 0 ) ;
charSetList = new List ( controls , SWT . V_SCROLL | SWT . BORDER ) ;
faceNameList = new List ( controls , SWT . V_SCROLL | SWT . BORDER ) ;
extStyleList = new List ( controls , SWT . V_SCROLL | SWT . MULTI | SWT . BORDER ) ;
fontSizeList = new List ( controls , SWT . V_SCROLL | SWT . BORDER ) ;
fontStyleList = new List ( controls , SWT . V_SCROLL | SWT . BORDER ) ;
fontSetList = new List ( fontSetGroup , SWT . V_SCROLL | SWT . BORDER ) ;
boolean isRightOriented = ( getStyle ( ) & SWT . MIRRORED ) ! = 0 ;
if ( ( getStyle ( ) & SWT . MIRRORED ) = = 0 ) {
if ( ( getStyle ( ) & SWT . MIRRORED ) = = 0 ) {
boolean isRightOriented = ( getStyle ( ) & SWT . MIRRORED ) ! = 0 ;
boolean isRightOriented = ( getStyle ( ) & SWT . MIRRORED ) ! = 0 ;
boolean isRightOriented = ( getStyle ( ) & SWT . MIRRORED ) ! = 0 ;
boolean isRightOriented = ( parent . getStyle ( ) & SWT . MIRRORED ) ! = 0 ;
endLine = content . getLineCount ( ) - 1 ;
paintY = clientArea . y - lineHeight ;
int endLine = startLine + lineCount ;
OS . gtk_tree_view_scroll_to_cell ( handle , path , 0 , true , 0 , 0 ) ;
OS . gtk_tree_view_scroll_to_cell ( handle , path , 0 , depth ! = 1 , 0.5f , 0.0f ) ;
if ( ! ( transfer instanceof TextTransfer ) ) return null ;
void _setVisible ( boolean visible ) {
void _setVisible ( boolean visible ) {
boolean tracking = DEBUG ;
boolean tracking = DEBUG ;
int [ ] argList2 = new int [ ] {
OS . XtSetValues ( handle , argList2 , argList2 . length / 2 ) ;
fRect . set ( x - fLineWidth / 2 , y - fLineWidth / 2 , width + fLineWidth , height + fLineWidth ) ;
return getText ( ) . substring ( selection . x , selection . y ) ;
if ( hAlign = = GridData . CENTER ) {
if ( hAlign = = GridData . END ) {
if ( hAlign = = GridData . FILL ) {
if ( vAlign = = GridData . CENTER ) {
if ( vAlign = = GridData . END ) {
if ( vAlign = = GridData . FILL ) {
OS . InstallEventHandler ( OS . GetControlEventTarget ( handle ) , display . fMouseProc , mask . length / 2 , mask , handle , null ) ;
mask = new int [ ] {
OS . InstallEventHandler ( OS . GetControlEventTarget ( handle ) , display . fControlProc , mask . length / 2 , mask , handle , null ) ;
public static final native void SetPt ( Point p , short h , short v ) ;
return fMacEvent . toOldMacEvent ( ) ;
if ( osName . startsWith ( WinNT ) & & osVersion ! = null ) {
private static final int SIZE = 16 ;
else if ( "str" . equals ( t ) | | "str" . equals ( t ) )
else if ( "str" . equals ( t ) | | "str" . equals ( t ) )
else if ( "str" . equals ( t ) | | "str" . equals ( t ) )
else if ( "str" . equals ( t ) | | "str" . equals ( t ) )
Vector keepSelected = new Vector ( ) ;
SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ;
SWT . error ( SWT . ERROR_INVALID_RANGE ) ;
deselectAll ( ) ;
OS . GetControlRegion ( cHandle , part , rgn ) ;
if ( false & & srcBitsPerPixel = = 32 ) {
if ( ! reparented | | ! OS . XtIsRealized ( shellHandle ) ) {
OS . XtResizeWidget ( handle , argList [ 1 ] , argList [ 3 ] + 1 , argList [ 5 ] ) ;
if ( index ! = 0 & & index > = start + 1 ) OS . XmListSelectPos ( handle , index , false ) ;
boolean caretVisible = false ;
SWT . error ( code ) ;
SWT . error ( code ) ;
Enumeration colors = printerColors . elements ( ) ;
Enumeration values = lineBackgrounds . elements ( ) ;
if ( reparented ) {
if ( reparented ) {
if ( attributes . map_state = = OS . IsViewable & & reparented ) return true ;
if ( reparented ) {
if ( isMotif ) {
if ( data . printToFile ) data . fileName = output ;
OS . ImmSetOpenStatus ( hIMC , false ) ;
String [ ] names = new String [ ] { "str" , "str" , "str" , "str" , "str" } ;
if ( ! ( control instanceof Tree ) & & ! ( control instanceof Table ) & & accessibleControlListeners . size ( ) = = 0 ) return code ;
if ( ! ( control instanceof Tree ) & & ! ( control instanceof Table ) & & accessibleControlListeners . size ( ) = = 0 ) return code ;
int x = 0 ;
moveColumns ( column . getIndex ( ) , columnWidth * - 1 ) ;
if ( x > = clientAreaWidth ) {
private String [ ] trimmedLabels ;
if ( textWidth > maxWidth ) {
while ( textWidth + dotsWidth > maxWidth & & text . length ( ) > 1 ) {
int flags = OS . DT_CALCRECT | OS . DT_EDITCONTROL | OS . DT_EXPANDTABS ;
public Point getOrigin ( ) {
public void setOrigin ( int x , int y ) {
postEvent ( SWT . DragDetect ) ;
if ( currentImage = = null & & image ! = null ) {
public int MIN_TAB_WIDTH = 3 ;
int gridLineWidth = parent . getLinesVisible ( ) ? parent . getGridLineWidth ( ) : 0 ;
import org . eclipse . swt . widgets . * ;
import org . eclipse . swt . widgets . * ;
for ( int i = column ; i < = lastColumn ; i + + ) {
for ( int i = row ; i < = lastRow ; i + + ) {
char ch = mbcsToWcs ( key ) ;
char mbcsToWcs ( int ch ) {
char mbcsToWcs ( int ch , String codePage ) {
if ( key < = 0x7F ) return ( char ) ch ;
int length = OS . XLookupString ( xEvent , buffer , buffer . length , keysym , null ) ;
length = 0 ;
length = 0 ;
if ( length = = 0 ) {
event . character = mbcsToWcs ( buffer [ 0 ] & 0xFF ) ;
int wcsToMbcs ( char ch ) {
int wcsToMbcs ( char ch , String codePage ) {
case SWT . Dispose : onDispose ( ) ; break ;
case SWT . MouseUp : onMouseUp ( event ) ; break ;
bits & = ~ OS . WS_VISIBLE ;
public static int getFontBidiAttributes ( GC gc ) {
if ( control ! = null & & control . isDisposed ( ) ) error ( SWT . ERROR_INVALID_ARGUMENT ) ;
if ( control ! = null & & control . isDisposed ( ) ) error ( SWT . ERROR_INVALID_ARGUMENT ) ;
+ valueDesc + "str" ) ;
assertEquals ( m . ztime . toInstant ( ) . toEpochMilli ( ) , m1 . ztime . toInstant ( ) . toEpochMilli ( ) ) ;
if ( annotation = = null & & ! methodName . startsWith ( "str" ) | | builderClass ! = null ) {
ObjectDeserializer deserializer = parserConfig . getDeserializer ( parent . getClass ( ) ) ;
ObjectDeserializer deserializer = parserConfig . getDeserializer ( parent . getClass ( ) ) ;
ObjectDeserializer deserializer = config . getDeserializer ( type ) ;
return ( T ) deserializer . deserialze ( this , type , fieldName ) ;
Object item = deserializer . deserialze ( this , type , null ) ;
deserializer = deserializers . get ( clazz ) ;
deserializer = AwtCodec . instance ;
deserializer = deserializers . get ( clazz ) ;
deserializers . put ( clazz , MiscCodec . instance ) ;
deserializers . put ( forType , autowired ) ;
deserializer = new EnumDeserializer ( clazz ) ;
deserializer = ObjectArrayCodec . instance ;
deserializer = CollectionCodec . instance ;
deserializer = CollectionCodec . instance ;
deserializer = MapDeserializer . instance ;
deserializer = new ThrowableDeserializer ( this , clazz ) ;
deserializer = createJavaBeanDeserializer ( clazz , type ) ;
putDeserializer ( type , deserializer ) ;
deserializer = deserializers . get ( clazz ) ;
deserializer = AwtCodec . instance ;
deserializers . put ( clazz , deserializer = ByteBufferCodec . instance ) ;
deserializers . put ( clazz , deserializer = MiscCodec . instance ) ;
deserializers . put ( clazz , deserializer = MiscCodec . instance ) ;
deserializers . put ( clazz , deserializer = MonetaCodec . instance ) ;
deserializer = new EnumDeserializer ( clazz ) ;
deserializer = ObjectArrayCodec . instance ;
deserializer = CollectionCodec . instance ;
deserializer = CollectionCodec . instance ;
deserializer = MapDeserializer . instance ;
deserializer = new ThrowableDeserializer ( this , clazz ) ;
deserializer = new PropertyProcessableDeserializer ( ( Class < PropertyProcessable > ) clazz ) ;
deserializer = MiscCodec . instance ;
deserializer = createJavaBeanDeserializer ( clazz , type ) ;
putDeserializer ( type , deserializer ) ;
if ( offset = = 0 | | millis % offset = = 0 ) {
assertEquals ( JSON . toJSONString ( vo . date ) , JSON . toJSONString ( result . date ) ) ;
Object jsonValue = toJSON ( entry . getValue ( ) , config ) ;
Object jsonValue = toJSON ( item , config ) ;
long power = 1 ;
if ( ( ! exp ) & & count < 17 ) {
for ( int i = 0 ; i < 1000 * 1000 * 1 ; + + i ) {
m . zone = DateTimeZone . forID ( "str" ) ;
throw new JSONException ( "str" + clazz . getName ( ) + "str" + fieldInfo . name , e ) ;
if ( out . isEnabled ( SerializerFeature . WriteBigDecimalAsPlain ) & & scale > = - 100 & & scale < 100 ) {
write ( isEnabled ( SerializerFeature . WriteBigDecimalAsPlain ) & & scale > = - 100 & & scale < 100
assertEquals ( "str" + t2 + "str" + t1 + "str" + t3 + "str" , text ) ;
write ( "str" ) ;
creatorConstructor = TypeUtils . getKoltinConstructor ( constructors , paramNames ) ;
if ( ! out . isEnabled ( SerializerFeature . WriteMapNullValue ) ) {
if ( y0 < "str" | | y0 > "str" ) {
if ( arguments = = null | | class_gd = = null ) {
String t1 = JSON . toJSONString ( time1 , SerializerFeature . WriteDateUseDateFormat ) ;
Assert . assertEquals ( "str" + t1 + "str" + stime2 + "str" , json ) ;
Assert . assertEquals ( "str" + JSON . toJSONString ( time1 , SerializerFeature . WriteDateUseDateFormat ) + "str" + stime2 + "str" , json ) ;
Assert . assertEquals ( JSON . toJSONString ( vo . getDate ( ) ) , JSON . toJSONString ( vo1 . getDate ( ) ) ) ;
public final static int DEFAULT_SIZE = 8192 ;
public final static int DEFAULT_SIZE = 4096 ;
if ( buf . length < = 1024 * 128 ) {
out . writeString ( ( String ) null ) ;
out . writeString ( chars ) ;
out . writeString ( ( String ) null ) ;
out . writeString ( ( String ) null ) ;
out . writeString ( ( String ) null ) ;
out . writeString ( ( String ) null ) ;
throw new JSONException ( "str" + paramNames + "str"
Assert . assertEquals ( "str" , obj . get ( 1001 ) ) ;
+ lexer . pos ( ) + "str" + fieldName ) ;
return deserialze ( parser , type , fieldName , 0 ) ;
char c1 = text . charAt ( start + i * 2 + 1 ) ;
assertTrue ( json . equals ( "str" )
buf = new char [ 1024 * 16 ] ;
Object val = fieldDeser . getPropertyValueDirect ( currentObject ) ;
mw . visitMethodInsn ( declaringClass . isInterface ( ) ? INVOKEINTERFACE : INVOKEVIRTUAL , type ( declaringClass ) , method . getName ( ) , desc ( method ) ) ;
return put ( ( Type ) type , ( ObjectSerializer ) value ) ;
public boolean isSchool ( ) {
JSON . parseObject ( "str" , Entity . class , 0 ) ;
if ( type instanceof WildcardType | | type instanceof TypeVariable | | type instanceof ParameterizedType ) {
} else if ( lexer . token ( ) = = JSONToken . COLON ) {
Map < String , ? > map = Collections . singletonMap ( "str" , "str" ) ;
config . propertyNamingStrategy = PropertyNamingStrategy . SnakeCase ;
parserConfig . propertyNamingStrategy = PropertyNamingStrategy . SnakeCase ;
config . propertyNamingStrategy = PropertyNamingStrategy . KebabCase ;
parserConfig . propertyNamingStrategy = PropertyNamingStrategy . KebabCase ;
config . propertyNamingStrategy = PropertyNamingStrategy . PascalCase ;
parserConfig . propertyNamingStrategy = PropertyNamingStrategy . PascalCase ;
config . propertyNamingStrategy = PropertyNamingStrategy . CamelCase ;
parserConfig . propertyNamingStrategy = PropertyNamingStrategy . CamelCase ;
case SnakeCase : {
case KebabCase : {
case PascalCase : {
case CamelCase : {
@SuppressWarnings ( { "str" , "str" } )
} else if ( beanContext ! = null & & beanContext . isJsonDirect ( ) ) {
Calendar calendar = Calendar . getInstance ( JSON . defaultTimeZone , JSON . defaultLocale ) ;
Calendar calendar = Calendar . getInstance ( JSON . defaultTimeZone , JSON . defaultLocale ) ;
Calendar calendar = Calendar . getInstance ( JSON . defaultTimeZone , JSON . defaultLocale ) ;
Calendar calendar = Calendar . getInstance ( JSON . defaultTimeZone , JSON . defaultLocale ) ;
Calendar calendar = Calendar . getInstance ( JSON . defaultTimeZone , JSON . defaultLocale ) ;
Calendar calendar = Calendar . getInstance ( JSON . defaultTimeZone , JSON . defaultLocale ) ;
Calendar calendar = Calendar . getInstance ( JSON . defaultTimeZone , JSON . defaultLocale ) ;
Calendar calendar = Calendar . getInstance ( JSON . defaultTimeZone , JSON . defaultLocale ) ;
Calendar calendar = Calendar . getInstance ( JSON . defaultTimeZone , JSON . defaultLocale ) ;
Calendar calendar = Calendar . getInstance ( JSON . defaultTimeZone , JSON . defaultLocale ) ;
Calendar calendar = Calendar . getInstance ( JSON . defaultTimeZone , JSON . defaultLocale ) ;
Calendar calendar = Calendar . getInstance ( JSON . defaultTimeZone , JSON . defaultLocale ) ;
protected final ASMClassLoader classLoader = new ASMClassLoader ( ASMSerializerFactory . class . getClassLoader ( ) ) ;
if ( beanInfo . creatorConstructor = = null & & beanInfo . buildMethod = = null & & beanInfo . factoryMethod = = null ) {
if ( ! method . getReturnType ( ) . equals ( fieldInfo . fieldClass ) ) {
& & ( beanToArray | | writeEnumUsingName )
if ( elementClass ! = null & & Modifier . isPublic ( elementClass . getModifiers ( ) ) ) {
if ( context . writeDirect & & Modifier . isPublic ( fieldClass . getModifiers ( ) ) ) {
if ( elementClass ! = null & & Modifier . isPublic ( elementClass . getModifiers ( ) ) ) {
if ( Modifier . isPublic ( fieldClass . getModifiers ( ) ) & & ! ParserConfig . isPrimitive ( fieldClass ) ) {
Assert . assertEquals ( 0 , fastJsonConfig . getFeatures ( ) . length ) ;
javaBeanSerializer . getFieldValues ( javaObject , json ) ;
if ( ( isDoubleA & & isDoubleB ) | | ( isDoubleA & & isIntB ) | | ( isDoubleB & & isIntA ) ) {
Assert . assertEquals ( "str" , new String ( out . toBytes ( ( String ) null ) , "str" ) ) ;
Assert . assertEquals ( 3 , json . size ( ) ) ;
Assert . assertEquals ( "str" , JSONToken . name ( Integer . MAX_VALUE ) ) ;
if ( method . getParameterTypes ( ) . length = = 1 ) {
public static boolean set ( Object rootObject , String path , Object value ) {
return jsonpath . set ( rootObject , value ) ;
if ( Map . class . isAssignableFrom ( clazz ) ) {
| | ch = = "str" | | ch = = "str" | | ch = = "str" ) {
| | ch = = "str" | | ch = = "str" | | ch = = "str" ) {
import com . alibaba . fastjson . util . IOUtils ;
derializer = ArrayDeserializer . instance ;
if ( superClass = = Object . class | | superClass = = null ) {
if ( superClass = = Object . class | | superClass = = null ) {
Assert . assertFalse ( "str" . equals ( JSON . toJSONString ( b ) ) ) ;
return castToDouble ( value ) ;
return castToDouble ( value ) ;
if ( type instanceof WildcardType | | type instanceof TypeVariable | | type instanceof ParameterizedType ) {
mw . visitVarInsn ( LLOAD , context . var ( "str" , 2 ) ) ;
mw . visitVarInsn ( DSTORE , context . var ( "str" , 2 ) ) ;
mw . visitVarInsn ( DLOAD , context . var ( "str" , 2 ) ) ;
mw . visitVarInsn ( LLOAD , context . var ( "str" , 2 ) ) ;
mw . visitVarInsn ( DLOAD , context . var ( "str" , 2 ) ) ;
mw . visitVarInsn ( LLOAD , context . var ( "str" , 2 ) ) ;
mw . visitVarInsn ( DLOAD , context . var ( "str" , 2 ) ) ;
mw . visitVarInsn ( LLOAD , context . var ( "str" , 2 ) ) ;
mw . visitVarInsn ( DLOAD , context . var ( "str" , 2 ) ) ;
public final static String VERSION = "str" ;
} else if ( List . class . isAssignableFrom ( propertyClass ) ) {
mw . visitTypeInsn ( CHECKCAST , getType ( List . class ) ) ;
mw . visitMethodInsn ( INVOKEINTERFACE , getType ( List . class ) , "str" , "str" ) ;
mw . visitMethodInsn ( INVOKEINTERFACE , getType ( List . class ) , "str" , "str" ) ;
mw . visitMethodInsn ( INVOKEINTERFACE , getType ( List . class ) , "str" , "str" ) ;
mw . visitMethodInsn ( INVOKEINTERFACE , getType ( List . class ) , "str" , "str" ) ;
mw . visitMethodInsn ( INVOKEINTERFACE , getType ( List . class ) , "str" , "str" ) ;
} else if ( List . class . isAssignableFrom ( propertyClass ) ) {
} else if ( List . class . isAssignableFrom ( propertyClass ) ) {
public static final String USER_AGENT = "str" + System . getProperty ( "str" ) ;
String userAgent = "str" + System . getProperty ( "str" ) ;
this . params = params ;
public static RequestBuilder newRequest ( String method , String url ) {
try ( Client client = Client . single ( ) . build ( ) ) {
try ( Client client = Client . single ( ) . verify ( false ) . build ( ) ) {
try ( Client client = Client . single ( ) . verify ( false ) . build ( ) ) {
try ( Client client = Client . single ( ) . verify ( false ) . proxy ( Proxy . httpProxy ( "str" , 8000 ) ) . build ( ) ) {
try ( Client client = Client . single ( ) . verify ( false ) . proxy ( Proxy . socketProxy ( "str" , 1080 ) ) . build ( ) ) {
Request request = build ( ) ;
public abstract Request build ( ) ;
try ( Client client = Client . single ( ) . build ( ) ) {
public Client build ( ) {
Request request = new HeadOnlyRequestBuilder ( ) . url ( "str" ) . build ( ) ;
public Request build ( ) {
public Request build ( ) {
public Request build ( ) {
return Client . single ( ) . closeOnRequstFinished ( true ) . build ( ) ;
assertEquals ( "str" , resp . getHistory ( ) . get ( 0 ) . getHost ( ) ) ;
import org . apache . commons . lang3 . StringUtils ;
actionWithConfirmationPerformedHook ( e ) ;
dialog . getWindow ( ) . setBackgroundDrawable ( new ColorDrawable ( 0 ) ) ;
Intent startIntent = new Intent ( TaskContract . ACTION_BROADCAST_TASK_STARTING ) ;
if ( mIsTheTitleContainerVisible & & Build . VERSION . SDK_INT > = 11 )
& & ! ( "str" . equals ( Locale . getDefault ( ) . getLanguage ( ) . toString ( ) ) ) )
leftFlingView . setCompoundDrawablesWithIntrinsicBounds ( resources . getDrawable ( R . drawable . ic_action_complete ) , null , null , null ) ;
private static String PREF_ALARM_ACTIVATED = "str" ;
editor . putBoolean ( PREF_ALARM_ACTIVATED , value ) ;
return settings . getBoolean ( PREF_ALARM_ACTIVATED , true ) ;
if ( position < 0 | | position > = getCount ( ) )
numberprefix , contenttable , false ) ;
public static final String BUILD_VERSION = "str" ;
private final javax . swing . JTextArea textarea ;
private final LinkedList < Integer [ ] > findselections = new LinkedList < > ( ) ;
private final org . jdesktop . application . ResourceMap resourceMap =
public static final String BUILD_VERSION = "str" ;
public static EnumFallbackTypeAdapterFactory create ( ) {
public class EnumFallbackTypeAdapterFactory implements TypeAdapterFactory {
public static final String VERSION = "str" ;
private String amount ;
public String getAmount ( ) {
public void setAmount ( String amount ) {
_baseOAuthUrl = new URL ( "str" ) ;
@ContextConfiguration ( loader = WebApplicationContextLoader . class , inheritLocations = false , locations = { "str" } )
JList < String > eventList = new JList < String > ( model ) ;
JList < String > defaultList = new JList < String > ( model ) ;
public class DefaultEventComboBoxModel < E > extends DefaultEventListModel < E > implements ComboBoxModel < E > {
private final JComboBox < ? > comboBox ;
private ComboBoxPopupLocationFix ( JComboBox < ? > comboBox ) {
public static ComboBoxPopupLocationFix install ( JComboBox < ? > comboBox ) {
public class EventComboBoxModel < E > extends EventListModel < E > implements ComboBoxModel < E > {
AutoCompleteSupport . install ( new JComboBox < Object > ( ) , new BasicEventList < Object > ( ) ) ;
AutoCompleteSupport . install ( new JComboBox < Object > ( ) , new BasicEventList < Object > ( ) , GlazedLists . toStringTextFilterator ( ) ) ;
final AutoCompleteSupport < Object > support = installAutoCompleteSupportRunnable . getSupport ( ) ;
private AutoCompleteSupport < Object > support ;
support = AutoCompleteSupport . install ( new JComboBox < Object > ( ) , new BasicEventList < Object > ( ) ) ;
public AutoCompleteSupport < Object > getSupport ( ) {
public class DefaultEventListModel < E > implements ListEventListener < E > , ListModel < E > {
public E getElementAt ( int index ) {
private JComboBox < CloseableFilterComponent > filterSelect ;
filterSelect = new JComboBox < > ( new DefaultEventComboBoxModel < CloseableFilterComponent > ( remainingFilterComponentsProxyList ) ) ;
public class NoFocusRenderer < E > implements TableCellRenderer , ListCellRenderer < E > {
private ListCellRenderer < ? super E > delegateListCellRenderer ;
public NoFocusRenderer ( ListCellRenderer < ? super E > delegate ) {
public Component getListCellRendererComponent ( JList < ? extends E > list , E value , int index , boolean isSelected , boolean hasFocus ) {
private JComboBox < E > comboBox ;
private final ListCellRenderer < Object > renderer ;
private ComboBoxModel < E > originalModel ;
private ListCellRenderer < ? super E > originalRenderer ;
private AutoCompleteSupport ( JComboBox < E > comboBox , EventList < E > items , TextFilterator < ? super E > filterator , Format format ) {
private static ActionListener [ ] unregisterAllActionListeners ( JComboBox < ? > comboBox ) {
private static void registerAllActionListeners ( JComboBox < ? > comboBox , ActionListener [ ] listeners ) {
private static JButton findArrowButton ( JComboBox < ? > c ) {
public static < E > AutoCompleteSupport < E > install ( JComboBox < E > comboBox , EventList < E > items ) {
public static < E > AutoCompleteSupport < E > install ( JComboBox < E > comboBox , EventList < E > items , TextFilterator < ? super E > filterator ) {
public static < E > AutoCompleteSupport < E > install ( JComboBox < E > comboBox , EventList < E > items , TextFilterator < ? super E > filterator , Format format ) {
public JComboBox < E > getComboBox ( ) {
final E prototypeValue = comboBox . getPrototypeDisplayValue ( ) ;
private Dimension getPrototypeSize ( E prototypeValue ) {
ListCellRenderer < ? super E > renderer = comboBox . getRenderer ( ) ;
public Component getListCellRendererComponent ( JList < ? > list , Object value , int index , boolean isSelected , boolean cellHasFocus ) {
final JComboBox < E > comboBox = new TableCellComboBox < > ( ) ;
private static final class TableCellComboBox < E > extends JComboBox < E > implements FocusListener {
private JList < String > userSelect ;
userSelect = new JList < String > ( usersListModel ) ;
userSelect . setCellRenderer ( new NoFocusRenderer < String > ( userSelect . getCellRenderer ( ) ) ) ;
public JList < String > getUserSelect ( ) {
private static final class UrlListCellRenderer extends JLabel implements ListCellRenderer < Url > {
public Component getListCellRendererComponent ( JList < ? extends Url > list , Url value , int index ,
JList < String > eventList = new JList < String > ( model ) ;
JList < String > defaultList = new JList < String > ( model ) ;
public Class < ? > getColumnClass ( int columnIndex ) {
private AutoCompleteSupport < String > autoCompleteSupport ;
private final JComboBox < String > comboBox ;
public SetValueProgrammaticallyActionHandler ( JComboBox < String > comboBox ) {
private JPanel createActionPanel ( String title , JList < String > list ) {
private JPanel createComboBoxModelPanel ( String title , ComboBoxModel < String > model ) {
final JList < String > list = new JList < > ( model ) ;
final JComboBox < String > plainComboBox = regularComboBox ;
private final DefaultListModel < String > model ;
public RecordActionHandler ( DefaultListModel < String > model ) {
public TextComponentMatcherEditor ( JTextComponent textComponent , TextFilterator < ? super E > textFilterator ) {
public void elementChanged ( Object element ) {
list . elementChanged ( o ) ;
public void elementChanged ( Object listElement ) {
public < E > EventList < E > createMemberList ( ) {
for ( int column = 0 ; column < = cMax ; column + + ) {
assertEquals ( new Float ( 0 ) , diff . getValue ( ) ) ;
assertEquals ( new Float ( 1 ) , diff . getValue ( ) ) ;
assertEquals ( new Float ( 0 ) , diff . getValue ( ) ) ;
assertEquals ( new Double ( 0 ) , diff . getValue ( ) ) ;
assertEquals ( new Double ( 1 ) , diff . getValue ( ) ) ;
assertEquals ( new Double ( 0 ) , diff . getValue ( ) ) ;
assertEquals ( new Integer ( 0 ) , diff . getValue ( ) ) ;
assertEquals ( new Integer ( 1 ) , diff . getValue ( ) ) ;
assertEquals ( new Integer ( 0 ) , diff . getValue ( ) ) ;
assertEquals ( new Long ( 0 ) , diff . getValue ( ) ) ;
assertEquals ( new Long ( 1 ) , diff . getValue ( ) ) ;
assertEquals ( new Long ( 0 ) , diff . getValue ( ) ) ;
super ( new Boolean ( source . size ( ) > 1 ) ) ;
super ( new Boolean ( source . isEmpty ( ) ) ) ;
super ( new Boolean ( source . size ( ) = = 1 ) ) ;
numbers . add ( new Integer ( 2 ) ) ;
private static final List < Integer > COLUMN_KEYS = Collections . singletonList ( new Integer ( 0 ) ) ;
final EventList < ? extends String > source = GlazedLists . eventListOf ( ( String [ ] ) null ) ;
final Comparator < Issue > issuesByStatusGrouper = GlazedLists . beanPropertyComparator ( Issue . class , "str" , new String [ 0 ] ) ;
SeparatorList < Issue > separatedIssues = new SeparatorList < Issue > ( filteredIssues , GlazedLists . beanPropertyComparator ( Issue . class , "str" , new String [ 0 ] ) , 0 , Integer . MAX_VALUE ) ;
public static final TableItemRenderer DEFAULT = new DefaultTableItemRenderer ( ) ;
class DefaultTableItemRenderer implements TableItemRenderer {
DebugList < Integer > list2 = list1 . createNewDebugList ( ) ;
public < E > DebugList < E > createNewDebugList ( ) {
return Math . abs ( o1 . intValue ( ) ) - Math . abs ( o2 . intValue ( ) ) ;
return Character . valueOf ( contained . getName ( ) . charAt ( 0 ) ) . compareTo ( new Character ( o . contained . getName ( ) . charAt ( 0 ) ) ) ;
list . add ( 0 , new Integer ( i ) ) ;
list . add ( list . size ( ) , new Integer ( i ) ) ;
Integer value = new Integer ( dice . nextInt ( 1000 ) ) ;
public static < K extends Comparable , V > Map < K , List < V > > syncEventListToMultiMap ( EventList < V > source , FunctionList . Function < V , ? extends K > keyMaker ) {
delegate = ( LockFactory ) Class . forName ( "str" ) . newInstance ( ) ;
return delegate . createReadWriteLock ( ) ;
return delegate . createLock ( ) ;
public void testAllPossibleGrouperStateChanges_FixMe ( ) {
Node < E > result = ( Node < E > ) evaluate ( sourceValue ) ;
return addToCollection ( clazz , propertyName , converter , ( Matcher ) Matchers . trueMatcher ( ) ) ;
return new XMLTagPath ( Collections . EMPTY_LIST , BODY ) ;
return addToCollection ( clazz , propertyName , ( Converter ) Converters . identityConverter ( ) , Matchers . trueMatcher ( ) ) ;
return lastCharOf ( a ) - lastCharOf ( b ) ;
private char lastCharOf ( String s ) {
public static < E > TableComparatorChooser < E > install ( JTable table , SortedList < E > sortedList , boolean multipleColumnSort ) {
throw new IllegalMonitorStateException ( ) ;
super . setBackground ( nodeComponent . getBackground ( ) ) ;
public void testUpdateProblem ( ) {
public void testUpdateProblem2 ( ) {
this . renderer = format ! = null & & defaultRendererInstalled ? new StringFunctionRenderer ( ) : null ;
public void guiTestDeleteKey ( ) throws BadLocationException {
postProcessDocumentChange ( filterBypass , null , valueBeforeEdit , selectionStart , selectionEnd , isStrict ( ) ) ;
if ( groupChangeType = = ListEvent . DELETE & & elementChangeType ! = ListEvent . INSERT
public void testBadListEventHandler_FixMe ( ) {
public void guiTestUninstall_FixMe ( ) {
public void testInsertRealOverVirtualParent_FixMe ( ) {
public void guiTestDeleteSelectedRows_FixMe ( ) {
public void guiTestConflictingThreads_FixMe ( ) {
final TreeElement < E > treeElement = ( TreeElement < E > ) get ( i ) ;
return GlazedLists . comparableComparator ( ) . compare ( new Integer ( getAmount ( ) ) , new Integer ( o . getAmount ( ) ) ) ;
protected static Runnable ENDTASK = new EndTaskRunnable ( ) ;
private static < E > AssemblerHelper < E > createAssemblerDelegate ( EventList < E > sourceList , ListEventPublisher publisher ) {
public static ListEventPublisher createListEventPublisher ( ) {
private PublisherAdapter < E > createPublisherDelegate ( ListEventPublisher publisher ) {
private void updateListEventListeners ( ListEventListener < E > toAdd , ListEventListener < E > toRemove , ListEvent < E > listEvent ) {
List < SubjectAndListener > sourceTargets = ( List < SubjectAndListener > ) sourceToPairs . get ( subject ) ;
List < SubjectAndListener > allSourcesForSourceTarget = ( List < SubjectAndListener > ) targetToPairs . get ( sourceTarget ) ;
final List < V > removed = ( List < V > ) this . remove ( key ) ;
final List < V > inserted = ( List < V > ) groupingList . get ( changeIndex ) ;
final List < V > mapValue = ( List < V > ) GroupingListMultiMap . this . get ( key ) ;
return new MultiMapEntry ( key , ( List < V > ) get ( key ) ) ;
checkKeyValueAgreement ( ( Comparable < K > ) getKey ( ) , newValue ) ;
rangeMatcherEditor . setRange ( new Integer ( slider . getValue ( ) ) , null ) ;
final TreePair treePair = getTreePair ( rowKey ) ;
final TreePair < C > treePair = getTreePair ( rowKey ) ;
return treePair . getCount ( start , end ) ;
priorityRangeModel . setRangeProperties ( 0 , 0 , 0 , 101 , false ) ;
private void handleDelete ( int sourceIndex ) {
ChildElement removedChildElement = ( ChildElement ) childElements . removeByIndex ( sourceIndex ) . getValue ( ) ;
return whiteSoFar + localIndex - currentNode . rootSize ;
DelegateMatcherEditorListener listener = ( DelegateMatcherEditorListener ) matcherEditorListeners . get ( index ) ;
if ( matcherEditors . size ( ) = = 1 ) fireMatchAll ( ) ;
} else if ( sortedIndex = = lowerThresholdIndex & & value < = upperThreshold ) {
subListBefore . set ( 14 , "str" ) ;
updates . addUpdate ( changeIndex - startIndex ) ;
for ( BarcodeIterator i = flagList . iterator ( ) ; i . hasNextBlack ( ) ; ) {
defaultIcons = loadIcons ( resourceRoot + "str" + resourcePath ) ;
for ( int i = 0 ; i < pathIcons . length ; i + + ) {
usersEventList = new UniqueList ( new CollectionList ( source , new IssueUserator ( ) ) ) ;
if ( beta ! = null ) betaProperty = beanProperty . get ( beta ) ;
if ( nextIndex < = 0 ) {
if ( constrained & & relaxed ) handleFilterChanged ( ) ;
connection . close ( new CTPServerShutdownException ( ) ) ;
class CTPServerShutdownException extends Exception {
public CTPServerShutdownException ( ) {
eventSelectionModel . addSelectionInterval ( 1 , 4 ) ;
eventSelectionModel . clearSelection ( ) ;
JScrollPane issuesTableScrollPane = new JScrollPane ( issuesJTable , JScrollPane . VERTICAL_SCROLLBAR_ALWAYS , JScrollPane . HORIZONTAL_SCROLLBAR_NEVER ) ;
JScrollPane usersListScrollPane = new JScrollPane ( issuesUserFiltered . getUserSelect ( ) , JScrollPane . VERTICAL_SCROLLBAR_ALWAYS , JScrollPane . HORIZONTAL_SCROLLBAR_NEVER ) ;
JScrollPane descriptionsTableScrollPane = new JScrollPane ( descriptionsTable , JScrollPane . VERTICAL_SCROLLBAR_ALWAYS , JScrollPane . HORIZONTAL_SCROLLBAR_NEVER ) ;
if ( second . type = = ListEvent . INSERT & & first . type ! = ListEvent . DELETE ) {
if ( recordHitsOrMisses ) cacheHits + + ;
if ( recordHitsOrMisses ) cacheMisses + + ;
throw new IllegalArgumentException ( "str" + revision . comparator ( ) + "str" + comparator ) ;
return ( indexOf ( object ) ! = - 1 ) ;
if ( atomicCount < masterSequence . getAtomicCount ( ) ) atomicChangeToShow = atomicCount ;
private Lock forwardLock = new J2SE12ReadWriteLock ( ) . writeLock ( ) ;
public final class ListChangeSequence {
private int changeCount = 0 ;
private int blockCount = 0 ;
private ArrayList changePool = new ArrayList ( ) ;
int getBlockCount ( int atomicCount ) {
ListChangeBlock getBlock ( int atomicCount , int block ) {
public final class ListChangeBlock {
ListChangeBlock ( int index , int type ) {
ListChangeBlock ( int startIndex , int endIndex , int type ) {
ListChangeBlock ( ) {
void setData ( int index , int type ) {
void setData ( int startIndex , int endIndex , int type ) {
void setInvalid ( ) {
boolean isValid ( ) {
int getStartIndex ( ) {
int getEndIndex ( ) {
int getType ( ) {
ListChangeBlock append ( int appendStartIndex , int appendEndIndex , int type ) {
public final class ListChangeEvent {
ListChangeEvent ( ListChangeSequence masterSequence ) {
public TaskContext queryTaskContext = null ;
if ( queryTaskContext ! = null ) queryTaskContext . cancelTask ( ) ;
public < T > ForReturnValue < T > ifReturns (
public < T > ForReturnValue < T > ifReturns (
return ifReturns ( condition , delayList ) ;
return ifReturns ( returnValue : : equals , delays ) ;
retryer . ifReturns ( s - > s . startsWith ( "str" ) , asList ( delay ) ) ;
retryer . ifReturns ( s - > s . startsWith ( "str" ) , asList ( delay ) . stream ( ) ) ;
private boolean ackOnError = false ;
public void testExecuteInTransactionNewInnerTx ( ) {
TransactionSupport . setTransactionIdSuffix ( "str" ) ;
invokeDelegate ( consumerRecords , acknowledgment , consumer ) ;
private void invokeDelegate ( List < ConsumerRecord < K , V > > consumerRecords , Acknowledgment acknowledgment ,
ListenerType listenerType = determineListenerType ( listener ) ;
private ListenerType determineListenerType ( GenericMessageListener < ? > listener ) {
initAssignedPartitions ( ) ;
private void initAssignedPartitions ( ) {
public void remainingRecordsReceived ( ) throws Exception {
. collect ( Collectors . toMap ( Map . Entry : : getKey , Map . Entry : : getValue ) ) ;
invokeRecordListenerInTx ( records ) ;
private void invokeRecordListenerInTx ( final ConsumerRecords < K , V > records ) {
ListenerConsumer . this . logger . debug ( "str" + offsets ) ;
( getBeanName ( ) = = null ? "str" : getBeanName ( ) ) + "str" ) ;
( getBeanName ( ) = = null ? "str" : getBeanName ( ) ) + "str" ) ;
assertThat ( threadName ) . contains ( "str" ) ;
assertThat ( threadName ) . contains ( "str" ) ;
assertThat ( threadName ) . contains ( "str" ) ;
if ( this . theListener instanceof BatchAcknowledgingMessageListener ) {
else if ( this . theListener instanceof AcknowledgingMessageListener ) {
this . acknowledgingMessageListener = ( AcknowledgingMessageListener < K , V > ) this . theListener ;
if ( this . isBatchListener ) {
if ( this . errorHandler = = null ) {
this . logger . error ( "str" , ee ) ;
this . logger . error ( "str" , er ) ;
this . logger . error ( "str" , ee ) ;
this . logger . error ( "str" , er ) ;
this . logger . error ( "str" + offset , e ) ;
( ( ConsumerSeekAware ) this . bean ) . registerSeekCallback ( callback ) ;
( ( ConsumerSeekAware ) this . bean ) . onPartitionsAssigned ( assignments , callback ) ;
( ( ConsumerSeekAware ) this . bean ) . onIdleContainer ( assignments , callback ) ;
final int numberOfFrames = getNumberOfFrames ( gifInfoPtr ) ;
private static class SlowLoadingInputStream extends BufferedInputStream {
public int read ( @NonNull byte [ ] buffer ) throws IOException {
return super . read ( buffer ) ;
public int read ( @NonNull byte [ ] buffer , int off , int len ) throws IOException {
return super . read ( buffer , off , len ) ;
private static native int getNumberOfFrames ( long gifInfoPtr ) ;
mStates = new long [ drawables . length ] [ ] ;
mStates = new long [ 1 ] [ ] ;
return GifInfoHandle . openAssetFileDescriptor ( mAssetManager . openFd ( mAssetName ) , false ) ;
if ( drawable instanceof GifDrawable & & mPositions [ i ] > 0 ) {
catch ( IOException | NotFoundException ignored )
private static native void seekToTime ( int gifFileInPtr , int pos , int [ ] pixels ) ;
private static native void seekToFrame ( int gifFileInPtr , int frameNr , int [ ] pixels ) ;
private static native void saveRemainder ( int gifFileInPtr ) ;
private static native void restoreRemainder ( int gifFileInPtr ) ;
private final ConcurrentLinkedQueue < AnimationListener > mListeners = new ConcurrentLinkedQueue < > ( ) ;
public void recycle ( )
public void onAddButtonClick ( View view ) {
classpath . append ( new File ( url . toURI ( ) ) ) ;
classpath . append ( new File ( url . toURI ( ) ) ) ;
Class < ? > result = null ;
Class < ? > result = null ;
if ( defaultFontSize > 0 & & host . getFontSize ( ) = = - 1 )
if ( prefs . getBoolean ( PreferenceConstants . EXTENDED_LONGPRESS , false ) ) {
getString ( R . string . file_chooser_select_file , getString ( R . string . select_for_key_import ) ) ) ;
public static String getPrivkeyString ( PubkeyBean pubkey , String passphrase ) {
if ( imported )
final static int DEFAULT_BITS = 2048 ;
String keyString = PubkeyUtils . getPrivkeyString ( pubkey , null ) ;
if ( PreferenceConstants . KEYMODE_RIGHT . equals ( keymode ) & & ! prefs . getBoolean ( "str" , false ) ) {
} else if ( PreferenceConstants . KEYMODE_LEFT . equals ( keymode ) & & ! prefs . getBoolean ( "str" , false ) ) {
for ( int i = 0 ; i < leftLength ; i + + ) {
} ) . start ( ) ;
} ) . start ( ) ;
byte [ ] xb = new byte [ tempbuf . length + len ] ;
handler . inputfeed ( buffer , start , n ) ;
if ( oldBase > = 0 ) {
return this . tryPublicKey ( host . getUsername ( ) , pubkey . getNickname ( ) , trileadKey ) ;
public final static int COLOR_BG_SHIFT = 14 ;
public final static int COLOR = 0x7fffe0 ;
public final static int COLOR_FG = 0x3fe0 ;
public final static int COLOR_BG = 0x7fc000 ;
attributes | = ( ( DCEvars [ i ] - 30 ) + 1 ) < < COLOR_FG_SHIFT ;
attributes | = ( ( DCEvars [ i ] - 40 ) + 1 ) < < COLOR_BG_SHIFT ;
attributes | = ( ( DCEvars [ i ] - 82 ) + 1 ) < < COLOR_FG_SHIFT ;
attributes | = ( ( DCEvars [ i ] - 92 ) + 1 ) < < COLOR_BG_SHIFT ;
fg = color [ ( ( currAttr & VDUBuffer . COLOR_FG ) > > VDUBuffer . COLOR_FG_SHIFT ) - 1 ] ;
bg = color [ ( ( currAttr & VDUBuffer . COLOR_BG ) > > VDUBuffer . COLOR_BG_SHIFT ) - 1 ] ;
view = inflater . inflate ( R . layout . item_pubkey , null , false ) ;
limit = bm - 1 ;
FIELD_HOST_LASTCONNECT , FIELD_HOST_COLOR } ,
if ( extras ! = null & & extras . getString ( ContactsBackupJob . ACCOUNT , "str" ) . equalsIgnoreCase ( account . name ) & &
Build . MANUFACTURER . substring ( 1 ) . toLowerCase ( Locale . getDefault ( ) ) + "str" + Build . MODEL + "str" ;
private static final String ASSET_URL = "str" ;
while ( urlNoDots . length ( ) > 0 & & urlNoDots . charAt ( 0 ) = = "str" ) {
return getFileName ( ) . length ( ) > 0 & & getFileName ( ) . charAt ( 0 ) = = "str" ;
if ( path . length ( ) > 0 & & path . charAt ( 0 ) = = "str" & & ! path . toLowerCase ( Locale . US ) . contains ( "str" ) ) {
private String mServerStatusText = "str" ;
private String mAuthStatusText = "str" ;
if ( mServerStatusIcon = = 0 & & "str" . equals ( mServerStatusText ) ) {
PreferenceManager . instantVideoUploadEnabled ( context ) ) {
! normalizedUrl . toLowerCase ( Locale . ROOT ) . startsWith ( HTTPS_PROTOCOL ) ) {
fileIcon . setImageDrawable ( MimeTypeUtil . getFileTypeIcon ( file . getMimetype ( ) , file . getFileName ( ) , context ) ) ;
if ( parent = = null & & ( mFolderUnlockToken = = null | | mFolderUnlockToken . isEmpty ( ) ) ) {
if ( mFolderUnlockToken ! = null & & ! mFolderUnlockToken . isEmpty ( ) ) {
PreferenceManager . instantVideoUploadEnabled ( this ) ) {
+ ProviderTableMeta . FILE_MOUNT_TYPE + "str"
activityViewHolder . dateTime . setText ( DateFormat . format ( "str" , activity . getDatetime ( ) . getTime ( ) ) ) ;
private long getFileChecksum ( String filepath ) {
& & userInfo . getTwitter ( ) = = null & userInfo . getWebsite ( ) = = null ) {
addToListIfNeeded ( result , R . drawable . ic_web , DisplayUtils . beautifyURL ( userInfo . getWebsite ( ) ) ,
if ( ! Device . getNetworkType ( context ) . equals ( JobRequest . NetworkType . ANY ) ) {
return getDefaultSharedPreferences ( context ) . getFloat ( AUTO_PREF__GRID_COLUMNS , 4.0f ) ;
FilesSyncHelper . scheduleNJobs ( false , getApplicationContext ( ) ) ;
FilesSyncHelper . scheduleNJobs ( false , getApplicationContext ( ) ) ;
FilesSyncHelper . scheduleNJobs ( false , getApplicationContext ( ) ) ;
FilesSyncHelper . scheduleNJobs ( false , getApplicationContext ( ) ) ;
FilesSyncHelper . scheduleNJobs ( true , getApplicationContext ( ) ) ;
FilesSyncHelper . scheduleFilesSyncIfNeeded ( mContext ) ;
. setLargeIcon ( BitmapFactory . decodeResource ( getResources ( ) , R . drawable . notification_icon ) )
. setLargeIcon ( BitmapFactory . decodeResource ( getResources ( ) , R . drawable . notification_icon ) )
PushConfigurationState . class ) ;
loadExternalSettingLinks ( preferenceCategoryMore ) ;
return uploadVideoPath + OCFile . PATH_SEPARATOR + subPath + ( fileName = = null ? "str" : fileName ) ;
File [ ] returnArray = new File [ files . size ( ) ] ;
File [ ] returnArray = new File [ files . size ( ) ] ;
File [ ] returnArray = new File [ files . size ( ) ] ;
Log_OC . e ( TAG , "str" ) ;
Log_OC . e ( TAG , "str" ) ;
Log_OC . e ( TAG , "str" ) ;
Log_OC . e ( TAG , "str" + decision ) ;
Log_OC . e ( TAG , "str" + intent . getAction ( ) ) ;
Log_OC . e ( TAG , "str" ) ;
Log_OC . e ( TAG , "str" ) ;
Log_OC . e ( TAG , "str" ) ;
Log_OC . e ( TAG , "str" ) ;
Log_OC . e ( TAG , "str" + intent . toString ( ) ) ;
Log_OC . e ( TAG , "str" ) ;
Log_OC . e ( TAG , "str" ) ;
Log_OC . e ( TAG , "str" ) ;
Log_OC . e ( TAG , "str" ) ;
Log_OC . e ( TAG , "str" ) ;
mSyncResult . delayUntil = ( System . currentTimeMillis ( ) / 1000 ) + 3 * 60 * 60 ;
ac [ i ] = DisplayUtils . convertIdn ( mAccountManager . getAccountsByType ( MainApp . getAccountType ( ) ) [ i ] . name , false ) ;
toHide . add ( R . id . action_send_file ) ;
mNotification . contentIntent = PendingIntent . getActivity ( getApplicationContext ( ) , ( int ) System . currentTimeMillis ( ) , showDetailsIntent , 0 ) ;
mNotification . contentIntent = PendingIntent . getActivity ( getApplicationContext ( ) , ( int ) System . currentTimeMillis ( ) , showDetailsIntent , 0 ) ;
finalNotification . contentIntent = PendingIntent . getActivity ( getApplicationContext ( ) , ( int ) System . currentTimeMillis ( ) , new Intent ( ) , 0 ) ;
mNotification . contentIntent = PendingIntent . getActivity ( getApplicationContext ( ) , ( int ) System . currentTimeMillis ( ) , showDetailsIntent , 0 ) ;
finalNotification . contentIntent = PendingIntent . getActivity ( getApplicationContext ( ) , ( int ) System . currentTimeMillis ( ) , new Intent ( ) , 0 ) ;
notification . contentIntent = PendingIntent . getActivity ( getContext ( ) . getApplicationContext ( ) , ( int ) System . currentTimeMillis ( ) , new Intent ( ) , 0 ) ;
mAdapter . swapDirectory ( directory , storageManager ) ;
} else if ( ! mLatestResult . isSslRecoverableException ( ) ) {
public static final int DEFAULT_DATA_TIMEOUT = 60000 ;
public static final int DEFAULT_DATA_TIMEOUT = 20000 ;
boolean result = false ;
if ( OCDirId > = 0 ) {
ContentResolver . requestSync ( account , "str" , bundle ) ;
if ( android . os . Build . VERSION . SDK_INT > = android . os . Build . VERSION_CODES . ICE_CREAM_SANDWICH ) {
WebdavEntry we = new WebdavEntry ( resp . getResponses ( ) [ 0 ] , getUri ( ) . getPath ( ) ) ;
WebdavEntry we = new WebdavEntry ( resp . getResponses ( ) [ i ] , getUri ( ) . getPath ( ) ) ;
public WebdavEntry ( MultiStatusResponse ms , String splitElement ) {
mPath = mUri . split ( splitElement , 2 ) [ 1 ] ;
public static final String WEBDAV_PATH_4_0 = "str" ;
if ( mFile . getStoragePath ( ) = = null ) {
Bitmap bmp = BitmapFactory . decodeFile ( mFile . getStoragePath ( ) ) ;
videoView . setVideoPath ( mFile . getStoragePath ( ) ) ;
Preconditions . checkNotNull ( rejectionPredicate , "str" ) ;
private static SpringContextHelper thisInstance = new SpringContextHelper ( ) ;
throw new WicketRuntimeException ( "str" ) ;
throw new WicketRuntimeException ( "str" ) ;
CometdPushBehavior . class , "str" ) ;
CometdPushBehavior . class , "str" ) ;
CometdPushBehavior . class , "str" ) ;
CometdPushBehavior . class , "str" ) ;
CometdPushBehavior . class , "str" ) ;
return Calendar . getInstance ( locale ) . getFirstDayOfWeek ( ) ;
Assert . assertEquals ( "str" , wicketTester . getLastResponseAsString ( ) ) ;
Assert . assertEquals ( "str" , 704 , data . length ) ;
import com . github . openjson . JSONObject ;
import com . github . openjson . JSONObject ;
import com . github . openjson . JSONObject ;
import com . github . openjson . JSONObject ;
private boolean jsInitialized = false ;
jsInitialized = true ;
checkbox . add ( new AjaxFormSubmitBehavior ( getGrid ( ) . getForm ( ) , "str" )
checkbox . add ( new AjaxFormSubmitBehavior ( getGrid ( ) . getForm ( ) , "str" )
import org . apache . wicket . IRequestListener ;
abstract class AbstractSelect2Choice < T , M > extends AbstractTextComponent < M > implements IRequestListener
getSettings ( ) . getAjax ( ) . setUrl ( urlForListener ( null ) ) ;
public void onRequest ( )
protected void onBookmarkableSubmit ( AjaxRequestTarget target )
protected void onBookmarkableError ( AjaxRequestTarget target )
protected void onSubmit ( AjaxRequestTarget target )
this . onBookmarkableSubmit ( target ) ;
protected void onError ( AjaxRequestTarget target )
this . onBookmarkableError ( target ) ;
protected abstract void onBookmarkableSubmit ( AjaxRequestTarget target ) ;
protected abstract void onBookmarkableError ( AjaxRequestTarget target ) ;
private Integer maximumSelectionLength ;
ajax . setProcessResults ( "str" ) ;
attributes . setPreventDefault ( true ) ;
Assert . assertEquals ( "str" , 357 , data . length ) ;
Assert . assertEquals ( "str" , 389 , data . length ) ;
if ( exception = = null )
if ( isItemSelected ( ( IModel < T > ) getDefaultModel ( ) ) )
String base = url . substring ( 0 , url . lastIndexOf ( "str" ) ) ;
private DefaultTreeModel convertToTreeModel ( List < ? > list )
private void add ( DefaultMutableTreeNode parent , List < ? > sub )
add ( child , ( List < ? > ) o ) ;
delegate . parse ( new ByteArrayInputStream ( bytes ) , encoding ) ;
Assert . assertEquals ( "str" , 437 , data . length ) ;
wicket . assertComponent ( "str" ,
wicket . clickLink ( "str" ) ;
. assertComponent ( "str" ,
wicket . clickLink ( "str" ) ;
assertEquals ( 15 , templates . size ( ) ) ;
target . add ( repeaterParent ) ;
new CompoundPropertyModel < MyMarker > ( new Model < MyMarker > ( ( MyMarker ) myMarker ) ) ) ;
target . add ( repeaterParent ) ;
add ( new EmptyPanel ( VIEW_PANEL_ID ) . setOutputMarkupId ( true ) ) ;
private boolean googleBarEnabled = false ;
final LoadableDetachableModel < List < IEvent > > eventsModel = new LoadableDetachableModel < List < IEvent > > ( ) {
addComponentInstantiationListener ( new SpringComponentInjector ( this , context ( ) , true ) ) ;
context . setWar ( "str" ) ;
} else if ( action instanceof IYuiMenuAjaxAction ) {
JQUERY_UI ( "str" , "str" ) ,
public Component setMarkupId ( String markupId ) {
public void setMarkupId ( String markupId ) {
private TextFilteredPropertyColumn createColumn ( String key , String sortProperty ,
return new TextFilteredPropertyColumn ( new ResourceModel ( key ) , sortProperty ,
response . renderOnEventJavascript ( "str" , "str" , "str" ) ;
buffer . append ( "str" ) ;
bb . setWar ( "str" ) ;
OpenLayersMap map = getOpenLayerMap ( ) ;
public class OpenLayersMap extends Panel {
public OpenLayersMap addControl ( Control control ) {
public OpenLayersMap addOverlay ( Overlay overlay ) {
public OpenLayersMap clearOverlays ( ) {
public OpenLayersMap removeControl ( Control control ) {
public OpenLayersMap removeOverlay ( Overlay overlay ) {
OpenLayersMap openLayersMap = new OpenLayersMap ( "str" ) ;
. sorted ( ( p1 , p2 ) - > Integer . compare ( p1 . v1 , p2 . v1 ) )
IntentModel < Long , Long , String > intentModel = new FeatureIntentModel < > ( totalData , featureData ) ;
IntentModel < Long , Long , String > intentModel = new FeatureIntentModel < > ( trainData , featureData ) ;
if ( caching & & lazyUserMap . get ( ) . containsKey ( u ) ) {
this ( model . caching , model . caching ? model . lazyUserMap . get ( ) . keySet ( ) . stream ( ) : null ) ;
b . assign ( qi , ( x , y ) - > x + y * Rui * Cui ) ;
double err2 = confidence . apply ( 0 ) * su . assign ( x - > x * x ) . zSum ( ) ;
@NoArgsConstructor ( access = AccessLevel . PACKAGE )
@NoArgsConstructor ( access = AccessLevel . PACKAGE )
@NoArgsConstructor ( access = AccessLevel . PACKAGE )
@NoArgsConstructor ( access = AccessLevel . PACKAGE )
@NoArgsConstructor ( access = AccessLevel . PACKAGE )
@NoArgsConstructor ( access = AccessLevel . PACKAGE )
@NoArgsConstructor ( access = AccessLevel . PACKAGE )
@Profile ( { "str" , "str" } )
@Profile ( { "str" , "str" } )
@Profile ( { "str" , "str" } )
assertThat ( series . getData ( ) , is ( equalTo ( Arrays . asList ( 1.0 , 2 , 3 ) ) ) ) ;
. withData ( 1.0 , 2 )
. withData ( 3.0 , 4 )
. withData ( 1.0 , 2 , 3 )
int src = canvas . saveLayer ( 0 , 0 , bitmap . getWidth ( ) , bitmap . getHeight ( ) , paint , Canvas . ALL_SAVE_FLAG ) ;
while ( SketchUtils . calculateSamplingSize ( outHeight , inSampleSize ) > targetHeight ) {
while ( SketchUtils . calculateSamplingSize ( outWidth , inSampleSize ) > targetWidth ) {
while ( ( SketchUtils . calculateSamplingSize ( outWidth , inSampleSize ) ) * ( SketchUtils . calculateSamplingSize ( outHeight , inSampleSize ) ) > maxPixels ) {
while ( SketchUtils . calculateSamplingSize ( outWidth , inSampleSize ) > maxSize | | SketchUtils . calculateSamplingSize ( outHeight , inSampleSize ) > maxSize ) {
boolean readFully = ( contentLength < = 0 & & httpResponse . isContentChunked ( ) ) | | completedLength = = contentLength ;
. commitAllowingStateLoss ( ) ;
if ( Sketch . META_DATA_KEY_INITIALIZER . equals ( appInfo . metaData . get ( key ) ) ) {
iconImageView . setOnClickListener ( new View . OnClickListener ( ) {
void setImage ( String imageUri , boolean correctImageOrientationDisabled ) {
largeImageViewer . getTileExecutor ( ) . submitInit ( imageUri , initKeyCounter , correctImageOrientationDisabled ) ;
final boolean correctImageOrientationDisabled ) throws DecodeException , IOException {
if ( ! correctImageOrientationDisabled ) {
largeImageViewer . setImage ( imageUri , imageView . getOptions ( ) . isCorrectImageOrientationDisabled ( ) ) ;
public void submitInit ( String imageUri , KeyCounter keyCounter , boolean correctImageOrientationDisabled ) {
initHandler . postInit ( imageUri , correctImageOrientationDisabled , keyCounter . getKey ( ) , keyCounter ) ;
init ( decodeExecutor , wrapper . imageUri , wrapper . correctImageOrientationDisabled , msg . arg1 , wrapper . keyCounter ) ;
public void postInit ( String imageUri , boolean correctImageOrientationDisabled , int key , KeyCounter keyCounter ) {
message . obj = new Wrapper ( imageUri , correctImageOrientationDisabled , keyCounter ) ;
private void init ( TileExecutor decodeExecutor , String imageUri , boolean correctImageOrientationDisabled , int key , KeyCounter keyCounter ) {
decoder = ImageRegionDecoder . build ( decodeExecutor . callback . getContext ( ) , imageUri , correctImageOrientationDisabled ) ;
public boolean correctImageOrientationDisabled ;
public Wrapper ( String imageUri , boolean correctImageOrientationDisabled , KeyCounter keyCounter ) {
this . correctImageOrientationDisabled = correctImageOrientationDisabled ;
void setImage ( String imageUri , boolean correctImageOrientationDisabled ) {
this . tileDecoder . setImage ( imageUri , correctImageOrientationDisabled ) ;
menuList . add ( new CheckMenu ( this , "str" , Settings . PREFERENCE_DISABLE_CORRECT_IMAGE_ORIENTATION , new CheckMenu . OnCheckedChangedListener ( ) {
bitmap = sentBitmap . copy ( sentBitmap . getConfig ( ) ! = null ? sentBitmap . getConfig ( ) : Bitmap . Config . ARGB_8888 , true ) ;
Bitmap blurBitmap = fastGaussianBlur ( bitmap , radius , bitmap . getConfig ( ) ! = null & & bitmap . isMutable ( ) ) ;
if ( Build . VERSION . SDK_INT > = Build . VERSION_CODES . HONEYCOMB & & drawable ! = null ) {
return super . setVisible ( visible , restart ) | | ( drawable ! = null & & drawable . setVisible ( visible , restart ) ) ;
if ( Build . VERSION . SDK_INT > = Build . VERSION_CODES . KITKAT & & drawable ! = null ) {
if ( Build . VERSION . SDK_INT > = Build . VERSION_CODES . LOLLIPOP & & drawable ! = null ) {
if ( Build . VERSION . SDK_INT > = Build . VERSION_CODES . LOLLIPOP & & drawable ! = null ) {
if ( Build . VERSION . SDK_INT > = Build . VERSION_CODES . LOLLIPOP & & drawable ! = null ) {
if ( Build . VERSION . SDK_INT > = Build . VERSION_CODES . LOLLIPOP & & drawable ! = null ) {
if ( Build . VERSION . SDK_INT > = Build . VERSION_CODES . LOLLIPOP & & drawable ! = null ) {
} else if ( one < two ) {
return SketchUtils . safeCompareResult ( o1 . drawRect . top , o2 . drawRect . top ) ;
return SketchUtils . safeCompareResult ( o1 . drawRect . left , o2 . drawRect . left ) ;
DataStreamSource < String > dataStream = env . addSource ( new FlinkKafkaConsumer < String > ( "str" , new SimpleStringSchema ( ) , properties ) ) ;
DataStreamSource < String > dataStream = env . addSource ( new FlinkKafkaConsumer < String > ( "str" , new SimpleStringSchema ( ) , properties ) ) ;
assertTrue ( RuntimeOptionsParser . VERSION . matches ( "str" ) ) ;
private CucumberException couldNotInvokeArgumentConversion ( CucumberBackendException e ) {
if ( unit . equals ( "str" ) ) {
connection . send ( "str" + roundOneDecimal ( c ) ) ;
When ( "str" , ( Double value , String unit ) - >
Then ( "str" , ( Double value , String unit ) - >
wait . until ( ExpectedConditions . elementToBeClickable ( By . id ( "str" ) ) ) ;
handleTestCaseFinished ( event ) ;
private void handleTestCaseFinished ( TestCaseFinished event ) {
} else if ( PluginFactory . isStepDefinitionReporterName ( name ) ) {
public static boolean isStepDefinitionReporterName ( String name ) {
public void should_handle_write_from_a_hook ( ) throws Throwable {
public void should_handle_embed_from_a_hook ( ) throws Throwable {
public void succeeds_if_no_features_are_found ( ) {
final Stats stats ;
public class WeldFactory implements ObjectFactory {
private WeldContainer containerInstance ;
containerInstance = new Weld ( ) . initialize ( ) ;
assertEquals ( "str" , c ) ;
Assert . assertTrue ( ! features . isEmpty ( ) , "str" ) ;
if ( ! beforeHooks . isEmpty ( ) ) {
if ( ! afterHooks . isEmpty ( ) ) {
if ( string = = null | | string . isEmpty ( ) ) {
if ( matches . isEmpty ( ) ) {
if ( ! entry . getValue ( ) . isEmpty ( ) ) {
if ( list . isEmpty ( ) ) {
if ( a . topCells ( ) . size ( ) ! = b . topCells ( ) . size ( ) & & ! b . topCells ( ) . isEmpty ( ) ) {
return ! list . isEmpty ( ) & & xStream . getSingleValueConverter ( list . get ( 0 ) . getClass ( ) ) ! = null ;
} else if ( instances . isEmpty ( ) ) {
xStream . processAnnotations ( getRawType ( ) ) ;
if ( List . class . isAssignableFrom ( getRawType ( ) ) ) {
converter = getConverter ( getRawType ( ) , xStream , locale ) ;
getRawType ( ) . getName ( ) ,
import cucumber . deps . com . thoughtworks . xstream . converters . SingleValueConverter ;
class JavaStepDefinition implements StepDefinition {
throw new CucumberException ( String . format ( "str" , type ) , e ) ;
throw new CucumberException ( String . format ( "str" , type ) , e ) ;
Object [ ] convertedArgs = convertArgs ( args ) ;
private Object [ ] convertArgs ( Object [ ] args ) {
. getCompilerResourcePath ( fileName ) ) , "str" ) ;
return FileUtils . readFileToString ( new File ( TestFileHelper . getIssuesResourcePath ( fileName ) ) , "str" ) ;
private static String [ ] ignoredCases = new String [ ] { "str" , "str" , "str" } ;
if ( skip | | "str" . equals ( when . getValue ( ) ) | | checkCondition ( model , when , template . getExpressionHandler ( ) ) ) {
fail ( e . getMessage ( ) ) ;
} else if ( value . matches ( "str" ) | | value . matches ( "str" ) ) {
private static final Logger logger = LoggerFactory . getLogger ( JadeModel . class ) ;
. collect ( toMap ( ( String path ) - > nameWithoutExtension ( path ) , path - > readYaml ( path ) ) )
} catch ( Throwable e ) {
import java . io . IOException ;
assertThat ( pages ) . hasSize ( 35 ) ;
assertThat ( tags . get ( "str" ) ) . hasSize ( 33 ) ;
assertThat ( categories . get ( "str" ) ) . hasSize ( 33 ) ;
System . out . println ( "str" + fromPath + "str" + toPath + "str" ) ;
throw new IllegalArgumentException ( "str" , e ) ;
return Resources . toUnixString ( path ) ;
return toUnixString ( parent . relativize ( path ) ) ;
return forModelAndView ( ModelAndView . of ( Resources . toUnixString ( path ) ) , context ) ;
return forModelAndView ( ModelAndView . of ( path . toString ( ) . replace ( "str" , "str" ) ) , context ) ;
private static final String [ ] DEFAULT_EXCLUDE = { "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" } ;
get ( "str" ) . produces ( 404 ) ;
return ( Fluent < R > ) filter ( value - > type . isInstance ( value ) ) ;
import org . bukkit . craftbukkit . v1_14_R1 . inventory . CraftInventoryPlayer ;
return new EntityTag ( object ) . getObjectAttribute ( attribute ) ;
else if ( attribute . startsWith ( "str" , 2 ) ) {
( ( Powerable ) data ) . setPowered ( state ) ;
( ( Dispenser ) data ) . setTriggered ( state ) ;
return path . eventArgLowerAt ( 1 ) . equals ( "str" ) ;
registerSpawnedOnlyTag ( "str" , new TagRunnable . ObjectForm < EntityTag > ( ) {
super ( false , script = = null | | script . getContainer ( ) . shouldDebug ( ) , null , script ) ;
String group = subSection . contains ( "str" ) ? subSection . getString ( "str" ) : "str" ;
registerTag ( "str" , tagProcessor . registeredObjectTags . get ( "str" ) ) ;
if ( key . b ( ) . equalsIgnoreCase ( "str" ) ) {
queue = new TimedQueue ( script . getName ( ) ) . setSpeed ( speedTicks ) ;
queue = new InstantQueue ( script . getName ( ) ) ;
if ( messageLow . contains ( subkeyword ) ) {
Debug . report ( scriptEntry , getName ( ) , action . debug ( ) + debug + ArgumentHelper . debugObj ( "str" , players . debuggable ( ) ) ) ;
if ( ( scores = = null | | scores . size ( ) = = 0 ) & & perScores = = null ) {
if ( ( value = = null | | value . size ( ) ! = scores . size ( ) ) & & perValue = = null ) {
else if ( getBlockTypeForTag ( attribute ) = = Material . FLOWER_POT ) {
else if ( material . getMaterial ( ) = = new LocationTag ( tstart . clone ( ) . add ( x , y , z ) ) . getBlockTypeForTag ( attribute ) ) {
Debug . echoError ( "str" + getBlockTypeForTag ( attribute ) . name ( ) + "str" ) ;
Debug . echoError ( "str" + getBlockTypeForTag ( attribute ) . name ( ) + "str" ) ;
if ( loc . getBlockTypeForTag ( attribute ) . name ( ) . equalsIgnoreCase ( ( ( MaterialTag ) material ) . getMaterial ( ) . name ( ) ) ) {
arg = ObjectFetcher . getObjectFrom ( object_class , object , scriptEntry . entryData . getTagContext ( ) ) ;
ScriptEventRegistry . registerMainEvents ( ) ;
public static void registerMainEvents ( ) {
item = event . getCurrentItem ( ) = = null ? new ItemTag ( Material . AIR ) : new ItemTag ( event . getCurrentItem ( ) ) ;
recipe . setIngredients ( Arrays . asList ( new ItemStack ( Material . AIR ) ) ) ;
return ( ( CraftMagicNumbers ) CraftMagicNumbers . INSTANCE ) . getMappingsVersion ( ) . equals ( "str" ) ;
context . put ( "str" , new EntityTag ( killerEntity ) . getDenizenObject ( ) ) ;
context . put ( "str" , new EntityTag ( ( LivingEntity ) shooter ) . getDenizenObject ( ) ) ;
if ( NMSHandler . getVersion ( ) . isAtLeast ( NMSVersion . v1_13_R2 ) ) {
if ( NMSHandler . getVersion ( ) . isAtLeast ( NMSVersion . v1_13_R2 ) ) {
if ( NMSHandler . getVersion ( ) . isAtLeast ( NMSVersion . v1_13_R2 ) ) {
String chunkString = e . getChunk ( ) . getX ( ) + "str" + e . getChunk ( ) . getZ ( ) + "str" + e . getChunk ( ) . getWorld ( ) . getName ( ) ;
if ( saved . getX ( ) ! = location . getX ( ) ) {
if ( saved . getY ( ) ! = location . getY ( ) ) {
else if ( ! MaterialCompat . isAnySign ( sign . getType ( ) ) ) {
import net . aufdemrand . denizencore . scripts . commands . core . SQLCommand ;
return new Element ( ( ( ArmorStand ) dentity . getBukkitEntity ( ) ) . hasArms ( ) )
return ( ( CraftMagicNumbers ) CraftMagicNumbers . INSTANCE ) . getMappingsVersion ( ) . equals ( "str" ) ;
context . put ( "str" , dInventory . mirrorBukkitInventory ( event . getClickedInventory ( ) ) ) ;
String fullMessage = ChatColor . LIGHT_PURPLE + "str" + ChatColor . RED + "str" +
to = event . getTo ( ) = = null ? null : new dLocation ( event . getTo ( ) ) ;
String name = determination . substring ( "str" . length ( ) ) ;
String rec_new = determination . substring ( "str" . length ( ) ) ;
if ( mechanism . matches ( "str" ) & & mechanism . requireObject ( dPlayer . class ) ) {
if ( mechanism . matches ( "str" ) & & mechanism . requireObject ( dNPC . class ) ) {
List < String > properties = ObjectFetcher . separateProperties ( "str" + attribute . getContext ( 1 ) + "str" ) ;
return EscapeTags . escape ( item . getItemStack ( ) . getItemMeta ( ) . getDisplayName ( ) ) ;
sb . append ( EscapeTags . escape ( cont . getString ( "str" ) ) ) . append ( "str" ) ;
output . append ( EscapeTags . escape ( itemLore ) ) . append ( "str" ) ;
current . append ( EscapeTags . escape ( set . getString ( i + 1 ) ) ) . append ( "str" ) ;
current . append ( EscapeTags . escape ( set . getString ( i + 1 ) ) ) . append ( "str" ) ;
current . append ( EscapeTags . escape ( set . getString ( i + 1 ) ) ) . append ( "str" ) ;
output . append ( EscapeTags . escape ( page ) ) . append ( "str" ) ;
list . add ( EscapeTags . escape ( atr . attr ) + "str" + EscapeTags . escape ( atr . slot ) + "str" + atr . op + "str" + atr . amt ) ;
String text = getFormat ( ) . replace ( "str" , "str" + EscapeTags . escape ( textToReplace ) + "str" ) ;
public static long warningRate ( ) {
. getLong ( "str" , 10000 ) ;
dB . echoError ( "str" + split [ 1 ] + "str" ) ;
NMSHandler . getInstance ( ) . createBlockLight ( location , brightness , duration = = null ? 0 : duration . getTicks ( ) ) ;
scriptEntry . addObject ( "str" , particleHelper . getParticle ( arg . getValue ( ) ) ) ;
if ( nmsItemStack ! = null & & nmsItemStack . hasTag ( ) ) {
if ( nmsItemStack ! = null & & nmsItemStack . hasTag ( ) ) {
if ( nmsItemStack ! = null & & nmsItemStack . hasTag ( ) ) {
private static Denizen denizen ;
URL url = new URL ( "str" ) ;
URL url = new URL ( "str" + ID ) ;
sender . sendMessage ( ChatColor . RED + "str" + ID ) ;
URL url = new URL ( "str" ) ;
Messaging . send ( sender , "str" + submit . Result ) ;
DyeColor color = ( ( Banner ) getBlock ( ) . getState ( ) ) . getBaseColor ( ) ;
for ( org . bukkit . block . banner . Pattern pattern : ( ( Banner ) getBlock ( ) . getState ( ) ) . getPatterns ( ) ) {
min = 1 , max = 3 , permission = "str" , flags = "str" )
profileField = EntityHuman . class . getDeclaredField ( "str" ) ;
return new dEntity ( possibleTarget ) . getDenizenObject ( ) . getAttribute ( attribute . fulfill ( attribs ) ) ;
livingHandle . aO = yaw ;
livingHandle . aM = yaw ;
livingHandle . aP = yaw ;
"str" , "str" , 0 ) ;
scriptEntry . addObject ( "str" , new Element ( "str" ) ) ;
scriptEntry . addObject ( "str" , new Element ( "str" ) ) ;
public enum Type { MAXIMUM , REMAINING }
public enum Mode { SET , ADD , REMOVE }
switch ( Mode . valueOf ( mode . asString ( ) . toUpperCase ( ) ) ) {
switch ( Mode . valueOf ( mode . asString ( ) . toUpperCase ( ) ) ) {
dB . report ( scriptEntry , getName ( ) , ( location ! = null ? location . debug ( ) : "str" ) + reset . debug ( ) ) ;
else if ( ! scriptEntry . hasObject ( "str" )
else if ( ! scriptEntry . hasObject ( "str" )
new Element ( d2 [ 4 ] ) . asBoolean ( ) , d2 . length > 5 ? dColor . valueOf ( d2 [ 5 ] . replace ( "str" , "str" ) ) . getColor ( ) : null ) , false ) ;
. append ( pot . hasParticles ( ) ) ;
sb . append ( "str" ) . append ( new dColor ( pot . getColor ( ) ) . identify ( ) . replace ( "str" , "str" ) ) ;
String [ ] d1 = data . get ( 0 ) . split ( "str" ) ;
if ( event . getHand ( ) = = EquipmentSlot . OFF_HAND ) {
if ( event . getHand ( ) = = EquipmentSlot . OFF_HAND ) {
if ( event . getHand ( ) = = EquipmentSlot . OFF_HAND ) {
if ( ( entity1 . aT ( ) ) & & ( ( entity1 ! = shooter ) | | ( age > = 5 ) ) ) {
"str" , "str" , 2 ) ;
import net . minecraft . server . v1_9_R1 . EntitySpectralArrow ;
public class FakeArrowEntity extends EntitySpectralArrow {
lore . add ( 0 , ItemScriptHelper . createItemScriptID ( item . getScriptName ( ) ) ) ;
dB . log ( "str" + "str" + string ) ;
dB . log ( "str" + "str" + string ) ;
dB . log ( "str" + string + "str" + e . getMessage ( ) + "str" ) ;
dB . log ( "str" + string + "str" + e . getMessage ( ) + "str" ) ;
String [ ] itemsInLine = items . substring ( 1 , items . length ( ) - 1 ) . split ( "str" , - 1 ) ;
this . a ( ( float ) 0.25F , ( float ) 0.25F ) ;
return new Element ( JSON . substring ( 176 , JSON . length ( ) - 185 ) )
GRANITE , POLISHED_GRANITE , DIORITE , POLISHED_DIORITE , ANDESITE , POLISHED_ANDESITE , COARSE_DIRT }
. getInt ( "str" , 100 ) ;
context . put ( "str" , new dEntity ( event . getIgnitingEntity ( ) ) ) ;
return new Element ( "str" ) . getAttribute ( attribute . fulfill ( 1 ) ) ;
if ( attribute . startsWith ( "str" ) )
if ( ! ScriptQueue . _queueExists ( event . getNameContext ( ) ) )
if ( attribute . startsWith ( "str" ) & & ! isSpawned ( ) ) {
return new dLocation ( entity . getLocation ( ) . clone ( ) . add ( 0 , - 0.5f , 0 ) )
. replace ( ( char ) 0x06 , "str" )
. replace ( ( char ) 0x06 , "str" ) ;
. replace ( "str" , ( char ) 0x06 ) ;
. replaceAll ( "str" , replacer ) ;
. replaceAll ( "str" , replacer ) ;
. replace ( ( char ) 0x05 , "str" )
. replace ( ( char ) 0x05 , "str" ) ;
. replace ( "str" , ( char ) 0x05 ) ;
dB . echoDebug ( event . getScriptEntry ( ) , "str" + id + "str" ) ;
dB . echoDebug ( event . getScriptEntry ( ) , "str" + attribute . getAttribute ( 2 ) + "str" ) ;
Set < String > inProgress = denizen . getSaves ( ) . getConfigurationSection ( "str" + player . getSaveName ( ) ) . getKeys ( false ) ;
dB . echoError ( scriptEntry . getResidingQueue ( ) , "str" ) ;
dB . echoError ( scriptEntry . getResidingQueue ( ) , "str" ) ;
dB . echoError ( scriptEntry . getResidingQueue ( ) , "str" ) ;
dB . echoError ( scriptEntry . getResidingQueue ( ) , "str" + sqlID . asString ( ) + "str" ) ;
dB . echoError ( scriptEntry . getResidingQueue ( ) , "str" + e . getMessage ( ) ) ;
dB . echoError ( scriptEntry . getResidingQueue ( ) , "str" + sqlID . asString ( ) + "str" ) ;
dB . echoError ( scriptEntry . getResidingQueue ( ) , "str" ) ;
dB . echoError ( scriptEntry . getResidingQueue ( ) , "str" + sqlID . asString ( ) + "str" ) ;
dB . echoError ( scriptEntry . getResidingQueue ( ) , "str" ) ;
dB . echoError ( scriptEntry . getResidingQueue ( ) , "str" + sqlID . asString ( ) + "str" ) ;
dB . echoError ( scriptEntry . getResidingQueue ( ) , "str" + action . asString ( ) + "str" ) ;
dB . echoError ( scriptEntry . getResidingQueue ( ) , "str" + e . getMessage ( ) ) ;
if ( ! event . hasAlternative ( ) ) dB . echoError ( "str" + attribute . getContext ( 1 ) + "str" ) ;
if ( ! event . hasAlternative ( ) ) dB . echoError ( "str" + event . raw_tag + "str" ) ;
if ( ! event . hasAlternative ( ) ) dB . echoError ( "str" + event . raw_tag + "str" ) ;
null , event . getPlayer ( ) ! = null ? new dPlayer ( event . getPlayer ( ) ) : null , context , true ) ;
dB . echoDebug ( event . getScriptEntry ( ) , "str" + id ) ;
dB . echoDebug ( event . getScriptEntry ( ) , "str" + attribute . getAttribute ( 2 ) ) ;
else if ( type = = Type . WALL_SIGN )
dList list = new dList ( ) ;
return new dLocation ( getLivingEntity ( ) . getTargetBlock ( null , range ) . getLocation ( ) . clone ( ) )
return new dLocation ( entity . getLocation ( ) . clone ( ) . add ( 0 , - 1 , 0 ) )
scriptEntry . defaultObject ( "str" , new Element ( 15 ) ) ;
int theAmount = ( int ) qty . asDouble ( ) ;
is . setAmount ( ( int ) qty . asDouble ( ) ) ;
return new dLocation ( getWorld ( ) . getHighestBlockAt ( this ) . getLocation ( ) . add ( 0 , - 1 , 0 ) )
dB . echoDebug ( "str" + arg . getValue ( ) ) ;
dB . echoDebug ( "str" + arg . getValue ( ) ) ;
? new dEntity ( getCitizen ( ) ) . getAttribute ( attribute )
dItem itemFrame = new dItem ( ( ( ItemFrame ) entity . getBukkitEntity ( ) ) . getItem ( ) ) ;
final boolean freeflight = destinations . size ( ) < 1 ;
return new Element ( getLivingEntity ( ) . getCustomName ( ) ) . getAttribute ( attribute . fulfill ( 1 ) ) ;
final static Pattern materialPattern = Pattern . compile ( "str" , Pattern . CASE_INSENSITIVE ) ;
dList entityList = new dList ( ) ;
if ( attribute . attributes . size ( ) > 0 ) {
dB . report ( getName ( ) , action . debug ( ) + ( type ! = null ? type . debug ( ) : "str" )
else if ( arg . matchesPrefix ( "str" ) )
blocks = new dList ( ( List < String > ) get ( "str" ) ) ;
if ( attribute . startsWith ( "str" )
if ( attribute . startsWith ( "str" )
( scriptEntry . getScript ( ) = = null ? null : scriptEntry . getScript ( ) . getContainer ( ) ) )
scriptEntry . addObject ( "str" , new Element ( - 1 ) ) ;
if ( amountelement . asDouble ( ) = = - 1 )
"str" , "str" , 0 ) ;
( scriptEntry . getPlayer ( ) ! = null ? scriptEntry . getPlayer ( ) . debug ( ) : "str" )
scriptEntry . getResidingQueue ( ) . context . get ( m . group ( 1 ) . toLowerCase ( ) ) ) ;
arg = TagManager . tag ( scriptEntry . getPlayer ( ) , scriptEntry . getNPC ( ) , arg , false ) ;
if ( raw_tag . split ( "str" , attribute ) [ attribute - 1 ] . toLowerCase ( ) . startsWith ( string ) ) return true ;
} catch ( Exception e ) { dB . echoDebug ( "str" + aH . getStringFrom ( arg ) + "str" ) ; }
import net . minecraft . server . v1_6_R1 . EntityLiving ;
import org . bukkit . craftbukkit . v1_6_R1 . entity . CraftLivingEntity ;
return dList . valueOf ( aH . getStringFrom ( arg ) ) ;
return dPlayer . valueOf ( aH . getStringFrom ( arg ) ) ;
return dNPC . valueOf ( aH . getStringFrom ( arg ) ) ;
if ( thisRegion . getId ( ) . equalsIgnoreCase ( region ) ) {
if ( sound ) scriptEntry . getPlayer ( ) . getWorld ( ) . playSound ( location , Sound . CHEST_CLOSE , 1 , 1 ) ;
. getBoolean ( "str" , false ) ;
event . setReplaced ( item_to_trim . substring ( from - 1 , to ) ) ;
( Player ) event . getDamager ( ) ,
final Pattern matchesDurationPtrn = Pattern . compile ( "str" , Pattern . CASE_INSENSITIVE ) ;
final static Pattern matchesDurationPtrn = Pattern . compile ( "str" , Pattern . CASE_INSENSITIVE ) ;
exitRadius = Integer . valueOf ( script . getTriggerOptionFor ( getClass ( ) , player , null , "str" ) ) ;
moveRadius = Integer . valueOf ( script . getTriggerOptionFor ( getClass ( ) , player , null , "str" ) ) ;
dB . echoDebug ( "str" + moveRadius + "str" ) ;
dB . echoDebug ( "str" + id + "str" ) ;
+ teleportLocation . debug ( ) + "str"
npc . spawn ( teleportLocation ) ;
int qty = aH . getIntegerFrom ( specifierContext ) ;
if ( speed = = null ) speed = new Duration ( ( ( double ) Settings . InteractDelayInTicks ( ) / 20 ) ) ;
dB . log ( "str" + id + "str" + ticks + "str" ) ;
Duration speed = new Duration ( Settings . InteractDelayInTicks ( ) / 20 ) ;
set ( "str" , speed . getSeconds ( ) ) ;
Duration speed = Duration . valueOf ( getString ( "str" , null ) ) ;
tag = tag . substring ( basecontextMatcher . end ( ) ) . trim ( ) ;
tag = tag . substring ( 0 , alternativeMatcher . start ( ) ) . trim ( ) ;
Duration speed = Duration . valueOf ( getString ( "str" , "str" ) ) ;
Script itemScript = Script . valueOf ( m [ 0 ] . group ( 1 ) ) ;
if ( plugin . getRequirementRegistry ( ) . list ( ) . containsKey ( reqEntry . split ( "str" ) [ 0 ] . toUpperCase ( ) ) ) {
public AbstractListener getListenerFor ( OfflinePlayer player , String listenerId ) {
public Map < String , AbstractListener > getListenersFor ( OfflinePlayer player ) {
for ( Map . Entry < String , AbstractListener > entry : getListenersFor ( ( OfflinePlayer ) player ) . entrySet ( ) ) {
if ( index < = 0 & & obj ! = null ) {
if ( val . equalsIgnoreCase ( String . valueOf ( obj ) ) ) {
new ScribeCommand ( ) . activate ( ) . as ( "str" ) . withOptions ( "str" , 0 ) ;
radius . put ( triggerName . toUpperCase ( ) , value ) ;
trait . setLocalRadius ( args . getFlag ( "str" ) , args . getFlagInteger ( "str" ) ) ;
if ( aH . matchesQuantity ( arg ) | | aH . matchesInteger ( arg ) | | aH . matchesDouble ( arg ) ) {
dB . echoDebug ( "str" , context . mode . getMode ( ) . toString ( ) ) ;
else if ( subType . equals ( "str" ) )
} catch ( Exception e ) { e . printStackTrace ( ) ; replaceType = ReplaceType . ASSTRING ; }
for ( Integer npcid : links ) {
new ChatTrigger ( ) . activate ( ) . as ( "str" ) . withOptions ( true , 0.5 , CooldownType . PLAYER ) ;
for ( String string : names . split ( "str" ) )
if ( ! argument . split ( "str" ) [ 0 ] . equalsIgnoreCase ( argumentName ) ) return false ;
dB . echoApproval ( "str" + assignment + "str" ) ;
dB . echoDebug ( "str" + assignment + "str" ) ;
desc = "str" , modifiers = { "str" } ,
desc = "str" , modifiers = { "str" } ,
if ( args . length ( ) > 2 ) {
new DamageTrigger ( ) . activate ( ) . as ( "str" ) . withOptions ( false , 0.5 , CooldownType . NPC ) ;
private String assignment = null ;
if ( assignment ! = null & & assignment . equalsIgnoreCase ( npc . getTrait ( AssignmentTrait . class ) . getAssignment ( ) ) )
pushable = key . getBoolean ( "str" , true ) ;
int incValue = Integer . valueOf ( plugin . getSaves ( ) . getString ( "str" + theDenizen . getName ( ) + "str" + theDenizen . getId ( ) + "str" + theFlag , "str" ) ) + 1 ;
int incValue = Integer . valueOf ( plugin . getSaves ( ) . getString ( "str" + theDenizen . getName ( ) + "str" + theDenizen . getId ( ) + "str" + theFlag , "str" ) ) - 1 ;
plugin . getSaves ( ) . set ( "str" + theDenizen . getName ( ) + "str" + theDenizen . getId ( ) + "str" + theFlag , theValue ) ;
plugin . getSaves ( ) . set ( "str" + theDenizen . getName ( ) + "str" + theDenizen . getId ( ) + "str" + theFlag , theValue ) ;
if ( plugin . debugMode ) cs . sendMessage ( ChatColor . LIGHT_PURPLE + "str" + ChatColor . RED + "str" + ChatColor . WHITE + "str" ) ;
aH . echoDebug ( "str" + chatTriggers . get ( x - 1 ) + "str" ) ;
return plugin . bookmarks . get ( denizenNPC , thisArg . split ( "str" ) [ 1 ] , BookmarkType . LOCATION ) ;
if ( plugin . getSaves ( ) . contains ( "str" + theScript + "str" ) ) {
if ( isGlobal ) {
echoDebug ( "str" , thisArg ) ;
echoDebug ( "str" , thisArg ) ;
echoDebug ( "str" , thisArg ) ;
echoDebug ( "str" , thisArg ) ;
plugin . getSaves ( ) . set ( "str" + theEntry . getPlayer ( ) . getName ( ) + "str" + theScript + "str" , System . currentTimeMillis ( ) + ( duration * 1000 ) ) ;
loc . setYaw ( loc . getYaw ( ) * 180 f / ( float ) Math . PI ) ;
if ( citizensNPC . getTrait ( LookClose . class ) . toggle ( ) )
if ( ! citizensNPC . getTrait ( LookClose . class ) . toggle ( ) )
if ( ! theEntry . getPlayer ( ) . getInventory ( ) . removeItem ( item ) . isEmpty ( ) )
if ( plugin . showStackTraces ) e . printStackTrace ( ) ;
} catch ( Throwable e ) {
if ( event . getPlayer ( ) . hasMetadata ( "str" ) ) {
private boolean isToggled = true ;
isToggled = key . getBoolean ( "str" , false ) ;
if ( thePlayer . isOp ( ) & & thePlayer . isSneaking ( ) ) {
plugin . scriptEngine . parseClickScript ( theDenizen , thePlayer , theScript ) ;
if ( taskQue . containsKey ( thePlayer ) )
interactScripts . add ( thisScript ) ;
interactScripts . add ( thisScript . split ( "str" , 2 ) [ 1 ] ) ;
if ( Files . notExists ( defaultConfigFile ) ) {
private static final String EMAIL_REGEX = "str" ;
+ "str" ) ) ;
. put ( JAVA , RpcType . PAGED_STREAMING , RequestPaged )
. put ( NODEJS , RpcType . PAGED_STREAMING , RequestAsyncPagedAll )
return packageFilePathPiece ( Name . anyCamel ( getGrpcTransportClassName ( interfaceConfig ) ) ) ;
longRunningConfigProto . getMetadataType ( ) ) ) ;
longRunningConfigProto . getMetadataType ( ) ) ) ;
method . getRequestStreaming ( )
. targetLanguage ( "str" )
if ( id . equals ( PYTHON ) ) {
. put ( Field . Kind . TYPE_INT64 , "str" )
. put ( Field . Kind . TYPE_UINT64 , "str" )
. put ( Type . TYPE_BYTES , "str" )
public ImmutableList < String > getFormattedAuthScopes ( Method method ) {
private String getGrpcClientVariableNameFor ( Interface service , Method method ) {
return stub . grpcClientVariableName ( ) ;
+ getGrpcClientVariableNameFor ( service , method )
public TypeRef getResourceType ( Field field ) {
if ( ! baseURI . endsWith ( "str" ) ) baseURI + = "str" ;
@WebService ( targetNamespace = "str" )
QName serviceName = new QName ( "str" , "str" ) ;
private static final String REST_TARGET_URL = "str" ;
private static final String REST_TARGET_URL = "str" ;
if ( name . isEmpty ( ) ) {
import static org . jboss . as . quickstarts . temperatureconverter . ejb . Scale . FAHRENHEIT ;
CELSIUS ( "str" ) , FAHRENHEIT ( "str" ) ;
out . write ( "str" ) ;
private ConnectionFactory connectionFactory ;
private Queue queue ;
@Pattern ( regexp = "str" )
assert currentBranchName ! = null : "str" ;
private ShowProjectColumn showProjectColumn = ShowProjectColumn . AUTO ;
String message = String . format ( "str" , method . getStatusText ( ) , method . getStatusCode ( ) ) ;
if ( mPost ! = null & & mMail . isRefferedPost ( ) ) {
. subscribe ( new Subscriber < AjaxResponse > ( ) {
if ( target ! = null & & target . contains ( "str" ) ) strNoansi = "str" ;
. subscribe ( new Subscriber < AjaxResponse > ( ) { java . lang . NullPointerException
private QueryTextListener mQueryListener = null ;
mSearchView . setOnQueryTextListener ( mQueryListener ) ;
public class QueryTextListener implements SearchView . OnQueryTextListener {
public QueryTextListener ( BoardRecyclerViewAdapter mAdapter ) {
mRecyclerView . setLayoutManager ( new WrapContentLinearLayoutManager ( context ) ) ;
LinearLayoutManager linearLayoutManager = new WrapContentLinearLayoutManager ( this ) ;
mRecyclerView . setLayoutManager ( new WrapContentLinearLayoutManager ( context ) ) ;
mRecyclerView . setLayoutManager ( new WrapContentLinearLayoutManager ( context ) ) ;
LinearLayoutManager linearLayoutManager = new WrapContentLinearLayoutManager ( context ) ;
bLoadOriginalImage = mPreference . getBoolean ( LOAD_ORIGINAL_IMAGE , false ) ;
notificationIntent . setFlags ( Intent . FLAG_ACTIVITY_CLEAR_TOP ) ;
return username . length ( ) > 0 ;
return password . length ( ) > 0 ;
holder . mView . setBackgroundDrawable ( ContextCompat . getDrawable ( SMTHApplication . getAppContext ( ) , R . drawable . recyclerview_sticky_item_bg ) ) ;
holder . mView . setBackgroundDrawable ( ContextCompat . getDrawable ( SMTHApplication . getAppContext ( ) , R . drawable . recyclerview_item_bg ) ) ;
private RecyclerView mRecyclerView = null ;
mRecyclerView = ( RecyclerView ) rootView . findViewById ( R . id . guidance_recycler_view ) ;
mRecyclerView . setLayoutManager ( new LinearLayoutManager ( context ) ) ;
mRecyclerView . setLayoutManager ( new GridLayoutManager ( context , mColumnCount ) ) ;
mRecyclerView . setAdapter ( new GuidanceRecyclerViewAdapter ( GuidanceContent . ITEMS , mListener ) ) ;
mRecyclerView . getAdapter ( ) . notifyItemInserted ( GuidanceContent . ITEMS . size ( ) ) ;
Consumer < List < String > > cons = null ;
Consumer < List < String > > cons = null ;
Map < String , Long > result = null ;
return atan ( y . divide ( x , mc ) , mc ) . add ( pi ( mc ) , mathContext ) ;
return atan ( y . divide ( x , mc ) , mc ) . subtract ( pi ( mc ) , mathContext ) ;
BigDecimalMath . atanh ( BigDecimal . valueOf ( 0 ) , MathContext . UNLIMITED ) ;
if ( result . multiply ( result ) . compareTo ( x ) = = 0 ) {
return round ( factorial ( x . intValueExact ( ) ) , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( value , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( pi , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
return round ( result , mathContext ) ;
BigDecimal result = BigDecimalMath . atan2 ( x , y , mathContext ) ;
BigRational factor = getCurrentFactor ( ) ;
protected abstract BigRational getCurrentFactor ( ) ;
protected BigRational getCurrentFactor ( ) {
protected BigRational getCurrentFactor ( ) {
return value . setScale ( MC_CHECK_DOUBLE . getPrecision ( ) , MC_CHECK_DOUBLE . getRoundingMode ( ) ) ;
return gPrefs . getBoolean ( IP6_FWD , true ) ;
return gPrefs . getBoolean ( IP6_INPUT , true ) ;
return gPrefs . getBoolean ( IP6_OUTPUT , true ) ;
return gPrefs . getBoolean ( ENABLE_IPV6 , true ) ;
return gPrefs . getBoolean ( ACTIVE_NOTIFICATION , true ) ;
if ( G . initPath ( ) ! = null & & ! G . initPath ( ) . isEmpty ( ) ) {
if ( updateCheckbox ) {
"str" , "str" , "str" , "str" , "str" } ;
InterfaceDetails cfg = InterfaceTracker . getCurrentCfg ( ctx ) ;
private static InterfaceDetails getInterfaceDetails ( Context context ) {
populateLogMessage ( findPreference ( "str" ) ) ;
private void populateLogMessage ( Preference logDmesg ) {
val . add ( "str" ) ;
private void startAction ( final int i ) {
Api . donateDialog ( MainActivity . this ) ;
public static boolean isXposedDM ( boolean val ) { gPrefs . edit ( ) . putBoolean ( XPOSED_FIX_DM_LEAK , val ) . commit ( ) ; return val ; }
public static boolean enableIPv6 ( ) { return gPrefs . getBoolean ( ENABLE_IPV6 , true ) ; }
if ( line ! = null & & ! line . equals ( "str" ) ) {
public void menuSetApplyOrSave ( final Menu menu , final boolean isEnabled ) {
. cancelable ( true )
. cancelable ( true )
setIpTablePath ( ctx , true ) ;
Api . toast ( ctx , ctx . getString ( R . string . export_rules_fail ) ) ;
private static boolean importRules ( Context ctx , File file , StringBuilder msg ) {
protected static StringBuilder result ;
public static boolean enableRoam ( ) { return gPrefs . getBoolean ( ENABLE_ROAM , false ) ; }
public static boolean enableLAN ( ) { return gPrefs . getBoolean ( ENABLE_LAN , true ) ; }
public static boolean disableIcons ( ) { return gPrefs . getBoolean ( DISABLE_ICONS , true ) ; }
scaleGesture . setTextSize ( TypedValue . COMPLEX_UNIT_PX , scaleGesture . getTextSize ( ) + 2.0f ) ;
scaleGesture . setTextSize ( TypedValue . COMPLEX_UNIT_PX , scaleGesture . getTextSize ( ) - 2.0f ) ;
G . setProfile ( multimode , ( id - 2 ) ) ;
if ( whitelist & & enableDNSProxy ( ) ) {
AFWALL_CHAIN_NAME = "str" + G . getMultiUserId ( ) ;
G . setProfile ( false , ( id - 2 ) ) ;
List < PackageInfoData > searchApp = Collections . synchronizedList ( new ArrayList < PackageInfoData > ( ) ) ;
final List < PackageInfoData > apps2 = isResultsFound ? searchApp : searchStr . equals ( "str" ) ? apps : Collections . synchronizedList ( new ArrayList < Api . PackageInfoData > ( ) ) ;
mDividerHeight = a . getDimensionPixelSize ( R . styleable . StickyListHeadersListView_android_dividerHeight , mDividerHeight ) ;
if ( getAdapter ( ) = = null | | getAdapter ( ) . getCount ( ) = = 0 ) return ;
import com . emilsjolander . components . StickyListHeaders . StickyListHeadersListView ;
private StickyListHeadersListView stickyList ;
stickyList = ( StickyListHeadersListView ) findViewById ( R . id . list ) ;
Block block = state = = null ? null : state . getBlock ( ) ;
Block block = state = = null ? null : state . getBlock ( ) ;
List < Integer > temp = new ArrayList < > ( ) ;
final HashMap < String , Integer > map = new HashMap < > ( ids . size ( ) , 1F ) ;
ArrayList < CelestialBody > cBodyList = new ArrayList < > ( ) ;
int index = Arrays . binarySearch ( ConfigManagerCore . staticLoadDimensions , registeredID ) ;
int providerID = index > = 0 ? worldDataTemp . getDimensionIdStatic ( ) : worldDataTemp . getDimensionIdDynamic ( ) ;
registrationOK = DimensionManager . getProviderType ( registeredID ) . getId ( ) = = providerID ;
result . put ( registeredID , WorldUtil . getDimensionTypeById ( providerID ) ) ;
if ( index > = 0 )
WorldUtil . registeredPlanets = new ArrayList < > ( ) ;
List < Object > objList = new ArrayList < > ( ) ;
WorldUtil . registeredPlanets = new ArrayList < > ( ) ;
List < Object > objList = new ArrayList < > ( ) ;
public FluidTank buggyFuelTank = new FluidTank ( EntityBuggy . tankCapacity ) ;
this . setSize ( 1.4F , 0.6F ) ;
return ( int ) ( fuelLevel * i / EntityBuggy . tankCapacity ) ;
entityItem . getItem ( ) . setTagCompound ( item . getTagCompound ( ) . copy ( ) ) ;
ItemStackHelper . loadAllItems ( nbt , this . getInventory ( ) ) ;
ItemStackHelper . saveAllItems ( nbt , this . getInventory ( ) ) ;
this . sneakLast = this . movementInput = = null ? false : this . movementInput . sneak ;
spaceshipRender . doRender ( OverlayRocket . minecraft . player . getRidingEntity ( ) . getClass ( ) . getConstructor ( World . class ) . newInstance ( OverlayRocket . minecraft . player . world ) , 0 , 0 , 0 , 0 , 0 ) ;
private static final DataParameter < Float > SPIN_PITCH = EntityDataManager . createKey ( EntityEvolvedZombie . class , DataSerializers . FLOAT ) ;
if ( biomes = = null | | biomes . length < size )
C_UPDATE_CONFIGS ( Side . CLIENT , Integer . class , Double . class , Integer . class , Integer . class , Integer . class , String . class , Boolean . class , Float . class , Float . class , Float . class , Float . class , Integer . class , String [ ] . class ) ,
EnergyConfigHandler . setConfigOverride ( ( Float ) configs . get ( 7 ) , ( Float ) configs . get ( 8 ) , ( Float ) configs . get ( 9 ) , ( Float ) configs . get ( 10 ) , ( Integer ) configs . get ( 11 ) ) ;
int sizeIDs = configs . size ( ) - 12 ;
if ( configs . get ( 12 ) instanceof String )
ConfigManagerCore . detectableIDs [ j ] = new String ( ( String ) configs . get ( 12 + j ) ) ;
ConfigManagerCore . detectableIDs = ( ( String [ ] ) configs . get ( 12 ) ) ;
OreDictionary . registerOre ( "str" , new ItemStack ( GCItems . itemBasicMoon , 1 , 1 ) ) ;
this . getEntityAttribute ( SharedMonsterAttributes . movementSpeed ) . setBaseValue ( 0.25D ) ;
Field f = c . getDeclaredField ( getNameDynamic ( KEY_FIELD_CLASSTOIDMAPPING ) ) ;
Field f = c . getDeclaredField ( getNameDynamic ( KEY_FIELD_CLASSTOIDMAPPING ) ) ;
if ( this . compressingCraftMatrix . getStackInSlot ( i ) ! = null & & this . compressingCraftMatrix . getStackInSlot ( i ) . getItem ( ) = = Items . water_bucket )
if ( this . compressingCraftMatrix . getStackInSlot ( i ) ! = null & & this . compressingCraftMatrix . getStackInSlot ( i ) . getItem ( ) = = Items . water_bucket )
GCBlocks . crudeOil . setBlockName ( "str" ) ;
GCBlocks . fuel . setBlockName ( "str" ) ;
playerAPI . localOnUpdate ( ) ;
prop . comment = "str" ;
} catch ( UnsatisfiedLinkError e )
input = new HashMap < Integer , ItemStack > ( ) ;
if ( ! this . worldObj . isRemote ) TileEntityOxygenSealer . loadedTiles . remove ( this ) ;
if ( ! this . worldObj . isRemote ) TileEntityOxygenSealer . loadedTiles . remove ( this ) ;
status = GCCoreUtil . translate ( "str" ) + "str" + ( int ) ( 0.5F + Math . min ( this . collector . lastOxygenCollected * 20 F , TileEntityOxygenCollector . OUTPUT_PER_TICK * 20 F ) ) + GCCoreUtil . translate ( "str" ) ;
e = ( float ) ( ( ( ( IStrictEnergyAcceptor ) acceptor ) . getMaxEnergy ( ) - ( ( IStrictEnergyAcceptor ) acceptor ) . getEnergy ( ) ) / EnergyConfigHandler . TO_MEKANISM_RATIO ) ;
e = ( ( IEnergyHandler ) acceptor ) . receiveEnergy ( sideFrom , Integer . MAX_VALUE , true ) / EnergyConfigHandler . TO_RF_RATIO ;
e = ( ( IEnergyReceiver ) acceptor ) . receiveEnergy ( sideFrom , Integer . MAX_VALUE , true ) / EnergyConfigHandler . TO_RF_RATIO ;
e = ( float ) result / EnergyConfigHandler . TO_IC2_RATIO ;
e = ( float ) MjAPI . getMjBattery ( acceptor , MjAPI . DEFAULT_POWER_FRAMEWORK , sideFrom ) . getEnergyRequested ( ) / EnergyConfigHandler . TO_BC_RATIO ;
e = ( float ) BCreceiver . powerRequest ( ) / EnergyConfigHandler . TO_BC_RATIO ;
sentToAcceptor = ( float ) ( ( IStrictEnergyAcceptor ) tileEntity ) . transferEnergyToAcceptor ( sideFrom , currentSending * EnergyConfigHandler . TO_MEKANISM_RATIO ) / EnergyConfigHandler . TO_MEKANISM_RATIO ;
sentToAcceptor = handler . receiveEnergy ( sideFrom , currentSendinginRF , false ) / EnergyConfigHandler . TO_RF_RATIO ;
sentToAcceptor = handler . receiveEnergy ( sideFrom , currentSendinginRF , false ) / EnergyConfigHandler . TO_RF_RATIO ;
sentToAcceptor = currentSending - ( float ) result / EnergyConfigHandler . TO_IC2_RATIO ;
sentToAcceptor = ( float ) MjAPI . getMjBattery ( tileEntity , MjAPI . DEFAULT_POWER_FRAMEWORK , sideFrom ) . addEnergy ( currentSending * EnergyConfigHandler . TO_BC_RATIO ) / EnergyConfigHandler . TO_BC_RATIO ;
sentToAcceptor = ( float ) receiver . receiveEnergy ( buildcraft . api . power . PowerHandler . Type . PIPE , toSendBC , sideFrom ) / EnergyConfigHandler . TO_BC_RATIO ;
float result = this . getNetwork ( ) . getRequest ( this ) / EnergyConfigHandler . IC2_RATIO ;
float result = this . getNetwork ( ) . getRequest ( this ) / EnergyConfigHandler . IC2_RATIO ;
return this . getNetwork ( ) . getRequest ( this ) / EnergyConfigHandler . IC2_RATIO ;
return this . getNetwork ( ) . getRequest ( this ) / EnergyConfigHandler . IC2_RATIO ;
double requiredEnergy = this . getNetwork ( ) . getRequest ( this ) / EnergyConfigHandler . BC3_RATIO ;
double requiredEnergy = this . getNetwork ( ) . getRequest ( this ) / EnergyConfigHandler . BC3_RATIO ;
energyBC = this . getNetwork ( ) . produce ( ( float ) energyBC * EnergyConfigHandler . BC3_RATIO , true , 1 , this ) / EnergyConfigHandler . BC3_RATIO ;
return MathHelper . floor_float ( sentGC / EnergyConfigHandler . RF_RATIO ) ;
return MathHelper . floor_float ( this . getNetwork ( ) . getRequest ( this ) / EnergyConfigHandler . RF_RATIO ) ;
return amount - this . getNetwork ( ) . produce ( ( float ) amount * EnergyConfigHandler . MEKANISM_RATIO , true , 1 , this ) / EnergyConfigHandler . MEKANISM_RATIO ;
return this . getNetwork ( ) . getRequest ( this ) / EnergyConfigHandler . MEKANISM_RATIO ;
return energyToReceive / EnergyConfigHandler . IC2_RATIO ;
float energy = ( float ) amount / EnergyConfigHandler . TO_IC2_RATIO ;
return ( int ) ( energyToReceive / EnergyConfigHandler . IC2_RATIO ) ;
float energy = amount / EnergyConfigHandler . TO_IC2_RATIO ;
return transferredMek / EnergyConfigHandler . TO_MEKANISM_RATIO ;
return ( float ) result / EnergyConfigHandler . TO_IC2_RATIO ;
return ( ( IEnergyHandler ) tileAdj ) . receiveEnergy ( inputAdj , MathHelper . floor_float ( toSend * EnergyConfigHandler . TO_RF_RATIO ) , simulate ) / EnergyConfigHandler . TO_RF_RATIO ;
return ( ( IEnergyReceiver ) tileAdj ) . receiveEnergy ( inputAdj , MathHelper . floor_float ( toSend * EnergyConfigHandler . TO_RF_RATIO ) , simulate ) / EnergyConfigHandler . TO_RF_RATIO ;
return ( float ) toSendBC / EnergyConfigHandler . TO_BC_RATIO ;
return ( float ) MjAPI . getMjBattery ( tileAdj , MjAPI . DEFAULT_POWER_FRAMEWORK , inputAdj ) . addEnergy ( toSendBC ) / EnergyConfigHandler . TO_BC_RATIO ;
return ( float ) toSendBC / EnergyConfigHandler . TO_BC_RATIO ;
return rec / EnergyConfigHandler . TO_BC_RATIO ;
return this . getMaxElectricityStored ( itemStack ) / EnergyConfigHandler . IC2_RATIO ;
return ( int ) ( this . getMaxElectricityStored ( itemStack ) / EnergyConfigHandler . IC2_RATIO ) ;
this . storage . extractEnergyGC ( ( float ) EnergizedItemManager . charge ( itemStack , energyToCharge * EnergyConfigHandler . TO_MEKANISM_RATIO ) / EnergyConfigHandler . TO_MEKANISM_RATIO , false ) ;
float energy = ( float ) result / EnergyConfigHandler . TO_IC2_RATIO ;
float energy = ( float ) result / EnergyConfigHandler . TO_IC2_RATIO ;
this . storage . extractEnergyGC ( ( float ) amount / EnergyConfigHandler . TO_IC2_RATIO , false ) ;
return MathHelper . floor_float ( this . storage . extractEnergyGC ( maxExtract / EnergyConfigHandler . TO_RF_RATIO , ! simulate ) * EnergyConfigHandler . TO_RF_RATIO ) ;
int energyDischargeIC2 = ( int ) ( energyToDischarge / EnergyConfigHandler . IC2_RATIO ) ;
int energyDischargeIC2 = ( int ) ( energyToDischarge / EnergyConfigHandler . IC2_RATIO ) ;
this . storage . receiveEnergyGC ( ( float ) EnergizedItemManager . discharge ( itemStack , energyToDischarge / EnergyConfigHandler . MEKANISM_RATIO ) * EnergyConfigHandler . MEKANISM_RATIO ) ;
double energyDischargeIC2 = energyToDischarge / EnergyConfigHandler . IC2_RATIO ;
double energyDischargeIC2 = energyToDischarge / EnergyConfigHandler . IC2_RATIO ;
float usedBC = this . storage . receiveEnergyGC ( ( float ) energyBC * EnergyConfigHandler . BC3_RATIO ) / EnergyConfigHandler . BC3_RATIO ;
return Math . ceil ( ( this . storage . receiveEnergyGC ( Integer . MAX_VALUE , true ) ) / EnergyConfigHandler . IC2_RATIO ) ;
return Math . ceil ( ( this . storage . receiveEnergyGC ( Integer . MAX_VALUE , true ) - this . IC2surplusInGJ ) / EnergyConfigHandler . IC2_RATIO ) ;
return Math . ceil ( ( this . storage . receiveEnergyGC ( Integer . MAX_VALUE , true ) ) / EnergyConfigHandler . IC2_RATIO ) ;
return Math . ceil ( ( this . storage . receiveEnergyGC ( Integer . MAX_VALUE , true ) - this . IC2surplusInGJ ) / EnergyConfigHandler . IC2_RATIO ) ;
float receive = this . storage . receiveEnergyGC ( this . storage . getMaxReceive ( ) , true ) / EnergyConfigHandler . BC3_RATIO ;
( ( PowerHandler ) this . powerHandlerBC ) . configure ( 0D , receive , 0 , ( int ) ( this . getMaxEnergyStoredGC ( ) / EnergyConfigHandler . BC3_RATIO ) ) ;
float requested = this . getRequest ( ForgeDirection . UNKNOWN ) / EnergyConfigHandler . BC3_RATIO ;
return used / EnergyConfigHandler . BC3_RATIO ;
return used / EnergyConfigHandler . BC3_RATIO ;
return this . getEnergyStoredGC ( ) / EnergyConfigHandler . BC3_RATIO ;
return this . getMaxEnergyStoredGC ( ) / EnergyConfigHandler . BC3_RATIO ;
return this . storage . getMaxReceive ( ) / EnergyConfigHandler . BC3_RATIO ;
return ( this . getMaxEnergyStoredGC ( ) - this . getEnergyStoredGC ( ) ) / EnergyConfigHandler . BC3_RATIO ;
return MathHelper . floor_float ( super . receiveElectricity ( from , maxReceive * EnergyConfigHandler . RF_RATIO , 1 , ! simulate ) / EnergyConfigHandler . RF_RATIO ) ;
return MathHelper . floor_float ( this . getEnergyStoredGC ( ) / EnergyConfigHandler . RF_RATIO ) ;
return MathHelper . floor_float ( this . getMaxEnergyStoredGC ( ) / EnergyConfigHandler . RF_RATIO ) ;
return this . receiveElectricity ( from , ( float ) amount * EnergyConfigHandler . MEKANISM_RATIO , 1 , true ) / EnergyConfigHandler . MEKANISM_RATIO ;
return this . getEnergyStoredGC ( ) / EnergyConfigHandler . MEKANISM_RATIO ;
return this . getMaxEnergyStoredGC ( ) / EnergyConfigHandler . MEKANISM_RATIO ;
private boolean isClient = FMLCommonHandler . instance ( ) . getEffectiveSide ( ) . isClient ( ) ;
isSmartMovingLoaded = Loader . isModLoaded ( "str" ) ;
for ( int i = 2 ; i < 11 ; i + + )
for ( int j = i + 1 ; j < 11 ; j + + )
for ( int i = 3 ; i < 12 ; i + + )
for ( int j = i + 1 ; j < 12 ; j + + )
Class GCGreg = Class . forName ( "str" ) ;
return "str" + this . getCommandName ( ) + "str" ;
gasname = GCCoreUtil . translate ( gasTankContents . getFluid ( ) . getUnlocalizedName ( ) ) ;
gasname = GCCoreUtil . translate ( gasTankContents . getFluid ( ) . getUnlocalizedName ( ) ) ;
gasname = GCCoreUtil . translate ( gasTankContents . getFluid ( ) . getUnlocalizedName ( ) ) ;
RecipeUtil . addRecipe ( new ItemStack ( GCBlocks . screen ) , new Object [ ] { "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , Blocks . glass } ) ;
int textWidthPixels = 39 ;
var3 . spaceStationName = "str" + var3 . owner ;
var3 . setSpaceStationName ( "str" + var3 . owner ) ;
var3 . spaceStationName = "str" + var3 . owner ;
var3 . setSpaceStationName ( "str" + var3 . owner ) ;
super ( GalacticraftCore . TEXTURE_PREFIX + "str" , Material . iron , false ) ;
int yTexPos = this . enabled ? 3 : 32 ;
if ( b ! = null & & b . getLightOpacity ( world , sideVec . x , sideVec . y , sideVec . z ) = = 0 )
this . addressValid = entry = = null | | ( this . worldObj ! = null & & ( entry . dimensionID = = this . worldObj . provider . dimensionId & & entry . position . x = = this . xCoord & & entry . position . y = = this . yCoord & & entry . position . z = = this . zCoord ) ) ;
GalacticraftCore . planetOverworld . setDimensionInfo ( 0 , WorldProvider . class , false ) ;
float f2 = par1 % 16 * 16 + j ;
return this . setDimensionInfo ( dimID , providerClass , true ) ;
super . writeToNBT ( nbt ) ;
GalacticraftCore . packetPipeline . sendToServer ( new PacketSimple ( EnumSimplePacket . S_UNLOCK_NEW_SCHEMATIC , new Object [ ] { } ) ) ;
if ( ! IGalacticraftWorldProvider . class . isAssignableFrom ( clazz ) )
if ( ! IGalacticraftWorldProvider . class . isAssignableFrom ( clazz ) )
if ( stack . getItem ( ) = = itemstack1 . getItem ( ) & & ( itemstack1 . getItemDamage ( ) = = 32767 | | stack . getItemDamage ( ) = = itemstack1 . getItemDamage ( ) ) )
return target = = null & & input = = null | | target . getItem ( ) = = input . getItem ( ) & & ( target . getItemDamage ( ) = = OreDictionary . WILDCARD_VALUE | | target . getItemDamage ( ) = = input . getItemDamage ( ) ) ;
networkedList . add ( stack1 = = null ? - 1 : Item . getIdFromItem ( stack1 . getItem ( ) ) ) ;
networkedList . add ( stack2 = = null ? - 1 : Item . getIdFromItem ( stack2 . getItem ( ) ) ) ;
networkedList . add ( stack3 = = null ? - 1 : Item . getIdFromItem ( stack3 . getItem ( ) ) ) ;
threadCooldownTotal = stopSealThreadCooldown = 50 + countEntities ;
public String playerToOpenFor = "str" ;
this . world . setBlock ( checkedVec . getPosition ( ) . intX ( ) , checkedVec . getPosition ( ) . intY ( ) , checkedVec . getPosition ( ) . intZ ( ) , GCCoreBlocks . breatheableAir . blockID , 0 , 3 ) ;
this . world . setBlock ( checkedVec . getPosition ( ) . intX ( ) , checkedVec . getPosition ( ) . intY ( ) , checkedVec . getPosition ( ) . intZ ( ) , 0 , 0 , 3 ) ;
public static final int LOCALBUILDVERSION = 6 ;
public static final int LOCALBUILDVERSION = 5 ;
if ( GCCoreItemBasic . names [ i ] . contains ( "str" ) | | GCCoreItemBasic . names [ i ] . contains ( "str" ) | | GCCoreItemBasic . names [ i ] . contains ( "str" ) )
@Mod ( name = GalacticraftCore . NAME , version = GalacticraftCore . LOCALMAJVERSION + "str" + GalacticraftCore . LOCALMINVERSION + "str" + GalacticraftCore . LOCALBUILDVERSION , useMetadata = true , modid = GalacticraftCore . MODID , dependencies = "str" )
private int heatLevel = MAX_HEAT_LEVEL ;
if ( ! this . worldObj . isRemote & & this . heatLevel > 0 )
if ( ! this . worldObj . isRemote & & ( ( this . heatLevel % 5 = = 0 & & this . heatLevel ! = 0 ) | | this . heatLevel = = 0 & & this . lastHeatLevel ! = 0 ) )
import net . minecraft . entity . EntityLivingBase ;
if ( par5Entity instanceof EntityLivingBase )
final EntityLivingBase livingEntity = ( EntityLivingBase ) par5Entity ;
double var9 = ( par2 + 0.5F ) - livingEntity . posX ;
livingEntity . knockBack ( livingEntity , 1 , var9 , var7 ) ;
float rotation = entity . wheelRotationX ;
this . wheelRotationX + = ( this . motionX * this . motionX + this . motionY * this . motionY + this . motionZ * this . motionZ ) * 250.0F * ( this . speed < 0 ? 1 : - 1 ) ;
RecipeUtil . addRecipe ( new ItemStack ( GCCoreBlocks . solarPanel , 1 , 0 ) , new Object [ ] { "str" , "str" , "str" , "str" , RecipeUtil . getIndustrialCraftItem ( "str" ) , "str" , RecipeUtil . getIndustrialCraftItem ( "str" ) , "str" , "str" , "str" , new ItemStack ( GCCoreItems . itemBasic , 1 , 1 ) , "str" , GCCoreItems . flagPole } ) ;
RecipeUtil . addRecipe ( new ItemStack ( GCCoreBlocks . solarPanel , 1 , 4 ) , new Object [ ] { "str" , "str" , "str" , "str" , RecipeUtil . getIndustrialCraftItem ( "str" ) , "str" , RecipeUtil . getIndustrialCraftItem ( "str" ) , "str" , "str" , "str" , new ItemStack ( GCCoreItems . itemBasic , 1 , 1 ) , "str" , GCCoreItems . flagPole } ) ;
catch ( Throwable e )
this . coordsTeleportedFromZ = coords ;
if ( ! this . mergeItemStack ( itemstack1 , this . numRows * 9 + 3 , this . inventorySlots . size ( ) , true ) )
final int amountToFill = Math . min ( liquid . amount , isCanister ? GCCoreItems . fuelCanister . getMaxDamage ( ) - 1 : FluidContainerRegistry . BUCKET_VOLUME ) ;
this . containingItems [ 2 ] = new ItemStack ( GCCoreItems . fuelCanister , 1 , GCCoreItems . fuelCanister . getMaxDamage ( ) - amountToFill ) ;
public static final int LOCALMAJVERSION = 0 ;
FMLClientHandler . instance ( ) . getClient ( ) . thePlayer . addChatMessage ( LanguageRegistry . instance ( ) . getStringLocalization ( "str" , "str" ) + String . valueOf ( GalacticraftCore . remoteMajVer ) + "str" + String . valueOf ( GalacticraftCore . remoteMinVer ) + "str" + String . valueOf ( GalacticraftCore . remoteBuildVer ) + "str" ) ;
GCLog . severe ( LanguageRegistry . instance ( ) . getStringLocalization ( "str" , "str" ) + String . valueOf ( GalacticraftCore . remoteMajVer ) + "str" + String . valueOf ( GalacticraftCore . remoteMinVer ) + "str" + String . valueOf ( GalacticraftCore . remoteBuildVer ) + "str" ) ;
GCLog . severe ( LanguageRegistry . instance ( ) . getStringLocalization ( "str" , "str" ) ) ;
GCLog . info ( LanguageRegistry . instance ( ) . getStringLocalization ( "str" , "str" ) + "str" + GalacticraftCore . remoteMajVer + "str" + GalacticraftCore . remoteMinVer + "str" + GalacticraftCore . remoteBuildVer ) ;
if ( this . maskInSlot ! = null & & this . lastMaskInSlot = = null & & this . maskInSlot . getItem ( ) . itemID = = GCCoreItems . oxygenMask . itemID )
if ( this . gearInSlot ! = null & & this . lastGearInSlot = = null & & this . gearInSlot . getItem ( ) . itemID = = GCCoreItems . oxygenGear . itemID )
if ( packet = = null )
if ( packet = = null )
if ( packet = = null )
if ( tile ! = null & & tile instanceof GCCoreTileEntityAirLock & & ! this . adjacentAirLocks . contains ( tile ) & & ( tile . xCoord = = this . head . xCoord | | tile . zCoord = = this . head . zCoord ) )
if ( tile ! = null & & tile . getColor ( ) ! = 15 )
if ( var8 . rocketStacks ! = null & & var8 . rocketStacks . length > 0 )
for ( int i = 0 ; i < var8 . rocketStacks . length ; i + + )
if ( transferInv )
if ( var8 . rocketStacks [ i ] = = null )
public static final String NAME = "str" ;
world . setBlock ( bx + cx , by + cy , bz + cz , GCCoreBlocks . crudeOilStill . blockID , 0 , d2 = = r2 ? 3 : 2 ) ;
BasicComponents . register ( GalacticraftCore . instance , GalacticraftCore . CHANNELENTITIES ) ;
PacketManager . sendPacketToClients ( PacketManager . getPacket ( GalacticraftCore . CHANNELENTITIES , this , this . getColor ( ) , this . preLoadColor ) ) ;
GCLog . info ( "str" ) ;
GCLog . info ( "str" + s ) ;
public double getSolarEnergyMultiplier ( )
public double getSolarEnergyMultiplier ( )
super ( GalacticraftCore . CHANNELENTITIES ) ;
super ( GalacticraftCore . CHANNELENTITIES ) ;
super ( GalacticraftCore . CHANNELENTITIES ) ;
super ( GalacticraftCore . CHANNELENTITIES ) ;
RecipeUtil . addRecipe ( new ItemStack ( GCCoreItems . buggyMaterial , 1 , 0 ) , new Object [ ] {
"str" , GregTech_API . getGregTechItem ( 0 , 1 , 66 )
RecipeUtil . addRecipe ( new ItemStack ( GCCoreItems . buggyMaterial , 1 , 1 ) , new Object [ ] {
RecipeUtil . addRecipe ( new ItemStack ( GCCoreItems . buggyMaterial , 1 , 2 ) , new Object [ ] {
RecipeUtil . addRecipe ( new ItemStack ( GCCoreItems . buggyMaterial , 1 , 0 ) , new Object [ ] {
RecipeUtil . addRecipe ( new ItemStack ( GCCoreItems . buggyMaterial , 1 , 1 ) , new Object [ ] {
RecipeUtil . addRecipe ( new ItemStack ( GCCoreItems . buggyMaterial , 1 , 2 ) , new Object [ ] {
RecipeUtil . addRecipe ( new ItemStack ( GCCoreItems . buggyMaterial , 1 , 0 ) , new Object [ ] {
RecipeUtil . addRecipe ( new ItemStack ( GCCoreItems . buggyMaterial , 1 , 1 ) , new Object [ ] {
RecipeUtil . addRecipe ( new ItemStack ( GCCoreItems . buggyMaterial , 1 , 2 ) , new Object [ ] {
RecipeUtil . addRecipe ( new ItemStack ( GCCoreItems . buggyMaterial , 1 , 0 ) , new Object [ ] {
RecipeUtil . addRecipe ( new ItemStack ( GCCoreItems . buggyMaterial , 1 , 1 ) , new Object [ ] {
RecipeUtil . addRecipe ( new ItemStack ( GCCoreItems . buggyMaterial , 1 , 2 ) , new Object [ ] {
if ( this . posY > ( this . worldObj . provider instanceof IExitHeight ? ( ( IExitHeight ) this . worldObj . provider ) . getYCoordinateToTeleport ( ) : 1200 ) )
public static KeyBinding tankRefill = new KeyBinding ( "str" , Keyboard . KEY_E ) ;
if ( minecraft . currentScreen = = null & & playerBase ! = null & & ! playerBase . capabilities . isCreativeMode )
if ( recipe ! = null & & par1GuiButton ! = null & & par1GuiButton . enabled & & recipe . matches ( this . playerToSend , false ) )
FMLLog . severe ( "str" + ( String ) packetReadout [ 0 ] ) ;
this . airRemaining = tankInSlot . getMaxDamage ( ) - tankInSlot . getItemDamage ( ) ;
this . airRemaining2 = tankInSlot2 . getMaxDamage ( ) - tankInSlot2 . getItemDamage ( ) ;
if ( drainSpacing > 0 & & this . tick % drainSpacing = = 0 & & ! OxygenUtil . isAABBInBreathableAirBlock ( this ) & & tankInSlot . getMaxDamage ( ) - tankInSlot . getItemDamage ( ) > 0 )
if ( drainSpacing2 > 0 & & this . tick % drainSpacing2 = = 0 & & ! OxygenUtil . isAABBInBreathableAirBlock ( this ) & & tankInSlot2 . getMaxDamage ( ) - tankInSlot2 . getItemDamage ( ) > 0 )
public static final int LOCALBUILDVERSION = 32 ;
GCCoreConfigManager . disableSpaceshipOverlay = GCCoreConfigManager . configuration . get ( Configuration . CATEGORY_GENERAL , "str" , true ) . getBoolean ( true ) ;
final GCCoreEntityBuggy var35 = new GCCoreEntityBuggy ( par2World , var29 + 0.5F , var33 + 1.0F , var34 + 0.5F ) ;
lightOxygenTankFull = new GCItem ( GCConfigManager . idItemLightOxygenTank ) . setMaxDamage ( 60 ) . setIconIndex ( 0 ) . setItemName ( "str" ) ;
medOxygenTankFull = new GCItem ( GCConfigManager . idItemMedOxygenTank ) . setMaxDamage ( 120 ) . setIconIndex ( 1 ) . setItemName ( "str" ) ;
heavyOxygenTankFull = new GCItem ( GCConfigManager . idItemHeavyOxygenTank ) . setMaxDamage ( 90 ) . setIconIndex ( 2 ) . setItemName ( "str" ) ;
Toast . makeText ( this , getResources ( ) . getString ( R . string . error_file_invalid ) ,
Toast . makeText ( this , getResources ( ) . getString ( R . string . error_file_not_found ) ,
Toast . makeText ( this , R . string . error_file_not_found , Toast . LENGTH_LONG ) . show ( ) ;
zimFileMissingBuilder . setMessage ( R . string . custom_app_missing_content ) ;
Toast . makeText ( MainActivity . this , getString ( R . string . error_file_not_found ) , Toast . LENGTH_LONG )
String error = String . format ( getString ( R . string . error_article_url_not_found ) , url ) ;
Snackbar . make ( snackbarRoot , R . string . new_tab_snack_bar , Snackbar . LENGTH_LONG )
showToast ( R . string . error_file_not_found , Toast . LENGTH_LONG ) ;
if ( mimeType = = null | | mimeType . isEmpty ( ) ) {
. readTimeout ( 60 , TimeUnit . SECONDS )
if ( nightMode ) {
if ( sharedPreferenceUtil ! = null & & sharedPreferenceUtil . nightMode ( ) ) {
if ( ! new File ( fileName ) . exists ( ) | | ! jniKiwix . loadZIM ( fileName ) ) {
= = PackageManager . PERMISSION_GRANTED | | Build . VERSION . SDK_INT < 19 | | ( Constants . IS_CUSTOM_APP & & Build . VERSION . SDK_INT ! = 23 ) ) {
if ( newVersion > = 3 & & ( oldVersion < 3 | | oldVersion = = 7 | | oldVersion = = 6 ) ) {
private static final int VERSION = 8 ;
public native boolean loadZIM ( String path ) ;
mLeftDrawerLayout . openDrawer ( GravityCompat . START ) ;
mLeftDrawerLayout . openDrawer ( GravityCompat . END ) ;
if ( mWebViews . size ( ) = = 1 & & ( mCurrentWebViewIndex = = index ) ) {
bookmarks = new ArrayList < > ( ) ;
menu . findItem ( R . id . menu_forward ) . setVisible ( true ) ;
private static final String PREF_BACK_TO_TOP = "str" ;
private boolean isFullscreenButtonEnabled ;
isFullscreenButtonEnabled = true ;
if ( isFullscreenButtonEnabled ) {
isFullscreenButtonEnabled = mySharedPreferences . getBoolean ( PREF_BACK_TO_TOP , isFullscreenButtonEnabled ) ;
if ( ! isFullscreenButtonEnabled ) {
zimFileName = fileName ;
progressDialog . setMessage ( callingActivity . getString ( R . string . rescan_fs_warning ) ) ;
String filePath = getIntent ( ) . getData ( ) . getPath ( ) ;
while ( ( suggestion = ZimContentProvider . getNextSuggestion ( ) ) ! = null ) {
return ( divisor = = 0 ? 0f : ( tokensMatched ( ) * 100 / ( float ) divisor ) ) ;
return ( divisor = = 0 ? 0f : ( tokensMatched ( ) * 100 / ( float ) divisor ) ) ;
verifyLogbackAccessEventQueues ( ) ;
private void verifyLogbackAccessEventQueues ( ) {
+ "str" + downloadBatchStatus . downloadError ( ) . type ( ) ;
DownloadError downloadError ( ) ;
public DownloadError downloadError ( ) {
return downloadError . get ( ) ;
return createErrorNotification ( builder , payload . downloadError ( ) ) ;
private DownloadError downloadError = null ;
InternalDownloadBatchStatusFixtures . this . downloadError = downloadError . get ( ) ;
+ "str" + downloadBatchStatus . percentageDownloaded ( ) + "str"
return destinationUri . getPath ( ) ;
values . put ( DownloadContract . Batches . COLUMN_VISIBILITY , NotificationVisibility . HIDDEN ) ;
public boolean isAllowedToDownload ( DownloadBatch downloadBatch ) {
public boolean isAllowedToDownload ( DownloadBatch downloadBatch ) {
builder . addAction ( R . drawable . dl__ic_action_cancel , "str" , pendingCancelIntent ) ;
builder . setContentTitle ( res . getQuantityString ( R . plurals . dl__notif_summary_active , cluster . size ( ) , cluster . size ( ) ) ) ;
builder . setContentTitle ( res . getQuantityString ( R . plurals . dl__notif_summary_waiting , cluster . size ( ) , cluster . size ( ) ) ) ;
return res . getQuantityString ( R . plurals . dl__duration_hours , hours , hours ) ;
return res . getQuantityString ( R . plurals . dl__duration_minutes , minutes , minutes ) ;
return res . getQuantityString ( R . plurals . dl__duration_seconds , seconds , seconds ) ;
mTextStringEditText . setText ( "str" ) ;
private Optional < ObjectMapper > objectMapper = Optional . of ( new JsonObjectMapper ( ) ) ;
} catch ( NoSuchMethodError e ) {
assertEquals ( "str" , response . getBody ( ) . getObject ( ) . getJSONObject ( "str" ) . getString ( "str" ) ) ;
assertEquals ( "str" , json . getObject ( ) . getJSONObject ( "str" ) . getString ( "str" ) ) ;
assertEquals ( "str" , json . getObject ( ) . getJSONObject ( "str" ) . getString ( "str" ) ) ;
final Future < org . apache . http . HttpResponse > future = ClientFactory . getAsyncHttpClient ( ) . execute ( requestObj , prepareCallback ( responseClass , callback ) ) ;
HttpClient client = ClientFactory . getHttpClient ( ) ;
if ( ( parameters . get ( JSON_PARAM_BODY ) ! = null ) ) {
public HeaderAuthentication ( AuthenticationParameter . . . headers ) {
header = new BasicHeader ( "str" , "str" + Base64 . encodeBase64String ( headerValue . getBytes ( ) ) . replace ( "str" , "str" ) ) ;
HttpClient . doRequest ( HttpMethod . DELETE , "str" , null , true , null ) ;
HttpClient . doRequest ( HttpMethod . GET , "str" , null , true , null ) ;
} else if ( c1 = = float . class | | c2 = = float . class ) {
set ( item , ( total > 0.0 ) ? order / total : 0.5 ) ;
double x = span = = 0 ? 0.5 * breadth : ( ( v - m_lo ) / span ) * breadth ;
double f = pspan = = 0 ? 0.5 : ( ( v - m_prevlo ) / pspan ) ;
"str" , caller ) ;
config . getBoolean ( "str" , ExternalIdCacheImpl . CACHE_NAME , "str" , true ) ;
"str" , extensionImpl . getClass ( ) , extension . getPluginName ( ) ) ;
| | ( iter . hasNext ( ) & & ( newSize + ellipsis . length ( ) ) > maxCombinedCommitMessageSize ) ) {
@SuppressWarnings ( { "str" , "str" } )
private static class TestSearcher extends StringSearcher {
public Predicate < ChangeData > ext ( String ext ) throws QueryParseException {
RevCommit initialHead = getRemoteHead ( project2 , "str" ) ;
Project . NameKey someProject = projectOperations . newProject ( ) . create ( ) ;
Project . NameKey project = projectOperations . newProject ( ) . submitType ( submitType ) . create ( ) ;
Project . NameKey grandChild = projectOperations . newProject ( ) . parent ( child ) . create ( ) ;
Project . NameKey grandChild = projectOperations . newProject ( ) . parent ( child ) . create ( ) ;
String parent = projectOperations . newProject ( ) . create ( ) . get ( ) ;
String parent = projectOperations . newProject ( ) . create ( ) . get ( ) ;
String parent = projectOperations . newProject ( ) . create ( ) . get ( ) ;
String parent = projectOperations . newProject ( ) . create ( ) . get ( ) ;
String parent = projectOperations . newProject ( ) . create ( ) . get ( ) ;
String parent = projectOperations . newProject ( ) . create ( ) . get ( ) ;
String projectName = projectOperations . newProject ( ) . create ( ) . get ( ) ;
String projectName = projectOperations . newProject ( ) . create ( ) . get ( ) ;
Project . NameKey p3 = projectOperations . newProject ( ) . create ( ) ;
Project . NameKey p1 = projectOperations . newProject ( ) . create ( ) ;
project2 = projectOperations . newProject ( ) . parent ( project1 ) . create ( ) ;
public DefaultUrlFormatter ( @CanonicalWebUrl Provider < String > canonicalWebUrlProvider ) {
logger . atFine ( ) . log ( "str" , alreadyAccepted . size ( ) , alreadyAccepted ) ;
logger . atFine ( ) . log ( "str" ) ;
sb . append ( "str" ) . append ( errMsg ) . append ( "str" ) ;
sb . append ( "str" )
sb . append ( "str" )
exception . expectMessage ( "str" ) ;
exception . expectMessage ( "str" ) ;
assertThat ( e . getMessage ( ) ) . contains ( "str" ) ;
if ( requestId ! = null ) {
if ( requestId ! = null ) {
logDebug ( "str" , errors . keySet ( ) ) ;
logDebug ( "str" , newChanges . size ( ) ) ;
logDebug ( "str" , newChanges . size ( ) ) ;
logDebug ( "str" , newChanges . size ( ) ) ;
logDebug ( "str" , actualCommands . size ( ) ) ;
logDebug ( "str" , commands . size ( ) ) ;
logDebug ( "str" , cmd . getResult ( ) , cmd ) ;
logDebug ( "str" , RefNames . REFS_USERS_SELF , newName ) ;
logDebug ( "str" , ops . size ( ) ) ;
logDebug ( "str" , repoOnlyOps . size ( ) ) ;
logDebug ( "str" , batchRefUpdate . getCommands ( ) . size ( ) ) ;
logDebug ( "str" , parallel ) ;
logDebug ( "str" , ops ) ;
"str" , ops . size ( ) , ops . keySet ( ) . size ( ) ) ;
logDebug ( "str" , tasks . size ( ) ) ;
logDebug ( "str" , task . id ) ;
logDebug ( "str" , branch , project ) ;
logDebug ( "str" , branch ) ;
logDebug ( "str" , src ) ;
logDebug ( "str" , s ) ;
logDebug ( "str" , change ) ;
logDebug ( "str" , indexBackedChangeSet ) ;
logDebug ( "str" , attempt ) ;
logDebug ( "str" , cs ) ;
logDebug ( "str" , alreadyAccepted . size ( ) ) ;
logDebug ( "str" , submitted . size ( ) ) ;
logDebug ( "str" , toSubmit ) ;
logDebug ( "str" , getClass ( ) . getSimpleName ( ) , toMerge . change ( ) . getId ( ) ) ;
logDebug ( "str" , alreadyMergedCommit . name ( ) ) ;
logDebug ( "str" , tipBefore , tipAfter ) ;
logDebug ( "str" , RefNames . REFS_CONFIG ) ;
logDebug ( "str" , getClass ( ) . getSimpleName ( ) , toMerge . change ( ) . getId ( ) ) ;
logDebug ( "str" , id , commit . name ( ) , c . getDest ( ) , s ) ;
logDebug ( "str" , psId ) ;
logDebug ( "str" , id ) ;
logDebug ( "str" , psa ) ;
logDebug ( "str" , c . getId ( ) ) ;
logDebug ( "str" , getId ( ) ) ;
logDebug ( "str" , ops . size ( ) ) ;
logDebug ( "str" , repoOnlyOps . size ( ) ) ;
logDebug ( "str" , results . size ( ) ) ;
logDebug ( "str" , e . getValue ( ) . size ( ) , id ) ;
logDebug ( "str" , id ) ;
logDebug ( "str" , id ) ;
logDebug ( "str" , id ) ;
logDebug ( "str" , current ) ;
logDebug ( "str" , s ) ;
logDebug ( "str" , r ) ;
logDebug ( "str" , r ) ;
logDebug ( "str" , ret , s . getProject ( ) ) ;
logDebug ( "str" , srcBranch ) ;
logDebug ( "str" , s ) ;
logDebug ( "str" , targetBranch ) ;
logDebug ( "str" , targetProject ) ;
logDebug ( "str" , srcBranch , ret ) ;
logDebug ( "str" , changeId ) ;
CC ( "str" ) ,
import com . google . gerrit . extensions . restapi . ResourceConflictException ;
public class MergeIdenticalTreeException extends ResourceConflictException {
return AccountPredicates . equalsNameIncludingSecondaryEmails ( name ) ;
preds . add ( equalsNameIncludingSecondaryEmails ( query ) ) ;
public static Predicate < AccountState > equalsNameIncludingSecondaryEmails ( String name ) {
log . error ( "str" , v ) ;
log . error ( "str" , v ) ;
log . error ( "str" , v ) ;
log . error ( "str" , v ) ;
log . error ( "str" , v ) ;
log . error ( "str" , v ) ;
log . error ( "str" , v ) ;
log . error ( "str" , v ) ;
log . error ( "str" , v ) ;
log . error ( "str" , v ) ;
assertArchiveNotPermitted ( ) ;
assertArchiveNotPermitted ( ) ;
String c = command ( r , "str" , abbreviated ) ;
private static final class Listener implements ContinuationListener {
this . writeJson = config . getBoolean ( "str" , "str" , true ) ;
long sizeDelta = size - aContent . length ;
parseAdditionalOptions ( bean , new HashSet < > ( ) ) ;
private void parseAdditionalOptions ( Object bean , Set < Object > parsedBeans ) {
this . readFromGit = cfg . getBoolean ( "str" , null , "str" , true ) ;
exception . expectMessage ( "str" ) ;
res = main . invoke ( clazz . getConstructor ( new Class [ ] { } ) . newInstance ( ) , new Object [ ] { argv } ) ;
shell = console . getConstructor ( new Class [ ] { } ) . newInstance ( ) ;
return ( T [ ] ) value . getDeclaringClass ( ) . getMethod ( "str" ) . invoke ( null ) ;
return ! reviewedBy . isEmpty ( ) ? reviewedBy . contains ( id ) : id . equals ( NOT_REVIEWED ) ;
static class BuildFailureException extends Exception {
private static class AuditEventTable extends FancyFlexTable < GroupAuditEventInfo > {
private String patchSetComment ;
log . warn ( "str" , e ) ;
log . warn ( "str" , e ) ;
if ( ! drop . isEmpty ( ) & & drop . getItem ( ) instanceof IPlantable ) {
if ( ! isSelected | | world . isRemote | | world . getTotalWorldTime ( ) % 5 > 0 ) {
if ( materials . isEmpty ( ) | | materials . stream ( ) . allMatch ( Material . UNKNOWN : : equals ) ) {
public static int cobaltRate = 20 ;
public static int arditeRate = 20 ;
for ( int i = 0 ; i < 16 ; i + + ) {
setHarvestLevel ( "str" , - 1 ) ;
setHarvestLevel ( "str" , - 1 ) ;
setHarvestLevel ( "str" , - 1 ) ;
return canConnect ( original , connected ) ;
return connected . getBlock ( ) = = original . getBlock ( ) & & original . getPropertyNames ( ) . contains ( prop ) & & connected . getValue ( prop ) = = original . getValue ( prop ) ;
public boolean isEffective ( IBlockState state ) {
if ( event . getType ( ) = = EnumCreatureType . MONSTER ) {
if ( config . getConfig ( Waila . CONFIG_TANK ) ) {
acceptedMinecraftVersions = "str" )
return Util . translateFormatted ( String . format ( LOC_Name , "str" ) + "str" , material . getLocalizedName ( ) ) ;
PropertyTableItem . TableItem item = new PropertyTableItem . TableItem ( model , 0 , - 0.46875f , 0 , 0.8f , ( float ) ( Math . PI / 2 ) ) ;
entity . setHeadingFromThrower ( player , player . rotationPitch , player . rotationYaw , 0.0F , 2.1F , 0.5F ) ;
if ( world . getPlayerChunkMap ( ) . isPlayerWatchingChunk ( playerMP , chunk . xPosition , chunk . zPosition ) ) {
WorldServer server = netHandler . playerEntity . getServerWorld ( ) ;
sender . addChatMessage ( foo . getLeft ( ) . getTextComponent ( ) . appendSibling ( new TextComponentString ( text . toString ( ) ) ) ) ;
sender . addChatMessage ( foo . getLeft ( ) . getTextComponent ( ) . appendSibling ( new TextComponentString ( text . toString ( ) ) ) ) ;
sender . addChatMessage ( foo . getLeft ( ) . getTextComponent ( ) . appendSibling ( new TextComponentString ( text . toString ( ) ) ) ) ;
sender . addChatMessage ( foo . getLeft ( ) . getTextComponent ( ) . appendSibling ( new TextComponentString ( text . toString ( ) ) ) ) ;
WorldServer server = netHandler . playerEntity . getServerWorld ( ) ;
WorldServer server = netHandler . playerEntity . getServerWorld ( ) ;
log . trace ( "str" , irecipe . getRecipeOutput ( ) . toString ( ) , amount , fluid
if ( block . isAir ( world , pos ) | | block . isReplaceable ( world , pos ) | | block . isLeaves ( world , pos ) )
if ( block . isAir ( world , pos ) | | block . canPlaceBlockAt ( world , pos ) | | world . getBlockState ( pos ) = = leaves )
protected static boolean attackEntitySecondary ( DamageSource source , float damage , Entity entity , boolean ignoreInvulv , boolean resetInvulv ) {
protected static boolean attackEntitySecondary ( DamageSource source , float damage , Entity entity , boolean ignoreInvulv , boolean resetInvulv , boolean noKnockback ) {
if ( hit & & resetInvulv ) {
if ( oreRequirement ! = null & & ! Config . forceRegisterAll ) {
damage = Math . max ( 1f , damage / 10 f ) ;
double f = 0.91d + 0.025d ;
attackEntitySecondary ( damageSource , damage , target , true , false ) ;
attackEntitySecondary ( DamageSource . inFire , fireDamage , target , false , true ) ;
super ( "str" , 0x2d51e2 , maxLevel , 0 ) ;
String materialInfo = StatCollector . translateToLocalFormatted ( "str" ,
dependencies = "str" +
if ( fstack . getFluidID ( ) = = fluid . getID ( ) )
return new FluidStack ( liquid . getFluid ( ) , maxDrain , liquid . tag ) ;
return new FluidStack ( liquid . getFluid ( ) , maxDrain , liquid . tag ) ;
if ( liquid . getFluidID ( ) = = fluidID )
if ( liquid = = null | | liquid . getFluid ( ) = = null | | liquid . getFluidID ( ) < = 0 | | castingDelay > 0 )
drawFluidStackTooltip ( logic . moltenMetal . get ( i ) , mouseX - cornerX + 36 , mouseY - cornerY , false ) ;
drawFluidStackTooltip ( logic . getFuel ( ) , mouseX - cornerX + 36 , mouseY - cornerY , true ) ;
protected void drawFluidStackTooltip ( FluidStack par1ItemStack , int par2 , int par3 , boolean fuel )
List list = getLiquidTooltip ( par1ItemStack , this . mc . gameSettings . advancedItemTooltips , fuel ) ;
public List getLiquidTooltip ( FluidStack liquid , boolean advanced , boolean fuel )
if ( fuel )
fluidToBeBroughtUp = logic . moltenMetal . get ( i ) . getFluidID ( ) ;
TConstructRegistry . addBowstringMaterial ( 2 , 2 , new ItemStack ( ( Item ) plantItem , 1 , 7 ) , new ItemStack ( TinkerWeaponry . bowstring , 1 , 2 ) , 1.2F , 1.1F , 1.2f , 0xf3414f ) ;
locString = "str" + tipName . substring ( 0 , bracket ) ;
String locString = "str" + tipName ;
int bracket = tipName . indexOf ( "str" ) ;
int bracket = locString . indexOf ( "str" ) ;
if ( ! checkRequiredTags ( "str" , tag , "str" , "str" ) )
if ( ammo ! = null & & ammo . hasTagCompound ( ) ) {
if ( block . removedByPlayer ( world , player , x , y , z , true ) )
@Pulse ( id = "str" , description = "str" , modsRequired = "str" , forced = true )
@Pulse ( id = "str" , description = "str" , modsRequired = "str" , forced = true )
@Pulse ( id = "str" , description = "str" , modsRequired = "str" , forced = true )
@Pulse ( id = "str" , description = "str" , modsRequired = "str" , forced = true )
@Pulse ( id = "str" , description = "str" , modsRequired = "str" , pulsesRequired = "str" , forced = true )
@Pulse ( id = "str" , description = "str" , modsRequired = "str" , forced = true )
@Pulse ( id = "str" , description = "str" , modsRequired = "str" , forced = true )
return slot > = this . getSizeInventory ( ) ? null : logic . getStackInSlot ( slot + 1 ) ;
int usage = ( int ) ( trueSpeed * 2.8f ) ;
if ( ! equalityOverrideLoaded & & entity instanceof EntityPlayer )
energy - = usage ;
TinkerTools . mattock . getLocalizedToolName ( ) , TinkerTools . broadsword . getLocalizedToolName ( ) , TinkerTools . longsword . getLocalizedToolName ( ) , TinkerTools . rapier . getLocalizedToolName ( ) , TinkerTools . dagger . getLocalizedToolName ( ) , TinkerTools . frypan . getLocalizedToolName ( ) , TinkerTools . battlesign . getLocalizedToolName ( ) , TinkerTools . chisel . getLocalizedToolName ( ) } ;
TinkerTools . arrowhead = new DynamicToolPart ( "str" , "str" ) ;
TConstructRegistry . addToolMaterial ( MaterialID . Alumite , "str" , 4 , 700 , 800 , 3 , 1.3F , 2 , 0f , LIGHT_PURPLE . toString ( ) , 0xffa7e9 ) ;
TConstructRegistry . addToolMaterial ( MaterialID . Paper , "str" , 0 , 30 , 200 , 0 , 0.3F , 0 , 0f , WHITE . toString ( ) , 0xFFFFFF ) ;
Smeltery . addMelting ( Blocks . cobblestone , 0 , 800 , new FluidStack ( TinkerSmeltery . moltenStoneFluid , TConstruct . ingotLiquidValue / 8 ) ) ;
recipe . addHeadItem ( new ItemStack ( head ) ) ;
return this . drain ( resource . amount , doDrain ) ;
return this . drain ( resource . amount , doDrain ) ;
@Pulse ( id = "str" , description = "str" , modsRequired = "str" , pulsesRequired = "str" )
Smeltery . addDictionaryMelting ( "str" + i + "str" , FluidType . getFluidType ( "str" ) , 0 , TConstruct . ingotLiquidValue / 18 * ( int ) Math . pow ( 9 , i ) ) ;
( ( TConstructFluid ) TinkerSmeltery . moltenEnder ) . suppressOverwritingFluidIcons ( ) ;
public int func_150905_g ( ItemStack stack )
super ( new int [ ] { 2 , 2 , 4 } , new float [ ] { 1f , 1f , 0.6f } , new String [ ] { "str" , "str" , "str" } , new String [ ] { "str" , "str" , "str" } ) ;
public CoordTuple centerPos = new CoordTuple ( 0 , 0 , 0 ) ;
exoCraftingEnabled = config . get ( "str" , "str" , true ) . getBoolean ( true ) ;
GameRegistry . addRecipe ( new ShapedOreRecipe ( new ItemStack ( Blocks . daylight_detector ) , new Object [ ] { "str" , "str" , "str" , "str" , "str" , "str" , Items . quartz , "str" , "str" } ) ) ;
Block block = BlockUtils . getBlockFromItemStack ( stack ) ;
ItemStack dropStack = new ItemStack ( TRepo . heartCanister , 1 , 1 ) ;
ItemStack dropStack = new ItemStack ( TRepo . heartCanister , 1 , 3 ) ;
} catch ( Exception e ) {
} catch ( Exception e ) {
ingotsBronzeAlloy = config . get ( "str" , "str" , 4 , "str" ) . getInt ( 4 ) ;
if ( input [ 0 ] ! = null & & input [ 0 ] . getItem ( ) ! = null & & input [ 0 ] . getItem ( ) instanceof IEnergyContainerItem & & input [ 0 ] . hasTagCompound ( ) )
if ( input [ 1 ] ! = null & & input [ 1 ] . getItem ( ) ! = null & & input [ 1 ] . getItem ( ) instanceof IEnergyContainerItem & & input [ 1 ] . hasTagCompound ( ) )
super ( new ItemStack [ 0 ] , 17 , "str" , "str" , "str" ) ;
super . readFromNBT ( tags ) ;
super . writeToNBT ( tags ) ;
super . readFromNBT ( tags ) ;
super . writeToNBT ( tags ) ;
islandRarity = config . get ( "str" , "str" , 1450 ) . getInt ( 1450 ) ;
world . setBlock ( x + xPos , y + yPos - 1 , z + zPos , topID , 0 , 0 ) ;
@Mod ( modid = "str" , name = "str" , version = "str" , dependencies = "str" )
System . out . println ( "str" ) ;
| | e2 . getPointerCount ( ) > SINGLE_TOUCH ) {
if ( ! handled & & null ! = parent & & ! mAllowParentInterceptOnEdge ) {
protected final OverScroller mScroller ;
private final Scroller mScroller ;
private final Handler handler = new Handler ( ) ;
private static final int [ ] sDrawables = { R . drawable . wallpaper , R . drawable . wallpaper , R . drawable . wallpaper ,
private static final String LOG_TAG = "str" ;
private static final boolean DEBUG = Log . isLoggable ( LOG_TAG , Log . DEBUG ) ;
ImageView imageView = getImageView ( ) ;
String [ ] paths = { "str" , "str" } ;
assertEquals ( invocation . dirname , "str" ) ;
assertEquals ( invocation . dirname , "str" ) ;
console . debug ( "str" + dirname ) ;
console . debug (
console . debug (
console . debug ( "str" + dataSize ) ;
console . warn ( "str" + file + "str" ) ;
console . debug ( "str" + debVersion + "str" ) ;
console . debug ( "str" + maintainer + "str" ) ;
console . debug ( "str" ) ;
console . debug ( "str" ) ;
private boolean symlink = true ;
final DateFormat sdf = ChangeSet . createDateFormat ( ) ;
final DateFormat df = ChangeSet . createDateFormat ( ) ;
public static DateFormat createDateFormat ( ) {
if ( s . charAt ( 0 ) = = "str" | | s . charAt ( 0 ) = = "str" ) {
packageDescriptor . set ( "str" , pDataSize . divide ( new BigInteger ( "str" ) ) . toString ( ) ) ;
packageDescriptor . set ( "str" , pDataSize . divide ( new BigInteger ( "str" ) . toString ( ) ) ;
. setArrowGravity ( ArrowGravity . TO_BOTTOM_CENTER )
centerPointF . x = viewRect . width ( ) / 2 ;
centerPointF . y = viewRect . height ( ) / 2 ;
centerPointF . x = viewRect . width ( ) / 2 ;
centerPointF . y = viewRect . height ( ) / 2 ;
sb . append ( inip . get ( k ) ) ;
c . cif = CIF . prepare ( is64 ? FFI . ABI_WIN64 : FFI . ABI_STDCALL , params . length ) ;
@DllImport ( entryPoint = "str" , internal = true , wideChar = false )
return Math . min ( ( float ) vncCanvas . getWidth ( ) / framebufferwidth , ( float ) vncCanvas . getHeight ( ) / framebufferheight ) ;
return ( float ) vncCanvas . getWidth ( ) / framebufferwidth < vncCanvas . getHeight ( ) / framebufferheight ;
if ( twoFingers | | inSwiping )
if ( twoFingers | | inSwiping )
if ( twoFingers | | inSwiping ) {
if ( twoFingers | | inSwiping )
if ( twoFingers | | inSwiping )
if ( twoFingers | | inSwiping ) {
public static final int REMOTE_SOUND_DISABLED = 2 ;
public static final int REMOTE_SOUND_ON_DEVICE = 0 ;
for ( i = Math . max ( numchars - 2 , 0 ) ; i > 0 ; i - - ) {
if ( backspaceWorkaround & & keyCode = = KeyEvent . KEYCODE_DEL )
boolean backspaceWorkaround = false ;
private static final Intent docIntent = new Intent ( Intent . ACTION_VIEW , Uri . parse ( "str" ) ) ;
if ( sshPrivKey ! = null & & sshPrivKey . length ( ) ! = 0 ) {
private int compressLevel = 8 ;
if ( sshPrivKey ! = null & & sshPrivKey ! = "str" ) {
oidToNameMapping . put ( "str" , "str" ) ;
gbcJbViewEditDistinguishedName . insets = new Insets ( 0 , 0 , 0 , 5 ) ;
gbcJbViewEditDistinguishedName . insets = new Insets ( 0 , 0 , 0 , 0 ) ;
add ( jbClearDistinguishedName , gbcJbClearDistinguishedName ) ;
public JKseTable ( Vector < ? extends Vector > rowData , Vector < ? > columnNames ) {
defaultDN = "str" ;
return this = = JCEKS | | this = = BKS | | this = = BKS_V1 | | this = = UBER ;
return ( osName . indexOf ( "str" ) > - 1 ) & & ( osVersion . equals ( "str" ) | | osVersion . equals ( "str" ) ) ;
CertificateFactory cf = CertificateFactory . getInstance ( X509_CERT_TYPE , BOUNCY_CASTLE . jce ( ) ) ;
defaultDN = preferences . get ( KSE3_DEFAULTDN , "str" ) ;
res . getString ( "str" ) , sslHost , Integer . toString ( sslPort ) ) , certs ,
return minTess & ~ ( DDispInfo . DISP_INFO_FLAG_MAGIC | DDispInfo . DISP_INFO_FLAG_HAS_MULTIBLEND ) ;
} catch ( IndexOutOfBoundsException ex ) {
} catch ( IndexOutOfBoundsException ex ) {
} catch ( IndexOutOfBoundsException ex ) {
} catch ( IndexOutOfBoundsException ex ) {
} catch ( IndexOutOfBoundsException ex ) {
private boolean detailMerge = true ;
private static final Pattern mapPattern = Pattern . compile ( "str" ) ;
String appidStr = cl . getOptionValue ( appidOpt . getOpt ( ) ) . toUpperCase ( ) ;
int appid = Integer . valueOf ( appidStr ) ;
Thread . sleep ( DELAY_SENDING_FRIEND_RECEIPT_TO_RELAY_MS ) ;
Log . i ( TAG , "str" + cookie_buf2 . arrayOffset ( ) ) ;
Log . i ( TAG , "str" + conference_identifier ) ;
MainActivity . update_savedata_file_wrapper ( ) ;
Log . i ( TAG , "str" + conference_num ) ;
final static boolean CTOXCORE_NATIVE_LOGGING = true ;
static void android_tox_callback_friend_sync_message_v2_cb_method ( long friend_number , String friend_message , long length , long ts_sec , long ts_ms , byte [ ] raw_message , long raw_message_length )
final static boolean CATCH_EXCEPTIONS = false ;
public static final int n_rec_audio_in_buffer_max_count = 5 ;
Log . i ( TAG , "str" + video_send_res + "str" + ToxVars . TOXAV_ERR_SEND_FRAME . value_str ( video_send_res ) ) ;
Log . i ( TAG , "str" + video_send_res + "str" + ToxVars . TOXAV_ERR_SEND_FRAME . value_str ( video_send_res ) ) ;
Log . i ( TAG , "str" + video_send_res + "str" + ToxVars . TOXAV_ERR_SEND_FRAME . value_str ( video_send_res ) ) ;
Log . i ( TAG , "str" + video_send_res + "str" + ToxVars . TOXAV_ERR_SEND_FRAME . value_str ( video_send_res ) ) ;
Log . i ( TAG , "str" + video_send_res + "str" + ToxVars . TOXAV_ERR_SEND_FRAME . value_str ( video_send_res ) ) ;
Log . i ( TAG , "str" + video_send_res + "str" + ToxVars . TOXAV_ERR_SEND_FRAME . value_str ( video_send_res ) ) ;
Log . i ( TAG , "str" + video_send_res + "str" + ToxVars . TOXAV_ERR_SEND_FRAME . value_str ( video_send_res ) ) ;
final static boolean CTOXCORE_NATIVE_LOGGING = true ;
static boolean PREF__X_zoom_incoming_video = true ;
static int PREF__X_audio_recording_frame_size = 60 ;
settings . getString ( "str" , "str" + 60 ) ) ;
PREF__X_audio_recording_frame_size = 60 ;
settings . getString ( "str" , "str" + 60 ) ) ;
PREF__X_audio_recording_frame_size = 60 ;
static void android_tox_callback_friend_read_receipt_message_v2_cb_method ( long friend_number , long ts_sec , byte [ ] msg_id )
static boolean PREF__use_native_audio_play = true ;
PREF__use_native_audio_play = settings . getBoolean ( "str" , true ) ;
PREF__use_native_audio_play = settings . getBoolean ( "str" , true ) ;
if ( ! isPasswordValid ( password1 ) )
if ( ! isPasswordValid ( password2 ) )
if ( TextUtils . isEmpty ( password1 ) )
if ( isPasswordValid ( password1 ) )
if ( TextUtils . isEmpty ( password2 ) )
if ( isPasswordValid ( password2 ) )
if ( ! TextUtils . equals ( password1 , password2 ) )
static int PREF__higher_audio_quality = 1 ;
PREF__higher_audio_quality = Integer . parseInt ( settings . getString ( "str" , "str" ) ) ;
PREF__higher_audio_quality = 1 ;
PREF__higher_audio_quality = Integer . parseInt ( settings . getString ( "str" , "str" ) ) ;
PREF__higher_audio_quality = 1 ;
canvas . drawColor ( id_data . color_a ) ;
init ( app_files_directory , PREF__udp_enabled , PREF__local_discovery_enabled_to_int , PREF__orbot_enabled_to_int , ORBOT_PROXY_HOST , ORBOT_PROXY_PORT , PREF__DB_secrect_key . substring ( 0 , Math . min ( PREF__DB_secrect_key . length ( ) , MAX_LEN_TOXENCRYPTSAVE_PASSPHRASE ) ) ) ;
init ( app_files_directory , PREF__udp_enabled , PREF__local_discovery_enabled_to_int , PREF__orbot_enabled_to_int , ORBOT_PROXY_HOST , ORBOT_PROXY_PORT , PREF__DB_secrect_key . substring ( 0 , Math . min ( PREF__DB_secrect_key . length ( ) , MAX_LEN_TOXENCRYPTSAVE_PASSPHRASE ) ) ) ;
static final int MAX_LEN_TOXENCRYPTSAVE_PASSPHRASE = 256 ;
statusText . setText ( "str" + fl . tox_conference_number + "str"
statusText . setText ( "str" + fl . tox_conference_number + "str"
statusText . setText ( "str" + fl . tox_conference_number ) ;
textView . setText ( get_conference_title_from_confid ( fl . conference_identifier ) ) ;
static int PREF__higher_video_quality = 1 ;
PREF__higher_video_quality = Integer . parseInt ( settings . getString ( "str" , "str" ) ) ;
PREF__higher_audio_quality = 0 ;
PREF__higher_video_quality = Integer . parseInt ( settings . getString ( "str" , "str" ) ) ;
PREF__higher_audio_quality = 0 ;
final static int NORMAL_GLOBAL_VIDEO_BITRATE = 2500 ;
static int GLOBAL_AUDIO_BITRATE = LOWER_GLOBAL_AUDIO_BITRATE ;
final static int GLOBAL_MIN_VIDEO_BITRATE = 190 ;
static boolean PREF__cam_recording_hint = false ;
delete_selected_messages ( main_activity_s , false , false , "str" ) ;
progressDialog2 = ProgressDialog . show ( c , "str" , dialog_text ) ;
Log . i ( TAG , "str" + ( long ) ( ( ( float ) ( s_time - System . currentTimeMillis ( ) ) / 1000 f ) ) + "str" + tox_iteration_interval_ms + "str" ) ;
positive = String . format ( "str" , ( absSeconds % 3600 ) / 60 , absSeconds % 60 ) ;
Toolbar toolbar = ( Toolbar ) findViewById ( R . id . toolbar ) ;
Callstate . tox_call_state = ToxVars . TOXAV_FRIEND_CALL_STATE . TOXAV_FRIEND_CALL_STATE_NONE . value ;
catch ( android . database . sqlite . SQLiteConstraintException e )
catch ( android . database . sqlite . SQLiteConstraintException e )
static void android_tox_callback_friend_connection_status_cb_method ( long friend_number , int a_TOX_CONNECTION )
static void logger ( int level , String text )
return ( other ! = null & & target = = other . target ) & & eqMethod . equals ( other . eqMethod ) ;
if ( ( ( value = = null ) & & ( v = = null ) ) | | ( value ! = null & & value . equals ( v ) ) )
FileOutputStream fout = new FileOutputStream ( tempFile ) ;
TypeUtils . parseType ( "str" ) ;
if ( ! check [ i ] . equals ( callbackTypes [ i ] ) ) {
} else if ( superclass ! = null & & superclass . equals ( Object . class ) ) {
TypeUtils . parseSignature ( "str" ) ;
if ( sig . equals ( Constants . SIG_STATIC ) & & ! TypeUtils . isInterface ( this . access ) ) {
if ( useHook & & ! TypeUtils . isInterface ( access ) ) {
for ( int i = 0 ; i < arrays . length ; i + + ) {
int accept ( Method method ) ;
if ( other ! = null & & compare ( other , method ) > = 0 ) {
offset + = getLengthBytes ( len_modulus ) ;
if ( ! ( pw1 . isValidated ( ) & & pw1_modes [ PW1_MODE_NO81 ] ) )
if ( ! ( pw1 . isValidated ( ) & & pw1_modes [ PW1_MODE_NO82 ] ) )
if ( ! ( pw1 . isValidated ( ) & & pw1_modes [ PW1_MODE_NO82 ] ) )
static final String KEY_DEBUGGABLE = "str" ;
log . error ( "str" , ex ) ;
LOG . debug ( "str" , ( ) - > e ) ;
public static final String QUERY_URL = "str" ;
LOG . warn ( "str" ) ;
LOG . warn ( "str" , metricName ) ;
LOG . warn ( "str" ) ;
LOG . warn ( "str" , osMetricsMap . size ( ) ) ;
LOG . info ( "str" , metricName , readerStartTime ,
LOG . warn ( "str" , metricName ) ;
LOG . error ( "str" , metricName ) ;
args . putInt ( "str" , MessagesController . getInstance ( currentAccount ) . blockedUsers . keyAt ( position ) ) ;
selectedUserId = MessagesController . getInstance ( currentAccount ) . blockedUsers . keyAt ( position ) ;
TLRPC . User user = MessagesController . getInstance ( currentAccount ) . getUser ( MessagesController . getInstance ( currentAccount ) . blockedUsers . keyAt ( position ) ) ;
if ( audioInfo ! = null & & ! TextUtils . isEmpty ( audioInfo . getAlbum ( ) ) )
} catch ( Throwable e ) {
AndroidUtilities . runOnUIThread ( new Runnable ( ) {
directory + "str" +
private static void tryLayout ( final Graphics2D graphics2D , final DistanceUnit scaleUnit , final double scaleDenominator ,
private static boolean fitsAvailableSpace ( final ScalebarAttributeValues scalebarParams ,
private static void doLayout ( final Graphics2D graphics2d , final ScalebarAttributeValues scalebarParams ,
+ Label . getRotatedHeight ( maxLabelSize , scalebarParams . getLabelRotation ( ) ) ;
+ Label . getRotatedWidth ( maxLabelSize , scalebarParams . getLabelRotation ( ) ) ;
private static DistanceUnit bestUnit ( final DistanceUnit scaleUnit , final double intervalDistance , final boolean lockUnits ) {
protected static double getNearestNiceValue ( final double value , final DistanceUnit scaleUnit , final boolean lockUnits ) {
private static int getNbSubIntervals ( final DistanceUnit scaleUnit , final double intervalDistance , final DistanceUnit intervalUnit ) {
private static int getFontSize ( final ScaleBarRenderSettings settings ) {
centerTransform . concatenate ( AffineTransform . getRotateInstance ( labelRotation ) ) ;
. assertSimilarity ( bufferedImage , 270 ) ;
assertSimilarity ( bufferedImage , 210 ) ;
. assertSimilarity ( bufferedImage , 210 ) ;
. assertSimilarity ( bufferedImage , 210 ) ;
. assertSimilarity ( bufferedImage , 130 ) ;
. assertSimilarity ( bufferedImage , 100 ) ;
if ( mapContext . isDpiSensitiveStyle ( ) ) {
@RequestMapping ( value = "str" + CAPABILITIES_URL , method = RequestMethod . GET )
Assert . isTrue ( ! allAttributes . isEmpty ( ) , "str" ) ;
if ( params = = null | | params . isEmpty ( ) ) {
while ( ! array . isEmpty ( ) ) {
assertTrue ( ! validate . isEmpty ( ) ) ;
if ( graphicFiles . isEmpty ( ) ) {
if ( group . satisfiedBy . isEmpty ( ) ) {
if ( results . isEmpty ( ) ) {
new ImageSimilarity ( bufferedImage , 4 ) . assertSimilarity ( getFile ( expectedDir + "str" ) , 44 ) ;
new ImageSimilarity ( bufferedImage , 4 ) . assertSimilarity ( getFile ( expectedDir + "str" ) , 44 ) ;
new ImageSimilarity ( bufferedImage , 4 ) . assertSimilarity ( getFile ( expectedDir + "str" ) , 44 ) ;
if ( root ! = null & & target ! = null
Matchers . equalTo ( "str" )
return String . format ( "str" , new Arg ( this . name ) ) ;
this . mask = 0xfL < < offset ;
this . mask = 0xfL < < offset ;
return ( int ) ( ( key & mask ) > > > offset ) ;
return ( max1 - min0 ) > = 0 & & ( max0 - min1 ) > = 0 ;
ctx . put ( "str" , t ! = null ) ;
sw . setWidth ( "str" ) ;
session . kick ( "str" ) ;
session . kick ( "str" ) ;
contentDisposition + "str" + java . net . URLEncoder . encode ( filename , "str" ) + "str" ) ;
response . setHeader ( "str" , disposition + "str" + java . net . URLEncoder . encode ( fileName , "str" ) + "str" ) ;
double t = ( System . currentTimeMillis ( ) - start ) / ( 60 * 1000.0 ) ;
stat . noOfUsers = userThreads . size ( ) ;
totalStat . noOfUsers = userThreads . size ( ) ;
public void flush ( boolean error ) {
if ( ! isDisableResponse & & ! error ) {
void close ( boolean error ) {
flush ( error ) ;
context . close ( e ! = null ) ;
table . setWidth ( "str" ) ;
if ( schema = = null | | ( ! schema . equals ( "str" ) & & ! schema . equals ( "str" ) ) ) {
desc = "str" ;
return b . priority - a . priority ;
return b . priority - a . priority ;
return b . priority - a . priority ;
loadAvg . put ( "str" , ( ( int ) ( osMXBean . getSystemLoadAverage ( ) * 1000 ) ) + "str" ) ;
} catch ( Throwable e ) {
} catch ( Throwable e ) {
length ( 40 , 10 , 20 , 15 , 15 , 10 ) .
logger . warn ( e . getMessage ( ) ) ;
logger . error ( e . getMessage ( ) ) ;
m . publicHost ,
m . publicHost ,
m . publicHost ,
Object [ ] whereValues ( ) {
protected String convertFieldName ( String name ) {
} catch ( Throwable e ) {
headers ( "str" , "str" , "str" , "str" , "str" ) ;
public QueryTerms limit ( int start , int limit ) {
this . limitEnd = limit ;
logErrorMessage ( "str" + depend + "str" + a . id ) ;
setResizable ( true ) ;
if ( sql . startsWith ( "str" ) | | sql . startsWith ( "str" ) | | sql . startsWith ( "str" ) ) {
addOptButton ( "str" , ValoTheme . BUTTON_PRIMARY , ( e ) - > viewConsole ( ) ) ;
@Service ( id = "str" , queryCount = 3 )
addOptButton ( "str" , ValoTheme . BUTTON_PRIMARY , ( e ) - > viewDetail ( ) ) ;
sql . append ( "str" ) . append ( fieldName ) . append ( "str" ) ;
sql . append ( "str" ) . append ( fieldName ) . append ( "str" ) . append ( "str" ) ;
sql . append ( "str" ) . append ( w . key ) . append ( "str" ) ;
sql . append ( "str" ) . append ( fieldName ) . append ( "str" ) ;
protected void initBaseUI ( ) {
String methodName = instanceName + "str" + m . getName ( ) ;
int serviceId = ( decoded [ 2 ] < < 8 ) | decoded [ 3 ] & 0xff ;
File tempDir = new File ( "str" + Jazmin . serverName ( ) ) ;
if ( ! tempDir . mkdirs ( ) ) {
cleanupVolumes ( ) ;
public void cleanupVolumes ( ) {
cleanupDeploymentInstance ( usedByInstance ) ;
protected void cleanupDeploymentInstance ( DeploymentUnitInstance instance ) {
String message = String . format ( "str" , instance . getState ( ) ) ;
String secretId = ObjectUtils . toString ( secretOpts . get ( SECRET_ID ) ) ;
throw new ClientVisibleException ( ResponseCodes . FORBIDDEN , "str" , "str" , null ) ;
throw new ClientVisibleException ( ResponseCodes . FORBIDDEN , "str" , "str" , null ) ;
throw new ClientVisibleException ( ResponseCodes . FORBIDDEN , "str" , "str" , null ) ;
if ( oldPortToIp . containsAll ( newPortToIp ) & & newPortToIp . containsAll ( oldPortToIp ) ) {
ITopic < String > topic = hazelcast . getTopic ( new TopicName ( eventName ) . getName ( ) ) ;
. fetchInto ( AgentRecord . class ) ;
. fetchInto ( AgentRecord . class ) ;
List < ? extends Agent > agents = create ( ) . select ( AGENT . fields ( ) )
List < ? extends Agent > oldAgents = create ( ) . select ( AGENT . fields ( ) )
public static final String STANDALONE_UNIT_INDEX = "str" ;
long stackId , Map < String , String > labels , String serviceIndex ) ;
null , String . valueOf ( svcInstanceIdGenerator . getNextAvailableId ( ) ) ) ;
Map < String , String > labels , String serviceIndex ) {
String name = "str" + instance . getUuid ( ) . substring ( 0 , 10 ) ;
labels , String . valueOf ( svcInstanceIdGenerator . getNextAvailableId ( ) ) ) ;
if ( network = = null & & StringUtils . isNotBlank ( mode ) & & ! instance . getNativeContainer ( ) ) {
list . add ( API_INTERCEPTOR_CONFIG ) ;
String config = API_INTERCEPTOR_CONFIG . get ( ) ;
new File ( API_INTERCEPTOR_CONFIG_FILE . get ( ) ) . delete ( ) ;
env . put ( "str" , API_INTERCEPTOR_CONFIG_FILE . get ( ) ) ;
apiProxyUrl . append ( "str" ) . append ( getProxyPort ( ) ) . append ( "str" ) ;
if ( ServiceConstants . isSystem ( stack ) | | isLBSystemService ( service ) ) {
String config = "str" ;
PortRule portRule = new PortRule ( hostname , path , listener . getSourcePort ( ) , null ,
lockManager . tryLock ( new ProjectTemplateLoadLock ( ) , new LockCallbackWithException < Object , Exception > ( ) {
boolean isDefault = account . getDefaultNetworkId ( ) = = null ? false : account . getDefaultNetworkId ( ) . equals ( ntwk . getId ( ) ) ;
return newEvent ( SCHEDULER_RELEASE_EVENT , resourceRequests , resource . getClass ( ) . getSimpleName ( ) , ObjectUtils . getId ( resource ) ) ;
return newEvent ( eventName , resourceRequests , "str" , attempt . getInstances ( ) . get ( 0 ) . getId ( ) ) ;
EventVO < Map < String , Object > > newEvent ( String eventName , List < ResourceRequest > resourceRequests , String resourceType , Object resourceId ) {
ProcessUtils . chainInData ( data , InstanceConstants . PROCESS_STOP ,
@Field ( nullable = false , required = false , defaultValue = "str" )
@Field ( nullable = false , required = false , defaultValue = "str" )
if ( identity ! = null & & identity . getExternalIdType ( ) . equalsIgnoreCase ( userType ( ) ) ) {
public static final org . jooq . ForeignKey < io . cattle . platform . core . model . tables . records . VolumeRecord , io . cattle . platform . core . model . tables . records . StorageDriverRecord > FK_VOLUME__STORAGE_DRIVER_ID = ForeignKeys0 . FK_VOLUME__STORAGE_DRIVER_ID ;
public static final org . jooq . ForeignKey < io . cattle . platform . core . model . tables . records . VolumeRecord , io . cattle . platform . core . model . tables . records . StorageDriverRecord > FK_VOLUME__STORAGE_DRIVER_ID = createForeignKey ( io . cattle . platform . core . model . Keys . KEY_STORAGE_DRIVER_PRIMARY , io . cattle . platform . core . model . tables . VolumeTable . VOLUME , io . cattle . platform . core . model . tables . VolumeTable . VOLUME . STORAGE_DRIVER_ID ) ;
private static final long serialVersionUID = 1017773517 ;
return java . util . Arrays . < org . jooq . ForeignKey < io . cattle . platform . core . model . tables . records . VolumeRecord , ? > > asList ( io . cattle . platform . core . model . Keys . FK_VOLUME__ACCOUNT_ID , io . cattle . platform . core . model . Keys . FK_VOLUME__INSTANCE_ID , io . cattle . platform . core . model . Keys . FK_VOLUME__IMAGE_ID , io . cattle . platform . core . model . Keys . FK_VOLUME__OFFERING_ID , io . cattle . platform . core . model . Keys . FK_VOLUME__ZONE_ID , io . cattle . platform . core . model . Keys . FK_VOLUME__HOST_ID , io . cattle . platform . core . model . Keys . FK_VOLUME__DEPLOYMENT_UNIT_ID , io . cattle . platform . core . model . Keys . FK_VOLUME__ENVIRONMENT_ID , io . cattle . platform . core . model . Keys . FK_VOLUME__VOLUME_TEMPLATE_ID , io . cattle . platform . core . model . Keys . FK_VOLUME__STORAGE_DRIVER_ID ) ;
if ( TRANSITIONING_ERROR_OVERRIDE . equals ( DataAccessor . fieldString ( obj , TRANSITIONING_FIELD ) ) ) {
if ( url ! = null & & StringUtils . isBlank ( md . getName ( ) ) ) {
String [ ] split = id . split ( "str" , 2 ) ;
noAzure ( response ) ;
if ( policy = = null | | request = = null | | request . getType ( ) = = null ) {
throw new IllegalStateException ( "str" , e ) ;
if ( info . getIpAddress ( ) = = null | | info . getIpAddress ( ) . getAddress ( ) = = null ) {
. and ( DYNAMIC_SCHEMA . STATE . in ( CommonStatesConstants . CREATING , CommonStatesConstants . ACTIVE ) )
. and ( DYNAMIC_SCHEMA . STATE . in ( CommonStatesConstants . CREATING , CommonStatesConstants . ACTIVE ) )
boolean wasNull = value = = null & & ( field . isNullable ( ) | | ! field . hasDefault ( ) ) ;
resolve . put ( ( ( InstanceLink ) input . get ( 0 ) ) . getLinkName ( ) + "str" , ips ) ;
( PROCESS_INSTANCE_TIME . get ( ) * 1000 ) ) ) ) )
. and ( USER_PREFERENCE . ACCOUNT_ID . eq ( accountId ) ) . and ( USER_PREFERENCE . REMOVED . isNull ( ) ) ) . fetch ( ) . size ( ) = = 0 ;
return createProject ( type , request ) ;
private Account createProject ( String type , ApiRequest apiRequest ) {
service . getEnvironmentId ( ) , SERVICE . REMOVED , null ) ;
"str" , volumeUri ,
if ( ! InstanceConstants . CONTAINER_LIKE . contains ( instance . getKind ( ) ) )
String [ ] split = code . split ( "str" , 2 ) ;
throw new ClientVisibleException ( ResponseCodes . BAD_REQUEST , "str" ) ;
accessMode = ( String ) config . get ( LdapConstants . ACCESSMODE ) ;
serviceAccountUsername = ( String ) config . get ( LdapConstants . SERVICE_ACCOUNT_USERNAME_FIELD ) ;
serviceAccountPassword = ( String ) config . get ( LdapConstants . SERVICE_ACCOUNT_PASSWORD_FIELD ) ;
userLoginField = ( String ) config . get ( LdapConstants . USER_LOGIN_FIELD_FIELD ) ;
. orderBy ( ( SPREAD . get ( ) ? HOST . COMPUTE_FREE . desc ( ) : HOST . COMPUTE_FREE . asc ( ) ) , HOST . ID . asc ( ) )
assignItems ( provider , agent , host , state , process ) ;
assignItems ( entry . getKey ( ) , agent , nic , state , process ) ;
protected void assignItems ( NetworkServiceProvider provider , Agent agent , Object owner , ProcessState state , ProcessInstance processInstance ) {
String contextId = getContext ( processInstance , owner , state . getResource ( ) ) ;
String context = getContext ( processInstance , otherAgent , state . getResource ( ) ) ;
labelKeyValueStatusMap . put ( StringUtils . lowerCase ( record . value1 ( ) ) ,
. and ( AUTH_TOKEN . EXPIRES . greaterThan ( new Date ( ) ) )
Identity identity = identityManager . projectMemberToIdentity ( projectMember ) ;
Identity identity = identityManager . projectMemberToIdentity ( member ) ;
givenIdentity = identityManager . projectMemberToIdentity ( givenIdentity ) ;
identityManager . untransform ( identityManager . projectMemberToIdentity ( member ) ) ;
return Collections . singletonList ( projectMemberToIdentity ( ( String ) criteria . get ( "str" ) ) ) ;
Identity newIdentity = projectMemberToIdentity ( identity . getId ( ) ) ;
public Identity projectMemberToIdentity ( String id ) {
public Identity projectMemberToIdentity ( ProjectMember member ) {
if ( instance ! = null & & InstanceConstants . STATE_STOPPED . equals ( instance . getState ( ) ) ) {
String scheme = StringUtils . startsWithIgnoreCase ( request . getResponseUrlBase ( ) , "str" ) ? "str" : "str" ;
String scheme = StringUtils . startsWithIgnoreCase ( request . getResponseUrlBase ( ) , "str" ) ? "str" : "str" ;
super ( String . format ( "str" , storagePool . getId ( ) , volumeUri = = null ? 0 : volumeUri . hashCode ( ) ) ) ;
label = resourceDao . createAndSchedule ( Label . class , objectManager . convertToPropertiesFor ( Label . class , labelData ) ) ;
label = resourceDao . createAndSchedule ( Label . class , objectManager . convertToPropertiesFor ( Label . class , labelData ) ) ;
public static final String OAUTH_BASIC = "str" ;
String fullPort = listener . getSourcePort ( ) + "str" + listener . getSourcePort ( ) ;
private static final long serialVersionUID = 1760963263 ;
public final org . jooq . TableField < io . cattle . platform . core . model . tables . records . CredentialRecord , java . lang . Long > REGISTRY_ID = createField ( "str" , org . jooq . impl . SQLDataType . BIGINT , this , "str" ) ;
return java . util . Arrays . < org . jooq . ForeignKey < io . cattle . platform . core . model . tables . records . CredentialRecord , ? > > asList ( io . cattle . platform . core . model . Keys . FK_CREDENTIAL__ACCOUNT_ID , io . cattle . platform . core . model . Keys . FK_CREDENTIAL__REGISTRY_ID ) ;
public static final org . jooq . ForeignKey < io . cattle . platform . core . model . tables . records . CredentialRecord , io . cattle . platform . core . model . tables . records . StoragePoolRecord > FK_CREDENTIAL__REGISTRY_ID = ForeignKeys0 . FK_CREDENTIAL__REGISTRY_ID ;
public static final org . jooq . ForeignKey < io . cattle . platform . core . model . tables . records . CredentialRecord , io . cattle . platform . core . model . tables . records . StoragePoolRecord > FK_CREDENTIAL__REGISTRY_ID = createForeignKey ( io . cattle . platform . core . model . Keys . KEY_STORAGE_POOL_PRIMARY , io . cattle . platform . core . model . tables . CredentialTable . CREDENTIAL , io . cattle . platform . core . model . tables . CredentialTable . CREDENTIAL . REGISTRY_ID ) ;
public void setRegistryId ( java . lang . Long value ) ;
private static final long serialVersionUID = - 1833553748 ;
public void setRegistryId ( java . lang . Long value ) {
@javax.persistence.Column ( name = "str" , precision = 19 )
public java . lang . Long getRegistryId ( ) {
return io . cattle . platform . core . model . tables . CredentialTable . CREDENTIAL . REGISTRY_ID ;
return getRegistryId ( ) ;
setRegistryId ( value ) ;
setRegistryId ( from . getRegistryId ( ) ) ;
public CredentialRecord ( java . lang . Long id , java . lang . String name , java . lang . Long accountId , java . lang . String kind , java . lang . String uuid , java . lang . String description , java . lang . String state , java . util . Date created , java . util . Date removed , java . util . Date removeTime , java . util . Map < String , Object > data , java . lang . String publicValue , java . lang . String secretValue , java . lang . Long registryId ) {
setValue ( 13 , registryId ) ;
if ( address ! = null ) {
return ( List < T > ) children ( obj , rel . getObjectType ( ) , rel . getPropertyName ( ) ) ;
. orderBy ( SPREAD . get ( ) ? HOST . COMPUTE_FREE . desc ( ) : HOST . COMPUTE_FREE . asc ( ) )
if ( macro ! = null & & macro . deprecated ) {
if ( charTyped = = "str" & & project ! = null & & file . getViewProvider ( ) . getLanguages ( ) . contains ( LatteLanguage . INSTANCE ) ) {
if ( charTyped = = "str" & & project ! = null & & file . getViewProvider ( ) . getLanguages ( ) . contains ( LatteLanguage . INSTANCE ) ) {
if ( localpart . length ( ) ! = 0 ) {
unescapedCache = super . asUnescapedString ( ) + "str" + resource ;
String localpart = XmppStringUtils . parseLocalpart ( jidString ) ;
String localpart = XmppStringUtils . parseLocalpart ( escapedJidString ) ;
gracePeriodMap . put ( "str" , gracePeriod ) ;
logger . info ( "str" , endpoint . getAddress ( ) ) ;
HBaseUtils . verifyColumns ( columns , hTableDesc ) ;
currentValNull = variableWidthVector . getAccessor ( ) . isNull ( valuesReadInCurrentPass ) ;
List < String > files = selection . getFiles ( ) ;
Type t = ( ( GroupType ) type ) . getType ( path [ depth ] ) ;
BOUNDS_CHECKING_ENABLED = ASSERT_ENABLED | | ! "str" . equals ( System . getProperty ( "str" ) ) ;
public static final BooleanValidator JSON_EXTENDED_TYPES = new BooleanValidator ( "str" , false ) ;
this . ownsZkConnection = coordinator = = null & & ! isDirect ;
jsonReader = new org . apache . drill . exec . vector . complex . fn . JsonReader ( buffer , false , false , false ) ;
jsonReader = new org . apache . drill . exec . vector . complex . fn . JsonReader ( buffer , false , false , false ) ;
test ( "str" ) ;
test ( "str" ) ;
test ( "str" ) ;
String t4 = "str" ;
test ( "str" ) ;
test ( "str" ) ;
test ( "str" ) ;
test ( "str" ) ;
test ( "str" ) ;
test ( "str" ) ;
PARQUET_WRITER_ENABLE_DICTIONARY_ENCODING , false ) ;
DrillPBError error = ErrorHelper . logAndConvertError ( context . getCurrentEndpoint ( ) , "str" + exception . getMessage ( ) , exception , logger ) ;
throw new QueryInputException ( "str" + e . getMessage ( ) , e ) ;
throw new QueryInputException ( "str" + e . getMessage ( ) , e ) ;
rowCount + = rowGroup . getRowCount ( ) ;
if ( fmd . getValueCount ( ) = = 0 & & ( ! fmd . hasGroupCount ( ) | | fmd . getGroupCount ( ) = = 0 ) ) {
if ( fmd . getValueCount ( ) = = 0 & & ( ! fmd . hasGroupCount ( ) | | fmd . getGroupCount ( ) = = 0 ) ) {
} while ( ( ! status . isLeftRepeating ( ) | | status . isRightPositionInCurrentBatch ( ) ) & & status . isRightPositionAllowed ( ) & & doCompare ( status . getLeftPosition ( ) , status . getRightPosition ( ) ) = = 0 ) ;
assert ! inSetup : "str" ;
assert ! inProcessing : "str" ;
assert ! inWait : "str" ;
private static final boolean EXTRA_DEBUG = true ;
public static final int MAX_BROADCAST_THRESHOLD = Integer . MAX_VALUE ;
public static final OptionValidator MULTIPHASE = new BooleanValidator ( "str" , false ) ;
} catch ( AssertionError | Exception ex ) {
return options . getOption ( HASHAGG . getOptionName ( ) ) . bool_val ;
return options . getOption ( STREAMAGG . getOptionName ( ) ) . bool_val ;
return options . getOption ( MERGEJOIN . getOptionName ( ) ) . bool_val ;
return options . getOption ( BROADCAST . getOptionName ( ) ) . bool_val ;
int copiedRecords = copier . copyRecords ( remainderIndex , remainingRecordCount ) ;
logger . debug ( String . format ( "str" ,
g . getBlock ( "str" ) . _return ( var . invoke ( "str" ) . arg ( JExpr . direct ( "str" ) ) ) ; ;
@FunctionTemplate ( names = { "str" , "str" , "str" } , scope = FunctionScope . SIMPLE , nulls = NullHandling . NULL_IF_NULL )
sb . append ( "str" ) ;
sb . append ( "str" ) ;
offsetVector . data . set$ { ( minor . javaType ! type . javaType ) ? cap_first } ( ( index + 1 ) * $ { type . width } , outputStart + len ) ;
offsetVector . data . set$ { ( minor . javaType ! type . javaType ) ? cap_first } ( ( index + 1 ) * $ { type . width } , outputStart + len ) ;
v . getValueVector ( ) ) . alloc ( recordCapacity ) ;
ArrayList < Object > list = new ArrayList < Object > ( ) ;
mergeFrom ( data , offset , len , message , schema , DEFAULT_INPUT_FACTORY ) ;
Mutable < String > packageName , javaPackageName ;
DefaultIdStrategy primary = new DefaultIdStrategy ( ) ;
public int currentOffset ( )
throw new IllegalStateException ( "str" + file ) ;
int expectedSize = ComputedSizeOutput . getSize ( pojoCompare , schema , true ) ;
kSchema . typeClass ( ) . getName ( ) ) ;
System . setProperty ( "str" , "str" ) ;
System . getProperty ( "str" , "str" ) ) ;
Boolean . getBoolean ( "str" ) ;
ProtobufIOUtil . mergeFrom ( data , p2 , schema ) ;
return ( RuntimeFieldFactory < T > ) __inlineValues . get ( typeClass . getName ( ) ) ;
if ( len > CodedInput . DEFAULT_BUFFER_SIZE )
if ( len > CodedInput . DEFAULT_BUFFER_SIZE & & in instanceof InputStream )
if ( len > CodedInput . DEFAULT_BUFFER_SIZE )
static final int DEFAULT_BUFFER_SIZE = 4096 ;
this ( input , new byte [ DEFAULT_BUFFER_SIZE ] , decodeNestedMessageAsGroup ) ;
} else if ( size < buffer . length ) {
final byte [ ] chunk = new byte [ Math . min ( sizeLeft , buffer . length ) ] ;
IOUtil . mergeFrom ( in , message , schema , false ) ;
final ByteArrayOutputStream out = new ByteArrayOutputStream ( 512 ) ;
final ByteArrayOutputStream baos = new ByteArrayOutputStream ( 512 ) ;
final int remaining = lb . buffer . length - lb . offset ;
final int leftover = value . length - remaining ;
System . arraycopy ( value , remaining , lb . buffer , 0 , leftover ) ;
lb . offset + = leftover ;
"str" , 512 ) ;
"str" , 255 ) ;
Schema < T > schema , boolean decodeNestedMessageAsGroup )
boolean decodeNestedMessageAsGroup ) throws IOException
final CodedInput input = new CodedInput ( in , decodeNestedMessageAsGroup ) ;
boolean decodeNestedMessageAsGroup ) throws IOException
boolean decodeNestedMessageAsGroup ) throws IOException
boolean decodeNestedMessageAsGroup ) throws IOException
private final boolean decodeNestedMessageAsGroup ;
public ByteArrayInput ( byte [ ] buffer , boolean decodeNestedMessageAsGroup )
this ( buffer , 0 , buffer . length , decodeNestedMessageAsGroup ) ;
public ByteArrayInput ( byte [ ] buffer , int offset , int len , boolean decodeNestedMessageAsGroup )
this . decodeNestedMessageAsGroup = decodeNestedMessageAsGroup ;
if ( decodeNestedMessageAsGroup & & WIRETYPE_END_GROUP = = ( tag & TAG_TYPE_MASK ) )
if ( decodeNestedMessageAsGroup )
if ( decodeNestedMessageAsGroup )
private final boolean decodeNestedMessageAsGroup ;
boolean decodeNestedMessageAsGroup ) {
this . decodeNestedMessageAsGroup = decodeNestedMessageAsGroup ;
CodedInput ( final InputStream input , boolean decodeNestedMessageAsGroup ) {
this . decodeNestedMessageAsGroup = decodeNestedMessageAsGroup ;
if ( decodeNestedMessageAsGroup & & WIRETYPE_END_GROUP = = ( tag & TAG_TYPE_MASK ) ) {
boolean encodeNestedMessageAsGroup ) {
this . encodeNestedMessageAsGroup = encodeNestedMessageAsGroup ;
CodedInput ( final InputStream input , boolean encodeNestedMessageAsGroup ) {
this . encodeNestedMessageAsGroup = encodeNestedMessageAsGroup ;
return ProtoUtil . toUnderscoreCase ( str ) . append ( "str" ) . toString ( ) ;
if ( eq > 0 & & eq + 2 < formatName . length ( ) )
java . lang . String name , defaultValueConstant ;
public java . lang . String getDefaultValueConstant ( )
if ( last = = null | | v . number ! = last . number )
public abstract class Field < T > implements Comparable < Field < ? > >
public int compareTo ( Field < ? > f )
public void writeFixed32 ( int fieldNumber , int value ) throws IOException
public void writeSFixed32 ( int fieldNumber , int value ) throws IOException
public void writeSInt32 ( int fieldNumber , int value ) throws IOException
public void writeSInt32 ( int fieldNumber , int value ) throws IOException ;
public void writeFixed32 ( int fieldNumber , int value ) throws IOException ;
public void writeSFixed32 ( int fieldNumber , int value ) throws IOException ;
buffer [ offset ] = ( byte ) ( value > > 24 & 0xFF ) ;
pbJSON . mergeFrom ( parser , builder ) ;
pbJSON . mergeFrom ( parser , builder ) ;
pbJSON . mergeFrom ( parser , builder ) ;
pbJSON . mergeFrom ( parser , builder ) ;
pbJSON . mergeFrom ( parser , builder ) ;
pbJSON . mergeFrom ( parser , builder ) ;
pbJSON . mergeFrom ( parser , builder ) ;
pbJSON . mergeFrom ( parser , builder ) ;
public String getOption ( String key )
propsErr ( ) ;
static void propsErr ( )
File outputDir = new File ( "str" ) ;
throw new IllegalStateException ( "str" + outputDir + "str" ) ;
String outputClassName = fullClassName . substring ( fullClassName . lastIndexOf ( "str" ) + 1 ) ;
File outputDir = new File ( "str" ) ;
throw new IllegalStateException ( "str" + outputDir + "str" ) ;
parser . getCurrentToken ( ) + "str" +
throw new IOException ( "str" + name + "str" +
parser . getCurrentToken ( ) + "str" +
parser . getCurrentToken ( ) + "str" +
parser . getCurrentToken ( ) + "str" + _propertyMeta . getName ( ) + "str" +
public final class V22LiteJSON extends ProtobufJSON
throw new IOException ( "str" + name + "str" + Task . class ) ;
parser . getCurrentToken ( ) + "str" +
Assert . notNull ( customer , "str" ) ;
import org . springframework . data . jdbc . mapping . event . BeforeSaveEvent ;
return ( ApplicationListener < BeforeSaveEvent > ) event - > {
import org . springframework . data . jdbc . mapping . event . BeforeSaveEvent ;
public ApplicationListener < BeforeSaveEvent > timeStampingSaveTime ( ) {
private int compressionLevel = DEFAULT_COMPRESSIONLEVEL ;
private void loadContextScopeBean ( BeanDefinitionReference contextScopeBean , Consumer < BeanDefinition > beanDefinitionConsumer ) {
String sayHello ( String name ) ;
Single < String > sayHelloTwo ( String name ) ;
private boolean enabled = false ;
traceBody ( "str" , fullResponse . content ( ) ) ;
GET ( "str" , issuesController , "str" , Integer . class ) ;
public HttpStreamsServerHandler ( ) {
if ( httpClient = = null ) {
if ( response . getStatus ( ) . getCode ( ) < HttpStatus . MULTIPLE_CHOICES . getCode ( ) ) {
if ( httpClient ! = null ) {
if ( response . getStatus ( ) . getCode ( ) > = HttpStatus . BAD_REQUEST . getCode ( ) ) {
if ( response . getStatus ( ) . getCode ( ) > = HttpStatus . BAD_REQUEST . getCode ( ) ) {
if ( s ! = null ) {
if ( s ! = null ) {
return new HttpCall ( httpClient , endpoint , compressionEnabled , encodedSpans ) ;
if ( encoding ! = null ) {
if ( endpoint ! = null ) {
if ( CollectionUtils . isNotEmpty ( urls ) ) {
if ( configuration = = null ) {
if ( metrics ! = null ) {
if ( reporter ! = null ) {
if ( ! GlobalTracer . isRegistered ( ) ) {
. orElseGet ( ( ) - > super . methodFromResponse ( httpResponse ) ) ;
return value . orElseGet ( ( ) - > super . route ( response ) ) ;
return value . orElseGet ( ( ) - > super . route ( response ) ) ;
try ( Tracer . SpanInScope scope = httpTracing . tracing ( ) . tracer ( ) . withSpanInScope ( span ) ) {
if ( object instanceof HttpResponse ) {
if ( active ! = null ) {
if ( instrumenter ! = null ) {
if ( existing ! = null & & ! ( existing instanceof InstrumentScheduleAction ) ) {
if ( instrumenter ! = null ) {
if ( existing ! = null & & ! ( existing instanceof TracingRunnableInstrumenter ) ) {
if ( LOG . isErrorEnabled ( ) ) {
if ( active ! = null ) {
if ( CollectionUtils . isNotEmpty ( value ) ) {
this ( publisher , tracer , ( Tracer . SpanBuilder ) null ) ;
if ( parentSpan ! = null & & spanBuilder ! = null ) {
if ( spanBuilder ! = null ) {
try ( Scope ignored = tracer . scopeManager ( ) . activate ( span , false ) ) {
try ( Scope ignored = tracer . scopeManager ( ) . activate ( span , isSingle ) ) {
if ( isSingle ) {
try ( Scope ignored = tracer . scopeManager ( ) . activate ( span , true ) ) {
if ( code > HTTP_SUCCESS_CODE_UPPER_LIMIT ) {
if ( error ! = null ) {
if ( message = = null ) {
@ConfigurationBuilder ( prefixes = "str" , excludes = { "str" , "str" , "str" , "str" , "str" , "str" , "str" } )
if ( configuration ! = null ) {
if ( samplerConfiguration ! = null ) {
if ( sampler ! = null ) {
if ( errorParser ! = null ) {
if ( propagationFactory ! = null ) {
if ( clock ! = null ) {
if ( traceContext ! = null ) {
if ( this . configuration . isExpandExceptionLogs ( ) ) {
if ( this . configuration . isZipkinSharedRpcSpan ( ) ) {
if ( reporter ! = null ) {
if ( sampler ! = null ) {
if ( ! GlobalTracer . isRegistered ( ) ) {
if ( LOG . isTraceEnabled ( ) ) {
if ( LOG . isTraceEnabled ( ) ) {
if ( returnObject = = null | | ( returnObject instanceof TracingPublisher ) ) {
if ( returnedObject = = null | | ( returnedObject instanceof TracingPublisher ) ) {
if ( CompletionStage . class . isAssignableFrom ( javaReturnType ) ) {
if ( completionStage ! = null ) {
return attr . subSequence ( start , end ) ;
if ( StringUtils . isEmpty ( System . getProperty ( JAEGER_SERVICE_NAME ) ) ) {
if ( samplerConfiguration ! = null ) {
if ( reporterConfiguration ! = null ) {
if ( samplerConfiguration ! = null ) {
if ( reporterConfiguration ! = null ) {
if ( codecConfiguration ! = null ) {
if ( metricsFactory ! = null ) {
if ( senderConfiguration ! = null ) {
if ( callable instanceof TracingCallable ) {
try ( Tracer . SpanInScope ignored = tracer . withSpanInScope ( span ) ) {
try ( Tracer . SpanInScope ignored = tracer . withSpanInScope ( span ) ) {
try ( Tracer . SpanInScope ignored = tracer . withSpanInScope ( span ) ) {
if ( existing ! = null ) {
LOG . error ( "str" , invocation . getDeclaringType ( ) . getName ( ) , invocation , nase . getServiceID ( ) ) ;
LOG . debug ( "str" , contentType ) ;
InterceptorChain < String > chain = new MethodInterceptorChain < > (
@Parameter ( defaultValue = "str" )
if ( isInPictureInPictureMode ( ) ) {
public final class Editor implements SharedPreferences . Editor {
WriteAction . runAndWait ( newModel : : commit ) ;
WriteAction . runAndWait ( modifiableModel : : commit ) ;
WriteAction . runAndWait ( modifiableModel : : commit ) ;
if ( ideFrame = = null | | ! ( ( JFrame ) ideFrame ) . isVisible ( ) )
import consulo . csharp . lang . psi . impl . source . resolve . methodResolving . MethodResolvePriorityInfo ;
MethodResolvePriorityInfo calcResult = ( ( MethodResolveResult ) validResult ) . getCalcResult ( ) ;
import consulo . csharp . lang . psi . impl . source . resolve . methodResolving . MethodResolvePriorityInfo ;
MethodResolvePriorityInfo calcResult = ( ( MethodResolveResult ) validResult ) . getCalcResult ( ) ;
DotNetTypeRef typeRef = UnityFunctionManager . createTypeRef ( scope , entry . getValue ( ) ) ;
public class UnitySpecificMethodCompletion implements CSharpMemberAddByCompletionContributor
showNotify ( project , pluginFileName , unityPluginFile , "str" , Collections . emptyList ( ) ) ;
OpenFileDescriptor descriptor = new OpenFileDescriptor ( openedProject , fileByPath , body . line - 1 , - 1 ) ;
return new LineMarkerInfo < PsiElement > ( element , element . getTextRange ( ) , Unity3dIcons . EventMethod , Pass . LINE_MARKERS , new ConstantFunction < PsiElement ,
list . add ( homePath + "str" ) ;
list . add ( homePath + "str" ) ;
DotNetTypeDeclaration type = DotNetPsiSearcher . getInstance ( getProject ( ) ) . findType ( attribute . getType ( ) , scope , CSharpTransform . INSTANCE ) ;
Unity3dRootModuleExtension unity3dRootModuleExtension = moduleRootLayer . getExtension ( Unity3dRootModuleExtension . class ) ;
public static final ShaderLabRole ZWrite = new ShaderLabSimpleRole ( "str" , "str" ) ;
public static final ShaderLabRole Lighting = new ShaderLabSimpleRole ( "str" , "str" ) ;
public static final ShaderLabRole ZTest = new ShaderLabSimpleRole ( "str" , "str" , "str" , "str" , "str" , "str" , "str" ) ;
for ( int i = 0 ; i < paths . length ; i + + )
addUnityExtensions ( list , homePath + "str" ) ;
compileContext . addMessage ( CompilerMessageCategory . ERROR , "str" , null , - 1 , - 1 ) ;
super ( new VerticalFlowLayout ( true , true ) ) ;
static final int MSG_COUNT = 10 * 1000 ;
notifyFiberStart ( t , fiber ) ;
Util . hitKeys ( robot , KeyEvent . VK_SHIFT , KeyEvent . VK_ESCAPE ) ;
assertTrue ( exceptionType . isAssignableFrom ( e . getCause ( ) . getClass ( ) ) ) ;
assertThrows ( IncompatibleClassChangeError . class , C ) ;
assertInvokeVirtualEquals ( 88 , C ) ;
assertThrows ( IncompatibleClassChangeError . class , C ) ;
assertInvokeVirtualEquals ( 99 , C ) ;
assertInvokeVirtualEquals ( 44 , C ,
< T , R > Collector < T , String , R > m ( Supplier < ? extends R > supplier , BiConsumer < R , T > accumulator ) {
< T , C extends Collection < T > > Collector < T , String , C > test1 ( Supplier < C > collectionFactory ) {
Collector < String , String , StringBuilder > test2 ( Supplier < StringBuilder > sb ) {
< R > Collector < Integer , String , R > m ( Supplier < R > s ) { return null ; }
Collector < T , String , M > g ( Function < T , K > classifier , Supplier < M > mapFactory , Collector < T , String , D > downstream ) { return null ; }
if ( ! path . endsWith ( "str" ) ) {
"str" , false ,
"str" , true ,
"str" , true ,
"str" , false ,
boolean awaitStopped = getParamAsBoolean ( "str" , request ) . orElse ( false ) ;
if ( awaitStopped ) {
timeWaited + = 10 ;
timeWaited + = 10 ;
private int schedulerMaxLinks = 100000 ;
private String dataFormat = "str" ;
private boolean englishLanguageDetectionEnabled = false ;
private int maxPagesPerDomain = Integer . MAX_VALUE ;
} catch ( BoilerpipeProcessingException | ArrayIndexOutOfBoundsException e ) {
httpFetcher . setConnectionRequestTimeout ( 1 * 60 * 1000 ) ;
PaginaURL pageParser = new PaginaURL ( page . getURL ( ) , page . getContent ( ) ) ;
private int connectionPoolSize = 10000 ;
private static final int MINIMUM_ACCESS_INTERVAL = 5000 ;
logger . info ( "str" + url , e . getMessage ( ) ) ;
Map < String , String > expectedMetadata = new HashMap < String , String > ( ) ;
this . dataFormat = params . getParamOrDefault ( "str" , "str" ) ;
targetModel . resetTimestamp ( ) ;
autocomplete . resolveAfterFilter ( autocomplete . getTextField ( ) . getText ( ) . toString ( ) , true ) ;
catch ( JSONException ex ) {
return content . getTextLength ( ) = = 0 ? 0 : content . getTextLength ( ) ;
registerManager . getRegister ( registerName ) . setContent ( content , false ) ;
editorAdaptor . getHistory ( ) . lock ( historyLock ) ;
+ "str" + to . getViewOffset ( ) + "str" ;
if ( tabstopDiff > 0 & & indent . length ( ) > = tabstopDiff ) {
while ( ( indent . length ( ) - index ) > = tabstop ) {
this . placeCursorAfter = placeCursorAfter ;
return new VisualMotionState ( Motion2VMC . LINEWISE , ImprovedParagraphMotion . PARAGRAPH_MOTIONS ) ;
public static final Option < String > SYNC_MODIFIABLE = globalString ( "str" , "str" , "str" , "str" ) ;
if ( specialKeys . containsKey ( event . keyCode ) ) {
MessageMode . CLIP_LINES_HINT } ;
public static final Option < Boolean > SEARCH_REGEX = bool ( "str" , true , "str" ) ;
resetCommandBuffer ( ) ;
editorAdaptor . getUserInterfaceService ( ) . setErrorMessage ( "str" + filename + "str" ) ;
if ( position > 1 )
if ( transition ! = null & & transition . getValue ( ) ! = null ) {
activateDefaultRegister ( ) ;
protected int destination ( int offset , TextContent content , boolean bailOff , boolean hasMoreCounts ) {
protected abstract int destination ( int offset , TextContent viewContent , boolean bailOff , boolean hasMoreCounts ) ;
offset = destination ( offset , editorAdaptor . getModelContent ( ) , bailOff & & i = = 0 , i ! = count - 1 ) ;
protected int destination ( int offset , TextContent content , boolean bailOff , boolean hasMoreCounts ) {
if ( ! shouldStopAtLeftBoundingChar ( ) | | hasMoreCounts )
while ( backwards ? offset > end : offset < end ) {
vim . getUserInterfaceService ( ) . setErrorMessage ( "str" + name ) ;
public static final Option < Boolean > SEARCH_HIGHLIGHT = bool ( "str" , false , "str" ) ;
assertEquals ( ( Integer ) 1 , s1 . press ( key ( "str" ) ) . getValue ( ) ) ;
assertEquals ( ( Integer ) 1 , union ( leaf , simpleB ) . press ( key ( "str" ) ) . getValue ( ) ) ;
assertEquals ( ( Integer ) 12 , union ( leaf , simpleB , simpleC ) . press ( key ( "str" ) )
assertEquals ( ( Integer ) 13 , union ( leaf , simpleB , simpleC ) . press ( key ( "str" ) )
assertEquals ( ( Character ) "str" , abcMap . press ( key ( "str" ) ) . getNextState ( ) . press ( key ( "str" ) )
assertEquals ( ( Integer ) 1 , new UnionState < Integer > ( state_a1 , state_a2 ) . press (
assertEquals ( ( Integer ) 2 , new UnionState < Integer > ( state_a2 , state_a1 ) . press (
assertEquals ( ( Integer ) 1 , new UnionState < Integer > ( state_a1 , state_b2 ) . press (
assertEquals ( ( Integer ) 2 , new UnionState < Integer > ( state_a1 , state_b2 ) . press (
assertEquals ( ( Integer ) 1 , new UnionState < Integer > ( state_b2 , state_a1 ) . press (
assertEquals ( ( Integer ) 2 , new UnionState < Integer > ( state_b2 , state_a1 ) . press (
assertEquals ( ( Integer ) 1 , union12 . press ( key ( "str" ) ) . getNextState ( ) . press ( key ( "str" ) )
assertEquals ( ( Integer ) 2 , union21 . press ( key ( "str" ) ) . getNextState ( ) . press ( key ( "str" ) )
if ( platformCommands ! = null & & platformCommands . contains ( tokens . peek ( ) ) ) {
boolean recursive = ! unconsumedKeyStrokes . isEmpty ( ) | | lastValue ! = null ;
changes = l . getEndOffset ( ) - p . getPosition ( ) ;
Token t = new SearchMove ( false ) ;
return new FindMove ( target , ! backwards , stopBeforeTarget ) ;
for ( int i = 0 ; i < pageCount ; i + + ) {
p . setPosition ( begin + indent . length ( ) + VimConstants . NEWLINE . length ( ) ) ;
return selectedRange . y > 0 ? new Selection ( selectedRange . x , selectedRange . y ) : null ;
expectedException . expectMessage ( "str" ) ;
if ( annotatedElement . getModifiers ( ) . contains ( PRIVATE ) ) {
getColumnAnnotationClass ( ) . getSimpleName ( ) + "str" + annotatedElement . getSimpleName ( )
public CompleteBuilder projection ( @Nullable String . . . columns ) {
public CompleteBuilder where ( @Nullable String where ) {
public CompleteBuilder whereArgs ( @Nullable Object . . . whereArgs ) {
public CompleteBuilder sortOrder ( @Nullable String sortOrder ) {
@NonNull @Override public ContentValues _toContentValues ( @NonNull Resources res ) {
@NonNull ContentValues _toContentValues ( @NonNull Resources res ) ;
Uri uri = mContentResolver . insert ( buildUri ( storableItem . getClass ( ) ) , storableItem . _toContentValues ( mResources ) ) ;
storableItem . _toContentValues ( mResources ) ,
static final FetchedDataChunk SHUTDOWN_COMMAND = new FetchedDataChunk ( null , null , - 1 ) ;
this . blackListTopics = Arrays . asList ( consumerConfig . getMirrorTopicsBlackList ( ) . split ( "str" ) ) ;
return System . getProperty ( "str" , "str" ) ;
return Utils . getInt ( System . getProperties ( ) , "str" , 9094 ) ;
assertEquals ( creatorId + "str" , broker . getZKString ( ) ) ;
if ( OffsetRequest . SMALLES_TIME_STRING . equals ( config . getAutoOffsetReset ( ) ) ) {
if ( OffsetRequest . SMALLES_TIME_STRING . equals ( autoOffsetReset ) ) {
public static final String SMALLES_TIME_STRING = "str" ;
this . autoOffsetReset = get ( "str" , OffsetRequest . SMALLES_TIME_STRING ) ;
import com . sohu . jafka . utils . KV . StringTuple ;
private final Pool < StringTuple , BlockingQueue < FetchedDataChunk > > queues ;
this . queues = new Pool < StringTuple , BlockingQueue < FetchedDataChunk > > ( ) ;
queues . put ( new StringTuple ( topic , threadId ) , stream ) ;
Map < StringTuple , String > partitionOwnershipDecision = new HashMap < StringTuple , String > ( ) ;
partitionOwnershipDecision . put ( new StringTuple ( topic , partition ) , consumerThreadId ) ;
for ( Map . Entry < StringTuple , String > e : partitionOwnershipDecision . entrySet ( ) ) {
successfullyOwnerdPartitions . add ( new StringTuple ( topic , partition ) ) ;
for ( StringTuple topicAndPartition : successfullyOwnerdPartitions ) {
offset = earliestOrLatestOffset ( topic , partition . brokerId , partition . partId , OffsetRequest . EARLIES_TTIME ) ;
offset = earliestOrLatestOffset ( topic , partition . brokerId , partition . partId , OffsetRequest . LATES_TTIME ) ;
BlockingQueue < FetchedDataChunk > queue = queues . get ( new StringTuple ( topic , consumerThreadId ) ) ;
public static class StringTuple extends KV < String , String > {
public StringTuple ( String k , String v ) {
_logger . error ( "str" + qname + "str" + vhost + "str" + "str" + result + "str" + body ) ;
System . out . println ( "str" ) ;
public PostFX blur ( int blurSize , float sigma , boolean horizontal )
blurShader . set ( "str" , horizontal ? 1 : 0 ) ;
else if ( Utilities . globalSettings . getBoolean ( "str" ) ) {
put ( "str" , false ) ;
put ( "str" , false ) ;
put ( "str" , 8 ) ;
if ( param . startsWith ( "str" ) | | param . startsWith ( "str" ) ) {
getUtil ( ) . gotoPage ( "str" , "str" , "str" ) ;
executeInCurrentExecutionContext ( async ) ;
executeInCurrentExecutionContext ( async ) ;
private void executeInCurrentExecutionContext ( boolean async ) throws RenderingException
if ( ! async & & ! this . parameters . isContentTransformed ( ) ) {
allowing ( mockSetup . bridge ) . getTranslatedDocumentInstance ( mockDocument ) ;
private static final String BASEDIR = "str" ;
import static org . mockito . ArgumentMatchers . anyMap ;
when ( query . bindValues ( anyMap ( ) ) ) . thenReturn ( query ) ;
props . setProperty ( "str" , dbProperties . get ( 5 ) ) ;
public static void afterAll ( )
String expectedStatement = "str" ;
expectedStatement = "str" ;
throw new RuntimeException ( String . format ( "str" , DBUSERNAME ) , e ) ;
"str" + StringUtils . join ( MATCHING_EVENT_TYPES , "str" ) + "str" , false , true ,
List < Object > parameters = new ArrayList < > ( ) ;
List < Object > parameters = new ArrayList < > ( ) ;
List < Object > paramList = new ArrayList < > ( 4 ) ;
List < Object > paramList = new ArrayList < > ( 4 ) ;
databaseId = selectQuery . uniqueResult ( ) ;
+ "str" ) ;
where . append ( "str" ) ;
where . append ( "str" ) ;
return searchEvents ( "str" , filter , false , nb , start , parameterValues , context ) ;
return searchEvents ( "str" , filter , false , nb , start , parameterValues , context ) ;
return searchEvents ( "str" , filter , false , nb , start , parameterValues , context ) ;
return searchEvents ( "str" , filter , false , nb , start ,
return searchEvents ( "str" , filter , false , nb , start , parameterValues , context ) ;
return this . searchEvents ( "str" , "str" , false , false , 0 , 0 , params , context ) ;
if ( Query . HQL . equals ( getLanguage ( ) ) & & LEGACY_HQL_MATCHER . matcher ( this . statement ) . find ( ) ) {
where . append ( "str" + parameterValues . size ( ) ) ;
where . append ( "str" ) ;
where . append ( "str" ) ;
List < Object > queryParameters = new ArrayList < > ( ) ;
where . append ( "str" ) ;
where . append ( "str" ) ;
queryParameters . add ( escapedSpaceReference + LIKE_APPEND ) ;
return getTagCountForQuery ( "str" , where . toString ( ) , queryParameters , context ) ;
getDriver ( ) . waitUntilCondition ( input - > input . getWindowHandles ( ) . size ( ) = = existingTabHandles . length + 1 ) ;
public void setup ( TestUtils setup ) throws Exception
this . logger . warn ( "str" ,
LOGGER . info ( "str" ,
DockerTestUtils . setLogbackLoggerLevel ( "str" , Level . TRACE ) ;
localEvent . setSource ( unserializeDeletedDocument ( remoteEvent . getSource ( ) , xcontext ) ) ;
private XWikiDocument unserializeDeletedDocument ( Serializable remoteData , XWikiContext xcontext )
return getBaseURL ( ) + ( ( StringUtils . isEmpty ( wiki ) | | wiki . equals ( "str" ) ) ? "str" : "str" + wiki + "str" ) ;
manage ( ) . timeouts ( ) . implicitlyWait ( 1 , TimeUnit . MILLISECONDS ) ;
mockStore . stubs ( ) . method ( "str" ) . will ( new CustomStub ( "str" )
XWikiDocument document = original . clone ( ) ;
this . logger . error ( "str" ,
this . logger . error (
DockerTestUtils . setLogbackLoggerLevel ( "str" , Level . DEBUG ) ;
tempdir . exists ( ) ) , e ) ;
@FindBy ( xpath = "str" )
protected DocumentReference getPre11DocumentReference ( File directory ) throws DataMigrationException
throws ParserConfigurationException , SAXException , IOException , DataMigrationException
@FindBy ( xpath = "str" )
this . asyncContext . useEntity ( reference ) ;
if ( parameters . isImage ( ) & & getFeed ( ) . getImage ( ) ! = null ) {
XDOM transformedBlock = this . xdom . clone ( ) ;
? new MySQLContainer < > ( String . format ( "str" , testConfiguration . getDatabaseTag ( ) ) )
this . verbose = newVerbose ;
private static final String VERBOSE_PROPERTY = "str" ;
private boolean verbose ;
resolveVerbose ( ) ;
private void resolveVerbose ( )
this . verbose = verbose ;
boolean newOffline = this . uiTestAnnotation . offline ( ) ;
public boolean isVerbose ( )
return this . verbose ;
if ( testConfiguration . isVerbose ( ) ) {
if ( testConfiguration . isVerbose ( ) ) {
if ( this . testConfiguration . isVerbose ( ) ) {
if ( testConfiguration . isVerbose ( ) ) {
if ( testConfiguration . isVerbose ( ) ) {
if ( testConfiguration . isVerbose ( ) ) {
if ( testConfiguration . isVerbose ( ) ) {
if ( testConfiguration . isVerbose ( ) ) {
if ( testConfiguration . isVerbose ( ) ) {
if ( testConfiguration . isVerbose ( ) ) {
if ( testConfiguration . isVerbose ( ) ) {
if ( testConfiguration . isVerbose ( ) ) {
if ( testConfiguration . isVerbose ( ) ) {
boolean verbose ( ) default false ;
boolean offline ( ) default false ;
f . format ( "str" ) ;
f . format ( "str" ) ;
assertEquals ( new PageReference ( CURRENT_WIKI , CURRENT_SPACE ) , reference ) ;
. createQuery ( "str" , Query . HQL ) )
Assert . assertEquals ( "str" , attachment . getMimeType ( ) ) ;
assertEquals ( String . format ( "str" , query ) , 1 , resultSize ) ;
this . logger . error ( "str" , docReference , e ) ;
return configurationSource . getProperty ( "str" , false ) ;
spaceAdministrationPage . getMetaDataValue ( "str" ) . equals ( "str" ) ) ;
getUtil ( ) . rest ( ) . deletePage ( "str" , "str" ) ;
descriptorDAB . setRoleType ( DocumentAccessBridge . class ) ;
@Mojo ( name = "str" , defaultPhase = LifecyclePhase . PREPARE_PACKAGE , requiresProject = true )
@Scope ( value = "str" )
public static final String EXTENSION_CLASSNAME = EXTENSION_SPACENAME + "str" ;
public static final String EXTENSIONVERSION_CLASSNAME = EXTENSION_SPACENAME + "str" ;
public static final String EXTENSIONDEPENDENCY_CLASSNAME = EXTENSION_SPACENAME + "str" ;
public static final String EXTENSIONPROXY_CLASSNAME = EXTENSION_SPACENAME + "str" ;
when ( coreConfigurationMock . getDefaultDocumentSyntax ( ) ) . thenReturn ( Syntax . XWIKI_2_1 ) ;
when ( coreConfiguration . getDefaultDocumentSyntax ( ) ) . thenReturn ( Syntax . XWIKI_2_1 ) ;
if ( ! deletedDocumentAPI . canUndelete ( ) ) {
if ( ! deletedDocumentAPI . canUndelete ( ) ) {
private static final Logger LOGGER = LoggerFactory . getLogger ( UndeleteAction . class ) ;
+ batchId + "str" , this . logRule . getMessage ( 0 ) ) ;
this . mail . waitForIncomingEmail ( 30000L , 1 ) ;
this . mail . waitForIncomingEmail ( 30000L , 3 ) ;
LOGGER . warn ( "str" ,
LOGGER . warn ( "str" ,
LOGGER . warn ( "str" ,
LOGGER . warn ( "str" ,
LOGGER . warn ( "str" ,
needsUpdate | = bclass . addTextAreaField ( "str" , "str" , 50 , 20 , "str" ) ;
needsUpdate = setClassDocumentFields ( document , document . getDocumentReference ( ) . getName ( ) ) ;
return fakeDocument . display ( getSyntaxFactory ( ) . createSyntaxFromIdString ( targetSyntaxId ) , true , true ,
this . mocker . getComponentUnderTest ( ) . url ( "str" , "str" , Collections . < String , Object > emptyMap ( ) ) ) ;
return successMessage . isDisplayed ( ) ;
private SpaceReferenceResolver < String > defaultSpaceReferenceResolver ;
return this . defaultSpaceReferenceResolver . resolve ( resourceReference . getReference ( ) , baseReference ) ;
Assert . assertEquals ( Arrays . asList ( ) , extension . getFeatures ( ) ) ;
protected ResourceType resourceType ;
this . resourceType = type ;
public EntityReference resolve ( ResourceReference resourceReference , EntityType entityType , Object . . . parameters )
if ( this . resourceType ! = null & & ! resourceReference . getType ( ) . equals ( this . resourceType ) ) {
. format ( "str" , this . resourceType , resourceReference ) ) ;
return convertReference ( entityReference , entityType ) ;
protected EntityReference convertReference ( EntityReference entityReference , EntityType entityType )
@Named ( "str" )
public static final ParameterizedType TYPE_RESOURCEREFERENCE =
new LinkedHashSet < String > ( Arrays . asList ( "str" , "str" ,
LOGGER . error ( "str" , context . getWiki ( ) . getEncoding ( ) , e ) ;
Assert . assertEquals ( Arrays . asList ( "str" ) , extension . getFeatures ( ) ) ;
Assert . assertEquals ( Arrays . asList ( "str" ) , extension . getFeatures ( ) ) ;
Assert . assertEquals ( Arrays . asList ( "str" ) , extension . getFeatures ( ) ) ;
LoginPage loginPage = LoginPage . gotoPage ( ) ;
this . resourceReferenceManager = Utils . getComponent ( ( Type ) ResourceReferenceManager . class ) ;
( ( PropertyClass ) property ) . setName ( name ) ;
getDriver ( ) . waitUntilElementIsVisible ( By . cssSelector ( "str" ) ) ;
@FindBy ( xpath = "str" )
@FindBy ( xpath = "str" )
Assert . assertEquals ( getUtil ( ) . getURL ( Arrays . asList ( "str" , this . baseExtension . getName ( ) ) , "str" ) ,
Assert . assertEquals ( getUtil ( ) . getURL ( Arrays . asList ( "str" , this . baseExtension . getName ( ) ) , "str" ) ,
Assert . assertEquals ( getUtil ( ) . getURL ( Arrays . asList ( "str" , this . baseExtension . getName ( ) ) , "str" ) ,
rest ( ) . savePage ( reference . getDocumentReference ( ) ) ;
sendMailPage . setHost ( "str" ) ;
StringBuilder query = new StringBuilder ( "str" ) ;
query . append ( "str" + createSpaceQuery ( false ) + "str" ) ;
if ( canSendEndWikiSpace ( force ) ) {
private boolean canSendEndWikiSpace ( boolean force )
currentValue . append ( value ) ;
assertFalse ( HqlQueryUtils . isSafe ( "str" ) ) ;
@Path ( "str" )
@Scope ( value = "str" , pattern = "str" )
statement . setString ( 2 , spaceName ) ;
private Provider < WikiDescriptorBuilder > wikiDescriptorBuilderProvider ;
this . wikiDescriptorBuilderProvider . get ( ) . save ( descriptor ) ;
descriptor = this . wikiDescriptorBuilderProvider . get ( ) . buildDescriptorObject ( serverClassObjects , document ) ;
String reference = "str" ;
private Provider < WikiDescriptorDocumentHelper > descriptorDocumentHelperProvider ;
documentNames = this . descriptorDocumentHelperProvider . get ( ) . getAllXWikiServerClassDocumentNames ( ) ;
String wikId = this . descriptorDocumentHelperProvider . get ( ) . getWikiIdFromDocumentFullname ( documentName ) ;
XWikiDocument document = descriptorDocumentHelperProvider . get ( ) . findXWikiServerClassDocument ( wikiAlias ) ;
XWikiDocument document = descriptorDocumentHelperProvider . get ( ) . getDocumentFromWikiId ( wikiId ) ;
when ( this . mockQueryManage . createQuery ( "str" , Query . XWQL ) ) . thenReturn ( query ) ;
throw new RuntimeException ( "str" + OldRendering . class
doc . setSyntax ( Syntax . XWIKI_2_1 ) ;
if ( pageURL ! = null ) {
Assert . fail ( "str" + this . baseExtension . getId ( ) . getId ( ) + "str" ) ;
this . logger . debug ( "str" , e ) ;
queryString = String . format ( "str" ,
+ "str" , MailStatus . class . getName ( ) ) ;
queryString = String . format ( "str" ,
+ "str" , MailStatus . class . getName ( ) ) ;
toggleTopMenu ( "str" ) ;
toggleTopMenu ( "str" ) ;
toggleTopMenu ( "str" ) ;
if ( StringUtils . isBlank ( doc . getTitle ( ) ) ) {
String result = getUserConfiguration ( ) . getProperty ( prefname , String . class ) ;
this . resourceReferenceSerializer = mocker . getInstance ( ResourceReferenceTypeSerializer . class ) ;
By . xpath ( "str" + jobName + "str" + actionLinkName + "str" ) ) . click ( ) ;
@FindBy ( xpath = "str" )
@FindBy ( linkText = "str" )
@FindBy ( xpath = "str" )
. findElements ( By . xpath ( "str" ) ) . size ( ) > 0 ;
return getDriver ( ) . findElements ( By . xpath ( "str" ) )
@FindBy ( xpath = "str" )
@FindBy ( xpath = "str"
+ "str" ) ) . click ( ) ;
getDriver ( ) . findElement ( By . xpath ( "str" ) ) . click ( ) ;
getDriver ( ) . findElement ( By . xpath ( "str" ) ) . click ( ) ;
getDriver ( ) . findElement ( By . xpath ( "str" ) ) . click ( ) ;
getDriver ( ) . findElement ( By . xpath ( "str" ) ) . click ( ) ;
if ( getUtil ( ) . hasElement ( By . xpath ( "str" ) ) ) {
new DefaultParameterizedType ( null , MimeMessageFactory . class , type ) ,
DocumentReference documentReference = new DocumentReference ( "str" , "str" , "str" ) ;
int objectNumber = getObjectMailNumber ( documentReference , mailClassReference , computedLocale ) ;
Locale locale ) throws MessagingException ;
"str" , attachmentReference ) , e ) ;
jobStatus = job . getStatus ( ) ;
private ConfigurationSource xwikicfg ;
return super . isPathBasedMultiWiki ( "str" . equals ( this . xwikicfg . getProperty ( "str" , "str" ) ) ) ;
return super . getWikiPathPrefix ( this . xwikicfg . getProperty ( "str" , "str" ) ) ;
String prefix = super . getWikiPathPrefix ( this . xwikicfg . getProperty ( "str" , "str" ) ) ;
String legacyValue = this . xwikicfg . getProperty ( "str" , "str" ) ;
ComponentManager componentManager = Utils . getRootComponentManager ( ) ;
LOGGER . error ( "str" , context . getAction ( ) , e ) ;
assertTrue ( wikiLink . getURL ( ) . endsWith ( "str" ) ) ;
Query query = queryManager . createQuery ( "str" , Query . XWQL ) ;
if ( ! entry . isDirectory ( ) & & zis . canReadEntryData ( entry ) ) {
if ( ! ctx . isMainWiki ( )
throw new WikiManagerException ( localizationManager . getTranslationPlain ( "str" , wikiId ) , e ) ;
throw new WikiManagerException ( localizationManager . getTranslationPlain ( "str" , wikiId ) , e ) ;
throw new IllegalArgumentException ( "str" + str ) ;
write ( ( OutputStream ) zipStream , encoding ) ;
public static final String ROLEHINT = "str" ;
if ( context . getWiki ( ) . ParamAsLong ( "str" , 0 ) = = 1 ) {
if ( context . getWiki ( ) . ParamAsLong ( "str" , 1 ) = = 1 ) {
LOGGER . error ( "str" , currentWiki , e ) ;
new WikiReference ( "str" ) ) . toString ( ) ) ;
String . format ( "str" , DISTRIBUTION_ACTION ) ) ;
. putAction ( "str" , Right . VIEW )
LegacyTestWiki testWiki = new LegacyTestWiki ( getMockery ( ) , getComponentManager ( ) , filename , legacymock ) ;
assertAccess ( "str" ,
this . mockedObjects . add ( mockRightBaseObject ( entry . getKey ( ) , type , true , false ) ) ;
this . mockedObjects . add ( mockRightBaseObject ( entry . getKey ( ) , type , false , true ) ) ;
this . mockedObjects . add ( mockRightBaseObject ( entry . getKey ( ) , type , false , false ) ) ;
this . mockRightService . stubs ( ) . method ( "str" ) . will ( returnValue ( true ) ) ;
String LEVEL_FIELD_NAME = "str" ;
protected XWikiContext context ;
this . context = context ;
this . context = context ;
return this . xcontextProvider ! = null ? this . xcontextProvider . get ( ) : this . context ;
DocumentReferenceResolver . TYPE_REFERENCE , "str" ) ;
public static final EntityReference GROUPCLASS_REFERENCE = new EntityReference ( "str" , EntityType . DOCUMENT ,
EntityType . DOCUMENT , new EntityReference ( "str" , EntityType . SPACE ) ) ;
public static final EntityReference SHEETCLASS_REFERENCE = new EntityReference ( "str" , EntityType . DOCUMENT ,
EntityType . DOCUMENT , new EntityReference ( "str" , EntityType . SPACE ) ) ;
public static final EntityReference RIGHTCLASS_REFERENCE = new EntityReference ( "str" , EntityType . DOCUMENT ,
EntityType . DOCUMENT , new EntityReference ( "str" , EntityType . SPACE ) ) ;
EntityType . DOCUMENT , new EntityReference ( "str" , EntityType . SPACE ) ) ;
setParentReference ( this . relativeEntityReferenceResolver . resolve ( parent , EntityType . DOCUMENT ) ) ;
assertGetFullText ( "str" , "str" ) ;
if ( installedExtension = = null | | ! installedExtension . getId ( ) . getVersion ( ) . equals ( extensionUI . getVersion ( ) ) ) {
if ( extensionUI = = null | | this . installedRepository . getInstalledExtension ( extensionUI ) ! = null ) {
return "str" . equals ( getXWikiPreference ( "str" , "str" , context ) ) ;
public void testInstallOnRootWithoutProgrammingRigths ( ) throws Throwable
public void testInstallOnNamespaceWithoutProgrammingRigths ( ) throws Throwable
public void testUninstallOnRootWithoutProgrammingRigths ( ) throws Throwable
public void testUninstallOnNamespaceWithoutProgrammingRigths ( ) throws Throwable
public static final String EXTENSION_JOBID_PREFIX = "str" ;
if ( ! Util . isValidXMLElementName ( newName ) ) {
getHibernateStore ( ) . loadXWikiCollection ( ( BaseObject ) element , getContext ( ) , true ) ;
Iterator < List < BaseObject > > it = xdoc . getXObjects ( ) . values ( ) . iterator ( ) ;
List < BaseObject > list = it . next ( ) ;
BaseObject bobj = list . get ( i ) ;
String prefix = baseObject . getXClass ( context ) . getName ( ) + "str" + baseObject . getNumber ( ) + "str" ;
Object [ ] propnames = baseObject . getXClass ( context ) . getFieldList ( ) . toArray ( ) ;
BaseClass bclass = baseObject . getXClass ( context ) ;
uninstallRequest . setId ( EXTENSION_JOBID_PREFIX + id ) ;
if ( repositoryStrings ! = null & & ! repositoryStrings . isEmpty ( ) ) {
syntaxId = this . xwikiPropertiesConfiguration . getProperty ( key , Syntax . XWIKI_2_1 . toIdString ( ) ) ;
"str" + syntaxId + "str" + Syntax . XWIKI_2_1 . toIdString ( )
syntax = Syntax . XWIKI_2_1 ;
+ "str" , new Object [ ] { repository , pattern , offset , nb , e } ) ;
setResponseExpectations ( d . getTime ( ) , 1 , "str" , "str" ) ;
setResponseExpectations ( d . getTime ( ) , this . fileContent . length , "str" , "str" ) ;
if ( "str" . equals ( XWikiConfigurationService . getProperty ( "str" , "str" , this . servletContext ) ) ) {
if ( "str" . equals ( xwiki . Param ( "str" , "str" ) ) ) {
if ( "str" . equals ( Param ( "str" , "str" ) ) ) {
if ( ! context . getMainXWiki ( ) . equalsIgnoreCase ( wikiName ) & & "str" . equals ( Param ( "str" , "str" ) ) ) {
if ( "str" . equals ( Param ( "str" , "str" ) )
if ( "str" . equals ( XWikiConfigurationService . getProperty ( "str" , "str" , getServletContext ( ) ) ) ) {
& & ( this . extensionId = = null | | matchesExtensionId ( ( ( AbstractExtensionEvent ) event ) . getExtensionId ( ) ) ) ;
private boolean matchesExtensionId ( ExtensionId extensionId )
this . mappingCache = this . cacheManager . createNewCache ( mappingCacheConfiguration ) ;
private static final String DEFAULT_CACHE_HINT = "str" ;
private static final String DEFAULT_LOCALCACHE_HINT = "str" ;
setAlgorithm ( Algorithm . LRU ) ;
public void setAlgorithm ( Algorithm mode )
private static final Logger LOGGER = LoggerFactory . getLogger ( TagPluginApi . class ) ;
@Component ( roles = { QueryExecutorManager . class } )
@Component ( roles = { QueryExecutorManager . class } )
setDatabase ( context . getMainXWiki ( ) ) ;
for ( XWikiAttachment attachment : doc . getAttachmentList ( ) ) {
throw new RuntimeException ( "str" , e ) ;
System . setProperty ( "str" , "str" ) ;
if ( ! modified & & xobject ! = null & & xobjectOriginal ! = null ) {
if ( ! StringUtils . isBlank ( defaultQualityParam ) ) {
getLogger ( ) . error ( "str" , e ) ;
initializeContext ( ) ;
private void initializeContext ( )
if ( FootnoteMacro . MACRO_NAME . equals ( macro . getId ( ) ) ) {
} else if ( PutFootnotesMacro . MACRO_NAME . equals ( macro . getId ( ) ) ) {
private EntityReferenceSerializer < String > defaultStringEntityReferenceSerializer =
result . setUser ( new DocumentReference ( this . resolver . resolve ( this . bridge . getCurrentUser ( ) , EntityType . DOCUMENT ) ) ) ;
private static final Map < String , String > FONT_SIZE_MAP ;
String fontSizeCss = FONT_SIZE_MAP . get ( fontSize ) ;
addSkinToZip ( skinName , zos , urlf . getExportedSkinFiles ( ) , context ) ;
addDirToZip ( file , zos , "str" + ZIPPATH_SEPARATOR , urlf . getExportedSkinFiles ( ) ) ;
public Collection < String > getExportedSkinFiles ( )
public String after ( String content , VelocityContext velocityContext )
return getAttachmentRecycleBinStore ( ) . getDeletedAttachment ( NumberUtils . toLong ( id ) , context , true ) ;
RenderingTestSuite suite = new RenderingTestSuite ( "str" ) ;
"str" , "str" , "str" ) ;
RenderingTestSuite suite = new RenderingTestSuite ( "str" ) ;
return this . doc . getURL ( action , queryString , getXWikiContext ( ) ) ;
private float defaultQuality = 0.5f ;
this . logger . error ( "str" , e ) ;
private X509CryptoService x509 ;
macroTransformation . transform ( wikiMacroMarker , txContext ) ;
return extractResult ( wikiMacroMarker . getChildren ( ) , macroBinding , context ) ;
} catch ( Exception ee ) {
if ( "str" . equals ( directiveName ) ) {
labelNone . setFor ( prefix + name + "str" ) ;
radioTrue . setID ( prefix + name ) ;
fail ( "str" ) ;
fail ( "str" ) ;
fail ( "str" ) ;
fail ( "str" ) ;
fail ( "str" ) ;
@Component ( value = "str" , roles = { QueryExecutorManager . class } )
@Component ( roles = { QueryExecutorManager . class } )
assertEquals ( engine . getRendererNames ( ) , new ArrayList < String > ( ) { {
assertEquals ( groovyFirst , engine . renderText ( text , document , getContext ( ) ) ) ;
assertEquals ( myEngine . getRendererNames ( ) , new ArrayList < String > ( ) { {
assertEquals ( velocityFirst , myEngine . renderText ( text , document , getContext ( ) ) ) ;
return this . componentManager . lookup ( QueryManager . class ) ;
String [ ] baseAndQuery = url . split ( "str" ) ;
suite . addTestsFromResource ( "str" , false ) ;
return getDocumentAsAuthor ( reference ) ;
throw new IOException ( "str" ) ;
assertEquals ( "str" , this . idGenerator . generateUniqueId ( "str" ) ) ;
assertEquals ( "str" , this . idGenerator . generateUniqueId ( "str" , "str" ) ) ;
new ObjectReference ( new EntityReference ( "str" , EntityType . DOCUMENT ) ) ;
new ObjectReference ( new EntityReference ( "str" , EntityType . OBJECT , null ) ) ;
addXObject ( classReference , baseObject ) ;
private int count = 10 ;
this . xClass . setDocumentReference ( getDocumentReference ( ) ) ;
this . syntaxId = getDefaultDocumentSyntaxId ( ) ;
syntaxId = getDefaultDocumentSyntaxId ( ) ;
private String getDefaultDocumentSyntaxId ( )
context . put ( "str" , "str" ) ;
context . put ( "str" , "str" ) ;
context . put ( "str" , "str" ) ;
context . put ( "str" , "str" ) ;
return configuration . getProperty ( IS_CAPTCHA_ENABLED_CFG_KEY , Boolean . FALSE ) . booleanValue ( ) ;
String redirect = Utils . getRedirect ( "str" , "str" , context ) ;
private static final String PREFIX = "str" ;
return this . configuration . getProperty ( PREFIX + "str" , DEFAULT_FILTER ) ;
private static final String PREFIX = "str" ;
return this . configuration . getProperty ( PREFIX + "str" , DEFAULT_FILTER ) ;
IOUtils . closeQuietly ( fis ) ;
DocumentImage documentImage = DocumentImage . class . cast ( image ) ;
URLImage urlImage = URLImage . class . cast ( image ) ;
DocumentImage documentImage = DocumentImage . class . cast ( image ) ;
URLImage urlImage = URLImage . class . cast ( image ) ;
DocumentImage documentImage = DocumentImage . class . cast ( image ) ;
URLImage urlImage = URLImage . class . cast ( image ) ;
if ( "str" . equals ( macroName ) ) {
if ( "str" . equals ( key ) ) {
return "str" . equals ( documentName ) ;
| | ( ( ( parameterType & RadeoxMacroConverter . PARAMETER_NOTNONE ) ! = 0 & & "str" . equals ( parameterValue ) ) ) ) {
if ( context . peekType ( ) = = HTMLType . BEGIN & & "str" . equals ( elementName ) ) {
if ( "str" . equals ( escaped ) ) {
if ( "str" . equals ( context . getCurrentElement ( ) . getName ( ) ) ) {
if ( "str" . equals ( parserId ) & & ! input . startsWith ( "str" ) & & ! input . startsWith ( "str" ) ) {
public RenderingTestSuite ( String name )
private static class MarkerBlock extends AbstractBlock
private int start = 1 ;
private Context context = Context . CURRENT ;
getLogger ( ) . debug ( "str" + remoteEvent + "str" ) ;
if ( this . events . contains ( localEvent . getEvent ( ) . getClass ( ) ) ) {
if ( this . events . contains ( remoteEvent . getEvent ( ) . getClass ( ) ) ) {
getConfigurationSource1 ( ) . setProperty ( "str" , Arrays . asList ( "str" ) ) ;
throw new MacroExecutionException ( "str" + titleParameter + "str" , e ) ;
public static final SyntaxType TWIKI = new SyntaxType ( "str" , "str" ) ;
return enabled ! = null ? enabled : false ;
public static final String CONFIGURATION_PATH = "str" ;
Boolean enabled = this . configurationSource . getProperty ( "str" , Boolean . class ) ;
return this . configurationSource . getProperty ( "str" , List . class ) ;
this . contentDescriptor = contentDescriptor ;
String id = this . idGenerator . generateUniqueId ( "str" , this . renderersUtils . renderPlainText ( children ) ) ;
fail ( "str" ) ;
return "str" + getWiki ( ) + "str" + getSpace ( ) + "str" + getPage ( ) + "str" ;
return "str" + this . event + "str" + this . listener + "str" ;
private String defaultDocumentSyntax = "str" ;
@Component ( "str" )
return baseDocument . getRenderedContent ( content , baseDocument . getSyntaxId ( ) , xwikiContext ) ;
childDoc . setContent ( "str" ) ;
childDoc . setContent ( "str" ) ;
doc . setContent ( "str" ) ;
private boolean wiki ;
public void setWiki ( boolean wiki )
this . wiki = wiki ;
VelocityExecutionContextInitializer . VELOCITY_CONTEXT_ID ) ;
public static final String VELOCITY_CONTEXT_ID = "str" ;
executionContext . setProperty ( VelocityExecutionContextInitializer . VELOCITY_CONTEXT_ID , context ) ;
return "str" + Calendar . getInstance ( ) . get ( java . util . Calendar . YEAR ) + "str" ;
Level . FINE ,
getLogger ( ) . log ( Level . FINE , String . format ( "str" , identifier ) ) ;
getLogger ( ) . log ( Level . FINE , String . format ( "str" , identifier ) ) ;
getLogger ( ) . log ( Level . WARNING , String . format ( "str" , identifier ) ) ;
Level . FINE ,
getLogger ( ) . log ( Level . FINE , String . format ( "str" , this ) ) ;
logger . log ( Level . FINE , String . format ( "str" , resource ) ) ;
getLogger ( ) . log ( Level . SEVERE , "str" ) ;
getLogger ( ) . log ( Level . FINE , "str" ) ;
getLogger ( ) . log ( Level . FINE , "str" ) ;
CompiledScript compiledScript = getCompiledScript ( content , ( Compilable ) engine ) ;
protected CompiledScript getCompiledScript ( String content , Compilable engine ) throws ScriptException
public static final Pattern STARLISTEND_PATTERN = Pattern . compile ( "str" ) ;
this . escapeFirstIfMatching = XWikiSyntaxEscapeHandler . STARLISTEND_PATTERN ;
if ( this . blockListener . getLinkDepth ( ) = = 1 ) {
for ( Object object : objectArray ) {
logger . debug ( "str" + resource . getDisplayName ( ) + "str" + request . getMethod ( )
import org . apache . commons . lang . StringUtils ;
LOG . debug ( "str" + loginDN + "str" ) ;
needsUpdate | = bclass . addTextAreaField ( "str" , "str" , 60 , 5 ) ;
private boolean interpretWikiSyntax ;
public XMLBlockConverterHandler ( Parser parser , boolean interpretWikiSyntax )
this . interpretWikiSyntax = interpretWikiSyntax ;
if ( ! this . interpretWikiSyntax ) {
parameters . getWiki ( ) ) ;
return new XMLBlockConverterHandler ( this . parser , interpretWikiSyntax ) ;
private boolean wiki = true ;
this . wiki = interpretWikiSyntax ;
public boolean getWiki ( )
return this . wiki ;
private boolean interpretWikiSyntax ;
public XMLBlockConverterHandler ( Parser parser , boolean interpretWikiSyntax )
this . interpretWikiSyntax = interpretWikiSyntax ;
if ( ! this . interpretWikiSyntax ) {
parameters . getWiki ( ) ) ;
return new XMLBlockConverterHandler ( this . parser , interpretWikiSyntax ) ;
+ "str" , store . createSQLQuery (
private List < ScriptContextInitializer > scriptContextInitializerList ;
this . scriptContextInitializerList = this . componentManager . lookupList ( ScriptContextInitializer . ROLE ) ;
this . scriptContextInitializerList = Collections . emptyList ( ) ;
for ( ScriptContextInitializer scriptContextInitializer : this . scriptContextInitializerList ) {
getXHTMLWikiPrinter ( ) . printXMLStartElement ( "str" , new String [ ] [ ] { { "str" , "str" } } ) ;
} else if ( classParam . getValue ( ) . equals ( "str" ) ) {
} else if ( classParam . getValue ( ) . equals ( "str" ) ) {
authClass = "str" ;
this . context . getWiki ( ) . getStore ( ) . searchDocuments ( sql , false , false , false , 0 , 0 ,
this . context . getWiki ( ) . getStore ( ) . searchDocuments ( sql , false , 0 , 0 ,
return dn . length ( ) = = 0 ? null : dn ;
return uid . length ( ) = = 0 ? null : uid ;
om . notify ( new DocumentSaveEvent ( doc . getWikiName ( ) + "str" + doc . getFullName ( ) ) , doc , context ) ;
om . notify ( new DocumentUpdateEvent ( doc . getWikiName ( ) + "str" + doc . getFullName ( ) ) , doc , context ) ;
om . notify ( new DocumentDeleteEvent ( doc . getWikiName ( ) + "str" + doc . getFullName ( ) ) , blankDoc , context ) ;
print ( "str" ) ;
setDefaultLanguage ( request . getParameter ( "str" ) ) ;
setMinorEdit ( request . getParameter ( "str" ) ! = null ) ;
import com . xpn . xwiki . user . impl . LDAP . XWikiLDAPAuthServiceImpl ;
this . authService = new XWikiLDAPAuthServiceImpl ( ) ;
public static < T > Map < String , T > getSubMap ( Map < String , T > map , String prefix )
HashMap < String , T > result = new HashMap < String , T > ( ) ;
public void fromSearchMap ( XWikiQuery query , Map < String , String [ ] > map )
if ( link . getReference ( ) = = null | | this . documentManager . exists ( link . getReference ( ) ) ) {
String cacheHint = Param ( "str" , "str" ) ;
String localCacheHint = Param ( "str" , "str" ) ;
void insertChildBefore ( Block blockToInsert , Block nextBlock ) ;
public void insertChildBefore ( Block blockToInsert , Block nextBlock )
blockToInsert . setParent ( this ) ;
this . childrenBlocks . add ( blockToInsert ) ;
this . childrenBlocks . add ( this . childrenBlocks . indexOf ( nextBlock ) , blockToInsert ) ;
public void insertChildAfter ( Block blockToInsert , Block previousBlock )
blockToInsert . setParent ( this ) ;
this . childrenBlocks . add ( blockToInsert ) ;
this . childrenBlocks . add ( this . childrenBlocks . indexOf ( previousBlock ) + 1 , blockToInsert ) ;
write ( "str" + name + "str" + name + "str" ) ;
listener . onId ( getName ( ) ) ;
write ( "str" + name + "str" ) ;
public List < Block > execute ( Map < String , String > parameters , String content , MacroTransformationContext macroContext )
root = macroContext . getCurrentMacroBlock ( ) . getParent ( ) ;
root = macroContext . getDom ( ) ;
return this . < Boolean > getParameterValue ( PARAM_ESCAPEWIKISYNTAX ) ;
return this . < Integer > getParameterValue ( PARAM_START ) ;
return this . < Integer > getParameterValue ( PARAM_DEPTH ) ;
return this . < Boolean > getParameterValue ( PARAM_NUMBERED ) ;
public abstract class AbstractBridgedXWikiComponentTestCase extends AbstractXWikiComponentTestCase
String cacheHint = Param ( "str" , "str" ) ;
String localCacheHint = Param ( "str" , "str" ) ;
configuration . setConfigurationId ( "str" ) ;
if ( appname = = null ) {
ComponentManager cm = super . getComponentManager ( ) ;
this . listeners . remove ( event . getClass ( ) . getName ( ) ) ;
return new LevelsClass ( ) ;
return new GroupsClass ( ) ;
thread = new Thread ( this , "str" ) ;
return "str" . equals ( Param ( "str" , "str" ) ) ;
private Package pack ;
@SuppressWarnings ( ANOTATE_UNCHECKED )
+ getRequest ( ) . getParameter ( "str" ) ) ;
LOG . info ( "str" + migration . migrator . getName ( ) + "str"
PreparedStatement deleteStatement = session . connection ( ) . prepareStatement ( "str" ) ;
deleteStatement . close ( ) ;
return clearName ( name , true , true , context ) ;
log . error ( "str" , ex2 ) ;
{ ( origdoc ! = null ) ? origdoc . getFullName ( ) : null , ( origdoc ! = null ) ? origdoc . getVersion ( ) : null , ( newdoc ! = null ) ? newdoc . getVersion ( ) : null } ;
LOG . debug ( "str" + urlFactoryClassName + "str" ) ;
LOG . error ( "str" + urlFactoryClassName + "str" ) ;
LOG . error ( "str" , e ) ;
private static final long UPLOAD_DEFAULT_MAXSIZE = 33554432L ;
return "str" . equals ( Param ( "str" , "str" ) ) ;
if ( archive = = null | | archive . get ( ) = = null ) {
return "str" . equals ( Param ( "str" , "str" ) ) ;
private static final String CLASS_XWIKIGROUPS = "str" + CLASS_SUFFIX_XWIKIGROUPS ;
needUpdate = groupDocument . removeObject ( bobj ) ;
public MetaDataDiff ( String field , Object prevValue , Object newValue ) {
buf . append ( prevValue . toString ( ) ) ;
buf . append ( newValue . toString ( ) ) ;
return result = = null ? new XWikiDBVersion ( 0 ) : result ;
String defaulttarget = xwiki . Param ( "str" , "str" ) ;
return display ( fieldname , mode , prefix , object , context ) ;
if ( xwiki . Param ( "str" , "str" ) . equals ( "str" ) )
XWikiRCSNodeInfo newNode = new XWikiRCSNodeInfo ( newNodeId (
getUpdatedNodeContents ( ) . add ( ncto1 ) ;
getUpdatedNodeContents ( ) . add ( ncto1 ) ;
public Set getUpdatedNodeInfos ( )
public Set getUpdatedNodeContents ( )
public XWikiPatch setDiffVersion ( XWikiDocument curDoc , XWikiDocument origDoc ,
return setDiffVersion ( curDoc , origDoc . toXML ( context ) , context ) ;
public XWikiPatch setDiffVersion ( XWikiDocument curDoc , String origDocXml ,
setContent ( XWikiPatchUtils . getDiff ( curDoc . toXML ( context ) , origDocXml ) ) ;
Object [ ] args = { curDoc . getFullName ( ) } ;
public void patch ( List origText ) throws XWikiException
XWikiPatchUtils . patch ( origText , getContent ( ) ) ;
XWikiRCSNodeContent nodeContent = null ;
nodeContent = ( XWikiRCSNodeContent ) contentRef . get ( ) ;
nodeContent = context . getWiki ( ) . getVersioningStore ( )
public XWikiRCSArchive ( String archiveText ) throws ParseException
super ( "str" , new StringInputStream ( archiveText ) ) ;
context . addDocumentArchive ( key , archiveDoc ) ;
String content = ToString . arrayToString ( origText . toArray ( ) ) ;
if ( ! auth . processLogin ( username , password , rememberme , wrappedRequest , response ,
storageType_class . setValues ( HASH + SEPARATOR + CLEAR ) ;
String content = "str" ;
toIndex . put ( id , data ) ;
String id = ( String ) docIt . next ( ) ;
reader . deleteDocument ( id . intValue ( ) ) ;
defaultbaseskin = Param ( "str" , "str" ) ;
log . warn ( "str" + propertiesFilename + "str" + e . getMessage ( ) ) ;
"str" , e , args ) ;
| | ! isValidZipURL ( url , context . getAction ( ) . trim ( ) ) )
if ( ( ! "str" . equals ( action ) | | ( showViewAction ) ) ) {
useDefaultWeb = ( web . equals ( defaultWeb ) ) & & ( "str" . equals ( action ) ) ;
| | ( ! name . equals ( xwiki . getDefaultPage ( context ) ) | | ( ! "str" . equals ( action ) ) ) ) {
name = name . replaceAll ( "str" , "str" ) ;
option option = new option ( display , item . getId ( ) ) ;
option option = new option ( display , value ) ;
if ( active = = null | | active . intValue ( ) = = 0 ) {
super . onRestoreInstanceState ( bundle . getParcelable ( STATE_INSTANCE ) ) ;
public static final String ENABLED = "str" ;
private boolean disableInternalCommands ;
public CommandLine ( String [ ] args , int historySize , String [ ] shellCommandsToExecute , boolean disableInternalCommands ) {
this . disableInternalCommands = disableInternalCommands ;
assertThat ( candidates , hasItem ( completionThat ( is ( equalTo ( "str" ) ) ) ) ) ;
assertThat ( candidates , hasItem ( completionThat ( is ( equalTo ( "str" ) ) ) ) ) ;
assertThat ( candidates , hasItem ( completionThat ( is ( equalTo ( "str" ) ) ) ) ) ;
assertThat ( candidates , hasItem ( completionThat ( is ( equalTo ( "str" ) ) ) ) ) ;
assertThat ( candidates , hasItem ( completionThat ( is ( equalTo ( "str" ) ) ) ) ) ;
assertThat ( candidates , hasItem ( completionThat ( startsWith ( "str" ) ) ) ) ;
assertThat ( candidates , hasItem ( completionThat ( is ( equalTo ( "str" ) ) ) ) ) ;
assertThat ( candidates , hasItem ( completionThat ( is ( equalTo ( "str" ) ) ) ) ) ;
assertThat ( candidates , hasItem ( completionThat ( is ( equalTo ( "str" ) ) ) ) ) ;
assertThat ( candidates , hasItem ( completionThat ( is ( equalTo ( "str" ) ) ) ) ) ;
assertThat ( candidates , hasItem ( completionThat ( is ( equalTo ( "str" ) ) ) ) ) ;
if ( logger . getLevel ( ) = = null & & clazz . getName ( ) . startsWith ( "str" ) ) {
public String getWelcomeMessage ( ) {
bannerText [ 1 ] = provider . getWelcomeMessage ( ) ;
public String getWelcomeMessage ( ) {
String getWelcomeMessage ( ) ;
@CliOption ( key = { "str" } , mandatory = true , help = "str" ) final String name1 ,
@CliOption ( key = { "str" } , mandatory = false , specifiedDefaultValue = "str" , help = "str" ) final String time ,
( client . height - g . textExtent ( text , StringNode . DRAW_FLAGS ) . y ) / 2 , StringNode . DRAW_FLAGS ) ;
public static void asyncLoadPicture ( final ContactsStruct convs , final ICallback callBack ) {
return rows ( ) . getRow ( rowNum ) . first ( ( rowName , cell ) - > cell . getValue ( ) . equals ( value ) ) ;
return rows ( ) . getRow ( rowNum ) . first ( ( rowName , cell ) - > cell . getValue ( ) . contains ( value ) ) ;
columnName - > select ( columns ( ) . headers ( ) , String : : toLowerCase ) . indexOf ( columnName . toLowerCase ( ) ) + 1 ,
return columns ( ) . getColumn ( colIndex ) . first ( ( columnName , cell ) - > cell . getValue ( ) . equals ( value ) ) ;
columnName - > select ( columns ( ) . headers ( ) , String : : toLowerCase ) . indexOf ( columnName . toLowerCase ( ) ) + 1 ,
return columns ( ) . getColumn ( colIndex ) . first ( ( columnName , cell ) - > cell . getValue ( ) . contains ( value ) ) ;
@ByClass ( "str" )
public static void init ( Class < ? > . . . sites ) {
@FindBy ( css = "str" )
context = first ( els , el - > el . getText ( ) . startsWith ( value ) ) ;
} catch ( Exception | Error ignore ) { return false ; }
} catch ( Exception | Error ignore ) { return false ; }
} catch ( Exception | Error ignore ) { return false ; }
import static com . epam . jdi . uitests . core . settings . JDIData . group ;
import static com . epam . jdi . uitests . core . settings . JDIData . group ;
import static com . epam . jdi . uitests . core . settings . JDIData . group ;
import static com . epam . jdi . uitests . core . settings . JDIData . group ;
public static boolean verifyLayout = false ;
Assert . areEquals ( jobsTable ( ) . rows ( ) . count ( ) , 4 ) ;
@JPage ( url = "str" , urlTemplate = "str" ,
new Select ( element ( ) . getWebElement ( ) ) . selectByVisibleText ( name ) ;
import static com . epam . jdi . uitests . core . settings . JDISettings . exception ;
jobListingPage . shouldBeOpened ( ) ;
jobListingPage . shouldBeOpened ( ) ;
jobListingPage . shouldBeOpened ( ) ;
jobListingPage . shouldBeOpened ( ) ;
jobListingPage . shouldBeOpened ( ) ;
jobListingPage . shouldBeOpened ( ) ;
jobListingPage . shouldBeOpened ( ) ;
jobListingPage . shouldBeOpened ( ) ;
jobListingPage . shouldBeOpened ( ) ;
homePage . shouldBeOpened ( ) ;
jobListingPage . shouldBeOpened ( ) ;
jobListingPage . shouldBeOpened ( ) ;
jobListingPage . shouldBeOpened ( ) ;
jobListingPage . shouldBeOpened ( ) ;
jobListingPage . shouldBeOpened ( ) ;
jobListingPage . shouldBeOpened ( ) ;
jobListingPage . shouldBeOpened ( ) ;
jobListingPage . shouldBeOpened ( ) ;
jobListingPage . shouldBeOpened ( ) ;
jobListingPage . shouldBeOpened ( ) ;
jobListingPage . shouldBeOpened ( ) ;
jobListingPage . shouldBeOpened ( ) ;
jobListingPage . shouldBeOpened ( ) ;
EpamSite . jobListingPage . shouldBeOpened ( ) ;
jobDescriptionPage . shouldBeOpened ( ) ;
homePage . shouldBeOpened ( ) ;
private static final String CHROME_MAC_DRIVER = "str" ;
By . xpath ( "str" )
instance = getElementInstance ( field , driverName , parent ) ;
private IBaseElement getElementInstance ( Field field , String driverName , Object parent ) {
public class StringCheckType {
value = @FindBy ( css = "str" ) ,
} catch ( NoClassDefFoundError e ) {
} catch ( Exception e ) {
} catch ( Exception e ) {
} catch ( Exception e ) {
. setNumber ( bundle . getInt ( "str" , ( int ) bundle . getDouble ( "str" ) ) )
notification . addAction ( 0 , actionTitle , pendingActionIntent ) ;
Long fireDate = Math . round ( bundle . getDouble ( "str" , bundle . getLong ( "str" ) ) ) ;
long vibrate = Math . round ( bundle . getDouble ( "str" , DEFAULT_VIBRATION ) ) ;
if ( largeIcon ! = null & & android . os . Build . VERSION . SDK_INT > = android . os . Build . VERSION_CODES . LOLLIPOP ) {
if ( largeIconResId ! = 0 ) {
if ( bundle . getString ( "str" ) ! = null ) {
promise . resolve ( parseIntent ( getCurrentActivity ( ) . getIntent ( ) ) ) ;
throw new InvalidRdfException ( "str" + ( theObj . getClass ( ) . getName ( ) ) + "str" ) ;
throw new InvalidRdfException ( "str" + ( theObj . getClass ( ) . getName ( ) ) + "str" ) ;
throw new IllegalStateException ( "str" , e ) ;
protected final Logger log = LoggerFactory . getLogger ( this . getClass ( ) ) ;
private final Model mModel ;
return mModel . equals ( m ) ;
return mModel . remove ( m , suppressReifications ) ;
return mModel . remove ( m ) ;
@Namespaces ( { "str" , "str" } )
@RdfsClass ( "str" )
@RdfProperty ( "str" )
@RdfProperty ( "str" )
@RdfProperty ( "str" )
@RdfProperty ( "str" )
@RdfProperty ( "str" )
@Namespaces ( { "str" , "str" ,
@RdfsClass ( "str" )
@RdfProperty ( "str" )
@RdfProperty ( "str" )
@Namespaces ( { "str" , "str" ,
@RdfsClass ( "str" )
@RdfProperty ( "str" )
@Namespaces ( { "str" , "str" ,
@RdfsClass ( "str" )
@Namespaces ( { "str" , "str" } )
@RdfsClass ( "str" )
@RdfProperty ( "str" )
@RdfProperty ( "str" )
@RdfProperty ( "str" )
@RdfProperty ( "str" )
@RdfProperty ( "str" )
@Namespaces ( { "str" , "str" ,
@RdfProperty ( "str" )
@Namespaces ( { "str" , "str" ,
@RdfsClass ( "str" )
@RdfProperty ( "str" )
@RdfProperty ( "str" )
@RdfProperty ( "str" )
aList . addAll ( CollectionUtil . list ( aResults ) ) ;
LOGGER . warn ( "str" + aName + "str" ) ;
private static String UNAMED_VAR_REGEX = VT_RE + "str" ;
if ( ! BeanReflectUtil . hasAnnotation ( theObj . getClass ( ) , RdfsClass . class ) ) {
if ( ! BeanReflectUtil . hasAnnotation ( theObj . getClass ( ) , Entity . class ) ) {
return BeanReflectUtil . getAnnotation ( theObj . getClass ( ) , RdfsClass . class ) ;
else if ( theLiteral . getLanguage ( ) ! = null & & ! theLiteral . getLanguage ( ) . equals ( "str" ) ) {
if ( mIndexedParameters . get ( aIndex ) = = null ) {
if ( mNamedParameters . get ( aName ) = = null ) {
import com . clarkparsia . fourstore . impl . sesame . FourStoreToSesame ;
catch ( com . clarkparsia . fourstore . api . QueryException e ) {
catch ( com . clarkparsia . fourstore . api . QueryException e ) {
catch ( com . clarkparsia . fourstore . api . QueryException e ) {
private static void recordMemoryUsage ( String prefix , MemoryUsage memory , Map < String , Long > metrics ) {
private static String poolTypeToMetricName ( MemoryType memoryType ) {
private static String poolNameToMetricName ( String poolName ) {
private static Class < ? extends Reporter < ? > > parserReporterArg ( String reporterArg ) {
private static Set < Class < ? extends Profiler > > parseProfilerArg ( String profilerArg ) {
private static List < String > parsePackageList ( String packages ) {
private static Collection < ThreadInfo > getAllRunnableThreads ( ) {
public final class TagUtil {
public final class StackTraceFormatter {
public final class Agent {
public final class MapUtil {
public final class ThreadDumper {
public final class ProfilerServer {
public final class TimeUtil {
public final class Arguments {
public final class MockArguments {
public final class RequestHandler {
private final CPUTraces traces ;
private final long reportingFrequency ;
private final Thread . State state ;
private final boolean arePatternsDefault ;
private final Map < String , String > tags ;
private final Reporter < ? > reporter ;
private final ThreadFactory defaultThreadFactory = Executors . defaultThreadFactory ( ) ;
Validador TELEFONE = ValidadorTelefone . getInstance ( ) ;
required = false ) @QueryParam ( "str" ) @DefaultValue ( "str" ) BooleanParam entail ,
required = false ) @QueryParam ( "str" ) @DefaultValue ( "str" ) BooleanParam entail ,
private static final Logger logger = Logger . getLogger ( Clique . class . getName ( ) ) ;
static Server server = new Server ( 10000 ) ;
static Server server = new Server ( 10000 ) ;
private boolean allowMultiple = false ;
public void deprecatedClassesReturned ( ) {
assertThat ( vocabulary . getConceptsFromTerm ( query ) , containsInAnyOrder ( cerebellum , deprecated ) ) ;
private boolean includeDeprecated = true ;
@Produces ( { CustomMediaTypes . APPLICATION_GRAPHML , MediaType . APPLICATION_XML } )
return Long . valueOf ( getId ( ) ) . hashCode ( ) ;
return ! ( ( String ) node . getProperty ( CommonProperties . URI ) ) . startsWith ( "str" ) ;
public interface Callback {
private static final Logger logger = Logger . getLogger ( Graph . class . getName ( ) ) ;
Optional < N > getConceptFromUri ( String uri ) ;
Collection < N > getConceptFromId ( Query query ) ;
List < N > getConceptsFromPrefix ( Query query ) ;
List < N > searchConcepts ( Query query ) ;
List < N > getConceptsFromTerm ( Query query ) ;
Set < String > getAllCategories ( ) ;
Set < String > getAllOntologies ( ) ;
List < String > getSuggestions ( String query ) ;
if ( null ! = property
List < String > extractSentences ( String text ) ;
List < PosToken > tagPOS ( String sentence ) ;
List < Token < String > > getChunks ( String text ) ;
List < Token < String > > getEntities ( String text ) ;
List < EntityAnnotation > annotateEntities ( EntityFormatConfiguration configuration )
void addLabel ( String label ) ;
Iterable < String > getLabels ( ) ;
void setInferred ( boolean inferred ) ;
void isInferred ( ) ;
void setAnonymous ( boolean anonymous ) ;
boolean isAnonymous ( ) ;
Iterable < Concept > getSubclasses ( ) ;
Iterable < Concept > getSuperclasses ( ) ;
Iterable < Concept > getEquivalentClasses ( ) ;
void setPreferredLabel ( String preferredLabel ) ;
String getPreferredLabel ( ) ;
Iterable < String > getSynonyms ( ) ;
void addSynonym ( String synonym ) ;
Iterable < String > getAcronyms ( ) ;
void addAcronym ( String acronym ) ;
Iterable < String > getAbbreviations ( ) ;
void addAbbreviation ( String abbreviation ) ;
void setDefinition ( String term ) ;
String getDefinition ( ) ;
void addCategory ( String category ) ;
Iterable < String > getCategories ( ) ;
void setUri ( String uri ) ;
String getUri ( ) ;
void setFragment ( String uri ) ;
String getFragment ( ) ;
void setCurie ( String curie ) ;
String getCurie ( ) ;
void setNegated ( boolean negated ) ;
boolean isNegated ( ) ;
void setParentOntology ( String ontology ) ;
String getParentOntology ( ) ;
void setOntology ( String ontology ) ;
String getOntology ( ) ;
void setOntologyVersion ( String version ) ;
String getOntologyVersion ( ) ;
void addType ( String type ) ;
Iterable < String > getTypes ( ) ;
void setTransitive ( boolean transitive ) ;
boolean isTransitive ( ) ;
void setReflexive ( boolean reflexive ) ;
boolean isReflexive ( ) ;
void setSymmetric ( boolean symmetric ) ;
boolean isSymmetric ( ) ;
void setQuantificationType ( String type ) ;
String getQuantificationType ( ) ;
logger . log ( Level . WARNING , "str" + property + "str" + literal . get ( ) . toString ( ) , e ) ;
tradingday = instance ;
private BigDecimal vostroRange ;
public BigDecimal getVostroRange ( ) {
this . vostroRange = ( BigDecimal ) this . getValueCode ( VOSTRO_RANGE ) ;
public void setVostroRange ( BigDecimal vostroRange ) {
if ( vostro2 > this . getVostroRange ( ) . doubleValue ( )
if ( vostro1 < ( - 1 * this . getVostroRange ( ) . doubleValue ( ) )
if ( vostro2 > this . getVostroRange ( ) . doubleValue ( )
. getVostroRange ( ) . doubleValue ( ) ) {
if ( vostro2 > this . getVostroRange ( ) . doubleValue ( )
. getVostroRange ( ) . doubleValue ( )
. getVostroRange ( ) . doubleValue ( ) ) {
if ( vostro1 < ( - 1 * this . getVostroRange ( ) . doubleValue ( ) )
. getVostroRange ( ) . doubleValue ( ) ) ) {
if ( vostro1 < ( - 1 * this . getVostroRange ( ) . doubleValue ( ) )
. getVostroRange ( ) . doubleValue ( ) )
. getVostroRange ( ) . doubleValue ( ) ) ) {
this ( frame , title , modal , component , null , null ) ;
public void moveStopOCAPrice ( Money stopPrice , boolean transmit )
_log . info ( "str" + setDate ) ;
_log . info ( "str" + date + "str" + tz ) ;
if ( OrderType . LMT . equals ( orderType ) & & null = = limitPrice )
if ( OrderType . STPLMT . equals ( orderType )
if ( OrderType . MKT . equals ( orderType ) ) {
if ( null ! = filledPrice ) {
return BigDecimal . ZERO ;
if ( this . tradestrategy . getStrategy ( ) . hasStrategyManager ( ) ) {
if ( this . isPositionOpen ( ) ) {
if ( this . isPositionOpen ( ) ) {
if ( this . isPositionOpen ( ) ) {
if ( this . isPositionOpen ( ) ) {
if ( this . isPositionOpen ( ) ) {
if ( this . isPositionOpen ( ) ) {
if ( this . isPositionOpen ( ) ) {
/ ( totalFilledQuantity / 2d ) ) ;
TestCase . assertNotNull ( this . strategyProxy . isPositionCovered ( ) ) ;
TestCase . assertFalse ( this . strategyProxy . isPositionCovered ( ) ) ;
TestCase . assertTrue ( this . strategyProxy . isPositionCovered ( ) ) ;
if ( getTrade ( ) . getIsOpen ( ) & & ! this . isPositionCovered ( ) ) {
if ( getTrade ( ) . getIsOpen ( ) & & ! this . isPositionCovered ( ) ) {
if ( getTrade ( ) . getIsOpen ( ) & & ! this . isPositionCovered ( ) ) {
if ( isPositionCovered ( ) ) {
if ( isPositionCovered ( ) ) {
public boolean isPositionCovered ( ) throws StrategyRuleException {
Date closeDate = ( Date ) this . getValueAt ( row , 1 ) ;
if ( tradestrategy . getBarSize ( ) > 3600 ) {
if ( null ! = barSize & & barSize = = 1 ) {
if ( tradestrategy . getBarSize ( ) > 3600 ) {
if ( closeHour < openHour
if ( ! candles . isEmpty ( ) ) {
EObject selectedContainerView , DDiagram diagram ) {
final ArrayList < Class > metaClasses = new ArrayList ( ) ;
public List < EObject > getValidsForCompositeDiagram ( EObject cur ) {
return ( ( DSemanticDecorator ) view . eContainer ( ) ) . getTarget ( ) ;
res = checkConnectable ( source , ( Interface ) generalization . getGeneral ( ) ) ;
res = checkConnectable ( source , ( Interface ) interfaceSupplier ) ;
res = checkConnectable ( target , ( Interface ) interfaceSupplier ) ;
final StructuredClassifier structuredClassifier = getFirstStructuredClassifierRelated2InterfaceView ( ( DNode ) sourceView ) ;
final StructuredClassifier structuredClassifier = getFirstStructuredClassifierRelated2InterfaceView ( ( DNode ) sourceView ) ;
final StructuredClassifier structuredClassifier = ( StructuredClassifier ) eContainer ;
connectProperty2Property ( structuredClassifier , ( Property ) source , ( Property ) target ) ;
generalPart . setQuery ( operation . isQuery ( ) ) ;
if ( editorKey = = UmlViewsRepository . General . Qualifiers . query ) {
if ( UmlViewsRepository . General . Qualifiers . query = = event . getAffectedEditor ( ) ) {
return key = = UmlViewsRepository . General . name | | key = = UmlViewsRepository . General . visibility | | key = = UmlViewsRepository . General . Qualifiers . leaf | | key = = UmlViewsRepository . General . Qualifiers . ordered | | key = = UmlViewsRepository . General . Qualifiers . static_ | | key = = UmlViewsRepository . General . Qualifiers . unique | | key = = UmlViewsRepository . General . Qualifiers . abstract_ | | key = = UmlViewsRepository . General . Qualifiers . query | | key = = UmlViewsRepository . General . type | | key = = UmlViewsRepository . General . Qualifiers . class ;
return key = = UmlViewsRepository . General . Qualifiers . leaf | | key = = UmlViewsRepository . General . Qualifiers . ordered | | key = = UmlViewsRepository . General . Qualifiers . static_ | | key = = UmlViewsRepository . General . Qualifiers . unique | | key = = UmlViewsRepository . General . Qualifiers . abstract_ | | key = = UmlViewsRepository . General . Qualifiers . query ;
if ( UmlViewsRepository . General . Qualifiers . query = = event . getAffectedEditor ( ) ) {
return key = = UmlViewsRepository . General . Qualifiers . leaf | | key = = UmlViewsRepository . General . Qualifiers . ordered | | key = = UmlViewsRepository . General . Qualifiers . static_ | | key = = UmlViewsRepository . General . Qualifiers . unique | | key = = UmlViewsRepository . General . Qualifiers . abstract_ | | key = = UmlViewsRepository . General . Qualifiers . query ;
int itemCount = getAdapter ( ) . getItemCount ( ) ;
int newPosition = ( position + 1 ) % itemCount ;
ShowSettingsUtil . getInstance ( ) . showSettingsDialog ( e . getProject ( ) , "str" ) ;
@State ( name = "str" , storages = { @Storage ( "str" ) } )
assertSort ( new String [ ] { "str" , "str" , } , Sort . HEXA , "str" , "str" ) ;
if ( from = = Style . PASCAL_CASE | | from = = Style . _SINGLE_WORD_CAPITALIZED ) {
_SINGLE_WORD_CAPITALIZED ( "str" ) {
{ Style . _SINGLE_WORD_CAPITALIZED , Style . SCREAMING_SNAKE_CASE } ,
@State ( name = "str" , storages = { @Storage ( id = "str" , file = "str" ) } )
@State ( name = "str" , storages = { @Storage ( file = "str" ) } )
GridDataFactory . fillDefaults ( ) . grab ( false , false ) . align ( SWT . BEGINNING , SWT . CENTER )
} else if ( bde . getLiveEnv ( ) = = null ) {
+ "str" ) ;
assertEquals ( RunState . RUNNING , app . getRunState ( ) ) ;
Element repo = getRepo ( pom , "str" ) ;
Element bom = getBom ( pom , "str" ) ;
if ( pair . getName ( ) = = null | | "str" . equals ( pair . getName ( ) ) ) {
if ( pair . getName ( ) = = null | | "str" . equals ( pair . getName ( ) ) ) {
if ( "str" . equals ( version ) ) {
ProjectSpecificLanguageServerWrapper lsWrapperForConnection = LanguageServiceAccessor . getLSWrapperForConnection ( project , serverDefinition ) ;
ExternalProcess process = new ExternalProcess ( new File ( "str" ) , cmd , true ) ;
assertGroupValues ( group , "str" , "str" , "str" , "str" ) ;
assertGroupValues ( group , "str" , "str" , "str" , "str" ) ;
ArrayList < T > choices = new ArrayList < > ( ) ;
CheckBoxModel < Dependency > cb = new CheckBoxModel < > ( label , dep , selection , enablement ) ;
HashSet < Dependency > selecteds = new HashSet < > ( ) ;
selection . setValue ( type . getRadio ( "str" ) ) ;
withImportStrategy ( "str" )
public void setUp ( ) throws Exception {
ArrayList < ICompletionProposal > proposals = new ArrayList < > ( properties . size ( ) ) ;
private static final boolean DEBUG = false ;
public TestBracketter testBracketer = new TestBracketter ( ) ;
RetryUtil . retryWhen ( "str" , 5 , FLAKY_SERVICE_BROKER ,
RetryUtil . retryWhen ( "str" , 5 , FLAKY_SERVICE_BROKER , ( ) - > {
RetryUtil . retryWhen ( "str" , 5 , FLAKY_SERVICE_BROKER , ( ) - > {
( e ) - > ExceptionUtil . getMessage ( e ) . contains ( "str" ) ,
public static int commonPrefixLength ( CharSequence s , CharSequence t ) {
public static String commonPrefix ( CharSequence s , CharSequence t ) {
if ( start = = 0 & & end = = len ) {
BootWizardActivator . getDefault ( ) . getPreferenceStore ( )
BootWizardActivator . getUrlConnectionFactory ( )
this . cancelationTokens = new CancelationTokens ( ) ;
return mono . get ( Duration . ofMinutes ( 2 ) ) ;
assertEquals ( HealthCheckSupport . HC_PORT , appElement . getHealthCheck ( ) ) ;
foo . setHealthCheck ( HealthCheckSupport . HC_NONE ) ;
assertEquals ( HealthCheckSupport . HC_NONE , appElement . getHealthCheck ( ) ) ;
if ( e instanceof AbstractLaunchConfigurationsDashElement < ? > & & e . getRunState ( ) . equals ( RunState . INACTIVE ) ) {
AbstractLaunchConfigurationsDashElement < ? > localDashProject = ( AbstractLaunchConfigurationsDashElement < ? > ) e ;
private final boolean noModeSwitch ;
return getRunTarget ( ) . isConnected ( ) ;
assertNotNull ( target . getRunTarget ( ) . getTargetProperties ( ) . getPassword ( ) ) ;
throw new AssertionFailedError ( "str" + l + "str" + l . getClass ( ) . getName ( ) ) ;
private synchronized void stopAnimation ( Object e ) {
return targetProperties . getSpace ( ) ! = null ? new CloudFoundryClient (
if ( prefix = = null )
mon . beginTask ( "str" + baseUrl . getValue ( ) , 4 ) ;
private final static boolean ADD_MOCKS = false ;
project . getProject ( ) , null ) ;
this . classLoaderSupport = JdtUtils . getProjectClassLoaderSupport ( project . getProject ( ) , null ) ;
assertTrue ( "str" + guide . getName ( ) + "str" , description ! = null & & ! "str" . equals ( description . trim ( ) ) ) ;
null ) , e ) ) ) ;
newName = type . getPackageFragment ( ) . getElementName ( ) + "str" + newName ;
return modificationTimestamp < getElementResource ( ) . getModificationStamp ( ) | | changedImportedBeansConfig ( ) ;
isVersion1 = content . contains ( "str" ) ;
if ( archiveFile . getProtocol ( ) . equals ( "str" ) & & ! new File ( archiveFile . toURI ( ) ) . isDirectory ( ) ) {
import org . eclipse . jdt . internal . ui . text . correction . proposals . LinkedCorrectionProposal ;
public class ChangeParameterTypeResolution extends LinkedCorrectionProposal implements IMarkerResolution {
super ( "str" , cu , null , 0 , null ) ;
Map < String , IField > allFields = new HashMap < String , IField > ( ) ;
return new HashSet < IField > ( allFields . values ( ) ) ;
if ( extendedInterface . contains ( "str" ) ) {
return session . getApplicationName ( ) ;
return model . equals ( viewer . getInput ( ) ) ;
if ( archiveFile . getProtocol ( ) . equals ( "str" ) & & ! new File ( archiveFile . getPath ( ) ) . isDirectory ( ) ) {
Object handler = loadHandler ( extension . getContributor ( ) . getName ( ) , handlerClassName ) ;
change . addTextEditGroup ( new TextEditGroup ( "str" , e ) ) ;
if ( element . getParent ( ) ! = null & & element . getParent ( ) instanceof IMethod & & types . contains ( ( ( IMethod ) element . getParent ( ) ) . getDeclaringType ( ) ) ) {
if ( bc . getElementResource ( ) ! = null & & bc . getElementResource ( ) . equals ( file ) ) {
if ( importedBc . getElementResource ( ) ! = null & & importedBc . getElementResource ( ) . equals ( file ) ) {
if ( newVersion ! = null & & newVersion . compareTo ( oldVersion ) > 0 ) {
RegistrationAttempt attempt = new ProductRegistrationAttempt ( productId , versionString , projectId ) ;
registerFeature ( usedPlugin , featureData ) ;
Collections . singletonMap ( "str" , part . getSite ( ) . getRegisteredName ( ) ) ) ;
protected void registerProductIfRequired ( String project ) {
if ( getCommandService ( ) ! = null & & manager ! = null & & commandId ! = null ) {
@SuppressWarnings ( { "str" } )
if ( je = = null | | ! je . exists ( ) ) {
undecidedButton . setText ( "str" ) ;
boolean useClasspath = true ;
useClasspath = prefs . getBoolean ( BeansCorePlugin . LOAD_NAMESPACEHANDLER_FROM_CLASSPATH_ID , true ) ;
classpathCheckbox . setText ( "str" ) ;
final List checkElements = checkedElements ! = null ? Arrays . asList ( checkedElements ) : Collections . emptyList ( ) ;
. getExtensionPoint ( "str" ) ;
@SuppressWarnings ( "str" )
String handlerClassName = config . getAttribute ( "str" ) ;
registerContentAssistCalculator ( "str" , "str" , clazz ) ;
public synchronized static Image getImage ( String ns , String icon ) {
public static final String PLUGIN_ID = "str" ;
ClassLoader cls = getClassLoader ( resource . getProject ( ) , null ) ;
validateFactoryMethod ( bean , mergedClassName , methodName , argCount , Static . YES , context ) ;
. getFullyQualifiedName ( ) ) , new ValidationProblemAttribute ( "str" , method ) ) ;
( BeanDefinitionParser ) loadParser ( "str" ) ) ;
IType [ ] subTypes = SuperTypeHierarchyCache . getTypeHierarchy ( interfaceType ) . getAllSubtypes ( interfaceType ) ;
IType [ ] subTypes = SuperTypeHierarchyCache . getTypeHierarchy ( type ) . getAllSubtypes ( type ) ;
IType [ ] subTypes = SuperTypeHierarchyCache . getTypeHierarchy ( type ) . getAllSubtypes ( type ) ;
IType [ ] subTypes = SuperTypeHierarchyCache . getTypeHierarchy ( superType ) . getAllSubtypes ( superType ) ;
IBeansProject project = BeansModelUtils . getParentOfClass ( this , IBeansProject . class ) ;
context . addProblems ( problem ) ;
import org . springframework . core . convert . support . ConversionServiceFactory ;
wrapper . setConversionService ( ConversionServiceFactory . createDefaultConversionService ( ) ) ;
wrapper . setConversionService ( ConversionServiceFactory . createDefaultConversionService ( ) ) ;
if ( resource ! = null & & resource . equals ( reference . getDefinition ( ) . getResource ( ) ) ) {
parser . setFeature ( "str" , true ) ;
paths . add ( file . toURI ( ) . toURL ( ) ) ;
if ( javaProject . equals ( delta . getElement ( ) ) | | javaProject . isOnClasspath ( delta . getElement ( ) ) ) {
return new URLClassLoader ( urls , this . getClass ( ) . getClassLoader ( ) ) ;
if ( graph ! = null & & getGraphicalViewer ( ) . getControl ( ) ! = null ) {
addCatalogEntry ( bundle , key , uri , catalogEntries , ICatalogEntry . ENTRY_TYPE_URI ) ;
String dotClassName = new StringBuilder ( ) . append ( "str" ) . append ( className ) . toString ( ) ;
if ( element instanceof ICompilationUnit & & element . getJavaProject ( ) . isOnClasspath ( element ) ) {
if ( element instanceof ICompilationUnit & & element . getJavaProject ( ) . isOnClasspath ( element ) ) {
ZipEntryStorage storage = ( ZipEntryStorage ) element ;
if ( variablePath ! = null & & variablePath . isPrefixOf ( fullPath ) ) {
import org . springframework . ide . eclipse . aop . core . internal . model . BeanAspectDefinition ;
( ( BeanAspectDefinition ) def ) . setProxyTargetClass ( configuration
aspectNode . getOwnerDocument ( ) , delegateRef , file ) ;
context . warning ( bean , "str" , "str" + beanName
if ( type ! = null & & type . isInterface ( ) ) {
. getPackageFragmentRoot ( ) ) . getPath ( ) ;
IPath jarPath = ( ( JarPackageFragmentRoot ) child ) . getPath ( ) ;
return request . getNode ( ) . getParentNode ( ) ;
else if ( element instanceof IBean ) {
. rootBeanDefinition ( "str" ) ;
if ( configSetName [ 0 ] ! = null & & configSetName [ 0 ] . length ( ) > 0 ) {
final String [ ] configSetName = new String [ 1 ] ;
BeanDefinition factoryBd = BeansModelUtils . getMergedBeanDefinition ( factoryB , null ) ;
beansProject . addConfig ( xmlFile , IBeansConfig . Type . MANUAL ) ;
if ( eventType = = IResourceChangeEvent . POST_BUILD & & ! SpringCoreUtils . isManifest ( file ) ) {
IProject project = createPredefinedProject ( "str" ) ;
assertTrue ( ! methods . isEmpty ( ) & & methods . toArray ( ) . length = = 1 ) ;
IProject project = createPredefinedProject ( "str" ) ;
IProject project = createPredefinedProject ( "str" ) ;
paths . addAll ( getBundleClassPath ( "str" ) ) ;
paths . addAll ( getBundleClassPath ( "str" ) ) ;
addClassPathUrls ( p . getProject ( ) , paths , resolvedProjects ) ;
. createContentService ( "str" ) ;
. getVisibleFilters ( false ) ;
public static final String PERSIST_AOP_MODEL_PREFERENCE = PLUGIN_ID + "str" ;
else if ( "str" . equals ( name ) | | "str" . equals ( name ) ) {
document , showExternal ) ;
for ( IBeansComponent component
beans . addAll ( component . getBeans ( ) ) ;
for ( IBeansComponent component : ( ( IBeansConfig ) element )
beans . addAll ( component . getBeans ( ) ) ;
getMessage ( problem ) , getElementResource ( ) , getLine ( problem ) ) ) ;
getMessage ( problem ) , getElementResource ( ) , getLine ( problem ) ) ) ;
private static final String ENABLEMENT_PREFIX = "str" ;
. getInitMethodName ( ) , 0 , Static . DONT_CARE ) ;
. getDestroyMethodName ( ) , 0 , Static . DONT_CARE ) ;
argCount , Static . YES ) ;
String methodName , int argCount , Static statics ) {
Public . DONT_CARE , statics ) ;
( statics = = Static . YES ? "str" : "str" )
( statics = = Static . YES ? "str" : "str" )
String methodName , int argCount , Static statics ) {
argCount , statics ) ;
this . targetCollectionText . setText ( this . property . getTargetCollection ( ) ) ;
this . fromText . setText ( this . property . getFrom ( ) ) ;
this . toText . setText ( this . property . getTo ( ) ) ;
+ node . getResource ( ) . getFullPath ( ) . toString ( ) . substring ( 1 ) ;
return super . getDescription ( element ) ;
if ( name . equals ( getUniqueElementName ( ) ) ) {
if ( name . equals ( getUniqueElementName ( ) ) ) {
text . append ( getElementStartLine ( ) ) ;
return ( ( IFile ) element ) . getName ( ) ;
. getExtensionPoint ( PROJECT_EXPLORER_EXTENSION_POINT ) ;
null ) ) ;
if ( BeansModelUtils . getBeanClass ( bean , null ) ! = null
if ( tElement instanceof IWebflowConfig & & openWebflowGraphAction . isEnabled ( ) ) {
else if ( tElement instanceof IFile & & openConfigFileAction . isEnabled ( ) ) {
boolean visit ( IModelElement element , IProgressMonitor monitor ) ;
public static String format ( String message , Object . . . objects ) {
WebflowModelXmlUtils . insertBefore ( state . getNode ( ) , refState . getNode ( ) ) ;
configFiles . remove ( ( IWebflowConfig ) elements . next ( ) ) ;
addStateReferenceProposals ( request , matchString , node ) ;
addStateReferenceProposals ( request , matchString , node ) ;
if ( ! ( other instanceof BeansTypedString ) ) {
if ( ! ( other instanceof AbstractBeansValueHolder ) ) {
BeansSearchMessages . SearchQuery_searchFor_property , args ) ;
addStateReferenceProposals ( request , matchString , node ) ;
refreshViewer ( getCommonViewer ( ) , element ) ;
refreshViewer ( getCommonViewer ( ) , element ) ;
public static void refreshViewer ( TreeViewer viewer , final Object javaElement ) {
viewer . expandToLevel ( calculateExpandToLevel ( javaElement ) ) ;
if ( ! ObjectUtils . nullSafeEquals ( this . context , that . context ) )
hashCode = 29 * hashCode + ObjectUtils . nullSafeHashCode ( context ) ;
if ( refBd . getBeanClassName ( ) = = null ) {
if ( factoryBd . getBeanClassName ( ) = = null ) {
if ( dependsBd . getBeanClassName ( ) = = null ) {
IBeanConstructorArgument carg = ( IBeanConstructorArgument )
List configNodes = new ArrayList ( ) ;
configNodes . add ( configNode ) ;
return ( ( IAdaptable ) element ) . getAdapter ( IModelElement . class ) ;
Iterator iter = getBeans ( ) . iterator ( ) ;
beansProject . setConfigSets ( l , true ) ;
if ( path ! = null & & ! configSet . hasConfig ( path ) ) {
alias . getElementName ( ) , alias . getName ( ) ) ;
if ( ! registry . containsBeanDefinition ( alias . getName ( ) ) ) {
"str" + alias . getName ( ) + "str" ,
alias . getElementName ( ) , alias . getName ( ) ) ;
aliasesMap . put ( alias , al ) ;
private String name ;
String getName ( ) ;
BeansEditorUtils . getBeanFlags ( bean , true ) ) ;
"str" + numArguments +
protected void createOutputStream ( OutputStream os ) throws Exception {
return ( bean ! = null ? bean . getElementName ( ) : "str" ) ;
public static final int ERROR_CODE_UNDEFINED_PARENT_BEAN = 5 ;
label . setText ( "str" +
return ( bean ! = null ? bean . isRootBean ( ) : true ) ;
setBeansConfig ( project ) ;
public class BeansProjectNature implements IProjectNature {
@Value ( "str" )
logEntityAction ( emptyId ( EntityType . ALARM ) , alarm ,
. andExpect ( status ( ) . isSeeOther ( ) )
. andExpect ( status ( ) . isSeeOther ( ) )
responseStatus = HttpStatus . SEE_OTHER ;
responseStatus = HttpStatus . SEE_OTHER ;
. andExpect ( status ( ) . isSeeOther ( ) )
new MqttFixedHeader ( UNSUBACK , false , AT_LEAST_ONCE , false , 0 ) ;
public final static String VERSION = "str" ;
cloudinary . url ( ) . suffix ( "str" ) . generate ( "str" ) ;
cloudinary . url ( ) . suffix ( "str" ) . privateCdn ( true ) . type ( "str" ) . generate ( "str" ) ;
cloudinary . url ( ) . suffix ( "str" ) . privateCdn ( true ) . generate ( "str" ) ;
cloudinary . url ( ) . suffix ( "str" ) . privateCdn ( true ) . generate ( "str" ) ;
String actual = cloudinary . url ( ) . suffix ( "str" ) . privateCdn ( true ) . generate ( "str" ) ;
actual = cloudinary . url ( ) . suffix ( "str" ) . privateCdn ( true ) . transformation ( new Transformation ( ) . angle ( 0 ) ) . generate ( "str" ) ;
String actual = cloudinary . url ( ) . suffix ( "str" ) . privateCdn ( true ) . format ( "str" ) . generate ( "str" ) ;
String actual = cloudinary . url ( ) . format ( "str" ) . privateCdn ( true ) . signed ( true ) . suffix ( "str" ) . generate ( "str" ) ;
actual = cloudinary . url ( ) . format ( "str" ) . privateCdn ( true ) . signed ( true ) . suffix ( "str" ) . transformation ( new Transformation ( ) . angle ( 0 ) ) . generate ( "str" ) ;
String actual = cloudinary . url ( ) . suffix ( "str" ) . privateCdn ( true ) . resourceType ( "str" ) . generate ( "str" ) ;
String actual = cloudinary . url ( ) . privateCdn ( true ) . suffix ( "str" ) . useRootPath ( true ) . generate ( "str" ) ;
public Url suffix ( String urlSuffix ) {
import javax . servlet . http . HttpServletRequest ;
HttpServletRequest request = ( HttpServletRequest ) context . getRequest ( ) ;
callbackUrl + = "str" + request . getServerPort ( ) + request . getContextPath ( ) ;
Trie target = Trie . fromString ( project . get ( Value . UTF8 . class , Activator . TARGET_CONFIG_OPTION ) . unwrap ( ) ) ;
context . emit ( new VerificationCondition ( "str" , context . getAssumptions ( ) ,
checkLoopInvariant ( "str" , stmt , afterFirstBodyContext ) ;
checkLoopInvariant ( "str" , stmt , afterArbitraryBodyContext ) ;
context . emit ( new VerificationCondition ( "str" , context . assumptions , clause ,
context . emit ( new VerificationCondition ( "str" , context . assumptions , clause ,
checkLoopInvariant ( "str" , stmt , context ) ;
checkLoopInvariant ( "str" , stmt , afterBodyContext ) ;
String nameStr = name . toString ( ) . replace ( "str" , "str" ) ;
check ( type ) ;
check ( method ) ;
SyntacticType element = parseArrayType ( ) ;
SyntacticType element = parseArrayType ( ) ;
r = m_body . substitute ( binding ) . instantiate ( generics ) ;
if ( least = = - 1 | | compare ( automaton , child , least ) < 0 ) {
if ( greatest = = - 1 | | compare ( automaton , child , greatest ) > 0 ) {
WycsFile tmp = new WycsFile ( Trie . ROOT . append ( filename ) , filename , tmpDecls ) ;
output . print ( "str" ) ;
finalEnv = finalEnv . merge ( environment . keySet ( ) , localEnv ) ;
environment . free ( ) ;
syntaxError ( "str" , nextIndent ) ;
rw . apply ( 100 , 100000 ) ;
rewriter . apply ( 1000 , maxSteps ) ;
} else if ( child = = K_VOID ) {
} else if ( triggerRef > = 0 & & quantifiedVariables [ triggerRef ] ) {
compact ( automaton , reachable ) ;
} else if ( triggerRef > = 0 & & quantifiedVariables [ triggerRef ] ) {
super ( kind ) ;
return new Expr . UnOp ( Expr . UOp . NEG , e , sourceAttr ( start , index - 1 ) ) ;
Expr rhs = parseAndOrExpression ( wf , generics , environment , terminated ) ;
Token token = tryAndMatch ( true , StringValue ) ;
"str" ) ) ;
if ( ! out . exists ( ) ) {
fos . write ( smt2File . toString ( ) . getBytes ( "str" ) ) ;
Collections . EMPTY_MAP ) ) ;
Collections . EMPTY_MAP ) ) ;
nblocks . add ( nblock ) ;
Nominal p = environment . getCurrent ( av . var ) ;
Nominal type = environment . getCurrent ( expr . var ) ;
public Nominal getCurrent ( String variable ) {
} else if ( c = = "str" & & ! escaped ) {
& & ( ( Expr . BinOp ) e ) . lhs instanceof Expr . ConstantAccess ) {
String var = ( ( Expr . ConstantAccess ) bop . lhs ) . name ;
sources = generated ;
if ( excludes ! = null & & excludes . matches ( e . id ( ) , from ) ) {
skipWhiteSpace ( ) ;
skipWhiteSpace ( ) ;
SyntacticType type = parseUnitType ( ) ;
SyntacticType type = parseUnitType ( ) ;
SyntacticType type = parseUnitType ( ) ;
paramTypes . add ( parseUnitType ( ) ) ;
paramTypes . add ( parseUnitType ( ) ) ;
ret = parseUnitType ( ) ;
Expr e = parseUnitExpression ( wf , environment , terminated ) ;
} else if ( c . target = = Code . NULL_REG ) {
return "str" + operand + arrayToString ( operands )
av . denominator = propagate ( av . denominator , environment ) ;
av . denominator = propagate ( av . denominator , environment ) ;
match ( RightCurly ) ;
Expr e = parseExpression ( environment ) ;
public static int compile ( String . . . args ) {
@Ignore ( "str" ) @Test public void While_Valid_11_RuntimeTest ( ) { verifyPassTest ( "str" ) ; }
@Test public void Test_List_12 ( ) { verifyPassTest ( "str" ) ; }
public static Automaton . Term maxMultiplicand ( Automaton automaton , int rBag ) {
int greatest = - 1 ;
return ( Automaton . Term ) automaton . get ( greatest ) ;
@Ignore ( "str" )
logger . logTimedMessage ( "str" + filename + "str" + number ,
e . op = = Expr . Binary . Op . SETUNION ? "str" : "str" ) ;
WYRT_PATH , "str" , name ) ;
WYRT_PATH , "str" , name ) ;
source = binding [ source ] ;
if ( compile ( "str" , WYRT_PATH , "str" , sourcepath , name ) ! = WycsMain . SYNTAX_ERROR ) {
throw new Error ( "str" + input . charAt ( pos ) + "str" , pos ) ;
Var ( automaton , root ) , automaton . add ( AnyT ) ) ) ;
public static class String extends Token {
return Expr . ForAll ( vars , contents ) ;
return Expr . Exists ( vars , contents ) ;
Var ( automaton , root ) , translate ( src , automaton , nEnvironment ) ) ) ;
Var ( automaton , root ) , Var ( automaton , root ) ) ) ;
private static final String SET_DIFFERENCE = "str" ;
Expr rhs = rightOperand . substitute ( binding ) ;
branch . write ( code . target , Expr . Nary ( Expr . Nary . Op . TUPLE , vals , branch . entry ( ) . attributes ( ) ) ) ;
idx = Expr . Nary ( Expr . Nary . Op . TUPLE , new Expr [ ] { branch . skolem ( ) , idx } ,
public Expr condition ;
@Ignore ( "str" ) @Test public void Test_Valid_051 ( ) { verifyPassTest ( "str" ) ; }
@Ignore ( "str" ) @Test public void Test_Valid_053 ( ) { verifyPassTest ( "str" ) ; }
@Ignore ( "str" ) @Test public void Test_Valid_055 ( ) { verifyPassTest ( "str" ) ; }
@Ignore ( "str" ) @Test public void Test_Valid_103 ( ) { verifyPassTest ( "str" ) ; }
variables . add ( parseSyntacticType ( generics , false ) ) ;
import wybs . lang . SyntaxError ;
} catch ( Throwable e ) {
List < Boolean > results = new Verifier ( true ) . verify ( wycs ) ;
syntaxError ( "str" + type , file , expr ) ;
@Ignore ( "str" ) @Test public void Range_Valid_1_RuntimeTest ( ) { verifyPassTest ( "str" ) ; }
@Test public void ConstrainedList_Valid_16_RuntimeTest ( ) { verifyPassTest ( "str" ) ; }
@Test public void ConstrainedList_Valid_19_RuntimeTest ( ) { verifyPassTest ( "str" ) ; }
@Test public void Range_Valid_1_RuntimeTest ( ) { verifyPassTest ( "str" ) ; }
@Test public void Method_Valid_1_RuntimeTest ( ) { verifyPassTest ( "str" ) ; }
@Ignore ( "str" ) @Test public void ConstrainedList_Valid_5_RuntimeTest ( ) { verifyPassTest ( "str" ) ; }
@Ignore ( "str" ) @Test public void ConstrainedList_Valid_12_RuntimeTest ( ) { verifyPassTest ( "str" ) ; }
@Ignore ( "str" ) @Test public void While_Valid_3_RuntimeTest ( ) { verifyPassTest ( "str" ) ; }
@Ignore ( "str" ) @Test public void While_Valid_6_RuntimeTest ( ) { verifyPassTest ( "str" ) ; }
@Ignore ( "str" ) @Test public void ConstrainedInt_Valid_13_RuntimeTest ( ) { verifyPassTest ( "str" ) ; }
@Ignore ( "str" ) @Test public void Ensures_Valid_3_RuntimeTest ( ) { verifyPassTest ( "str" ) ; }
@Ignore ( "str" ) @Test public void RealDiv_Valid_3_RuntimeTest ( ) { verifyPassTest ( "str" ) ; }
@Ignore ( "str" ) @Test public void SetUnion_Valid_5_RuntimeTest ( ) { verifyPassTest ( "str" ) ; }
int size = input . read_uv ( ) ;
value = value > > > ( 8 - count ) ;
assert mode > = STATIC & & mode < = INTERFACE ;
output . write_uv ( CONSTANT_Tuple ) ;
if ( index < tokens . size ( ) & & tokens . get ( index ) instanceof LeftBrace ) {
boolean r19 = false ;
for ( int i : code . modifiedOperands ) {
return List ( branch . automaton ( ) , vals ) ;
return Set ( branch . automaton ( ) , vals ) ;
return Record ( branch . automaton ( ) , vals ) ;
return Tuple ( branch . automaton ( ) , vals ) ;
Automaton . Term unbounded = ( Automaton . Term ) automaton . get ( list . get ( 0 ) ) ;
boolean r19 = false ;
boolean r19 = false ;
int elementRoot = automaton . addAll ( element_automaton . getRoot ( 0 ) ,
int child = automaton . addAll ( element_automaton . getRoot ( 0 ) ,
int elementRoot = automaton . addAll ( element_automaton . getRoot ( 0 ) ,
int elementRoot = automaton . addAll ( element_automaton . getRoot ( 0 ) ,
int child = automaton . addAll ( element_automaton . getRoot ( 0 ) ,
int idx = Num ( branch . automaton ( ) , code . index ) ;
if ( environment . get ( v . var ) ! = null ) {
srcSlot = generate ( src . second ( ) , environment , codes ) ;
codes . append ( Code . LoopEnd ( labels . get ( i ) ) ) ;
if ( td . constraint ! = null ) {
} else if ( code instanceof Code . AssertOrAssume ) {
if ( s . lhs instanceof Expr . AssignedVariable ) {
if ( ith . equals ( jth ) ) {
myOut ( 1 , "str" + decl . type . name
+ "str" + type2JavaType ( data ) + "str" ) ;
public static Term T_TERM ( String name , Type . Ref data ) {
public final Type . Ref data ;
private Term ( String name , Type . Ref data ) {
terms . put ( cd . name , Type . T_TERM ( cd . name , null ) ) ;
if ( type . data ! = null ) {
} else if ( type ! = null ) {
if ( decl . type . data = = null ) {
public Type . Ref parsePattern ( Environment environment , int src , ArrayList < Code > codes ) {
return Type . T_REF ( parseType ( ) ) ;
return Type . T_REF ( Type . T_TERM ( name , null ) ) ;
Type . Ref data = null ;
return Type . T_REFANY ;
myOut ( 3 , "str" + r . second ( ) + "str" ) ;
out . print ( "str" + type2HexStr ( type ) + "str" ) ;
String r = "str" + ivk . name ;
+ "str" ) ;
myOut ( 2 , "str" ) ;
double r = java . lang . Math . sqrt ( v ) ;
addReadConversion ( c . type . value ( ) , bytecodes ) ;
coerceAfter ( req , code . type . value ( ) , index , entry ) ;
public interface EffectiveList extends EffectiveSetOrList {
return index = = i . index & & ( type = = i . type | | ( type ! = null & & type . equals ( i . type ) ) ) ;
blk . append ( Code . Load ( t , 0 ) ) ;
blk . append ( Code . Store ( e . getValue ( ) , slot ) ) ;
checkIsSubtype ( Type . T_BOOL , expr , context ) ;
checkIsSubtype ( Type . T_BOOL , uop . mhs , context ) ;
checkIsSubtype ( Type . T_META , rhs , context ) ;
checkIsSubtype ( Type . T_REAL , lhs , context ) ;
checkIsSubtype ( Type . T_REAL , src , context ) ;
checkIsSubtype ( Type . T_BYTE , src , context ) ;
Type . Reference procType = checkType ( expr . qualification . result ( ) . raw ( ) , Type . Reference . class , receiver , context ) ;
checkIsSubtype ( msgType . receiver ( ) , expr . qualification , context ) ;
checkIsSubtype ( fpt , paramTypes . get ( i ) , exprArgs . get ( i ) , context ) ;
checkIsSubtype ( fpt , paramTypes . get ( i ) , exprArgs . get ( i ) , context ) ;
checkIsSubtype ( Type . T_INT , expr . index , context ) ;
checkIsSubtype ( dict . key ( ) , expr . index , context ) ;
checkIsSubtype ( Type . T_STRING , expr . src , context ) ;
SyntacticElement elem , Context context ) {
private void checkIsSubtype ( Nominal t1 , Nominal t2 , SyntacticElement elem , Context context ) {
private void checkIsSubtype ( Nominal t1 , Expr t2 , Context context ) {
private void checkIsSubtype ( Type t1 , Expr t2 , Context context ) {
throw new ResolveError ( "str" + nid ) ;
private Block generate ( UnresolvedType t , Context context ) {
Context context ) {
Context context ) {
Context context ) {
afterType = ( Nominal ) srcType . update ( da . index . result ( ) , afterType ) ;
blk . append ( Code . SetUnion ( ( Type . EffectiveSet ) result , Code . OpDir . UNIFORM ) , attributes ( v ) ) ;
blk . append ( Code . SetIntersect ( ( Type . EffectiveSet ) result , Code . OpDir . UNIFORM ) , attributes ( v ) ) ;
blk . append ( Code . SetDifference ( ( Type . EffectiveSet ) result , Code . OpDir . UNIFORM ) , attributes ( v ) ) ;
blk . append ( Code . ListAppend ( ( Type . EffectiveList ) result , Code . OpDir . UNIFORM ) , attributes ( v ) ) ;
public EffectiveRecord update ( String field , Type type ) {
checkIsSubtype ( pa . srcType , Nominal . Reference ( afterType ) , lv ) ;
HashSet < Pair < NameID , Nominal . FunctionOrMethod > > candidates = new HashSet < Pair < NameID , Nominal . FunctionOrMethod > > ( ) ;
HashSet < Pair < NameID , Nominal . FunctionOrMethod > > candidates = new HashSet < Pair < NameID , Nominal . FunctionOrMethod > > ( ) ;
HashSet < Pair < NameID , Nominal . Message > > candidates = new HashSet < Pair < NameID , Nominal . Message > > ( ) ;
HashSet < Pair < NameID , Nominal . Message > > candidates = new HashSet < Pair < NameID , Nominal . Message > > ( ) ;
Collection < Pair < NameID , Nominal . FunctionOrMethod > > candidates )
Collection < Pair < NameID , Nominal . Message > > candidates )
Collection < Pair < NameID , Nominal . FunctionOrMethod > > candidates )
Collection < Pair < NameID , Nominal . Message > > candidates )
ArrayList < WhileyFile . Import > imports ) throws ResolveError {
Nominal . FunctionOrMethod ft = ( Nominal . FunctionOrMethod ) resolveAsType ( f . unresolvedType ( ) , buildImports ( wf , f ) ) ;
} else if ( lhs = = Type . T_STRING & & Type . isSubtype ( Type . T_CHAR , rhs ) ) {
} else if ( rhs = = Type . T_STRING & & Type . isSubtype ( Type . T_CHAR , lhs ) ) {
if ( result ! = null ) {
ca . value = resolver . resolveAsConstant ( nid ) ;
NameID nid = resolver . resolveAsName ( expr . var , imports ) ;
Type . FunctionOrMethodOrMessage type = ( Type . FunctionOrMethodOrMessage ) new Type . BinaryReader ( bin ) . readType ( ) ;
public Nominal < Type . FunctionOrMethod > type ;
public Nominal < Type . FunctionOrMethod > type ( ) {
Pair < NameID , Nominal < Type . FunctionOrMethod > > p ;
NameID nid = resolver . resolveAsName ( expr . var , imports ) ;
| | expr instanceof Expr . ModuleAccess ) {
result = Type . T_INT ;
result = Type . T_INT ;
for ( WhileyFile . Parameter p : d . parameters ) {
Message m = ( Message ) d ;
propagate ( d . statements , environment , imports ) ;
if ( funType instanceof Type . Method ) {
mc . methodType = ( Nominal ) p . second ( ) ;
WhileyFile . Method md = ( WhileyFile . Method ) fd ;
public void asyncSend ( Method method , Object [ ] arguments ) {
this . arguments = new ArrayList < Expr > ( arguments ) ;
Expr . MessageSend r = new Expr . MessageSend ( nid , receiver , exprArgs , expr . synchronous , expr . attributes ( ) ) ;
public static void flush ( ) {
} else if ( Type . isImplicitCoerciveSubtype ( lhs , rhs ) ) {
if ( ti < toLabels . size ( ) ) {
int [ ] myChildren = contiguousZipIntersection ( fromState . children , from ,
| | fromState . children . length ! = toState . children . length ) {
| | fromState . children . length ! = toState . children . length ) {
blk . append ( Code . Load ( null , Code . THIS_SLOT ) , attributes ( t ) ) ;
Collections . EMPTY_LIST ) , attributes ( t ) ) ;
blk . append ( Code . Load ( null , Code . THIS_SLOT ) , attributes ( t ) ) ;
Collections . EMPTY_LIST ) , attributes ( t ) ) ;
blk . append ( Code . Store ( null , j ) , attributes ( t ) ) ;
return new Pair < Type , Block > ( cached , null ) ;
@Ignore ( "str" ) @Test public void Export_CompileFail_1_RuntimeFailTest ( ) { contextFailTest ( "str" ) ; }
@Ignore ( "str" )
@Ignore ( "str" ) @Test public void Function_Invalid_6_StaticTest ( ) { contextFailTest ( "str" ) ; }
@Ignore ( "str" ) @Test public void Native_CompileFail_1_RuntimeFailTest ( ) { contextFailTest ( "str" ) ; }
@Ignore ( "str" ) @Test public void Process_Invalid_2_StaticTest ( ) { contextFailTest ( "str" ) ; }
@Ignore ( "str" ) @Test public void Contractive_Valid_1_RuntimeTest ( ) { runTest ( "str" ) ; }
@Ignore ( "str" ) @Test public void Coercion_Valid_5_RuntimeTest ( ) { runTest ( "str" ) ; }
@Ignore ( "str" ) @Test public void FunctionRef_Valid_6_RuntimeTest ( ) { runTest ( "str" ) ; }
@Ignore ( "str" ) @Test public void MethodCall_Valid_8_RuntimeTest ( ) { runTest ( "str" ) ; }
@Ignore ( "str" ) @Test public void Process_Valid_13_RuntimeTest ( ) { runTest ( "str" ) ; }
addReadConversion ( fromType . element ( ) , bytecodes ) ;
avg = ( avg / ( totalClones ) ) ;
System . err . println ( "str" + totalElems + "str" + totalClones + "str" + avg + "str" ) ;
if ( to . equals ( from ) | | to = = Type . T_VOID ) {
if ( o instanceof ForAll ) {
syntaxError ( errorMessage ( BREAK_OUTSIDE_LOOP ) , filename , s ) ;
public static final int BREAK_OUTSIDE_LOOP = 14 ;
imports . add ( 1 , new Import ( new PkgID ( impd . pkg ) , impd . module , impd . name ) ) ;
if ( ! environment . containsKey ( ivk . name ) ) {
nenvironment . put ( c . variable , Collections . EMPTY_SET ) ;
resolve ( st , nenvironment , imports ) ;
Type . Function wyft = ( Type . Function ) Type . Method ( null , Type . T_VOID , Type . T_VOID , WHILEY_SYSTEM_T ,
Automatas . canonicalise ( automata , null ) ;
public static void generateCanonicalisationTests ( ArrayList < Automata > types )
for ( int i = 0 ; i ! = types . size ( ) ; + + i ) {
inplaceReorder ( automata , candidates . get ( 0 ) . n2i ) ;
State os = ostates [ i ] ;
} else if ( lv instanceof DictLVal ) {
this . type = t ;
super ( t ) ;
public Type . Dictionary type ( ) {
return new Compound ( automata ) ;
Type r = construct ( K_FUNCTION , null , rparams ) ;
Type r = construct ( K_FUNCTION , null , rparams ) ;
if ( candidate = = null ) {
paramTypes [ i + + ] = Type . T_ANY ;
return super . isIntersectionInner ( fromIndex , fromSign , toIndex , toSign ) ;
if ( method . type ( ) instanceof Type . Meth ) {
if ( mt . receiver ( ) ! = null ) {
for ( int i = start ; i < fields . length ; + + i ) {
Type to = fromString ( "str" ) ;
return T_NOT ( parseNotTerm ( ) ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
if ( intersection ( i , fromSign , toIndex , toSign ) ) {
if ( intersection ( fromIndex , fromSign , j , toSign ) ) {
if ( ! intersection ( i , fromSign , toIndex , toSign ) ) {
if ( ! intersection ( fromIndex , fromSign , j , toSign ) ) {
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkNotSubtype ( "str" , "str" ) ;
checkIsSubtype ( "str" , "str" ) ;
return ! fromSign | | ! toSign ;
public static final int [ ] NOCHILDREN = new int [ 0 ] ;
suptypes . set ( toIndex , fromIndex , newSuptype ) ;
Automatas . computeFixpoint ( relation ) ;
Automatas . computeFixpoint ( relation ) ;
Automatas . computeFixpoint ( relation ) ;
return super . isSubtype ( fromIndex , from , toIndex , to , subtypes , suptypes ) ;
public static final void computeFixpoint ( Relation relation ) {
import wyautl . lang . * ;
public final Automata from ( ) {
public final Automata to ( ) {
public final boolean update ( int fromIndex , int toIndex ) {
public final boolean isRelated ( int fromIndex , int toIndex ) {
int s2child = s2children [ l ] ;
ModuleLoader . Skeleton m = loader . loadSkeleton ( mid ) ;
lineEnd = parseLine ( text , lineEnd ) ;
int freeSlot = mcase . body ( ) . numSlots ( ) ;
public Block transform ( Code . ListLoad code , int freeSlot , SyntacticElement elem ) {
private String input ;
input = tmp . toString ( ) ;
tmp . add ( 0 , method . type ( ) . ret ( ) ) ;
if ( environment . size ( ) > methodCase . body ( ) . numSlots ( ) ) {
translate ( mcase . body ( ) , mcase . body ( ) . numSlots ( ) , constants , bytecodes ) ;
int freeSlot = body . numSlots ( ) ;
blk . append ( precondition . shift ( freeSlot ) . relabel ( ) ) ;
environment . put ( "str" , Code . THIS_SLOT ) ;
module . add ( propagate ( method ) ) ;
process ( module , stage ) ;
protected void process ( Module module , Transform stage ) throws IOException {
while ( ! ( token instanceof Bar ) ) {
postcondition . add ( Code . Fail ( "str" ) , attributes ( fd . postcondition ) ) ;
if ( code . slot = = Code . THIS_SLOT & & Type . isSubtype ( Type . T_PROCESS ( Type . T_ANY ) , iter ) ) {
if ( e . slot = = Code . THIS_SLOT & & Type . isCoerciveSubtype ( Type . T_PROCESS ( Type . T_ANY ) , src ) ) {
int diff = 1 ;
defined . add ( 1 ) ;
Type . Fun wyft = Type . T_METH ( WHILEY_SYSTEM_T ,
receiver = ( Type . Process ) environment . pop ( ) ;
Type . Fun funtype = bindFunction ( ivk . name , receiver , types , stmt ) ;
} else if ( c . type = = Type . T_CHAR | | c . type = = Type . T_BYTE ) {
bytecodes . add ( new Bytecode . IfCmp ( op , T_BYTE , c . target ) ) ;
r . add ( bytes [ i ] ) ;
r . add ( bytes [ i ] ) ;
Byte r = ( Byte ) bytes . get ( i ) ;
bytecodes . add ( new Bytecode . If ( Bytecode . If . NE , trueTarget ) ) ;
ftype = new JvmType . Function ( JAVA_LANG_STRING , JAVA_LANG_STRING , T_CHAR ) ;
ftype = new JvmType . Function ( JAVA_LANG_STRING , T_CHAR , JAVA_LANG_STRING ) ;
public static String append ( final String lhs , final char rhs ) {
public static String append ( final char lhs , final String rhs ) {
bytecodes . add ( new Bytecode . LoadConst ( ( int ) e . value ) ) ;
JvmType . Function ftype = new JvmType . Function ( T_BYTE ) ;
"str" , ftype , Bytecode . VIRTUAL ) ) ;
bytecodes . add ( new Bytecode . Store ( c . slot , convertType ( elementType ) ) ) ;
public static List fromStringList ( String [ ] args ) {
code = inferSetUnion ( entry , environment ) ;
code = inferSetDifference ( entry , environment ) ;
code = infer ( ( Code . SetIntersect ) code , entry , environment ) ;
Type ret_t = method . type ( ) . ret ( ) ;
if ( Type . isomorphic ( toType , fromType ) ) {
buf . append ( ( char ) reader . read_un ( 7 ) ) ;
bytecodes . add ( new Bytecode . LoadConst ( nameMangle ( nid . name ( ) , e . type ) ) ) ;
private Stmt parseDebug ( ) {
matchKeyword ( "str" ) ;
return "str" + et . name ( ) . module ( ) + "str" + et . name ( ) . name ( ) + "str" ;
Type . Fun ft = new TypeParser ( split [ split . length - 1 ] ) . parseRestFunType ( ) ;
this . desc = desc ;
writer . buildProcess ( i , ( Integer ) node . data ) ;
private static boolean isSubtype ( int n1 , Node [ ] graph1 , int n2 , Node [ ] graph2 , BitSet subtypeMatrix , BitSet suptypeMatrix ) {
return subtypeMatrix . get ( ( e1 * g2Size ) + e2 ) ;
if ( ! subtypeMatrix . get ( ( e1 * g2Size ) + e2 ) ) {
if ( ! suptypeMatrix . get ( ( e1 * g2Size ) + e2 ) ) {
| | ! subtypeMatrix
if ( subtypeMatrix . get ( ( i * g2Size ) + j ) ) {
if ( ! subtypeMatrix . get ( ( i * g2Size ) + n2 ) ) {
if ( subtypeMatrix . get ( ( n1 * g2Size ) + j ) ) {
return narrowRecordType ( ( ( Type . Named ) t ) . type ) ;
return narrowRecordType ( Type . unfold ( ( Type . Recursive ) t ) ) ;
return ( o1 ! = null & & o1 . equals ( o2 ) ) | | ( o1 = = o2 ) ;
return new Expr . UnOp ( Expr . UOp . NOT , parseIndexTerm ( false ) ,
if ( nf . equals ( this ) ) {
if ( nf ! = f ) {
} else if ( source instanceof SetConstructor ) {
public static boolean debug = false ;
postcondition = Block . substitute ( pbinding , postcondition ) ;
return new WVariable ( "str" + fvidx + + ) ;
parameterNames . add ( "str" + i ) ;
if ( ncases = = 1 ) {
blk . add ( new Code . CheckEnd ( lab ) , stmt . attribute ( Attribute . Source . class ) ) ;
HashMap < WExpr , WExpr > binding = new HashMap < WExpr , WExpr > ( ) ;
return new Module . Case ( mcase . parameterNames ( ) , body , mcase . attributes ( ) ) ;
return new Module . Case ( mcase . parameterNames ( ) , body , mcase . attributes ( ) ) ;
return new Module . Case ( mcase . parameterNames ( ) , body , mcase . attributes ( ) ) ;
if ( precondition ! = null ) {
if ( precondition ! = null ) {
rhs + = args . get ( 0 ) + "str" + args . get ( 1 ) + "str" + args . get ( 2 )
public static String toShortString ( Type t ) {
| | t instanceof Meta | | t instanceof Existential ) {
return "str" + a . msg + "str" ;
return isSubtype ( r1 . type , r2 . type ) ;
Named l = ( Named ) o ;
. attribute ( Attribute . Source . class ) ) ;
. first ( ) ) , s . attribute ( Attribute . Source . class ) ) ;
. first ( ) ) , s . attribute ( Attribute . Source . class ) ) ;
if ( ert ! = null & & ert . types . containsKey ( v . var ) ) {
Pair < CExpr , Block > lhs = resolve ( freeReg , sg . lhs ) ;
if ( method . type ( ) . receiver ! = null ) {
Type gdiff = Type . greatestDifference ( v . type , type ) ;
Type rt1type = rt1 . type ;
Type . List st = ( Type . List ) t ;
public String toString ( ) { return "str" ; }
Pair < Block , HashMap < String , Value > > r = propagate ( body , environment ) ;
blk . addAll ( r . first ( ) ) ;
return new Pair ( blk , join ( environment , r . second ( ) ) ) ;
for ( int i = 0 ; i < indent ; + + i ) {
Thread . sleep ( timeout ) ;
while ( index < bytecodes . size ( ) & & ! visited . contains ( index ) ) {
int checkNesting = 0 ;
checkNesting + + ;
checkNesting - - ;
} else if ( checkNesting = = 0 | | ! reachable ) {
} else if ( c instanceof Code . ForallEnd ) {
reachable = reachable | | reachables . contains ( label . label ) ;
public static class Case extends SyntacticElement . Impl {
public static LVar extractLVar ( CExpr lhs ) {
return extractLVar ( la . src ) ;
protected void translateTypeTest ( String trueTarget , Type src ,
modules . add ( typeInference . apply ( m ) ) ;
Label label = ( Label ) code ;
Goto got = ( Goto ) code ;
HashMap < String , HashMap < String , Type > > flowsets ) {
if ( code . op = = Code . COP . SUBTYPEEQ ) {
modules . add ( typeInference . apply ( m ) ) ;
JvmType type = convertType ( lub ) ;
JvmType type = convertType ( lub ) ;
String mangled = nameMangle ( c . name . name ( ) , c . type ) ;
return CExpr . INVOKE ( funtype , ivk . name , ivk . caseNum , receiver , args ) ;
return new Pair < Type , Block > ( td . type ( ) , td . constraint ( ) ) ;
if ( ncases = = 1 ) {
blk . add ( ivk , attributes ) ;
CExpr . Variable v = ( CExpr . Variable ) ca . lhs ;
Type . Tuple tt = ( Type . Tuple ) Type . effectiveTupleType ( la . lhs . type ( ) ) ;
blk . add ( new Code . Assign ( CExpr . VAR ( init_t , s . name ) , init_tb . first ( ) ) ) ;
translate ( r , slots , bytecodes ) ;
for ( WhileyFile . Decl d : wf . declarations ) {
if ( method ! = null ) {
Block . usedVariables ( postcondition , uses ) ;
return "str" + label + + ;
op = Bytecode . If . NE ;
op = Bytecode . If . EQ ;
} else if ( c instanceof Code . BinOp ) {
public static class Variable extends SyntacticElement . Impl implements Expr {
public static class BinOp extends SyntacticElement . Impl implements Expr {
public static class UnOp extends SyntacticElement . Impl implements Expr {
public static class Invoke extends SyntacticElement . Impl implements Expr {
public static final class VarDecl extends SyntacticElement . Impl implements
public static final class Assign extends SyntacticElement . Impl implements Stmt {
public static final class Assert extends SyntacticElement . Impl implements Stmt {
public static final class Return extends SyntacticElement . Impl implements Stmt {
public static final class IfElse extends SyntacticElement . Impl implements Stmt {
public static class Skip extends SyntacticElement . Impl implements Stmt {
Type t = environment . get ( v . name ( ) ) ;
return new ListType ( tc , ult . constraint ( ) ) ;
return new SetType ( tc , ult . constraint ( ) ) ;
return new TupleType ( types , utt . constraint ( ) ) ;
public static < T extends UnresolvedType > T recondition ( T t , Condition c ) {
return ( T ) Types . T_REAL ( c ) ;
} else if ( t instanceof UserDefType ) {
bytecodes . add ( new Bytecode . Load ( slot , JAVA_LANG_OBJECT ) ) ;
bytecodes . add ( new Bytecode . Load ( slot , JAVA_LANG_OBJECT ) ) ;
bytecodes . add ( new Bytecode . Load ( slot , JAVA_LANG_OBJECT ) ) ;
bytecodes . add ( new Bytecode . Load ( slot , JAVA_LANG_OBJECT ) ) ;
if ( t ! = null & & ! t . isSubtype ( val . type ( null ) ) ) {
if ( r ! = null ) {
if ( contains ( WBool . FALSE ) ) {
protected Proof checkModel ( Map < WVariable , WValue > model ) {
} else if ( expr instanceof None ) {
Expr expr = readExpr ( reader , constantPool ) ;
t = simplifyRecursiveTypes ( t ) ;
ModuleInfo . TypeDef td = mi . type ( key . name ( ) ) ;
Condition c = tc . second ( ) ;
writer . write ( out . toByteArray ( ) ) ;
int sw = input . read_u1 ( ) ;
HashMap < String , Integer > slots , HashMap < String , Type > environment , ArrayList < Bytecode > bytecodes ) {
Pair < Type , Condition > t = expandType ( p . type ( ) , types ) ;
r_t = expandType ( ret . type ( ) , types ) ;
r_t = expandType ( rec . type ( ) , types ) ;
Pair < Type , Condition > tc = expandType ( t , types ) ;
check ( ( TypeDecl ) d ) ;
@Test public void RecursiveType_Invalid_4_StaticTest ( ) { contextFailTest ( "str" ) ; }
output . println ( "str" + td . name ( ) + "str" + td . type ( ) ) ;
output . println ( "str" + td . name ( ) + "str" + td . constant ( ) ) ;
} else if ( androidSize > = 6 ) {
public static final boolean DEBUG = false ;
Assert . assertNull ( "str" ,
. addClasses ( DuckConverter . class , Duck . class , Donald . class , UpperCaseDuckConverter . class )
. addClasses ( CdiOptionalInjectionTest . class )
Iterable < ConfigSource > getConfigSources ( ) ;
public abstract void registerConfig ( Config config , ClassLoader classLoader ) ;
ConfigSource [ ] getConfigSources ( ) ;
String getName ( ) ;
public String getName ( ) {
public String getName ( ) {
private static Pattern re = Pattern . compile ( "str" ) ;
return ver + ( beta = = null ? "str" : beta ) + "str" + makeMTSVersionModCount ( mtsver ) ;
@MapperScan ( basePackages = { "str" } )
throw new GradleException ( String . format ( "str" , extension , sourceFile ) ) ;
private boolean currentIsOneOf ( final Token . IdType . . . types ) {
} else if ( idType . equals ( tok ( "str" ) ) ) {
if ( ! tokenCheck ( "str" ) ) {
final boolean b = simpleParse ( "str" , tok ( "str" ) , tok ( "str" ) ,
} else if ( i . equals ( tok ( "str" ) ) ) {
DEFAULT_DRUNTIME_PATH = new File ( "str" ) ;
DEFAULT_DRUNTIME_PATH = new File ( "str" ) ;
DEFAULT_DRUNTIME_PATH = new File ( "str" ) ;
IElementType KW_IMPORT = new DlangTokenType ( "str" ) ;
compilerSources . add ( root + "str" ) ;
configuration . setName ( "str" ) ;
private int generalDubOptions = 1 ;
r = r & & AssignExpression ( b , l + 1 ) ;
DLanguageAssignExpression getAssignExpression ( ) ;
DLanguageShiftExpression getShiftExpression ( ) ;
TedPermission . with ( App . sApp )
TedPermission . with ( App . sApp )
TedPermission . with ( App . sApp )
int navBarHeightPxIn1280x720Ui = CommonUtils . px2dp ( CommonUtils . getNavigationBarHeightInPx ( ) ) * 2 ;
for ( int i = 0 ; i < arguments . size ( ) ; + + i ) {
if ( i < originalTypes . length & & isGenericRuntimeParameterIdiom ( originalMethod , originalTypes [ i ] ) ) {
modules . add ( new AndroidOpenSettings ( reactContext ) ) ;
Activity activity = activityMonitor . waitForActivityWithTimeout ( 2000 ) ;
} catch ( Throwable ignored ) { }
if ( locationOnScreen [ 0 ] < = 0 )
boolean textShown = waiter . waitForText ( text , 1 , WAIT_TIME , true ) ! = null ;
return getView ( id , 0 ) ;
public void scrollToSide ( int side , float scrollPosition ) {
public void scrollViewToSide ( View view , int side , float scrollPosition ) {
public void scrollToSide ( Side side , float scrollPosition ) {
float x = screenWidth * scrollPosition ;
public void scrollViewToSide ( View view , Side side , float scrollPosition ) {
float x = corners [ 0 ] + viewWidth * scrollPosition ;
if ( view ! = null & & ! ( view . getClass ( ) . getName ( )
public < T extends AbsListView > boolean scrollList ( Class < T > classToFilterBy , T absListView , int direction , ArrayList < T > listViews ) {
if ( absListView = = null )
scrollListToLine ( absListView , absListView . getFirstVisiblePosition ( ) + 1 ) ;
if ( lineToScrollTo = = absListView . getLastVisiblePosition ( ) )
scrollListToLine ( absListView , lineToScrollTo ) ;
TextView textView = ( TextView ) spinner . getChildAt ( 0 ) ;
drawingTime = view . getDrawingTime ( ) ;
TextView textView = ( TextView ) spinner . getChildAt ( spinner . getSelectedItemPosition ( ) ) ;
Assert . assertTrue ( "str" , false ) ;
Assert . assertTrue ( "str" , false ) ;
Assert . assertTrue ( "str" , false ) ;
Assert . assertTrue ( "str" , false ) ;
Assert . assertTrue ( "str" , false ) ;
Assert . assertTrue ( "str" , false ) ;
Assert . assertTrue ( "str" , false ) ;
Assert . assertTrue ( "str" , false ) ;
Assert . assertTrue ( "str" , false ) ;
robotiumUtils . waitForText ( text , 0 , TIMEOUT , scroll ) ;
} else if ( index > = 3 & & index < 5 ) {
} else if ( index > = 5 ) {
ArrayList < TextView > textViewList = getCurrentTextViews ( null ) ;
+ "str" + String . format ( "str" , ( ( results . getProcessingTimeMs ( ) / 1000.0 ) % 60 ) ) + "str" ) ;
public Integer getMatchesTemplate ( ) {
public Double getEpochTime ( ) {
public Double getProcessingTimeMs ( ) {
public Double getMatchesTemplate ( ) {
public Double getRegionConfidence ( ) {
public Double getProcessingTimeMs ( ) {
import java . util . List ;
private final List < Coordinate > coordinates ;
private final List < Candidate > candidates ;
public Result ( String plate , Double confidence , Double matches_template , String region , Double region_confidence , Double processing_time_ms , List < Coordinate > coordinates , List < Candidate > candidates ) {
public List < Coordinate > getCoordinates ( ) {
public List < Candidate > getCandidates ( ) {
import java . util . List ;
private final List < Result > results ;
public Results ( Double epoch_time , Double processing_time_ms , List < Result > results ) {
public List < Result > getResults ( ) {
int startLife = 40 ;
) . setText ( "str" ) ) ;
new BoostTargetEffect ( xValue , xValue , Duration . EndOfTurn , true ) , false
) . setText ( "str" ) ) ;
cards . add ( new SetCardInfo ( "str" , 158 , Rarity . UNCOMMON , mage . cards . b . BlindFury . class ) ) ;
cards . add ( new SetCardInfo ( "str" , 230 , Rarity . COMMON , mage . cards . m . MtendaLion . class ) ) ;
cards . add ( new SetCardInfo ( "str" , 137 , Rarity . UNCOMMON , mage . cards . r . ReignOfTerror . class ) ) ;
import mage . abilities . decorator . ConditionalRestrictionEffect ;
this . addAbility ( new SimpleStaticAbility ( new ConditionalRestrictionEffect (
ability = new SimpleActivatedAbility ( new KenrithTheReturnedKingEffect ( ) , new ManaCostsImpl ( "str" ) ) ;
staticText = "str" ;
start = Math . max ( 0 , page * conf . CARDS_PER_PAGE - totalTokensEmblems ) ;
end = Math . max ( 0 , ( page + 1 ) * conf . CARDS_PER_PAGE - totalTokensEmblems ) ;
public boolean checkEventType ( GameEvent event , Game game ) {
public boolean checkTrigger ( GameEvent event , Game game ) {
. orElse ( 0 ) ;
cards . add ( new SetCardInfo ( "str" , 166 , Rarity . COMMON , mage . cards . f . Fruition . class ) ) ;
if ( ! player . moveCards ( card , Zone . BATTLEFIELD , source , game , true , false , false , null ) ) {
return player . drawCards ( 1 , game ) > 0 ;
return watcher . getAmountOfSpellsPlayerCastOnCurrentTurn ( source . getControllerId ( ) ) > 1
import mage . filter . StaticFilters ;
this . addAbility ( new SimpleStaticAbility ( new HeraldicBannerEffect ( ) ) ) ;
private HeraldicBanner ( final HeraldicBanner card ) {
| | ! player . hasOpponent ( getControllerOrSelf ( event . getTargetId ( ) , game ) , game )
Permanent creature2 = game . getPermanent ( source . getTargets ( ) . get ( 1 ) . getFirstTarget ( ) ) ;
if ( card = = null | | ! player . moveCards ( card , Zone . BATTLEFIELD , source , game ) ) {
new DamageTargetControllerEffect ( 3 ) , AdamantCondition . RED ,
import mage . abilities . effects . common . ReturnSourceFromGraveyardToBattlefieldEffect ;
ability . addCost ( new RemoveCountersSourceCost ( CounterType . WISH . createInstance ( ) ) ) ;
new BoostControlledEffect ( 1 , 1 , Duration . WhileOnBattlefield , filter , true )
Zone . GRAVEYARD ,
this . addAbility ( new LoyaltyAbility ( new CreateTokenEffect ( new FoodToken ( ) ) , 2 ) ) ;
super ( Zone . BATTLEFIELD , null , StaticFilters . FILTER_SPELL_INSTANT_OR_SORCERY , false , false ) ;
& & ! ( zce . getTarget ( ) instanceof PermanentToken ) ;
Player player = game . getPlayer ( source . getFirstTarget ( ) ) ;
source . getControllerId ( ) , null , true
cards . add ( new SetCardInfo ( "str" , 288 , Rarity . RARE , mage . cards . w . Wellspring . class ) ) ;
controller . moveCards ( exileZone . getCards ( game ) , Zone . BATTLEFIELD , source , game , false , true , false , null ) ;
return playerSet . stream ( ) . noneMatch ( ( ( Permanent ) source ) : : isControlledBy ) ;
return playerSet . stream ( ) . noneMatch ( ( ( Spell ) source ) : : isControlledBy ) ;
return playerSet . stream ( ) . noneMatch ( ( ( StackObject ) source ) : : isControlledBy ) ;
return playerSet . stream ( ) . noneMatch ( ( ( Card ) source ) : : isOwnedBy ) ;
CopyEffect copyEffect = new CopyEffect ( Duration . UntilYourNextTurn , newBluePrint , volrathTheShapestealer . getId ( ) ) ;
) . setText ( "str" ) ) ;
return watcher ! = null & & ! watcher . castFaceDownThisTurn ( input . getPlayerId ( ) ) ;
Ability ability = new EntersBattlefieldTriggeredAbility ( new DamageTargetEffect ( xValue ) . setText ( "str" ) ) ;
this . staticText = "str" ;
new DrawCardSourceControllerEffect ( 1 ) . setText ( "str" ) , false
) . setText ( "str" ) , false ) ) ;
if ( usedFreeMulligans . containsKey ( player . getId ( ) ) ) {
new FilterCard ( "str" + ( cardsToDiscard > 1 ? "str" : "str" ) + "str" ) ) ;
"str" ) ) ;
InfoEffect . addInfoToPermanent ( game , source , permanent , "str" ) ;
& & input . getObject ( ) . getToughness ( ) . getValue ( ) < sourcePermanent . getToughness ( ) . getValue ( ) ;
Ability ability = new LoyaltyAbility ( new ChandraAcolyteOfFlameGraveyardEffect ( ) , - 2 ) ;
public static final String MAGE_VERSION_MINOR_PATCH = "str" ;
filter2 . add ( AnotherPredicate . instance ) ;
if ( spell . getColor ( game ) . isBlack ( ) | | spell . getColor ( game ) . isBlue ( ) ) {
if ( copyToArtifact . isArtifact ( ) & & ! copyToArtifact . getId ( ) . equals ( copyFromArtifact . getId ( ) ) ) {
private static final FilterControlledCreaturePermanent filter
ability . addTarget ( new TargetControlledCreaturePermanent ( filter ) ) ;
public static final String MAGE_VERSION_MINOR_PATCH = "str" ;
super ( Outcome . Detriment ) ;
if ( nonlands . size ( ) > 0 ) {
if ( sourceObject = = null | | this . controllerId . equals ( sourceObject . getControllerId ( ) ) ) {
public static final String MAGE_VERSION_MINOR_PATCH = "str" ;
effect2 . setTargetPointer ( new FixedTarget ( permId , game ) ) ;
this . getSpellAbility ( ) . addEffect ( new ReturnToHandTargetEffect ( ) ) ;
new ReturnFromGraveyardToBattlefieldTargetEffect ( true )
import mage . target . common . TargetControlledPermanent ;
ability . addTarget ( new TargetControlledPermanent ( StaticFilters . FILTER_CONTROLLED_ANOTHER_CREATURE ) ) ;
ability . addTarget ( new TargetCreaturePermanent ( 0 , 1 ) ) ;
) , - 1 ) ) ;
) . setText ( "str" ) ) ;
new TargetCardInLibrary ( 0 , Integer . MAX_VALUE , filter ) , true , true
this . addAbility ( new SimpleStaticAbility ( new SpellsCostReductionControllerEffect ( filter , 4 ) ) ) ;
new BoostSourceEffect ( 2 , 2 , Duration . WhileOnBattlefield ) ,
this . getSpellAbility ( ) . addEffect ( new CreateDelayedTriggeredAbilityEffect ( new RepeatedReverberationTriggeredAbility ( ) ) ) ;
class RepeatedReverberationTriggeredAbility extends DelayedTriggeredAbility {
RepeatedReverberationTriggeredAbility ( ) {
private RepeatedReverberationTriggeredAbility ( final RepeatedReverberationTriggeredAbility ability ) {
new RepeatedReverberationEffect ( )
class RepeatedReverberationEffect extends OneShotEffect {
RepeatedReverberationEffect ( ) {
private RepeatedReverberationEffect ( final RepeatedReverberationEffect effect ) {
controller . moveCards ( card , Zone . BATTLEFIELD , source , game ) ;
new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( ) ) ,
this . addAbility ( new LoyaltyAbility ( new GetEmblemEffect ( new MuYanlingSkyDancerEmblem ( ) ) , - 8 ) ) ;
import mage . abilities . condition . common . NotMyTurnCondition ;
) , NotMyTurnCondition . instance , "str" +
new CreateTokenEffect ( new TreasureToken ( ) , 2 )
. filter ( permanent - > ! permanent . getOwnerId ( ) . equals ( source . getControllerId ( ) ) )
this . addAbility ( new EntersBattlefieldTriggeredAbility ( new CreateTokenEffect ( new SpiritWhiteToken ( ) ) ) ) ;
ability . addEffect ( new UntapSourceEffect ( ) ) ;
. getPlayersInRange ( source . getControllerId ( ) , game )
cards . add ( new SetCardInfo ( "str" , 221 , Rarity . COMMON , mage . cards . a . AnvilwroughtRaptor . class ) ) ;
cards . add ( new SetCardInfo ( "str" , 48 , Rarity . COMMON , mage . cards . b . BoneToAsh . class ) ) ;
this . hasBasicLands = true ;
public void testHybridAndPhyrexian ( ) {
public void testSplitCards ( ) {
public void testSplitCards2 ( ) {
public void testEmptyManaCosts ( ) {
public void testXCosts ( ) {
ability . addTarget ( new TargetCreaturePermanent ( 0 , 2 ) ) ;
super ( 0 , 2 , filter2 ) ;
import mage . target . common . TargetOpponent ;
ability . addTarget ( new TargetOpponent ( ) ) ;
private SoulhunterRakshasa ( final SoulhunterRakshasa card ) {
new BoostControlledEffect ( 2 , 0 , Duration . EndOfTurn , filter ) , 1
this . getSpellAbility ( ) . addEffect ( new ReturnToBattlefieldUnderOwnerControlTargetEffect ( ) ) ;
int toDiscard = Math . min ( player . getHand ( ) . size ( ) , 2 ) ;
public static final String MAGE_VERSION_MINOR_PATCH = "str" ;
public static final int MAGE_VERSION_PATCH = 36 ;
public static final String MAGE_VERSION_MINOR_PATCH = "str" ;
StaticFilters . FILTER_CONTROLLED_CREATURE , source . getControllerId ( ) , source . getSourceId ( ) , game
private static final FilterCard filter = new FilterBySubtypeCard ( SubType . MOUNTAIN ) ;
cards . removeAll ( cardsToKeep ) ;
true , false , Duration . EndOfTurn
public int announceXMana ( int min , int max , int multiplier , String message , Game game , Ability ability ) {
public int announceXMana ( int min , int max , int multiplier , String message , Game game , Ability ability ) {
return computerPlayer . announceXMana ( min , max , multiplier , message , game , ability ) ;
public int announceXMana ( int min , int max , int multiplier , String message , Game game , Ability ability ) {
public int announceXMana ( int min , int max , int multiplier , String message , Game game , Ability ability ) {
String extraMessage = ( multiplier = = 1 ? "str" : "str" + multiplier + "str" ) ;
public int announceXMana ( int min , int max , int multiplier , String message , Game game , Ability ability ) {
int announceXMana ( int min , int max , int multiplier , String message , Game game , Ability ability ) ;
2 , new CardsInControllerGraveCondition ( 1 , StaticFilters . FILTER_CARD_LAND )
1 , 0 , Duration . WhileOnBattlefield ,
this . addAbility ( new NinjutsuAbility ( new ManaCostsImpl ( "str" ) ) ) ;
ExileZone zone = game . getExile ( ) . getExileZone ( CardUtil . getCardExileZoneId ( game , source . getSourceId ( ) , true ) ) ;
private static final DynamicValue xValue = new PermanentsOnBattlefieldCount ( filter2 , - 1 ) ;
ability . addTarget ( new TargetCardInYourGraveyard ( 0 , 1 , filter ) ) ;
player . moveCards ( card , Zone . EXILED , source , game , true , false , false , null ) ;
CardInfo secondSideCard = CardRepository . instance . findCardWPreferredSet ( card . getSecondSideName ( ) , card . getSetCode ( ) , false ) ;
CardUtil . reduceCost ( abilityToModify , Math . min ( reductionAmount , 5 ) ) ;
ability . addTarget ( new TargetPermanent ( 0 , 1 , filter2 , false ) ) ;
public static final String MAGE_VERSION_MINOR_PATCH = "str" ;
addAbility ( new SimpleStaticAbility ( new PreventAllDamageToSourceEffect ( Duration . WhileOnBattlefield ) ) ) ;
removeCounters ( CounterType . LOYALTY . getName ( ) , countersToRemove , game ) ;
public static final String MAGE_VERSION_MINOR_PATCH = "str" ;
private static final boolean MAGE_VERSION_MINOR_PATCH_MUST_BE_SAME = true ;
public static final String MAGE_VERSION_MINOR_PATCH = "str" ;
public static final String MAGE_VERSION_MINOR_PATCH = "str" ;
private static final long CARD_CONTENT_VERSION = 222 ;
private FilterCard makeFilter ( ) {
if ( ! game . getBattlefield ( ) . getActivePermanents ( filter , source . getControllerId ( ) , game ) . isEmpty ( ) ) {
g . drawImage ( FRAME_INVENTION , 3 , 3 , cardWidth - 6 , cardHeight - 6 , null ) ;
if ( event . getAmount ( ) = = 0 | | ! event . getData ( ) . equals ( "str" )
super ( Zone . BATTLEFIELD , null ) ;
ability . addTarget ( new TargetPermanent ( filter2 ) ) ;
super ( "str" , "str" ) ;
refreshDeck ( true ) ;
new GideonBlackbladeToken ( ) , "str" , Duration . WhileOnBattlefield
this . addAbility ( new SimpleStaticAbility ( new NarsetParterOfVeilsEffect ( ) ) , new CardsAmountDrawnThisTurnWatcher ( ) ) ;
Ability ability = new LoyaltyAbility ( new PutTopCardOfLibraryIntoGraveTargetEffect ( 4 ) , - 1 ) ;
) . setText ( "str" +
if ( ! basicLandNames . contains ( entry . getKey ( ) ) & & ! anyNumberCardsAllowed . contains ( entry . getKey ( ) ) ) {
Permanent permanent2 = game . getPermanent ( source . getTargets ( ) . get ( 1 ) . getFirstTarget ( ) ) ;
Player player = game . getPlayer ( source . getTargets ( ) . get ( 1 ) . getFirstTarget ( ) ) ;
game . addDelayedTriggeredAbility ( new MassacreGirlDelayedTriggeredAbility ( ) , source ) ;
if ( isConnected ( ) & & sessionId ! = null ) {
Player player = game . getPlayer ( source . getControllerId ( ) ) ;
if ( opponent = = null | | ! opponent . hasOpponent ( source . getControllerId ( ) , game ) ) {
) . setText ( "str" ) ) ;
) . setText ( "str" ) ) ;
this . addAbility ( new PlaneswalkerEntersWithLoyaltyCountersAbility ( 5 ) ) ;
this . addAbility ( new LoyaltyAbility ( new TezzeretMasterOfTheBridgeEffect2 ( ) , - 8 ) ) ;
public static final String MAGE_VERSION_MINOR_PATCH = "str" ;
Assert . assertEquals ( "str" , url . baseUrl ) ;
Assert . assertEquals ( "str" , url . baseUrl ) ;
Assert . assertEquals ( "str" , url . baseUrl ) ;
Assert . assertEquals ( "str" , url . baseUrl ) ;
String url = "str" + tokenData . getExpansionSetCode ( ) . trim ( ) + "str"
lifeLost + = game . getPlayer ( opponentId ) . loseLife ( 3 , game , false ) ;
game . getPlayer ( source . getControllerId ( ) ) . gainLife ( lifeLost , game , source ) ;
Assert . fail ( "str" + doubleErrors . size ( ) ) ;
Assert . fail ( "str" + errorsList . size ( ) ) ;
Assert . assertEquals ( "str" + player . getName ( ) + "str"
Assert . assertEquals ( "str" + player . getName ( ) + "str" + player . getChoices ( ) + "str" , count , player . getChoices ( ) . size ( ) ) ;
Assert . assertEquals ( "str" + player . getName ( ) + "str" + player . getTargets ( ) + "str" , count , player . getTargets ( ) . size ( ) ) ;
Assert . fail ( "str" + doubleErrors . size ( ) ) ;
errorsList . add ( "str" + set . getCode ( ) + "str" + checkCard . getName ( ) + "str" + currentClass + "str" + needClass + "str" ) ;
Assert . fail ( "str" + errorsList . size ( ) ) ;
Assert . fail ( "str" + errorsList . size ( ) ) ;
Assert . fail ( "str" + errorsList . size ( ) ) ;
Assert . fail ( "str" + errorsList . size ( ) ) ;
String mes = "str" + errorMessages . toString ( ) ;
System . out . println ( "str" + errors . size ( ) + "str" ) ;
+ "str" + maxTurn + "str" + maxPhase + "str" ,
Assert . assertEquals ( "str" + player . getName ( ) + "str"
Assert . assertEquals ( "str" + player . getName ( ) + "str" + player . getChoices ( ) + "str" , count , player . getChoices ( ) . size ( ) ) ;
Assert . assertEquals ( "str" + player . getName ( ) + "str" + player . getTargets ( ) + "str" , count , player . getTargets ( ) . size ( ) ) ;
logger . info ( "str" + expansions . size ( ) ) ;
logger . info ( "str" + cards . size ( ) ) ;
Assert . fail ( "str" + s + "str" + manaList . toString ( ) ) ;
wasOutdated = true ;
skipYou = new HashMap ( ) { {
skipYou = new HashMap ( ) { {
private static final long EXPANSION_CONTENT_VERSION = 18 ;
private static final long CARD_CONTENT_VERSION = 219 ;
if ( expansionSet = = null | | ! expansionSet . getSetType ( ) . isEternalLegal ( ) ) {
boolean selected3x3 = MageFrame . getPreferences ( ) . get ( LAYOYT_CONFIG_KEY , MageBook . LAYOUT_3X3 ) . equals ( MageBook . LAYOUT_3X3 ) ;
private KessDissidentMageWatcher ( final KessDissidentMageWatcher watcher ) {
import mage . abilities . common . SimpleActivatedAbility ;
Ability ability = new SimpleActivatedAbility (
super ( ownerId , setInfo , new CardType [ ] { CardType . ENCHANTMENT } , "str" ) ;
if ( card ! = null & & null ! = game . getContinuousEffects ( ) . asThough ( card . getId ( ) , AsThoughEffectType . PLAY_FROM_NOT_OWN_HAND_ZONE , card . getSpellAbility ( ) , getId ( ) , game ) ) {
import mage . game . Game ;
super ( effect ) ;
super ( effect ) ;
super ( Zone . ALL , effect , optional ) ;
cards . add ( new SetCardInfo ( "str" , 244 , Rarity . UNCOMMON , mage . cards . s . SuperiorNumbers . class ) ) ;
setRuleAtTheTop ( true ) ;
sb . append ( "str" ) ;
sb . append ( count . toString ( ) ) . append ( "str" ) ;
sbRule . append ( "str" ) ;
sb . append ( spliceCosts . getText ( ) ) . append ( nonManaCosts ? "str" : "str" ) ;
if ( ! shortRule ) {
assertAbility ( playerA , "str" , new RiotAbility ( ) , true ) ;
effect . setTargetPointer ( new FixedTarget ( source . getTargets ( ) . get ( 1 ) . getFirstTarget ( ) , game ) ) ;
super ( Zone . ALL , effect , true ) ;
) . setBackInRandomOrder ( true ) . setText ( "str" +
if ( permanent ! = null & & permanent . isCreature ( ) & & permanent . isControlledBy ( source . getControllerId ( ) ) ) {
Player player = game . getPlayer ( source . getFirstTarget ( ) ) ;
Player player = game . getPlayer ( targetPointer . getFirst ( game , source ) ) ;
Player player = game . getPlayer ( source . getControllerId ( ) ) ;
this . addAbility ( new SimpleStaticAbility ( new TeysaKarlovEffect ( ) ) ) ;
& & game . getPermanentOrLKIBattlefield ( numberOfTriggersEvent . getSourceId ( ) ) ! = null
return zEvent . getFromZone ( ) = = Zone . BATTLEFIELD
super ( new AddCountersSourceEffect ( CounterType . LOYALTY . createInstance ( ) ) , Duration . EndOfTurn , false ) ;
= new FilterControlledCreaturePermanent ( "str" ) ;
static final FilterControlledPermanent filter = new FilterControlledPermanent ( "str" ) ;
if ( ! game . isSimulation ( ) ) {
mode . addTarget ( new TargetPermanent ( filter ) ) ;
put ( "str" , "str" ) ;
import mage . game . permanent . token . RedGreenBeastToken ;
new CreateTokenEffect ( new RedGreenBeastToken ( ) ) ,
true , true , Zone . HAND , false , false , false
this . addAbility ( new SimpleStaticAbility ( new BoostOpponentsEffect ( - 1 , 0 , Duration . WhileOnBattlefield ) ) ) ;
= new FilterControlledCreaturePermanent ( "str" ) ;
if ( permanent = = null ) {
ability . addCost ( new SacrificeTargetCost ( new TargetControlledPermanent ( 2 , 2 , filter , true ) ) ) ;
& & zEvent . getCards ( ) ! = null ) {
cards . add ( new SetCardInfo ( "str" , 197 , Rarity . UNCOMMON , mage . cards . r . RakdosFirewheeler . class ) ) ;
String serverAddress = "str" ;
TriggeredAbility ability = new SpellCastOpponentTriggeredAbility ( new BecomesCreatureSourceEffect ( new OpalAcrolithToken ( ) , "str" , Duration . WhileOnBattlefield , true , false ) ,
class OpalAcrolithToken extends TokenImpl {
public OpalAcrolithToken ( final OpalAcrolithToken token ) {
panel . pickAbility ( ( AbilityPickerView ) callback . getData ( ) ) ;
ability . addEffect ( effect2 . setText ( "str" ) ) ;
ArrayList < CardNameAmount > deck = new ArrayList < > ( ) ;
permanent . addCounters ( CounterType . P1P1 . createInstance ( amount ) , source , game , appliedEffects ) ;
if ( choice . getChoice ( ) . equals ( CHOICE_1 ) ) {
logger . error ( "str" + sessionId + "str" + session . getUserId ( ) + "str" ) ;
import mage . game . events . GameEvent ;
damageMap . putIfAbsent ( event . getSourceId ( ) , new HashSet < > ( ) ) ;
+ + amountGoblins ;
game . addDelayedTriggeredAbility ( new MnemonicBetrayalDelayedTriggeredAbility ( cards , cardMap ) , source ) ;
for ( UUID targetId : targetPointer . getTargets ( game , source ) ) {
int power = target . getPower ( ) . getValue ( ) ;
new TapTargetEffect ( ) . setText ( "str" )
Player player = game . getPlayer ( source . getControllerId ( ) ) ;
false , SetTargetPointer . PLAYER , true
) . setText ( "str" ) ) ;
Player player = game . getPlayer ( source . getControllerId ( ) ) ;
Player player = game . getPlayer ( source . getControllerId ( ) ) ;
private static final FilterCard filter = new FilterCard ( "str" ) ;
this . getSpellAbility ( ) . addTarget ( new TargetCardInYourGraveyard ( 0 , 4 ) ) ;
this . staticText = "str"
new SearchLibraryGraveyardPutInHandEffect ( filter , false , true )
xValue , xValue , Duration . EndOfTurn , true
private static final FilterPermanent filter = new FilterCreaturePermanent ( "str" ) ;
staticText = "str" ;
cards . add ( new SetCardInfo ( "str" , 196 , Rarity . UNCOMMON , mage . cards . a . AzoriusSignet . class ) ) ;
cards . add ( new SetCardInfo ( "str" , 203 , Rarity . UNCOMMON , mage . cards . d . DimirSignet . class ) ) ;
cards . add ( new SetCardInfo ( "str" , 207 , Rarity . UNCOMMON , mage . cards . i . IzzetSignet . class ) ) ;
cards . add ( new SetCardInfo ( "str" , 102 , Rarity . UNCOMMON , mage . cards . s . SigiledStarfish . class ) ) ;
import mage . abilities . effects . common . CreateTokenTargetEffect ;
return new CreateTokenTargetEffect (
targetZoneLookedCards , putOnTop , reveal , reveal ) ;
0 , 1 , Zone . LIBRARY ,
new DestroyTargetEffect ( false , true ) .
cards . add ( new SetCardInfo ( "str" , 230 , Rarity . UNCOMMON , mage . cards . s . StatusStatue . class ) ) ;
"str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str"
cards . add ( new SetCardInfo ( "str" , 46 , Rarity . MYTHIC , mage . cards . t . ThantisTheWarweaver . class ) ) ;
cards . add ( new SetCardInfo ( "str" , 51 , Rarity . MYTHIC , mage . cards . y . YennetCryptSovereign . class ) ) ;
new SowerOfDiscordEntersBattlefieldEffect ( )
class SowerOfDiscordEntersBattlefieldEffect extends OneShotEffect {
public SowerOfDiscordEntersBattlefieldEffect ( ) {
public SowerOfDiscordEntersBattlefieldEffect ( final SowerOfDiscordEntersBattlefieldEffect effect ) {
TriggeredAbility ability = new EntersBattlefieldTriggeredAbility ( new LoseLifeTargetEffect ( 4 ) , false ) ;
public EzurisBrigade ( UUID ownerId , CardSetInfo setInfo ) {
Effect effect = new ConditionalOneShotEffect (
TriggeredAbility triggeredAbility = new EntersBattlefieldTriggeredAbility ( new BoostTargetEffect ( - 4 , - 4 , Duration . EndOfTurn ) ) ;
public SnapsailGlider ( UUID ownerId , CardSetInfo setInfo ) {
TriggeredAbility ability = new EntersBattlefieldTriggeredAbility ( new GainLifeEffect ( 5 ) ) ;
this . getSpellAbility ( ) . addEffect ( new CaravanVigilEffect ( ) ) ;
this . addAbility ( new BeginningOfEndStepTriggeredAbility ( Zone . BATTLEFIELD , new DrawCardSourceControllerEffect ( 1 ) ,
this . getSpellAbility ( ) . addEffect ( new MoltenPsycheEffect ( ) ) ;
public CarapaceForger ( UUID ownerId , CardSetInfo setInfo ) {
TriggeredAbility ability = new EntersBattlefieldTriggeredAbility ( new CreateTokenEffect ( new ZombieToken ( ) ) ) ;
TriggeredAbility ability = new EntersBattlefieldTriggeredAbility ( new WoodlandSleuthEffect ( ) ) ;
Ability ability = new ConditionalActivatedAbility ( Zone . BATTLEFIELD , new CreateTokenEffect ( new DemonToken ( ) ) ,
private static final FilterAttackingCreature filter = new FilterAttackingCreature ( ) ;
addCard ( Zone . BATTLEFIELD , playerA , "str" , 1 ) ;
this . getSpellAbility ( ) . addEffect ( new ConditionalContinuousEffect (
this . getSpellAbility ( ) . addTarget ( new TargetCreaturePermanent ( ) ) ;
this . getSpellAbility ( ) . addEffect ( new ConditionalOneShotEffect (
this . getSpellAbility ( ) . addTarget ( new TargetPlayer ( ) ) ;
ConditionalContinuousEffect effect = new ConditionalContinuousEffect ( new BoostControlledEffect ( 3 , 0 , Duration . WhileOnBattlefield , StaticFilters . FILTER_PERMANENT_CREATURE , false ) ,
Ability ability = new ConditionalInterveningIfTriggeredAbility (
public GhalmasWarden ( UUID ownerId , CardSetInfo setInfo ) {
this . getSpellAbility ( ) . addEffect ( new BrimstoneVolleyEffect ( ) ) ;
TriggeredAbility conditional = new ConditionalInterveningIfTriggeredAbility (
this . addAbility ( new EntersBattlefieldAbility ( new ConditionalOneShotEffect ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 4 ) ) ,
this . addAbility ( new EntersBattlefieldAbility (
TriggeredAbility ability = new EntersBattlefieldTriggeredAbility ( new BoostSourceEffect ( 3 , 3 , Duration . EndOfTurn ) , false ) ;
this . getSpellAbility ( ) . addEffect (
this . getSpellAbility ( ) . addTarget ( new TargetCreaturePermanent ( ) ) ;
Ability ability = new ActivateIfConditionActivatedAbility ( Zone . BATTLEFIELD , new ArgentSphinxEffect ( ) , new ManaCostsImpl ( "str" ) , MetalcraftCondition . instance ) ;
Ability ability = new ConditionalInterveningIfTriggeredAbility ( new EntersBattlefieldTriggeredAbility ( new AddCountersTargetEffect ( CounterType . P1P1 . createInstance ( 2 ) , Outcome . BoostCreature ) ) ,
addCard ( Zone . HAND , playerA , "str" , 1 ) ;
new GainAbilityControlledEffect ( new EquipAbility ( Outcome . AddAbility , new GenericManaCost ( 0 ) ) , Duration . WhileOnBattlefield , filter ) ,
this . getSpellAbility ( ) . addEffect ( new ConditionalOneShotEffect ( new DamageTargetEffect ( 4 ) , new DamageTargetEffect ( 2 ) , MetalcraftCondition . instance , effectText ) ) ;
this . addAbility ( new EntersBattlefieldAbility ( new ConditionalOneShotEffect ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 2 ) ) ,
this . getSpellAbility ( ) . addEffect ( new ConcussiveBoltEffect ( ) ) ;
private static final FilterPermanent filter = new FilterPermanent ( "str" ) ;
ability . setAbilityWord ( AbilityWord . METALCRAFT ) ;
ability . setRuleAtTheTop ( true ) ;
public ChromeSteed ( UUID ownerId , CardSetInfo setInfo ) {
Permanent permanent = game . getPermanent ( source . getFirstTarget ( ) ) ;
ability . addEffect ( new EnterAttributeAddChosenSubtypeEffect ( ) ) ;
if ( card . getName ( ) . toLowerCase ( Locale . ENGLISH ) . equals ( "str" ) ) {
cards . add ( new SetCardInfo ( "str" , 277 , Rarity . RARE , mage . cards . b . BoobyTrap . class ) ) ;
if ( ! canGainLife | | amount < = 0 ) {
staticText = "str" ;
targetPlayer . shuffleLibrary ( source , game ) ;
return CardType . PLANESWALKER ;
super ( ownerId , setInfo , new CardType [ ] { CardType . CREATURE } , "str" ) ;
super ( Zone . COMMAND , new RowanKenrithEmblemEffect ( ) , false ) ;
UUID creatureId = this . getSourceId ( ) ;
& & game . isActivePlayer ( source . getControllerId ( ) ) ) {
& & game . isActivePlayer ( source . getControllerId ( ) )
this . staticText = "str" ;
return ActivationStatus . getFalse ( ) ;
return game . isActivePlayer ( this . playerId ) ;
for ( UUID targetId : this . getTargetPointer ( ) . getTargets ( game , source ) ) {
ability = new DiesAttachedTriggeredAbility ( new AvariceAmuletChangeControlEffect ( ) , "str" , false ) ;
if ( validForTurnNum = = game . getTurnNum ( ) ) {
if ( game . getCombat ( ) . attacksAlone ( ) ) {
turnPhases . contains ( game . getTurn ( ) . getPhase ( ) . getType ( ) ) ;
for ( FixedTarget fixedTarget : this . detainedObjects ) {
this . controlledFromStartOfControllerTurn = true ;
if ( turnPhase = = TurnPhase . BEGINNING | | turnPhase = = TurnPhase . PRECOMBAT_MAIN ) {
Ability ability = new LoyaltyAbility ( new DestroyTargetEffect ( ) , - 3 ) ;
super ( new DamageTargetEffect ( 3 ) , Duration . OneUse , true ) ;
super ( new IsarethTheAwakenerEffect ( ) , Duration . OneUse , true ) ;
super ( new AddCountersTargetEffect ( CounterType . P1P1 . createInstance ( ) ) , Duration . OneUse , true ) ;
for ( Permanent permanent : game . getBattlefield ( ) . getAllActivePermanents ( filter , controller . getId ( ) , game ) ) {
Zone . BATTLEFIELD , new BoostEnchantedEffect ( 1 , 1 , Duration . WhileOnBattlefield )
Ability ability = new LoyaltyAbility ( new AddCountersTargetEffect ( CounterType . P1P1 . createInstance ( ) ) , 1 ) ;
cards . add ( new SetCardInfo ( "str" , 265 , Rarity . RARE , mage . cards . g . GrimFeast . class ) ) ;
import mage . game . permanent . token . CatToken2 ;
new CreateTokenEffect ( new CatToken2 ( ) , 2 , true , true ) , false
) . setText ( "str" )
) . setText ( "str" ) ,
ability . addTarget ( new TargetControlledCreaturePermanent ( StaticFilters . FILTER_CONTROLLED_ANOTHER_CREATURE ) ) ;
for ( String setName : setNames . split ( "str" ) ) {
HashMap < String , Integer > localizedLanguageIds = getlocalizedMultiverseIds ( multiverseId ) ;
this . quit = false ;
setStoredBookmark ( bookmark ) ;
private void getOtherUseableActivatedAbilities ( MageObject object , Zone zone , Game game , Map < UUID , ActivatedAbility > useable ) {
for ( Permanent permanent : selectedToUntap ) {
for ( Entry < Entry < RestrictionUntapNotMoreThanEffect , Set < Ability > > , Integer > notMoreThanEffect : notMoreThanEffectsUsage . entrySet ( ) ) {
available . removeDuplicated ( ) ;
cards . add ( new SetCardInfo ( "str" , 38 , Rarity . RARE , mage . cards . s . SpiritualSanctuary . class ) ) ;
game . informPlayers ( getLogName ( ) + "str" + player . getLogName ( ) ) ;
staticText = controllingPlayerName + "str" + controlledPlayerName ;
this . addAbility ( new DrawCardControllerTriggeredAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( ) ) , false ) ) ;
public < T extends EventListener > Iterator < T > getIterator ( Class < T > . . . listenerClass ) {
return new PermanentsOnTheBattlefieldCondition ( filter , ComparisonType . MORE_THAN , 0 ) . apply ( game , this ) ;
this . addAbility ( new EntersBattlefieldTriggeredAbility ( new SoulFoundryImprintEffect ( ) , true , "str" ) ) ;
this . addAbility ( new EntersBattlefieldTriggeredAbility ( new SummonersEggImprintEffect ( ) , true , "str" ) ) ;
EntersBattlefieldTriggeredAbility ability = new EntersBattlefieldTriggeredAbility ( new ThoughtPrisonImprintEffect ( ) , true , "str" ) ;
Ability ability = new EntersBattlefieldTriggeredAbility ( new DuplicantExileTargetEffect ( ) , true , "str" ) ;
if ( onlyControlled & & ! abilityToModify . getControllerId ( ) . equals ( source . getControllerId ( ) ) ) {
super ( ownerId , setInfo , new CardType [ ] { CardType . SORCERY } , "str" ) ;
controller . damage ( targetCreature . getPower ( ) . getValue ( ) , targetCreature . getId ( ) , game , false , true ) ;
namePredicatesArabianNights . add ( new NamePredicate ( "str" ) ) ;
namePredicatesArabianNights . add ( new NamePredicate ( "str" ) ) ;
namePredicatesArabianNights . add ( new NamePredicate ( "str" ) ) ;
namePredicatesArabianNights . add ( new NamePredicate ( "str" ) ) ;
"str" ) ) ;
return "str" + super . getRule ( ) ;
SpellMasteryCondition . instance , "str" ) ;
effect . setText ( "str" ) ;
this . staticText = "str" ;
staticText = "str" ;
effect . setText ( "str" ) ;
return new StringBuilder ( "str" ) . append ( super . getRule ( ) ) . toString ( ) ;
this . staticText = "str" ;
new BoostSourceEffect ( 1 , 0 , Duration . WhileOnBattlefield ) , HellbentCondition . instance , "str" ) ) ;
staticText = "str" ;
this . staticText = "str" ;
"str" ) ) ;
super ( Zone . BATTLEFIELD , new ConditionalContinuousEffect ( new BoostSourceEffect ( 2 , 2 , Duration . WhileOnBattlefield ) , CommanderInPlayCondition . instance , "str" ) ) ;
super ( Zone . BATTLEFIELD , new ConditionalContinuousEffect ( new BoostSourceEffect ( 2 , 2 , Duration . WhileOnBattlefield ) , CommanderInPlayCondition . instance , "str" ) ) ;
private static final String text = "str"
this . staticText = "str" ;
this . staticText = "str" ;
effect . setText ( "str" ) ;
"str" ) ) ) ;
this . staticText = "str" ;
this . staticText = "str" ;
this . staticText = "str" ;
effect . setText ( "str" ) ;
effect . setText ( "str" ) ;
return new StringBuilder ( "str" ) . append ( super . getRule ( ) ) . toString ( ) ;
return "str" + super . getRule ( ) ;
this . staticText = "str" ;
"str" ) ) ;
StringBuilder sb = new StringBuilder ( "str" ) ;
effect . setText ( "str" ) ;
"str" ) ) ;
SpellMasteryCondition . instance , "str" ) ;
private static final String text = "str"
StringBuilder sb = new StringBuilder ( "str" ) ;
this . staticText = "str" ;
private static final String ruleText = "str" ;
this . staticText = "str" ;
effect . setText ( "str" ) ;
this . staticText = "str" ;
this . staticText = "str" ;
"str" ) ) ;
effect . setText ( "str" ) ;
effect . setText ( "str" ) ;
this . staticText = "str" ;
"str" ) ) ) ;
return new StringBuilder ( "str" ) . append ( super . getRule ( ) ) . toString ( ) ;
"str" ) ) ;
effect . setText ( "str" ) ;
"str" ) ) ;
staticText = "str" ;
this . staticText = "str" + sweepSubtype + ( sweepSubtype . getDescription ( ) . endsWith ( "str" ) ? "str" : "str" ) + "str" ;
"str" ) ) ;
null , "str" , null ) ) ;
"str" ) ) ) ; }
"str" ) ) ;
this . staticText = "str" ;
this . staticText = "str" ;
return new StringBuilder ( "str" ) . append ( super . getRule ( ) ) . toString ( ) ;
return new StringBuilder ( "str" ) . append ( striveCost ) . append ( "str" ) . toString ( ) ;
new PermanentsOnBattlefieldCount ( filter )
TargetPermanent target = new TargetPermanent ( 0 , 1 , filter , true ) ;
return game . damagePlayerOrPlaneswalker ( targetPointer . getFirst ( game , source ) , tappedAmount , myr . getId ( ) , game , false , true ) > 0 ;
if ( source ! = null & & source . getId ( ) = = this . getSourceId ( ) ) {
FilterMana getColorIdentity ( ) ;
if ( object . getColor ( game ) . contains ( ObjectColor . WHITE )
private static final String rule = "str" ;
ConditionalActivatedAbility ability = new ConditionalActivatedAbility ( Zone . BATTLEFIELD , new JeweledAmuletAddCounterEffect ( ) , new ManaCostsImpl ( "str" ) , new SourceHasCounterCondition ( CounterType . CHARGE , 0 , 0 ) , rule ) ;
ability . addTarget ( new TargetCardInYourGraveyard ( 0 , numbTargets , new FilterCard ( "str" + ( numbTargets = = 1 ? "str" : "str" ) + "str" ) ) ) ;
cards . add ( new SetCardInfo ( "str" , 167 , Rarity . COMMON , mage . cards . t . TouchOfDeath . class ) ) ;
cards . add ( new SetCardInfo ( "str" , 55 , Rarity . COMMON , mage . cards . w . Warning . class ) ) ;
for ( UUID playerId : game . getState ( ) . getPlayersInRange ( sourceAbility . getControllerId ( ) , game ) ) {
controller . moveCards ( exile . getCards ( game ) , Zone . BATTLEFIELD , source , game , false , false , true , null ) ;
this . staticText = "str" ;
super ( ownerId , setInfo , new CardType [ ] { CardType . SORCERY } , "str" ) ;
while ( continueCasting & & controller . isInGame ( ) ) {
chkUnique . setSelected ( "str" . equals ( MageFrame . getPreferences ( ) . get ( KEY_DECK_EDITOR_SEARCH_UNIQUE , "str" ) ) ) ;
chkUnique . setSelected ( false ) ;
getEffects ( ) . setTargetPointer ( new FixedTarget ( event . getTargetId ( ) , game . getState ( ) . getZoneChangeCounter ( event . getTargetId ( ) ) ) ) ;
if ( game . getPlayer ( getControllerId ( ) ) . hasOpponent ( event . getPlayerId ( ) , game ) ) {
import mage . game . events . DamagedEvent ;
if ( ( ( DamagedEvent ) event ) . isCombatDamage ( )
targetPermanent . damage ( enteringCreature . getPower ( ) . getValue ( ) , enteringCreature . getId ( ) , game , false , true ) ;
targetPlayer . damage ( enteringCreature . getPower ( ) . getValue ( ) , enteringCreature . getId ( ) , game , false , true ) ;
super ( duration ) ;
super ( PlayerAttackedStepWatcher . class . getSimpleName ( ) , WatcherScope . GAME ) ;
chosenGroup . addBlockerToGroup ( permanent . getId ( ) , controller . getId ( ) , game ) ;
cards . add ( new SetCardInfo ( "str" , 117 , Rarity . COMMON , mage . cards . r . Rust . class ) ) ;
Permanent permanent = game . getPermanentEntering ( event . getTargetId ( ) ) ;
player . putCardsOnTopOfLibrary ( cards , game , source , ! backInRandomOrder ) ;
private static final Pattern layoutStackEntryPattern = Pattern . compile ( "str" ) ;
this . staticText = "str" ;
super ( Duration . EndOfTurn , Outcome . Detriment ) ;
super ( Outcome . Detriment ) ;
Set < Card > cards = owner . getLibrary ( ) . getTopCards ( game , amount ) ;
filterAll . add ( new SubtypePredicate ( SubType . MERFOLK ) ) ;
new TapTargetCost ( new TargetControlledPermanent ( 5 , 5 , filterAll , true ) ) ) ) ;
import mage . abilities . effects . common . cost . SpellsCostReductionAllOfChosenSubtypeEffect ;
new SpellsCostReductionAllOfChosenSubtypeEffect ( new FilterCreatureCard ( "str" ) , 1 ) ) ) ;
choice . setMessage ( "str" ) ;
effect . setText ( "str" ) ;
cards . add ( new SetCardInfo ( "str" , 191 , Rarity . COMMON , mage . cards . c . CrawWurm . class ) ) ;
cards . add ( new SetCardInfo ( "str" , 168 , Rarity . RARE , mage . cards . p . PowerSurge . class ) ) ;
cards . add ( new SetCardInfo ( "str" , 42 , Rarity . RARE , mage . cards . v . VeteranBodyguard . class ) ) ;
cards . add ( new SetCardInfo ( "str" , 287 , Rarity . RARE , mage . cards . v . VolcanicIsland . class ) ) ;
TxtDeckImporter importer = new TxtDeckImporter ( false ) ;
super ( effect , Duration . Custom ) ;
ability . addEffect ( new GainAbilityAttachedEffect ( gainedAbility , AttachmentType . AURA ) . setText ( "str" ) ) ;
super ( ownerId , setInfo , new CardType [ ] { CardType . ENCHANTMENT } , "str" ) ;
Duration . WhileOnBattlefield , BecomesCreatureAttachedEffect . LoseType . ALL_BUT_COLOR ) ) ) ;
cards . add ( new SetCardInfo ( "str" , 9 , Rarity . RARE , mage . cards . k . KongmingSleepingDragon . class ) ) ;
cards . add ( new SetCardInfo ( "str" , 14 , Rarity . RARE , mage . cards . p . PangTongYoungPhoenix . class ) ) ;
if ( mageObject instanceof Spell & & ( ( Spell ) mageObject ) . isCopy ( ) ) {
if ( mageObject instanceof Spell & & ( ( Spell ) mageObject ) . isCopy ( ) ) {
super ( ownerId , setInfo , new CardType [ ] { CardType . CREATURE } , "str" ) ;
super ( ownerId , setInfo , new CardType [ ] { CardType . ARTIFACT , CardType . CREATURE } , "str" ) ;
UUID exileZoneId = CardUtil . getExileZoneId ( game , source . getSourceId ( ) , source . getSourceObjectZoneChangeCounter ( ) ) ;
ExileZone exileZone = game . getExile ( ) . getExileZone ( CardUtil . getExileZoneId ( game , source . getSourceId ( ) , source . getSourceObjectZoneChangeCounter ( ) ) ) ;
permanent . changeControllerId ( enchantment . getControllerId ( ) , game ) ;
return watcher . getCardsDrawnThisTurn ( sourceAbility . getControllerId ( ) ) ;
private final Map < UUID , Integer > cardsDrawnThisTurn = new HashMap < > ( ) ;
& & ! controllerId . equals ( playerId ) & & getZone ( ) ! = Zone . HAND ) {
super ( ownerId , setInfo , new CardType [ ] { CardType . CREATURE } , "str" ) ;
Effect effect = new ReturnToBattlefieldUnderOwnerControlTargetEffect ( true ) ;
type . append ( String . join ( "str" , getSubTypes ( ) . stream ( ) . map ( SubType : : toString ) . collect ( Collectors . toList ( ) ) ) ) ;
effect = new DoUnlessTargetPaysCost ( new DamageTargetEffect ( 2 , true , "str" ) , new SacrificeTargetCost ( new TargetControlledCreaturePermanent ( ) ) ,
. add ( tooltipDelayLabel , org . jdesktop . layout . GroupLayout . DEFAULT_SIZE , 308 , Short . MAX_VALUE )
super ( ownerId , setInfo , new CardType [ ] { CardType . SORCERY } , "str" ) ;
if ( target1 . canChoose ( source . getSourceId ( ) , controller . getId ( ) , game ) ) {
if ( target2 . canChoose ( source . getSourceId ( ) , controller . getId ( ) , game ) ) {
if ( target3 . canChoose ( source . getSourceId ( ) , controller . getId ( ) , game ) ) {
if ( target4 . canChoose ( source . getSourceId ( ) , controller . getId ( ) , game ) ) {
Card copy1 = game . copyCard ( card , source , source . getControllerId ( ) ) ;
Card copy2 = game . copyCard ( card , source , source . getControllerId ( ) ) ;
Card copy3 = game . copyCard ( card , source , source . getControllerId ( ) ) ;
this . originalId = ability2 . getOriginalId ( ) ;
private static final FilterPermanent filterToken = new FilterPermanent ( SubType . REFLECTION , "str" ) ;
this . paid = permanent . addCounters ( counter , ability , game ) ;
this . cost = effect . cost . copy ( ) ;
super ( PlayerDamagedBySourceWatcher . class . getSimpleName ( ) , WatcherScope . PLAYER ) ;
boolean weAreDoingIt = getControllerId ( ) . equals ( event . getPlayerId ( ) ) ;
& & affectedControllerId . equals ( source . getControllerId ( ) ) ) {
for ( String type : this . supertypes . split ( SEPARATOR ) ) {
effect . setText ( "str" ) ;
return ComparisonType . compare ( inputValue , type , value ) ;
creature . addCounters ( CounterType . P1P1 . createInstance ( ) , source , game , event . getAppliedEffects ( ) ) ;
super ( ownerId , setInfo , new CardType [ ] { CardType . CREATURE } , "str" ) ;
return sb . toString ( ) . replace ( "str" , "str" ) . replace ( "str" , "str" ) . replace ( "str" , "str" ) . trim ( ) ;
if ( player ! = null & & ( player . canBeTargetedBy ( targetSource , sourceControllerId , game ) | | notTarget ) & & filter . match ( player , game ) ) {
if ( ( permanent . canBeTargetedBy ( targetSource , sourceControllerId , game ) | | notTarget ) & & filter . match ( permanent , game ) ) {
this . addAbility ( new FlashbackAbility ( new ManaCostsImpl ( "str" ) , TimingRule . SORCERY ) ) ;
staticText = "str" ;
super ( ownerId , setInfo , new CardType [ ] { CardType . ENCHANTMENT } , "str" ) ;
this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD , new CanopyCoverEffect ( ) ) ) ;
class CanopyCoverEffect extends RestrictionEffect {
public CanopyCoverEffect ( ) {
public CanopyCoverEffect ( final CanopyCoverEffect effect ) {
if ( equipped ! = null & & permanent . getId ( ) . equals ( equipped . getId ( ) ) ) {
super ( ownerId , setInfo , new CardType [ ] { CardType . INSTANT } , "str" ) ;
this . staticText = "str" ;
game . informPlayers ( controller . getLogName ( ) + "str" + cost . getText ( ) ) ;
private final FilterCard filter ;
public void cleanUp ( ) {
gameSessionPlayer . cleanUp ( ) ;
this . choice = effect . choice . copy ( ) ;
controller . moveCards ( card , Zone . GRAVEYARD , source , game ) ;
this . addAbility ( new ConditionalActivatedAbility ( Zone . BATTLEFIELD , new BecomesCreatureSourceEffect ( new JadeStatueToken ( ) , "str" , Duration . EndOfCombat ) , new ManaCostsImpl ( "str" ) , new IsPhaseCondition ( TurnPhase . COMBAT ) , "str" ) ) ;
super ( ownerId , setInfo , new CardType [ ] { CardType . ENCHANTMENT } , "str" ) ;
import mage . target . targetpointer . FixedTarget ;
& & ( ( DamageEvent ) event ) . isCombatDamage ( ) ) {
for ( Permanent permanent : game . getBattlefield ( ) . getAllActivePermanents ( new FilterCreaturePermanent ( ) , game ) ) {
if ( ! playerId . equals ( defendingPlayerId ) & & controller . hasOpponent ( playerId , game ) ) {
import mage . filter . common . FilterControlledPermanent ;
import mage . target . common . TargetControlledPermanent ;
private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "str" ) ;
ability . addCost ( new SacrificeTargetCost ( new TargetControlledPermanent ( 1 , 1 , filter , false ) ) ) ;
& & owner . getCommandersIds ( ) . contains ( input . getId ( ) ) ;
super ( "str" , "str" , ExpansionSet . buildDate ( 2012 , 11 , 2 ) , SetType . SUPPLEMENTAL ) ;
super ( "str" , "str" , ExpansionSet . buildDate ( 2017 , 6 , 9 ) , SetType . SUPPLEMENTAL ) ;
super ( "str" , "str" , ExpansionSet . buildDate ( 1998 , 6 , 24 ) , SetType . SUPPLEMENTAL ) ;
import mage . filter . predicate . permanent . ControllerIdPredicate ;
filter . add ( new ControllerIdPredicate ( playerId ) ) ;
super ( ownerId , setInfo , new CardType [ ] { CardType . CREATURE } , "str" ) ;
this . getSpellAbility ( ) . addTarget ( new TargetCardInYourGraveyard ( new FilterCreatureCard ( "str" ) ) ) ;
Ability ability3 = new DiesAttachedTriggeredAbility ( new ReturnToHandAttachedEffect ( ) , "str" , false ) ;
Ability ability3 = new DiesAttachedTriggeredAbility ( new ReturnToHandAttachedEffect ( ) , "str" , false ) ;
staticText = "str" ;
Ability ability3 = new DiesAttachedTriggeredAbility ( new ReturnToHandAttachedEffect ( ) , "str" , false ) ;
Ability ability3 = new DiesAttachedTriggeredAbility ( new ReturnToHandAttachedEffect ( ) , "str" , false ) ;
this . addAbility ( new DiesAttachedTriggeredAbility ( new ReinsOfTheVinesteedEffect ( ) , "str" , true ) ) ;
Ability ability3 = new DiesAttachedTriggeredAbility ( new ReturnToHandAttachedEffect ( ) , "str" , false ) ;
if ( targetDescription ! = null & & targetDescription . length ( ) > 0 ) {
import org . junit . Assert ;
Assert . assertEquals ( DomainErrors . Errors . STATUS_NOT_FOUND . getCode ( ) , parser . getInt ( "str" ) ) ;
super ( ownerId , setInfo , new CardType [ ] { CardType . CREATURE } , "str" ) ;
this . cardNumber = "str" ;
this . cardNumber = "str" ;
this . cardNumber = "str" ;
this . cardNumber = "str" ;
this . cardNumber = "str" ;
this . cardNumber = "str" ;
this . cardNumber = "str" ;
this . cardNumber = "str" ;
this . cardNumber = "str" ;
this . cardNumber = "str" ;
effect . setText ( "str" ) ;
Effect effect = new GainAbilityControlledEffect ( HexproofAbility . getInstance ( ) , Duration . EndOfGame ) ;
private static final long EXPANSION_CONTENT_VERSION = 11 ;
PreferencesDialog . getCachedValue ( PreferencesDialog . KEY_GAME_ASK_MOVE_TO_GRAVE_ORDER , "str" ) . equals ( "str" ) ,
FilterControlledPermanent filter = new FilterControlledPermanent ( "str" ) ;
super ( ownerId , 63 , "str" , Rarity . COMMON , new CardType [ ] { CardType . INSTANT } , "str" ) ;
while ( ! topCards . isEmpty ( ) & & controller . isInGame ( ) ) {
topCards . remove ( libCard ) ;
import mage . filter . predicate . other . PlayerIdPredicate ;
filter . add ( Predicates . not ( new PlayerIdPredicate ( sourceCard . getOwnerId ( ) ) ) ) ;
private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "str" ) ;
CreateTokenEffect createTokenEffect = new CreateTokenEffect ( new ElementalShamanToken ( "str" ) ) ;
super ( "str" ) ;
public ElementalShamanToken ( String setCode ) {
this . addAbility ( new EntersBattlefieldTriggeredAbility ( new CreateTokenEffect ( new ElementalShamanToken ( "str" ) , 2 ) , false ) ) ;
filter . add ( new PlayerPredicate ( TargetController . OPPONENT ) ) ;
if ( controller ! = null & & newController ! = null & & controller . getId ( ) ! = newController . getId ( ) ) {
Zone . GRAVEYARD , new DoIfCostPaid ( new ReturnFromGraveyardToHandTargetEffect ( ) , new ManaCostsImpl ( "str" ) ) , TargetController . YOU , false , false ) ;
this . cardNumber = "str" ;
import mage . target . common . TargetCreaturePermanentAmount ;
this . getSpellAbility ( ) . addTarget ( new TargetCreaturePermanentAmount ( 6 ) ) ;
assertHandCount ( playerB , 1 ) ;
public void testUseWithMercilessExecutioner ( ) {
castSpell ( 2 , PhaseStep . PRECOMBAT_MAIN , playerB , "str" ) ;
setChoice ( playerB , "str" ) ;
this . getSpellAbility ( ) . addTarget ( new TargetCardInYourGraveyard ( new FilterCreatureCard ( "str" ) ) ) ;
effect . setText ( "str" ) ;
targetCreature . damage ( targetCreature . getPower ( ) . getValue ( ) , targetCreature . getId ( ) , game , false , true ) ;
super ( ownerId , 151 , "str" , Rarity . RARE , new CardType [ ] { CardType . SORCERY } , "str" ) ;
LoyaltyAbility ability2 = new LoyaltyAbility ( new BecomesCreatureSourceEffect ( new GideonChampionOfJusticeToken ( ) , "str" , Duration . EndOfTurn , false , true ) , 0 ) ;
super ( Zone . BATTLEFIELD , effect , optional ) ;
this . staticText = "str" ;
TargetCardInHand target = new TargetCardInHand ( xValue , new FilterCard ( "str" ) ) ;
import mage . abilities . costs . common . DiscardTargetCost ;
Ability ability = new SpellCastControllerTriggeredAbility ( new NoyanDarEffect ( ) , filter , true ) ;
assertPermanentCount ( playerC , "str" , 1 ) ;
this ( playerId , additionalCardType , gainsHaste , number , tapped , attacking , attackedPlayer , Integer . MIN_VALUE , Integer . MIN_VALUE , false ) ;
this . attackedPlayer = attackedPlayer ;
EmptyToken token = new EmptyToken ( ) ;
TriggeredAbility triggeredAbility = new EntersBattlefieldTriggeredAbility ( new DrawDiscardControllerEffect ( 1 , 1 , true ) ) ;
abilityToModify . addCost ( cost . copy ( ) ) ;
staticText = "str" ;
this . addAbility ( new SimpleManaAbility ( Zone . BATTLEFIELD , new Mana ( 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 ) , new TapSourceCost ( ) ) ) ;
if ( table . getRowCount ( ) > 0 & & table . getRowCount ( ) > = table . getEditingRow ( ) & & table . getEditingRow ( ) > = 0 ) {
targetPlayer . loseLife ( 1 , game ) ;
this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD , new BoostEnchantedEffect ( 3 , - 1 , Duration . WhileOnBattlefield ) ) ) ;
if ( artifacts > 0 & & controller . chooseUse ( outcome , "str" , source , game ) ) {
addCard ( Zone . BATTLEFIELD , playerA , "str" , 1 ) ;
addTarget ( playerB , "str" ) ;
assertGraveyardCount ( playerA , "str" , 1 ) ;
this . addAbility ( new AttacksAllTriggeredAbility ( new LoseLifeDefendingPlayerEffect ( 1 , true ) , false , filter , SetTargetPointer . PLAYER , false ) ) ;
import mage . filter . common . FilterCreatureCard ;
private static FilterCreatureCard filter = new FilterCreatureCard ( ) ;
this ( effect , optional , new FilterCreaturePermanent ( optional ? "str" : "str" ) ) ;
this ( effect , optional , new FilterCreaturePermanent ( optional ? "str" : "str" ) ) ;
this . useFirstManaAbility = userData . useFirstManaAbility ;
this . secondSideCard = new IncitedRabble ( ownerId ) ;
return PreferencesDialog . getCachedValue ( PreferencesDialog . KEY_CARD_IMAGES_SAVE_TO_ZIP , "str" ) . equals ( "str" ) ;
return "str" + userName + "str" + User . userStatsToMatchHistory ( userStats . getProto ( ) ) + "str" + User . userStatsToTourneyHistory ( userStats . getProto ( ) ) ;
return "str" + userName + "str" + user . getUserData ( ) . getMatchHistory ( ) + "str" + user . getUserData ( ) . getTourneyHistory ( ) ;
this . history = seat . getPlayer ( ) . getUserData ( ) . getMatchHistory ( ) + "str" + seat . getPlayer ( ) . getUserData ( ) . getTourneyHistory ( ) ;
controller . moveCards ( card , Zone . BATTLEFIELD , source , game , false , false , false , null ) ;
import mage . target . TargetPermanent ;
this . getSpellAbility ( ) . addTarget ( new TargetPermanent ( ) ) ;
import mage . target . common . TargetCreaturePermanent ;
ability . addTarget ( new TargetCreaturePermanent ( ) ) ;
ability . addTarget ( new TargetCreaturePermanent ( filter ) ) ;
compare . red = 0 ;
compare . green = 0 ;
compare . blue = 0 ;
compare . black = 0 ;
compare . white = 0 ;
this . getSpellAbility ( ) . addEffect ( new SearchLibraryPutInHandEffect ( new TargetCardInLibrary ( new FilterCreatureCard ( ) ) , true ) ) ;
this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD , new CantBeBlockedSourceEffect ( Duration . EndOfTurn ) , new ManaCostsImpl ( "str" ) ) ) ;
super ( ownerId , 28 , "str" , Rarity . UNCOMMON , new CardType [ ] { CardType . SORCERY } , "str" ) ;
class MeteorBlastEffect extends OneShotEffect {
public MeteorBlastEffect ( final MeteorBlastEffect effect ) {
cubeCards . add ( new CardIdentity ( "str" , "str" ) ) ;
cubeCards . add ( new CardIdentity ( "str" , "str" ) ) ;
cubeCards . add ( new CardIdentity ( "str" , "str" ) ) ;
cubeCards . add ( new CardIdentity ( "str" , "str" ) ) ;
cubeCards . add ( new CardIdentity ( "str" , "str" ) ) ;
cubeCards . add ( new CardIdentity ( "str" , "str" ) ) ;
cubeCards . add ( new CardIdentity ( "str" , "str" ) ) ;
import mage . filter . predicate . permanent . ControllerIdPredicate ;
filter . add ( new ControllerIdPredicate ( targetPlayer . getId ( ) ) ) ;
+ ( version = = null ? "str" : version . toString ( ) ) + "str"
this . expansionSetCode = "str" ;
this . expansionSetCode = "str" ;
sb . append ( "str" ) . append ( mode . getTargets ( ) . get ( 0 ) . getTargetName ( ) ) . append ( "str" ) ;
this . targetName = "str" ;
public ManaType getAsThoughManaType ( ManaType manaType , ManaPoolItem mana , UUID affectedControllerId , Ability source , Game game ) {
public ManaType getAsThoughManaType ( ManaType manaType , ManaPoolItem mana , UUID affectedControllerId , Ability source , Game game ) {
public ManaType getAsThoughManaType ( ManaType manaType , ManaPoolItem mana , UUID affectedControllerId , Ability source , Game game ) {
ManaType getAsThoughManaType ( ManaType manaType , ManaPoolItem mana , UUID affectedControllerId , Ability source , Game game ) ;
if ( ( ( AsThoughManaEffect ) effect ) . getAsThoughManaType ( manaType , mana , controllerId , ability , game ) = = null ) {
ManaType usableManaType = ( ( AsThoughManaEffect ) effect ) . getAsThoughManaType ( manaType , mana , controllerId , ability , game ) ;
public ManaType getAsThoughManaType ( ManaType manaType , ManaPoolItem mana , UUID affectedControllerId , Ability source , Game game ) {
public ManaType getAsThoughManaType ( ManaType manaType , ManaPoolItem mana , UUID affectedControllerId , Ability source , Game game ) {
public ManaType getAsThoughManaType ( ManaType manaType , ManaPoolItem mana , UUID affectedControllerId , Ability source , Game game ) {
import mage . filter . common . FilterCreaturePermanent ;
Player player = game . getPlayer ( source . getControllerId ( ) ) ;
Collection < Permanent > permanents = game . getBattlefield ( ) . getAllActivePermanents ( ) ;
assertPermanentCount ( playerA , "str" , 1 ) ;
if ( permanent ! = null & & permanent . getCardType ( ) . contains ( CardType . CREATURE ) ) {
if ( permanent ! = null & & permanent . getCardType ( ) . contains ( CardType . CREATURE ) ) {
attachedTo . addAbility ( protectionAbility , source . getSourceId ( ) , game ) ;
private static final int [ ] defaultColumnsWidth = { 20 , 100 , 100 , 80 , 80 } ;
controller . searchLibrary ( target , game ) ;
SpellMasteryCondition . getInstance ( ) ,
class GideonsPhalanxKnightToken extends Token {
subtype . add ( "str" ) ;
this . subtype . add ( "str" ) ;
"str" ) ) ) ;
ButtonColumn buttonColumn = new ButtonColumn ( tableMatches , action , tableMatches . convertColumnIndexToView ( TournamentMatchesTableModel . ACTION_COLUMN ) ) ;
return response . getUUID ( ) ;
if ( ! target . isRequired ( sourceId , game ) | | target . getNumberOfTargets ( ) = = 0 ) {
Permanent permanent = game . getPermanent ( id ) ;
Permanent sourcePermanent = game . getPermanent ( source . getSourceId ( ) ) ;
package mage . sets . fifthedition ;
import mage . abilities . condition . common . KickedCondition ;
totalCost . add ( ( ManaCost ) cumulativeCost . copy ( ) ) ;
package mage . sets . planarchaos ;
private static final FilterCreaturePermanent filter = new FilterCreaturePermanent ( "str" ) ;
Ability ability = new SimpleActivatedAbility ( Zone . BATTLEFIELD , new BlocksIfAbleAllEffect ( filter , Duration . EndOfTurn ) , new ManaCostsImpl ( "str" ) ) ;
ExpansionRepository . instance . setContentVersion ( ExpansionRepository . instance . getContentVersionConstant ( ) ) ;
allCards . removeAll ( cards . getCards ( game ) ) ;
if ( targetName ! = null & & targetName . length ( ) > 0 ) {
this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD , new SpellsCostReductionControllerEffect ( filter , 1 ) ) ) ;
this . put ( card . getId ( ) , new CardView ( card , game , card . getId ( ) , false ) ) ;
mode1 . getEffects ( ) . add ( new DestroyTargetEffect ( ) ) ;
import mage . abilities . costs . common . ExileSourceCost ;
ability . addCost ( new ExileSourceCost ( ) ) ;
if ( ! repeatable ) {
if ( event . getType ( ) = = EventType . ACTIVATED_ABILITY & & event . getPlayerId ( ) . equals ( getControllerId ( ) ) ) {
cubeCards . add ( new CardIdentity ( "str" , "str" ) ) ;
boolean obsolete = RepositoryUtil . isDatabaseObsolete ( connectionSource , VERSION_ENTITY_NAME , EXPANSION_DB_VERSION ) ;
public class MemoryLapse2 extends mage . sets . seventhedition . MemoryLapse {
staticText = "str" ;
game . getCombat ( ) . checkAttackRequirements ( player , game ) ;
addTarget ( playerB , playerA ) ;
assertHandCount ( playerB , "str" , 0 ) ;
affectedObjectList . add ( new MageObjectReference ( sourceId , game ) ) ;
logger . warn ( "str" + card . getName ( ) + "str" + card . getSet ( ) + "str" + responseCode + "str" + url . toString ( ) ) ;
cost . pay ( source , game , targetCreature . getControllerId ( ) , targetCreature . getControllerId ( ) , false ) ;
owner . putCardsOnTopOfLibrary ( cardsPlayer , game , source , onTop ) ;
owner . putCardsOnTopOfLibrary ( cardsPlayer , game , source , onTop ) ;
import mage . filter . FilterPermanent ;
import mage . target . TargetPermanent ;
loyaltyAbility . addTarget ( new TargetPermanent ( 0 , 4 , new FilterPermanent ( ) , false ) ) ;
protected static final String REMINDER_TEXT = "str" ;
if ( player ! = null & & cardsToDiscard . get ( playerId ) ! = null ) {
import mage . filter . FilterCard ;
startTime = new Date ( ) ;
this . startTime = new Date ( ) ;
. addGroup ( gl_jPanel3 . createParallelGroup ( Alignment . LEADING )
StringBuilder sb = new StringBuilder ( "str" ) . append ( manaCosts . getText ( ) ) ;
draft = new BoosterDraft ( ( DraftOptions ) options . getLimitedOptions ( ) , getSets ( ) ) ;
super ( Zone . ALL , effect , optional ) ;
. append ( "str" ) . toString ( ) ,
if ( ! match . isDoneSideboarding ( ) | | ( ! matchPlayer . hasQuit ( ) & & match . getGame ( ) ! = null & & matchPlayer . getPlayer ( ) . isInGame ( ) ) ) {
this . cardNumber = 266 ;
this . cardNumber = 271 ;
this . cardNumber = 264 ;
this . cardNumber = 261 ;
this . cardNumber = 250 ;
this . cardNumber = 243 ;
this . cardNumber = 244 ;
this . cardNumber = 268 ;
this . cardNumber = 232 ;
this . cardNumber = 275 ;
this . cardNumber = 241 ;
this . cardNumber = 231 ;
this . cardNumber = 267 ;
this . cardNumber = 278 ;
this . cardNumber = 249 ;
this . cardNumber = 265 ;
this . cardNumber = 252 ;
this . cardNumber = 277 ;
this . cardNumber = 253 ;
this . cardNumber = 240 ;
this . cardNumber = 263 ;
this . cardNumber = 274 ;
this . cardNumber = 269 ;
this . cardNumber = 257 ;
this . cardNumber = 270 ;
this . cardNumber = 256 ;
this . cardNumber = 239 ;
this . cardNumber = 233 ;
this . subtype . add ( "str" ) ;
player . setCastSourceIdWithoutMana ( objectId ) ;
this . addAbility ( new AttacksTriggeredAbility ( new BoostSourceEffect ( new PermanentsOnBattlefieldCount ( attackingFilter ) , new StaticValue ( 0 ) , Duration . EndOfTurn , true ) , false ) ) ;
sb . append ( "str" ) . append ( getManaCosts ( ) . getText ( ) ) . append ( "str" ) . append ( getCosts ( ) . getText ( ) ) . append ( "str" ) . toString ( ) ;
staticText = "str" ;
logger . debug ( user . getId ( ) + "str" + formatter . format ( user . getConnectionTime ( ) ) + "str" + user . getName ( ) + "str" + user . getUserState ( ) . toString ( ) + "str" + user . getPingInfo ( ) + "str" ) ;
Effect effect = new GainAbilityAllEffect ( IndestructibleAbility . getInstance ( ) , Duration . EndOfTurn , filter , false ) ;
public Counter ( final Counter counter ) {
if ( isTableOwner ( tableId , userId ) | | UserManager . getInstance ( ) . isAdmin ( userId ) ) {
logger . debug ( table . getId ( ) + "str" + table . getName ( ) + "str" + formatter . format ( table . getStartTime ( ) = = null ? table . getCreateTime ( ) : table . getCreateTime ( ) ) + "str" + table . getState ( ) . toString ( ) + "str" + ( table . isTournament ( ) ? "str" : "str" ) ) ;
logger . error ( "str" + userId + "str" + chatId ) ;
private static final transient Logger logger = Logger . getLogger ( PlayerImpl . class ) ;
logger . warn ( "str" ) ;
logger . fatal ( "str" + getId ( ) , ex ) ;
if ( you . getHand ( ) . count ( filter , source . getSourceId ( ) , source . getControllerId ( ) , game ) > 0 ) {
private final String [ ] columnNames = new String [ ] { "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" } ;
turnIgnoringPlayersPair . getValue ( ) . add ( game . getPriorityPlayerId ( ) ) ;
Effect effect = new BoostTargetEffect ( 5 , 5 , Duration . EndOfTurn ) ;
. append ( "str" ) . toString ( ) ;
matchResult . append ( "str" ) . append ( match . getDraws ( ) ) ;
cubeCards . add ( new CardIdentity ( "str" , "str" ) ) ;
cubeCards . add ( new CardIdentity ( "str" , "str" ) ) ;
if ( ! playable . contains ( ability . getSourceId ( ) ) & & canPlay ( ability , available , game ) ) {
if ( controllers . containsKey ( tournamentId ) ) {
logger . debug ( userName + "str" + chatId + "str" + ( reason = = null ? "str" : reason . toString ( ) ) ) ;
if ( spell ! = null & & filter . match ( spell , getControllerId ( ) , game ) ) {
while ( true & & player . isInGame ( ) ) {
return controller . moveCardToHandWithInfo ( permanent , source . getSourceId ( ) , game , Zone . BATTLEFIELD ) ;
return controller . moveCardToHandWithInfo ( card , source . getSourceId ( ) , game , Zone . GRAVEYARD ) ;
card . moveToZone ( Zone . LIBRARY , source . getSourceId ( ) , game , false ) ;
if ( ! savedStates . contains ( bookmark - 1 ) ) {
import mage . filter . FilterCard ;
private static final FilterCard filterCard = new FilterCard ( "str" ) ;
private String joinList ( List < String > items ) {
return new ArrayList < > ( ) ;
ArrayList < CardType > list = new ArrayList < > ( ) ;
int turns = countersRemoved / 5 ;
for ( Permanent permanent : game . getBattlefield ( ) . getActivePermanents ( sourceControllerId , game ) ) {
this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD , new BoostAllEffect ( 1 , 0 , Duration . WhileOnBattlefield , filter , false ) ) ) ;
return new DrawCardSourceControllerEffect ( game . getBattlefield ( ) . count ( filter , source . getSourceId ( ) , source . getControllerId ( ) , game ) ) . apply ( game , source ) ;
if ( original ! = null & & ! original . getName ( ) . equals ( this . getName ( ) ) ) {
cubeCards . add ( new CardIdentity ( "str" , "str" ) ) ;
game . informPlayers ( new StringBuilder ( player . getName ( ) ) . append ( "str" ) . append ( groups . size ( ) ) . append ( groups . size ( ) = = 1 ? "str" : "str" ) . toString ( ) ) ;
cubeCards . add ( new CardIdentity ( "str" , "str" ) ) ;
cubeCards . add ( new CardIdentity ( "str" , "str" ) ) ;
cubeCards . add ( new CardIdentity ( "str" , "str" ) ) ;
cubeCards . add ( new CardIdentity ( "str" , "str" ) ) ;
cubeCards . add ( new CardIdentity ( "str" , "str" ) ) ;
cubeCards . add ( new CardIdentity ( "str" , "str" ) ) ;
cubeCards . add ( new CardIdentity ( "str" , "str" ) ) ;
import mage . game . events . DamagedEvent ;
if ( ability instanceof AlternativeSourceCosts & & ( ( AlternativeSourceCosts ) ability ) . isActivated ( ) ) {
String abilityText = "str" ;
private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent ( "str" ) ;
private static final long CARD_DB_VERSION = 27 ;
player . moveCardToExileWithInfo ( targetCard , null , null , source . getSourceId ( ) , game , Zone . GRAVEYARD ) ;
player . moveCardToExileWithInfo ( targetCard , null , null , source . getSourceId ( ) , game , Zone . HAND ) ;
player . moveCardToExileWithInfo ( targetCard , null , null , source . getSourceId ( ) , game , Zone . LIBRARY ) ;
"str" ) ) ;
private final Map < UUID , LookedAt > lookedAt = new HashMap < > ( ) ;
private final Map < UUID , Abilities < ActivatedAbility > > otherAbilities = new HashMap < > ( ) ;
private List < TriggeredAbility > triggered = new ArrayList < > ( ) ;
List < String > perms = new ArrayList < > ( ) ;
private final Map < UUID , MageCard > cards = new HashMap < > ( ) ;
public static final int MAX_IMAGES = 350 ;
boolean drawImage = showCards . size ( ) < = MAX_IMAGES ;
private final List < AlternativeCost2 > prowlCosts = new LinkedList < > ( ) ;
if ( card . getSubtype ( ) . size ( ) > 1 & & i < card . getSubtype ( ) . size ( ) ) {
filterEnchantment . add ( new ControllerIdPredicate ( attackedPlayer . getId ( ) ) ) ;
game . getBattlefield ( ) . getActivePermanents ( filter , playerId , sourceId , game ) ;
return controller . moveCardToExileWithInfo ( card , null , null , source . getSourceId ( ) , game , null ) ;
Set < String > targets = new HashSet < > ( ) ;
targetMap = new HashMap < > ( ) ;
handCards . put ( hand . getKey ( ) , CardsViewUtil . convertSimple ( hand . getValue ( ) , loadedCards ) ) ;
this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD , new GainAbilityAttachedEffect ( ability1 , AttachmentType . AURA , Duration . WhileOnBattlefield , "str" ) ) ) ;
Player player = game . getPlayer ( source . getControllerId ( ) ) ;
if ( target . canChoose ( source . getControllerId ( ) , player . getId ( ) , game ) & & you . chooseTarget ( outcome , player . getHand ( ) , target , source , game ) ) {
super ( PreferencesDialog . KEY_SIDEBOARD_SORT_BY , PreferencesDialog . KEY_SIDEBOARD_SORT_INDEX , PreferencesDialog . KEY_SIDEBOARD_SORT_ASCENDING , PreferencesDialog . KEY_SIDEBOARD_PILES_TOGGLE ) ;
super ( PreferencesDialog . KEY_DRAFT_SORT_BY , PreferencesDialog . KEY_DRAFT_SORT_INDEX , PreferencesDialog . KEY_DRAFT_SORT_ASCENDING , PreferencesDialog . KEY_DRAFT_PILES_TOGGLE ) ;
import mage . abilities . common . SpellCastControllerTriggeredAbility ;
Effect effect = new SearchLibraryPutOnLibraryEffect ( new TargetCardInLibrary ( new FilterCreatureCard ( ) ) , true , true ) ;
this . addAbility ( new SpellCastControllerTriggeredAbility ( effect , filter , true ) ) ;
this . addAbility ( new SpellCastControllerTriggeredAbility ( effect2 , filter2 , false ) ) ;
this . cardType = token . getCardType ( ) ;
if ( you . chooseUse ( Outcome . Detriment , "str" , game ) ) {
staticText = "str" ;
permanent = ( Permanent ) game . getLastKnownInformation ( source . getSourceId ( ) , Zone . BATTLEFIELD ) ;
if ( tapped & & ! game . getState ( ) . getContinuousEffects ( ) . asThough ( this . getId ( ) , AsThoughEffectType . BLOCK_TAPPED , game ) ) {
sourceCreature . damage ( permanent . getPower ( ) . getValue ( ) , permanent . getId ( ) , game , true , false ) ;
TargetPlayer auraTarget = new TargetPlayer ( true ) ;
TargetPlayer target = new TargetPlayer ( true ) ;
TargetPlayer target = new TargetPlayer ( true ) ;
this . getSpellAbility ( ) . addTarget ( new TargetPlayer ( true ) ) ;
TargetPlayer target = new TargetPlayer ( true ) ;
TargetPlayer target = new TargetPlayer ( true ) ;
TargetPlayer auraTarget = new TargetPlayer ( true ) ;
artifactcreatureorland . add ( Predicates . or (
untappedcreatureyoucontrol . add ( Predicates . not ( new TappedPredicate ( ) ) ) ;
invalid . put ( card . getName ( ) , "str" ) ;
you . drawCards ( 2 , game , event . getAppliedEffects ( ) ) ;
this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD , new BoostSourceEffect ( 1 , 0 , Duration . EndOfTurn ) , new SacrificeTargetCost ( new TargetControlledCreaturePermanent ( 1 , 1 , filter , true ) ) ) ) ;
for ( Ability ability : object . getAbilities ( ) ) {
this ( effect , true ) ;
DynamicValue sweepValue = new SweepNumber ( "str" , true ) ;
if ( ! filter . match ( card , game ) ) {
if ( amount > 0 & & player . chooseTarget ( Outcome . Tap , target , source , game ) ) {
if ( ! optional | | player . chooseUse ( outcome , "str" , game ) ) {
private static final int MIN_SOURCE = 3 ;
import mage . filter . common . FilterCreaturePermanent ;
this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD , new GainAbilityControlledEffect ( ability , Duration . WhileOnBattlefield , new FilterCreaturePermanent ( "str" , "str" ) ) ) ) ;
ability . addEffect ( new CreateTokenTargetEffect ( new HippoToken ( ) ) ) ;
Ability ability2 = new SimpleStaticAbility ( Zone . BATTLEFIELD , new BecomesCreatureAttachedEffect ( new OozeToken ( ) , "str" , Duration . WhileOnBattlefield ) ) ;
this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD , new BecomesCreatureAttachedEffect ( new TreefolkToken ( ) , "str" , Duration . WhileOnBattlefield ) ) ) ;
Ability ability2 = new SimpleStaticAbility ( Zone . BATTLEFIELD , new BecomesCreatureAttachedEffect ( new GiantToken ( ) , "str" , Duration . WhileOnBattlefield ) ) ;
Ability ability2 = new SimpleStaticAbility ( Zone . BATTLEFIELD , new BecomesCreatureAttachedEffect ( new GiantToken ( ) , "str" , Duration . Custom ) ) ;
permanent . damage ( multiTarget . getTargetAmount ( target ) , source . getSourceId ( ) , game , true , false ) ;
player . damage ( multiTarget . getTargetAmount ( target ) , source . getSourceId ( ) , game , false , true ) ;
import mage . filter . common . FilterControlledPermanent ;
private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "str" ) ;
conditionApplies = game . getBattlefield ( ) . count ( filter , source . getSourceId ( ) , source . getControllerId ( ) , game ) < this . count ;
conditionApplies = game . getBattlefield ( ) . count ( filter , source . getSourceId ( ) , source . getControllerId ( ) , game ) > this . count ;
conditionApplies = game . getBattlefield ( ) . count ( filter , source . getSourceId ( ) , source . getControllerId ( ) , game ) = = this . count ;
conditionApplies = game . getBattlefield ( ) . countAll ( filter , source . getControllerId ( ) , game ) < this . count ;
conditionApplies = game . getBattlefield ( ) . countAll ( filter , source . getControllerId ( ) , game ) > this . count ;
conditionApplies = game . getBattlefield ( ) . countAll ( filter , source . getControllerId ( ) , game ) = = this . count ;
super ( ownerId , 130 , "str" , Rarity . MYTHIC , new CardType [ ] { CardType . ENCHANTMENT } , "str" ) ;
this . staticText = "str" ;
private List < SpliceCardEffect > getApplicableSpliceCardEffects ( Game game , UUID playerId ) {
if ( ability . getControllerId ( ) . equals ( playerId ) & & ( ! ( ability instanceof StaticAbility ) | | ability . isInUseableZone ( game , null , false ) ) ) {
List < SpliceCardEffect > spliceEffects = getApplicableSpliceCardEffects ( game , abilityToModify . getControllerId ( ) ) ;
if ( ! varCosts . isEmpty ( ) ) {
this . addAbility ( new SimpleActivatedAbility ( Zone . BATTLEFIELD , new GainAbilitySourceEffect ( FirstStrikeAbility . getInstance ( ) , Duration . EndOfTurn ) , new ManaCostsImpl ( "str" ) ) ) ;
super ( Duration . EndOfGame , Layer . ControlChangingEffects_2 , SubLayer . NA , Outcome . GainControl ) ;
player . damage ( amount . calculate ( game , source ) , source . getSourceId ( ) , game , false , true ) ;
player . damage ( amount . calculate ( game , source ) , source . getSourceId ( ) , game , false , true ) ;
game . informPlayers ( new StringBuilder ( "str" ) . append ( targetPlayer . getName ( ) ) . append ( "str" ) . append ( card . getName ( ) ) . toString ( ) ) ;
if ( rEffects . get ( entry ) = = null | | consumedAbilitiesIds . size ( ) = = ( ( HashSet < Ability > ) rEffects . get ( entry ) ) . size ( ) ) {
super ( zone , effect , optional ) ;
game . informPlayers ( new StringBuilder ( getName ( ) ) . append ( "str" ) . append ( discarded ) . append ( discarded = = 1 ? "str" : "str" ) . append ( "str" ) . toString ( ) ) ;
import mage . abilities . common . EntersBattlefieldAbility ;
game . informPlayers ( new StringBuilder ( "str" ) . append ( card . getName ( ) ) . append ( "str" ) . append ( player . getName ( ) ) . toString ( ) ) ;
Player player = game . getPlayer ( targetId ) ;
for ( Permanent permanent : game . getBattlefield ( ) . getAllActivePermanents ( source . getControllerId ( ) ) ) {
Player controller = game . getPlayer ( source . getControllerId ( ) ) ;
if ( defender . isHuman ( ) ) {
card . putOntoBattlefield ( game , Zone . GRAVEYARD , source . getSourceId ( ) , source . getControllerId ( ) ) ;
if ( card . putOntoBattlefield ( game , Zone . GRAVEYARD , source . getSourceId ( ) , source . getControllerId ( ) ) ) {
FilterControlledPermanent filter = new FilterControlledPermanent ( "str" ) ;
Effect effect = new GainLifeEffect ( new TargetPermanentPowerPlusToughnessCount ( ) ) ;
class TargetPermanentPowerPlusToughnessCount implements DynamicValue {
return new TargetPermanentPowerPlusToughnessCount ( ) ;
private static final String ruleText = "str" ;
. append ( duration = = Duration . EndOfTurn ? "str" : "str" ) ;
staticText = "str" ;
sourcePermanent = ( Permanent ) game . getLastKnownInformation ( source . getFirstTarget ( ) , Zone . BATTLEFIELD ) ;
if ( t . startsWith ( "str" ) )
return Arrays . asList ( "str" ) ;
return Arrays . asList ( "str" ) ;
card . moveToZone ( Zone . HAND , source . getSourceId ( ) , game , false ) ;
sourcePermanent . addCounters ( CounterType . P1P1 . createInstance ( amount ) , game ) ;
if ( toCopyFromPermanent ! = null ) {
"str" , "str" , ChatMessage . MessageColor . ORANGE ) ;
Card card = game . getCard ( cardId ) ;
CardUtil . adjustCost ( ( Ability ) spellAbility , reduceCount ) ;
import mage . filter . FilterPermanent ;
private static final FilterPermanent filter = new FilterPermanent ( "str" ) ;
staticText = "str" ;
permanent . removeCounters ( CounterType . P1P1 . createInstance ( ) , game ) ;
this . staticText = "str" ;
this . getSpellAbility ( ) . addTarget ( new TargetCreatureOrPlayer ( true ) ) ;
ability . addTarget ( new TargetPlayer ( true ) ) ;
Watcher watcher = game . getState ( ) . getWatchers ( ) . get ( "str" , source . getControllerId ( ) ) ;
Assert . assertFalse ( "str" , moggFlunkies . isTapped ( ) ) ;
opponent . loseLife ( amountLifeGained , game ) ;
if ( ! card . getSubtype ( ) . contains ( "str" ) & & CardUtil . isPermanentCard ( card ) ) {
"str" ) ) ) ;
this . addAbility ( new SimpleActivatedAbility ( Constants . Zone . BATTLEFIELD , new AddContinuousEffectToGame ( new AlchemistsRefugeEffect ( ) ) , new CompositeCost ( new ManaCostsImpl ( "str" ) , new TapSourceCost ( ) , "str" ) ) ) ;
permanent . removeAllAbilities ( source . getSourceId ( ) , game ) ;
List < Permanent > permanents = game . getBattlefield ( ) . getActivePermanents ( source . getControllerId ( ) , game ) ;
private static final FilterPermanent filter = new FilterCreaturePermanent ( "str" ) ;
player . revealCards ( "str" , cards , game ) ;
card . moveToZone ( Zone . GRAVEYARD , source . getSourceId ( ) , game , false ) ;
this . getSpellAbility ( ) . addTarget ( new TargetCreatureOrPlayerAmount ( 2 ) ) ;
this . addAbility ( new ActivateOncePerTurnActivatedAbility ( Constants . Zone . BATTLEFIELD , new BoostSourceEffect ( 2 , 2 , Constants . Duration . EndOfTurn ) , new ManaCostsImpl ( "str" ) ) ) ;
import mage . filter . common . FilterControlledLandPermanent ;
private final static FilterControlledLandPermanent filter = new FilterControlledLandPermanent ( "str" ) ;
Ability ability = new DiesTriggeredAbility ( new PutLibraryIntoGraveTargetEffect ( 5 ) ) ;
super ( ownerId , 223 , "str" , Rarity . COMMON , new CardType [ ] { CardType . INSTANT } , "str" ) ;
super ( ownerId , 71 , "str" , Rarity . MYTHIC , new CardType [ ] { CardType . CREATURE } , "str" ) ;
super ( ownerId , 75 , "str" , Rarity . RARE , new CardType [ ] { CardType . CREATURE } , "str" ) ;
super ( ownerId , 83 , "str" , Rarity . RARE , new CardType [ ] { CardType . SORCERY } , "str" ) ;
staticText = "str" ;
super ( ownerId , 12 , "str" , Rarity . RARE , new CardType [ ] { CardType . CREATURE } , "str" ) ;
} else if ( count < 6 & & type = = 1 ) {
super ( new TargetCardInHand ( new FilterCard ( ) ) , false ) ;
for ( Permanent creature : game . getBattlefield ( ) . getActivePermanents ( filter , source . getControllerId ( ) , source . getSourceId ( ) , game ) ) {
FilterCard filter = new FilterCard ( "str" ) ;
import mage . target . common . TargetCreaturePermanent ;
TargetPermanent auraTarget = new TargetCreaturePermanent ( ) ;
permanent . addCounters ( newCounter , game ) ;
new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 0 ) , new MultikickerCount ( ) , true ) ,
staticText = "str" ;
if ( attacker ! = null & & attacker . canAttack ( game ) & & attacker . getControllerId ( ) . equals ( playerId ) ) {
if ( blocker ! = null & & group ! = null & & group . canBlock ( blocker , game ) & & blocker . getControllerId ( ) . equals ( playerId ) ) {
if ( attackerValue > blockerValue
private String currentSet = "str" ;
private static final FilterLandPermanent filter = new FilterLandPermanent ( "str" ) ;
if ( cv . getId ( ) . equals ( entry . getValue ( ) . getId ( ) ) ) {
String key1 = cv . getName ( ) + cv . getExpansionSetCode ( ) + cv . getCardNumber ( ) ;
String key2 = cardView . getName ( ) + cardView . getExpansionSetCode ( ) + cardView . getCardNumber ( ) ;
super ( ownerId , 198 , "str" , Rarity . COMMON , new CardType [ ] { CardType . CREATURE } , "str" ) ;
super ( ownerId , 158 , "str" , Rarity . UNCOMMON , new CardType [ ] { CardType . CREATURE } , "str" ) ;
super ( ownerId , 178 , "str" , Rarity . MYTHIC , new CardType [ ] { CardType . CREATURE } , "str" ) ;
this . expansionSetCode = "str" ;
this . expansionSetCode = "str" ;
this . expansionSetCode = "str" ;
this . expansionSetCode = "str" ;
this . expansionSetCode = "str" ;
if ( player . choose ( this . outcome , target , source . getSourceId ( ) , game ) ) {
if ( player . choose ( this . outcome , target , source . getSourceId ( ) , game ) ) {
if ( player ! = null & & player . choose ( Outcome . ReturnToHand , target , source . getSourceId ( ) , game ) ) {
if ( player . choose ( outcome , target , source . getSourceId ( ) , game ) ) {
playerFilter . add ( Predicates . or ( playerPredicates ) ) ;
TargetLandPermanent target = new TargetLandPermanent ( 0 , amount , new FilterLandPermanent ( ) , true ) ;
this . addAbility ( new SimpleStaticAbility ( Constants . Zone . BATTLEFIELD , new ConditionalContinousEffect ( new BoostSourceEffect ( 4 , 4 , Constants . Duration . WhileOnBattlefield ) , new CardsInOpponentGraveCondition ( 10 ) , "str" ) ) ) ;
if ( zone ! = Zone . BATTLEFIELD & & game . getContinuousEffects ( ) . asThough ( object . getId ( ) , AsThoughEffectType . CAST , game ) ) {
super ( ownerId , 103 , "str" , Rarity . RARE , new CardType [ ] { CardType . CREATURE } , "str" ) ;
if ( set . getReleaseDate ( ) . after ( innistradBlockDate ) & & set . getReleaseDate ( ) . before ( m13Date ) ) {
castSpell ( 1 , Constants . PhaseStep . PRECOMBAT_MAIN , playerA , "str" , "str" ) ;
Ability ability0 = new EntersBattlefieldAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 1 ) ) ) ;
if ( ! f . exists ( ) & & f . getParentFile ( ) ! = null ) {
private static final FileFilter anyFileFilter = new FileFilter ( ) {
if ( sourcePermanent ! = null & & permanent ! = null ) {
if ( ruling ! = null & & ! ruling . replace ( "str" , "str" ) . trim ( ) . isEmpty ( ) ) {
logger . fatal ( "str" + ex . getMessage ( ) , ex ) ;
if ( player ! = null & & player . choose ( Outcome . BoostCreature , target , card . getId ( ) , game ) ) {
addCard ( Constants . Zone . BATTLEFIELD , playerB , "str" , 1 ) ;
super ( "str" , "str" ) ;
this . cardNumber = 216 ;
this . cardNumber = 214 ;
targetPlayer . discard ( card , source , game ) ;
private static final String [ ] symbols = { "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" } ;
FilterPermanent filter = new FilterPermanent ( "str" ) ;
filterWhiteSpell . setColor ( ObjectColor . WHITE ) ;
private static final FilterControlledPermanent filter = new FilterControlledPermanent ( "str" ) ;
filterWhiteSpell . setColor ( ObjectColor . WHITE ) ;
setDefaultCloseOperation ( WindowConstants . DO_NOTHING_ON_CLOSE ) ;
this . getLevels ( ) . add ( new LevelAbility ( 5 , - 1 , levelAbilities , 5 , 5 ) ) ;
if ( node . stateValue = = state & & node . action ! = null ) {
this . cardNumber = 246 ;
if ( player . chooseUse ( Outcome . PutLandInPlay , "str" , game ) ) {
card . putOntoBattlefield ( game , Zone . HAND , source . getId ( ) , player . getId ( ) ) ;
card . putOntoBattlefield ( game , Zone . HAND , source . getId ( ) , permanent . getControllerId ( ) ) ;
targets = threats ( playerId , new FilterCreaturePermanent ( ) , game ) ;
targets = threats ( opponentId , new FilterCreaturePermanent ( ) , game ) ;
this . getSpellAbility ( ) . addEffect ( new DestroyAllEffect ( new FilterCreaturePermanent ( ) ) ) ;
return permanent . canBeTargetedBy ( game . getObject ( source . getSourceId ( ) ) , controllerId , game ) & & filter . match ( permanent , source . getSourceId ( ) , controllerId , game ) ;
if ( permanent . canBeTargetedBy ( targetSource , sourceControllerId , game ) & & filter . match ( permanent , sourceId , sourceControllerId , game ) ) {
if ( permanent . canBeTargetedBy ( targetSource , sourceControllerId , game ) & & filter . match ( permanent , sourceId , sourceControllerId , game ) ) {
return permanent . canBeTargetedBy ( targetSource , source . getControllerId ( ) , game ) & & filter . match ( permanent , source . getSourceId ( ) , source . getControllerId ( ) , game ) ;
if ( permanent . canBeTargetedBy ( targetSource , sourceControllerId , game ) & & filter . match ( permanent , sourceId , sourceControllerId , game ) ) {
if ( permanent . canBeTargetedBy ( targetSource , sourceControllerId , game ) & & filter . match ( permanent , sourceId , sourceControllerId , game ) ) {
if ( permanent . canBeTargetedBy ( targetSource , sourceControllerId , game ) & & filter . match ( permanent ) ) {
if ( permanent . canBeTargetedBy ( targetSource , sourceControllerId , game ) & & filter . match ( permanent ) ) {
return permanent . canBeTargetedBy ( targetSource , source . getControllerId ( ) , game ) & & filter . match ( permanent ) ;
public boolean canBeTargetedBy ( MageObject source , UUID controllerId , Game game ) ;
public boolean canBeTargetedBy ( MageObject source , UUID sourceControllerId , Game game ) {
if ( ! targets . containsKey ( permanent . getId ( ) ) & & permanent . canBeTargetedBy ( targetSource , sourceControllerId , game ) ) {
if ( ! targets . containsKey ( permanent . getId ( ) ) & & permanent . canBeTargetedBy ( targetSource , sourceControllerId , game ) ) {
return permanent . canBeTargetedBy ( targetSource , source . getControllerId ( ) , game ) & & filter . match ( permanent , source . getSourceId ( ) , source . getControllerId ( ) , game ) ;
if ( permanent . canBeTargetedBy ( targetSource , sourceControllerId , game ) & & filter . match ( permanent , sourceId , sourceControllerId , game ) ) {
if ( permanent . canBeTargetedBy ( targetSource , sourceControllerId , game ) & & filter . match ( permanent , sourceId , sourceControllerId , game ) ) {
if ( effect . filter ! = null )
this . cardSelector . loadSideboard ( new ArrayList < Card > ( deck . getSideboard ( ) ) , this . bigCard ) ;
cardSelector . loadSideboard ( new ArrayList < Card > ( deck . getSideboard ( ) ) , getBigCard ( ) ) ;
cardSelector . loadSideboard ( new ArrayList < Card > ( deck . getSideboard ( ) ) , this . bigCard ) ;
private boolean limited = false ;
public void loadSideboard ( List < Card > sideboard , BigCard bigCard ) {
this . limited = true ;
if ( limited ) {
if ( limited )
if ( limited )
if ( perm . removeAttachment ( attachment . getId ( ) , this ) )
private String currentSet = "str" ;
this . addAbility ( new SimpleStaticAbility ( Zone . BATTLEFIELD , new StromkirkEffect ( ) ) ) ;
return new CreepyDollEffect ( this ) ;
if ( ( ( DamagedCreatureEvent ) event ) . isCombatDamage ( ) & & event . getSourceId ( ) . equals ( sourceId ) ) {
this . addAbility ( new BlocksOrBecomesBlockedTriggeredAbility ( new DamageTargetEffect ( 1 , true , "str" ) , false ) ) ;
super ( ownerId , 232 , "str" , Rarity . COMMON , new CardType [ ] { CardType . ARTIFACT } , "str" ) ;
if ( p = = null | | ! p . equals ( Proxy . NO_PROXY ) ) {
private static FilterCreaturePermanent filter = new FilterCreaturePermanent ( "str" ) ;
if ( permanent ! = null & & permanent . getCardType ( ) . contains ( CardType . CREATURE ) & & permanent . getControllerId ( ) . equals ( this . getControllerId ( ) ) & & permanent . getPower ( ) . getValue ( ) > 2 ) {
import mage . abilities . common . EntersBattlefieldAbility ;
this . addAbility ( new EntersBattlefieldAbility ( new AddCountersSourceEffect ( CounterType . P1P1 . createInstance ( 5 ) ) ) ) ;
import mage . target . TargetPlayer ;
ability . addTarget ( new TargetPlayer ( ) ) ;
super ( "str" , "str" , "str" , "str" , new GregorianCalendar ( 2001 , 5 , 1 ) . getTime ( ) , Constants . SetType . EXPANSION ) ;
protected ComparisonScope scopeCardType = ComparisonScope . Any ;
protected ComparisonScope scopeSupertype = ComparisonScope . Any ;
public boolean canBlock ( Permanent attacker , Permanent blocker , Ability source , Game game ) {
if ( table . getMatch ( ) ! = null & & table . getMatch ( ) . getGame ( ) ! = null )
if ( attached ! = null & & attached . getCardType ( ) . contains ( CardType . ENCHANTMENT ) ) {
private Ability ability = new BloodthirstAbility ( 3 ) ;
super ( "str" , "str" ) ;
if ( costs . canPay ( sourceId , controllerId , game ) & & getTargets ( ) . canChoose ( this . getId ( ) , playerId , game ) ) {
if ( ! canChoose ( source . getId ( ) , playerId , game ) )
return permanent . canBeTargetedBy ( game . getObject ( source . getId ( ) ) ) & & filter . match ( permanent , source . getSourceId ( ) , controllerId , game ) ;
super ( ownerId , 196 , "str" , Rarity . RARE , new CardType [ ] { CardType . ARTIFACT } , "str" ) ;
int amount = source . getManaCostsToPay ( ) . getVariableCosts ( ) . get ( 0 ) . getAmount ( ) ;
this . expansionSetCode = "str" ;
super ( ownerId , 165 , "str" , Rarity . UNCOMMON , new CardType [ ] { CardType . CREATURE } , "str" ) ;
super ( ownerId , 144 , "str" , Rarity . RARE , new CardType [ ] { CardType . LAND } , null ) ;
super ( ownerId , 92 , "str" , Rarity . UNCOMMON , new CardType [ ] { CardType . INSTANT } , "str" ) ;
super ( ownerId , 260 , "str" , Rarity . RARE , new CardType [ ] { CardType . ARTIFACT , CardType . CREATURE } , "str" ) ;
super ( ownerId , 23 , "str" , Rarity . UNCOMMON , new CardType [ ] { CardType . SORCERY } , "str" ) ;
super ( Constants . Zone . BATTLEFIELD , new MimicVatEffect ( ) , true ) ;
super ( Constants . Zone . BATTLEFIELD , new NimDeathmantleEffect ( ) , true ) ;
this . subtype . add ( "str" ) ;
int rate = ( int ) ( ( 15 - stdRate + 1 ) * ( 2 / 3f ) * 100 + 500 ) ;
private static final String text = "str" ;
staticText = "str" ;
Ability ability = new EntersBattlefieldAbility ( new CopyEffect ( ) , "str" ) ;
this . addAbility ( new EntersBattlefieldAbility ( new TapSourceUnlessPaysEffect ( new PayLifeCost ( 2 ) ) , "str" ) ) ;
this . addAbility ( new EntersBattlefieldAbility ( new TapSourceUnlessPaysEffect ( new PayLifeCost ( 2 ) ) , "str" ) ) ;
this . addAbility ( new EntersBattlefieldAbility ( new SigilOfDistinctionEffect ( ) , "str" ) ) ;
this . addAbility ( new EntersBattlefieldAbility ( new TapSourceUnlessPaysEffect ( new PayLifeCost ( 2 ) ) , "str" ) ) ;
this . addAbility ( new EntersBattlefieldAbility ( new AddCountersSourceEffect ( CounterType . M1M1 . createInstance ( 2 ) ) , "str" ) ) ;
private static final String abilityText = "str" ;
this . addAbility ( new EntersBattlefieldAbility ( new AddCountersSourceEffect ( new AddCountersSourceEffect ( CounterType . CHARGE . createInstance ( 6 ) ) ) , "str" ) ) ;
this . addAbility ( new EntersBattlefieldAbility ( new TapSourceUnlessPaysEffect ( new PayLifeCost ( 2 ) ) , "str" ) ) ;
this . addAbility ( new EntersBattlefieldAbility ( new AddCountersSourceEffect ( CounterType . M1M1 . createInstance ( 5 ) ) , "str" ) ) ;
Ability ability = new EntersBattlefieldAbility ( new PhyrexianMetamorphEffect ( ) , "str" ) ;
super ( ownerId , 92 , "str" , Rarity . COMMON , new CardType [ ] { CardType . CREATURE } , "str" ) ;
super ( ownerId , 141 , "str" , Rarity . UNCOMMON , new CardType [ ] { CardType . CREATURE } , "str" ) ;
super ( ownerId , 160 , "str" , Rarity . COMMON , new CardType [ ] { CardType . CREATURE } , "str" ) ;
super ( ownerId , 129 , "str" , Rarity . UNCOMMON , new CardType [ ] { CardType . CREATURE } , "str" ) ;
super ( ownerId , 90 , "str" , Rarity . COMMON , new CardType [ ] { CardType . CREATURE } , "str" ) ;
super ( ownerId , 142 , "str" , Rarity . COMMON , new CardType [ ] { CardType . CREATURE } , "str" ) ;
this . supertype . add ( "str" ) ;
this . supertype . add ( "str" ) ;
this . supertype . add ( "str" ) ;
this . supertype . add ( "str" ) ;
this . supertype . add ( "str" ) ;
this . supertype . add ( "str" ) ;
this . supertype . add ( "str" ) ;
this . supertype . add ( "str" ) ;
this . supertype . add ( "str" ) ;
protected ComparisonScope scopeColor = ComparisonScope . Any ;
String state = ( String ) tableModel . getValueAt ( modelRow , 6 ) ;
sb . append ( "str" ) ;
sb . append ( "str" ) . append ( name ) . append ( "str" ) ;
effect . setStaticText ( "str" ) ;
public String getDynamicText ( Ability source ) {
ability = new BeginningOfUpkeepTriggeredAbility ( new SacrificeEffect ( new FilterCreaturePermanent ( ) , 1 , "str" ) , Constants . TargetController . OPPONENT , false ) ;
if ( ( event . getType ( ) = = GameEvent . EventType . DECLARE_ATTACKER | | event . getType ( ) = = GameEvent . EventType . DECLARE_BLOCKER ) & & event . getSourceId ( ) . equals ( enchantment . getAttachedTo ( ) ) ) {
this . toughness = new MageInt ( 2 ) ;
if ( event . getType ( ) = = GameEvent . EventType . DECLARE_ATTACKER & & event . getTargetId ( ) . equals ( source . getControllerId ( ) ) ) {
this . cardNumber = 133 ;
new LoseLifeTargetEffect ( 1 ) ,
ability . addEffect ( new GainLifeEffect ( 1 ) ) ;
this . counter = counter . copy ( ) ;
this . counter = effect . counter . copy ( ) ;
String path = packageName . replace ( "str" , "str" ) ;
String filePathElement = "str" ;
String clazz = jarEntry . getName ( ) . replaceAll ( "str" , "str" ) . replace ( "str" , "str" ) ;
return super . getRule ( false ) ;
String path = packageName . replace ( "str" , File . separator ) ;
if ( ( ( TargetPermanent ) target ) . canTarget ( playerId , response . getUUID ( ) , source , game ) ) {
TargetCardInLibrary target = new TargetCardInLibrary ( 0 , 3 , filter ) ;
this . toughness = new MageInt ( 2 ) ;
if ( logger . isDebugEnabled ( ) & & ( combat = = null | | combat . getGroups ( ) . isEmpty ( ) ) )
if ( damageEvent . isCombatDamage ( ) & & p ! = null & & p . getId ( ) . equals ( this . getSourceId ( ) ) ) {
this . addAbility ( new EquipAbility ( Constants . Outcome . AddAbility , new GenericManaCost ( 1 ) ) ) ;
public BufferedImage getSicknessImage ( ) {
private static BufferedImage imageSickness = null ;
private BufferedImage image ;
public ImagePanel ( BufferedImage image ) {
public ImagePanel ( BufferedImage image , int style ) {
BufferedImage sickness = ImageManagerImpl . getInstance ( ) . getSicknessImage ( ) ;
public String getDynamicText ( Ability source ) {
if ( event . getType ( ) = = GameEvent . EventType . SPELL_CAST & & event . getPlayerId ( ) . equals ( this . getControllerId ( ) ) ) {
filter . getCardType ( ) . add ( CardType . ENCHANTMENT ) ;
super ( Constants . Zone . BATTLEFIELD , new GainLifeEffect ( 3 ) ) ;
rules . add ( ability . getRule ( ) ) ;
Card card = player . getGraveyard ( ) . get ( targetId , game ) ;
this . addAbility ( new EntersBattlefieldAbility ( new TapSourceUnlessPaysEffect ( new PayLifeCost ( 2 ) ) , "str" ) ) ;
this . addAbility ( new EntersBattlefieldAbility ( new TapSourceUnlessPaysEffect ( new PayLifeCost ( 2 ) ) , "str" ) ) ;
this . addAbility ( new EntersBattlefieldAbility ( new TapSourceUnlessPaysEffect ( new PayLifeCost ( 2 ) ) , "str" ) ) ;
this . addAbility ( new EntersBattlefieldAbility ( new TapSourceUnlessPaysEffect ( new PayLifeCost ( 2 ) ) , "str" ) ) ;
this . addAbility ( new EntersBattlefieldAbility ( new TapSourceUnlessPaysEffect ( new PayLifeCost ( 2 ) ) , "str" ) ) ;
this . addAbility ( new EntersBattlefieldAbility ( new TapSourceUnlessPaysEffect ( new PayLifeCost ( 2 ) ) , "str" ) ) ;
this . addAbility ( new EntersBattlefieldAbility ( new TapSourceUnlessPaysEffect ( new PayLifeCost ( 2 ) ) , "str" ) ) ;
this . addAbility ( new EntersBattlefieldAbility ( new TapSourceUnlessPaysEffect ( new PayLifeCost ( 2 ) ) , "str" ) ) ;
this . addAbility ( new EntersBattlefieldAbility ( new TapSourceUnlessPaysEffect ( new PayLifeCost ( 2 ) ) , "str" ) ) ;
this . addAbility ( new EntersBattlefieldAbility ( new TapSourceUnlessPaysEffect ( new PayLifeCost ( 2 ) ) , "str" ) ) ;
return "str" + baseEffects . getText ( source ) ;
return "str" + text ;
this . expansionSetCode = "str" ;
this . expansionSetCode = "str" ;
if ( permanent . getCardType ( ) . contains ( CardType . LAND ) & & permanent . getControllerId ( ) . equals ( this . controllerId ) ) {
int value = permanent . isTapped ( ) ? 4 : 5 ;
value + = ability . getEffects ( ) . size ( ) ;
target . addTarget ( response . getUUID ( ) , source , game ) ;
if ( attachment ! = null & & ! ( attachment . getSubtype ( ) . contains ( "str" ) | |
super ( ownerId , 196 , "str" , Rarity . COMMON , new CardType [ ] { CardType . SORCERY } , "str" ) ;
this . color . setRed ( true ) ;
if ( event . getType ( ) = = EventType . BEGINNING_PHASE_PRE & & game . getActivePlayerId ( ) . equals ( controllerId ) )
if ( ratioBoosterMythic > 0 & & rnd . nextInt ( ratioBoosterMythic ) = = 1 ) {
if ( event . getType ( ) = = EventType . BEGINNING_PHASE_PRE )
if ( ! cardType . contains ( CardType . CREATURE ) | | ! hasSummoningSickness ( ) ) {
return ! ( this . controlledFromStartOfTurn | | this . abilities . containsKey ( HasteAbility . getInstance ( ) . getId ( ) ) ) ;
if ( hasSummoningSickness ( ) )
super ( ownerId , 69 , "str" , Rarity . COMMON , new CardType [ ] { CardType . INSTANT } , "str" ) ;
super ( ownerId , 22 , "str" , Rarity . COMMON , new CardType [ ] { CardType . INSTANT } , "str" ) ;
return "str" + this . getSource ( ) . getTargets ( ) . get ( 0 ) . getTargetName ( ) + "str" ;
mStatusBarHeight = getStatusBarHeight ( ) ;
private static final String WRITE_WITHOUT_RESPONSE = "str" ;
} else if ( action . equals ( WRITE_WITHOUT_RESPONSE ) ) {
. executed ( during ( 24 * 60 , TimeDivision . minutes ) )
} catch ( @SuppressWarnings ( "str" ) ParseException e ) {
public static TypeComparators comparatorsByTypeOf ( AbstractIterableAssert < ? , ? , ? , ? > assertion ) {
public static TypeComparators comparatorForElementFieldsWithTypeOf ( AbstractIterableAssert < ? , ? , ? , ? > assertion ) {
public static Map < ? , ? > comparatorForElementFieldsWithNamesOf ( AbstractIterableAssert < ? , ? , ? , ? > assertion ) {
private static final String DELIMITER = String . format ( "str" ) ;
"str" + describe ( zipSatisfyErrors ) ,
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
thrown . expectIndexOutOfBoundsException ( "str" ) ;
String message = String . format ( "str" , size - 1 , index ) ;
return char1 . compareTo ( char2 ) ;
return short1 . compareTo ( short2 ) ;
"str" ) ) ;
default AbstractBigIntegerAssert < ? > assertThat ( BigInteger actual ) {
public void isInstanceOf_should_check_the_original_stream_without_consuming_it ( ) {
public void isInstanceOfAny_should_check_the_original_stream_without_consuming_it ( ) {
private ErrorMessageFactory factoryWithNoOccurrence ;
factoryWithNoOccurrence = shouldContainOnlyOnce ( "str" , "str" , 0 ) ;
String message = factoryWithNoOccurrence . create ( new TestDescription ( "str" ) , new StandardRepresentation ( ) ) ;
maps . assertHasEntrySatisfying ( someInfo ( ) , ( Map < Integer , ? > ) null , 8 , o - > assertThat ( o ) . isNotNull ( ) ) ;
iterables . < String > assertAllSatisfy ( someInfo ( ) , actual , s - > {
public static void failBecauseExceptionWasNotThrown ( Class < ? extends Throwable > exceptionClass ) {
super ( "str" , actual , comparisonStrategy ) ;
super ( "str" , actual , comparisonStrategy ) ;
super ( "str" , actual , comparisonStrategy ) ;
super ( "str" , actual , expected , found , comparisonStrategy ) ;
super ( "str" , actual , expected , comparisonStrategy ) ;
ErrorMessageFactory factory = shouldBeSortedAccordingToGivenComparator ( 1 , array ( "str" , "str" , "str" ) ,
super ( "str" , comparisonStrategy , actual , values , unexpected ) ;
super ( "str" , actual , expected , notFound , comparisonStrategy ) ;
super ( "str" , expected , actual , point , offset . value ) ;
assertEquals ( "str" , message ) ;
assertEquals ( "str" , message ) ;
super ( "str" , expected , actual , offset . value ) ;
import static org . fest . util . Collections . duplicatesFrom ;
if ( duplicates . isEmpty ( ) ) return ;
if ( duplicates . isEmpty ( ) ) return ;
private Longs longs ;
longs = mock ( Longs . class ) ;
assertions . longs = longs ;
verify ( longs ) . assertNotEqual ( assertions . info , assertions . actual , 8 ) ;
private Shorts shorts ;
shorts = mock ( Shorts . class ) ;
assertions . shorts = shorts ;
verify ( shorts ) . assertIsPositive ( assertions . info , assertions . actual ) ;
private Shorts shorts ;
shorts = mock ( Shorts . class ) ;
assertions . shorts = shorts ;
verify ( shorts ) . assertNotEqual ( assertions . info , assertions . actual , ( short ) 8 ) ;
private Shorts shorts ;
shorts = mock ( Shorts . class ) ;
assertions . shorts = shorts ;
verify ( shorts ) . assertIsZero ( assertions . info , assertions . actual ) ;
private Shorts shorts ;
shorts = mock ( Shorts . class ) ;
assertions . shorts = shorts ;
verify ( shorts ) . assertIsNotZero ( assertions . info , assertions . actual ) ;
private Longs longs ;
longs = mock ( Longs . class ) ;
assertions . longs = longs ;
verify ( longs ) . assertEqual ( assertions . info , assertions . actual , 8 ) ;
private Longs longs ;
longs = mock ( Longs . class ) ;
assertions . longs = longs ;
verify ( longs ) . assertIsNegative ( assertions . info , assertions . actual ) ;
private Shorts shorts ;
shorts = mock ( Shorts . class ) ;
assertions . shorts = shorts ;
verify ( shorts ) . assertIsNegative ( assertions . info , assertions . actual ) ;
private Shorts shorts ;
shorts = mock ( Shorts . class ) ;
assertions . shorts = shorts ;
verify ( shorts ) . assertEqual ( assertions . info , assertions . actual , ( short ) 8 ) ;
private Longs longs ;
longs = mock ( Longs . class ) ;
assertions . longs = longs ;
verify ( longs ) . assertIsZero ( assertions . info , assertions . actual ) ;
private Longs longs ;
longs = mock ( Longs . class ) ;
assertions . longs = longs ;
verify ( longs ) . assertIsPositive ( assertions . info , assertions . actual ) ;
private Longs longs ;
longs = mock ( Longs . class ) ;
assertions . longs = longs ;
verify ( longs ) . assertIsNotZero ( assertions . info , assertions . actual ) ;
private static final Logger logger =
return instrument ( origBytes , loader ) ;
String typename = cls . getName ( ) . replace ( "str" , "str" ) ;
newLocal ( "str" , beginScopeLabel , endScopeLabel ) ;
newLocal ( "str" , beginScopeLabel , endScopeLabel ) ;
notifyItemInserted ( items . size ( ) - 1 ) ;
if ( messages . isEmpty ( ) ) return ;
text . setText ( isSelected ( ) ? "str" : message . getText ( ) ) ;
text . setText ( isSelected ( ) ? "str" : message . getText ( ) ) ;
if ( new File ( field . getText ( ) ) . canExecute ( ) | | new File ( myProject . getBasePath ( ) , field . getText ( ) ) . exists ( ) ) return ;
if ( new File ( field . getText ( ) ) . exists ( ) | | new File ( myProject . getBasePath ( ) , field . getText ( ) ) . exists ( ) ) return ;
return ( ( PsiWhiteSpace ) ( createFileFromText ( project , "str" ) ) . getFirstChild ( ) ) ;
private static final String REQUIRED_PARSER_HELPER_VERSION = "str" ;
parsePatTopType ( builder , ( ( PInfixApp ) patTopType ) . p2 , comments ) ;
infixDecl . intMaybe = jsonDeserializationContext . deserialize ( stuff . get ( 2 ) , Integer . class ) ;
throw new RuntimeException ( "str" + patTopType . toString ( ) ) ;
if ( ( stuff = objType . getAsJsonArray ( "str" ) ) ! = null ) {
} else if ( ( stuff = objType . getAsJsonArray ( "str" ) ) ! = null ) {
} else if ( ( stuff = objType . getAsJsonArray ( "str" ) ) ! = null ) {
} else if ( ( stuff = objType . getAsJsonArray ( "str" ) ) ! = null ) {
public String message ( ) default "str" ;
return ( new Random ( SmsSenderUtil . getCurrentTime ( ) ) ) . nextInt ( 900000 ) + 100000 ;
} catch ( Throwable e ) {
} catch ( Throwable e ) {
} catch ( Throwable e ) {
return Integer . compare ( o1 . getObjectNumber ( ) . getNumber ( ) , o2 . getObjectNumber ( ) . getNumber ( ) ) ;
return Integer . compare ( o1 . pageIndex , o2 . pageIndex ) ;
shadingDict . put ( "str" , new PDFReference ( "str" ) ) ;
patternDict . put ( "str" , new PDFReference ( "str" ) ) ;
colorSpaceDict . put ( "str" , new PDFReference ( "str" ) ) ;
adjustIPD ( blocks [ y ] [ gridUnits . length - 1 ] , - borderWidth ) ;
} else if ( ch > = 0x2066 ) {
documentHandler . getContext ( ) . setPageNumber ( index + 1 ) ;
int o2Hash = System . identityHashCode ( o2 ) ;
reader . skip ( skips * 2L ) ;
reader . skip ( skips * 4L ) ;
private static final String ATT_DESC = "str" ;
String name = lastAttributes . getValue ( "str" ) ;
if ( b0 = = 19 ) {
if ( MimeConstants . MIME_AFP_IOCA_FS45 . equals ( imageObjectInfo . getMimeType ( ) ) ) {
if ( imageObjectInfo . getBitsPerPixel ( ) = = 32 ) {
int spaceDiff = font . getCharWidth ( CharUtilities . SPACE ) - font . getCharWidth ( orgChar ) ;
return ( minLevel = = maxLevel ) & & ( minLevel > 0 ) & & ( ( minLevel & 1 ) ! = 0 ) ;
protected boolean started ;
protected ResourceGroup resourceGroup ;
private ImageSizeParameter imageSizeParameter ;
private IDEStructureParameter ideStructureParameter ;
protected FOUserAgent userAgent ;
protected int currentBPPosition ;
protected int currentIPPosition ;
protected int containingBPPosition ;
protected int containingIPPosition ;
private GraphicsObject graphicsObj ;
protected TextHandler customTextHandler ;
private AFPResourceManager resourceManager ;
private AFPResourceInfo resourceInfo ;
private AFPPaintingState paintingState ;
protected String name ;
private Font spaceFont ;
private int nextStart ;
private boolean hasChanged ;
private AlignmentContext alignmentContext ;
private int lineStartBAP ;
private int lineEndBAP ;
private String id ;
private PresentationTextData currentPresentationTextData ;
private List presentationTextDataList ;
private static Map < String , Color > colorMap ;
private int [ ] paddingCorresponding ;
private int [ ] borderWidthCorresponding ;
private Map < String , List < Resolvable > > unresolved ;
private boolean fakeNonEmpty ;
private boolean isCachedValue ;
private int numberConsumed ;
private int currentTokenStartIndex ;
private int exprIndex ;
private Block separator ;
private boolean kerning ;
private Attributes attr ;
private OutputStream out ;
private int value ;
private Typeface charSet ;
private int scale ;
protected int startNumber ;
private boolean sourceTransparency ;
protected int [ ] coords ;
protected boolean relative ;
private ImageSegment imageSegment ;
protected String defaultValue ;
protected boolean contextDep ;
protected boolean setByShorthand ;
private PropertyMaker [ ] shorthands ;
private List headerLastRow ;
private String pageNumberString ;
private Map < String , List < PageViewport > > pendingResolved ;
private static CollapsingBorderModel collapse ;
private int overflow ;
protected GraphicsNode origGraphicsNode ;
private boolean clip ;
private int ipd ;
private int ignoreAtStart ;
private int ignoreAtEnd ;
private boolean isOTFFile ;
private BookmarkTree bookmarkTree ;
private boolean pageSequenceFound ;
private FOEventHandler foEventHandler ;
private Block curBlockArea ;
private boolean safeSetPageDevice ;
private boolean autoRotateLandscape ;
private boolean optimizeResources ;
private boolean inMarker ;
private boolean blockItemFound ;
private boolean isClosed ;
private Flow mainFlow ;
private float characterSpacing ;
private boolean allTextAsBitmaps ;
private boolean useColorCanvas ;
private boolean disabledPJL ;
private Font font ;
private int contentAreaIPD ;
protected TransformerFactory transFactory ;
protected FopFactory fopFactory ;
protected Font overrideFont ;
private List objects ;
private RtfBookmark mBookmark ;
private boolean isRelative ;
private boolean complete ;
private Document document ;
private PageGroup currentPageGroup ;
private PageObject currentPageObject ;
private Overlay currentOverlay ;
private AbstractPageObject currentPage ;
protected String shadingName ;
protected PDFDeviceColorSpace colorSpace ;
protected List background ;
protected List bBox ;
protected boolean antiAlias ;
protected List domain ;
protected List matrix ;
protected PDFFunction function ;
protected List coords ;
protected List extend ;
protected int bitsPerCoordinate ;
protected int bitsPerFlag ;
protected List decode ;
protected int bitsPerComponent ;
protected int verticesPerRow ;
protected ObjectEnvironmentGroup objectEnvironmentGroup ;
protected URL url ;
protected boolean perCentH ;
protected boolean perCentW ;
protected boolean scaleUniform ;
private byte [ ] imagedata ;
private byte flags ;
protected Font overrideFont ;
protected boolean readBinary ;
private boolean foundUnexpected ;
private int level ;
protected int binaryLength ;
private static RtfColorTable instance ;
private Hashtable colorIndex ;
private Vector colorTable ;
private Hashtable namedColors ;
private GraphicsChainedSegment currentSegment ;
private boolean readingFilename ;
private Map < String , ColorProfile > colorProfiles ;
private PropertyList pList ;
protected FOUserAgent userAgent ;
protected String valueStr ;
protected List valueElements ;
protected boolean started ;
protected boolean finish ;
protected boolean finished ;
protected int blockProgressionOffset ;
private Area parentArea ;
private int storedIPDVariation ;
protected InlineAdjustingInfo adjustingInfo ;
private boolean inlineElementList ;
private static RtfFontManager instance ;
private Hashtable fontIndex ;
private Vector fontTable ;
private int accumulatedSpace ;
private String bookmark ;
private RtfParagraphBreak lastBreak ;
private LineAdjustingInfo adjustingInfo ;
private PDFColor transparent ;
protected int xOffset ;
protected int yOffset ;
protected List < Area > children ;
protected String name ;
private int maxColIndexReferenced ;
private int lastGeneratedID ;
private int hash ;
private static RtfTemplate instance ;
private String templateFilePath ;
private Statistics statistics ;
private int idGen ;
private AttributeValue fontFamilyAttributeValue ;
private AttributeValue fontStyleAttributeValue ;
private AttributeValue fontWeightAttributeValue ;
private byte found ;
protected boolean generatesReferenceArea ;
protected boolean generatesBlockArea ;
private static List activeObservers ;
private boolean paintAsBitmap ;
protected int curPos ;
private Set pageSegments ;
private FlowLayoutManager childFLM ;
private StaticContentLayoutManager footnoteSeparatorLM ;
private Map < String , Typeface > usedFonts ;
private Map < FontTriplet , String > triplets ;
private Map < FontTriplet , Integer > tripletPriorities ;
private Map < String , Typeface > fonts ;
private Map < FontTriplet , Map < Integer , Font > > fontInstanceCache ;
private FontEventListener eventListener ;
protected FontFileReader sourceSansReader ;
protected FontFileReader alexBrushReader ;
private List elementLists ;
private boolean isClosed ;
protected ResourceEnvironmentGroup resourceEnvironmentGroup ;
private int roundedCornerCount ;
private List < ExtensionAttachment > extensionAttachments ;
private Map < QName , String > foreignAttributes ;
private boolean isOutOfLineFODescendant ;
protected MIFElement colorCatalog ;
protected PGFElement pgfCatalog ;
protected MIFElement fontCatalog ;
protected RulingElement rulingCatalog ;
protected MIFElement tblCatalog ;
protected MIFElement views ;
protected MIFElement variableFormats ;
protected MIFElement xRefFormats ;
protected MIFElement document ;
protected MIFElement bookComponent ;
protected MIFElement initialAutoNums ;
protected MIFElement aFrames ;
protected MIFElement tbls ;
protected List textFlows ;
private PDFFilter pdfFilter ;
private int listNum ;
private boolean blockOrInlineItemFound ;
protected List mapPageOverlays ;
private boolean blockItemFound ;
static boolean notImplementedWarningGiven ;
private static boolean notImplementedWarningGiven ;
private int borderStyleId ;
private Map hyphPatNames ;
private List preProcessPresentationObjects ;
private boolean complete ;
private InputStream inputStream ;
private int number ;
private GraphicsData currentData ;
private ColorConverter colorConverter ;
protected int currentPageNum ;
protected int startPageNum ;
private String filename ;
private String desc ;
private String src ;
private Configuration cfg ;
private Map < String , CachedFontFile > fontfileMap ;
private Map < String , Long > failedFontMap ;
private Map < String , EmbedFontInfo > filefontsMap ;
private PDFFilter pdfFilter ;
private boolean blockItemFound ;
private boolean errorDump ;
private Color color ;
private String url ;
private ImageInfo imageInfo ;
protected PDFResources resources ;
protected String patternName ;
protected List bBox ;
protected PDFShading shading ;
protected List xUID ;
protected StringBuffer extGState ;
protected List matrix ;
protected StringBuffer patternDataStream ;
private int numberConsumed ;
private boolean hasForcing ;
private InlineLevelLayoutManager childLM ;
private Attributes xslAttributes ;
private boolean inTextMode ;
private boolean inWhiteSpace ;
private boolean nextIsEOL ;
private boolean hasSections ;
private ImageOutputControl imageOutputControl ;
private ImageInputDescriptor imageInputDescriptor ;
private ImageCellPosition imageCellPosition ;
private ImageRasterData imageRasterData ;
private PDFFilter pdfFilter ;
private boolean subtractive ;
private boolean grayCoding ;
private int currentPageNumber ;
private int nestedTableDepth ;
private RtfAttributes headerAttribs ;
private byte objOrent ;
private boolean failOnly ;
private File compare ;
protected SimpleLog logger ;
private boolean firstPage ;
protected Map < QName , String > foreignAttributes ;
protected List < ExtensionAttachment > extensionAttachments ;
private boolean blockItemFound ;
private int rotation ;
private int xoaOset ;
private int yoaOset ;
private int xOffset ;
private int yOffset ;
private boolean applied ;
private String outputFormat ;
private OutputStream stream ;
private FOTreeBuilder foTreeBuilder ;
private int counter ;
private int currentPage ;
private int firstPage ;
private ImageProxyPanel [ ] pagePanels ;
private JPanel gridPanel ;
private int startPosX ;
private int startPosY ;
private Inline footnoteCitation ;
private String currentKey ;
private List overLays ;
private ITableColumnsInfo parentITableColumnsInfo ;
private FOText prevFOTextThisBlock ;
private FOText nextFOTextThisBlock ;
private Block ancestorBlock ;
private int currentPosition ;
protected Block child ;
protected int count ;
private boolean started ;
private boolean complete ;
private int contentAreaIPD ;
private CommonBorderPaddingBackground borderProps ;
private int highestCell ;
protected HashMap < String , Maker > foObjs ;
protected String namespaceURI ;
private static boolean notImplementedWarningGiven ;
private int spanIndex ;
protected Log logger ;
private File userConfigFile ;
private File fofile ;
private File xsltfile ;
private File xmlfile ;
private File areatreefile ;
private File iffile ;
private File imagefile ;
private File outfile ;
private String outputmode ;
private boolean useStdIn ;
private boolean useStdOut ;
private boolean useCatalogResolver ;
private boolean conserveMemoryPolicy ;
private boolean overrideTargetResolution ;
private Vector xsltParams ;
private String mimicRenderer ;
private boolean flushCache ;
private static PercentBaseContext pseudoContextForValidation ;
private PropertyMaker shorthandMaker ;
private int [ ] [ ] extraCorresponding ;
private boolean topLevelSVGFound ;
private int currentPrintDirection ;
private static boolean elObserversRegistered ;
private int current ;
protected Root rootFObj ;
private boolean used ;
protected FONode currentFObj ;
private int nestedMarkerDepth ;
private List mapPageSegments ;
private ObjectAreaDescriptor objectAreaDescriptor ;
private ObjectAreaPosition objectAreaPosition ;
private PresentationTextDescriptor presentationTextDataDescriptor ;
private PageDescriptor pageDescriptor ;
protected InlineArea curArea ;
protected CommonBorderPaddingBackground commonBorderPaddingBackground ;
protected AlignmentContext alignmentContext ;
protected boolean somethingChanged ;
protected AreaInfo areaInfo ;
private boolean blockOrInlineItemFound ;
private boolean useNativeEncoding ;
private int [ ] width ;
private boolean hasListItem ;
private boolean blockOrInlineItemFound ;
private AlignmentContext alignmentContext ;
protected StatusListener statusListener ;
private ColumnSetup columns ;
protected int startingPageNumber ;
private PageViewport pageRef ;
protected int baseLevel ;
protected int nativeCount ;
protected Font ovFontState ;
protected OutputStream outputStream ;
protected int width ;
protected int height ;
protected int widthRes ;
protected int heightRes ;
private boolean resolved ;
protected boolean useKerning ;
protected long lastLoca ;
private short lastChar ;
protected boolean useAdvanced ;
private AffineTransform currentTransform ;
private float pixelUnitToMillimeter ;
private boolean baseWidthSet ;
private static HyphenationTreeCache hTreeCache ;
private static boolean statisticsDump ;
private int x ;
private int y ;
private boolean bSuppressLastPar ;
private URI extUri ;
private boolean writeForBreak ;
private int currentOrientation ;
private int currentVariableSpaceCharacterIncrement ;
private int currentInterCharacterAdjustment ;
private int orientation ;
private int xCoord ;
private int yCoord ;
private int rowIndex ;
protected PSShading shading ;
protected List xUID ;
protected StringBuffer extGState ;
private ImageContent imageContent ;
private CharacterSet charSet ;
private boolean resolved ;
private transient List < Resolvable > dependents ;
protected int functionType ;
protected List < Double > domain ;
protected List < Double > range ;
protected List < Double > size ;
protected List < Double > encode ;
protected List < Double > decode ;
protected StringBuffer functionDataStream ;
protected List < String > filter ;
protected List < Double > cZero ;
protected List < Double > cOne ;
protected List < Function > functions ;
protected List < Double > bounds ;
protected String name ;
private static ResultCollector instance ;
private int [ ] width ;
private int xHeight ;
private int ascender ;
private int descender ;
private Font f1 ;
private int style ;
private float size ;
private FontMetrics fmt ;
private boolean ignoreASCIIFilters ;
private boolean disableAllFilters ;
private boolean complete ;
private boolean started ;
protected PDFDocumentGraphics2D graphics ;
protected AbstractPSDocumentGraphics2D graphics ;
private boolean drawBoundary ;
private int currentRowOffset ;
private EffRow currentRow ;
private int tablePartOffset ;
private TableRow currentTableRow ;
private int instreamObjectCount ;
private static boolean notImplementedWarningGiven ;
private HyphContext hyphContext ;
private double ipdAdjust ;
private double dSpaceAdjust ;
private AlignmentContext alignmentContext ;
private int spaceBefore ;
private int spaceAfter ;
private int lineStartBorderAndPaddingWidth ;
private int lineEndBorderAndPaddingWidth ;
private boolean isCached ;
private boolean isErrorDiffusion ;
private static RtfStyleSheetTable instance ;
private Hashtable styles ;
private Hashtable attrTable ;
private Vector nameTable ;
private Numeric op2 ;
private LinkedList < PageBreakPosition > pageBreaks ;
private List < List < KnuthElement > > footnotesList ;
private List < Integer > lengthList ;
private int totalFootnotesLength ;
private int insertedFootnotesLength ;
private boolean footnotesPending ;
private boolean newFootnotes ;
private int firstNewFootnoteIndex ;
private int footnoteListIndex ;
private MinOptMax footnoteSeparatorLength ;
private boolean storedValue ;
private boolean autoHeight ;
private boolean favorSinglePart ;
private RtfAttributes attrs ;
private String bookmarkTitle ;
private PageViewport pageRef ;
private static PropertyMaker [ ] generics ;
private Property [ ] enums ;
private CFFDataReader cffReader ;
private int portraitRotation ;
private boolean colorImages ;
private boolean nativeImagesSupported ;
private boolean canEmbedJpeg ;
private boolean strokeGocaText ;
private int width ;
private int height ;
private int fontCount ;
private int orientation ;
private boolean filled ;
private String imageUri ;
private static boolean notImplementedWarningGiven ;
private Block separator ;
protected boolean tableRowsFound ;
protected boolean tableCellsFound ;
private boolean rowsStarted ;
private FOText ft ;
protected FOText lastFOTextProcessed ;
protected ActiveEnvironmentGroup activeEnvironmentGroup ;
private PresentationTextObject currentPresentationTextObject ;
protected int rotation ;
protected boolean complete ;
private boolean clippingDisabled ;
private Iterator childIter ;
private CharIterator curCharIter ;
private int x ;
private int y ;
private int orientation ;
private boolean conserveMemoryPolicy ;
protected String creator ;
protected Date creationDate ;
protected String author ;
protected String title ;
protected String subject ;
protected String keywords ;
private boolean clip ;
private static Registry instance ;
private boolean clip ;
protected int spaceDifference ;
static boolean notImplementedWarningGiven ;
private int ocNameIndex ;
private boolean hasClasses ;
private boolean inPageSequence ;
private boolean bPrevHeaderSpecified ;
private boolean bPrevFooterSpecified ;
private boolean bHeaderSpecified ;
private boolean bFooterSpecified ;
private boolean blockItemFound ;
protected int pageWidth ;
protected int pageHeight ;
private int currentPageNumber ;
protected boolean transparentPageBackground ;
private GeneralPath currentPath ;
protected CharacterSet charSet ;
private boolean openItem ;
private long charMapOps ;
protected PDFDeviceColorSpace colorSpace ;
protected List background ;
protected List bBox ;
protected boolean antiAlias ;
protected List domain ;
protected PSFunction function ;
protected List coords ;
protected List extend ;
private int generation ;
private boolean force ;
protected boolean considerTooShort ;
protected int startLine ;
protected int endLine ;
protected int totalStretch ;
protected int totalShrink ;
public int fitRecoveryCounter ;
private int nextPageIndex ;
private boolean inPageSequence ;
private boolean inTextObject ;
private FontSubstitutions fontSubstitutions ;
private boolean enableBase14Kerning ;
private Property [ ] orderedFontStretchValues ;
private boolean bNextRowBelongsToHeader ;
private long pageWidth ;
private long pageHeight ;
protected String url ;
protected RtfText mText ;
private int pageGroupCount ;
private int pageCount ;
private int imageCount ;
private int imImageCount ;
private int imageSegmentCount ;
private int graphicCount ;
private int objectContainerCount ;
private int resourceCount ;
private int resourceGroupCount ;
private int overlayCount ;
private int textObjectCount ;
private int activeEnvironmentGroupCount ;
private int documentCount ;
private int objectEnvironmentGroupCount ;
private Configuration cfg ;
protected List < EmbedFontInfo > embedFontInfoList ;
private String uri ;
private Dimension imageDimension ;
private String name ;
private boolean levelChanged ;
private List < String > charNames ;
private SingleByteFont sbfont ;
private boolean standardEncoding ;
private String name ;
appendCharacters ( new String ( new char [ ] { c . getCharacter ( ) } ) ) ;
appendCharacters ( foText . getCharSequence ( ) . toString ( ) ) ;
private void appendCharacters ( String str ) {
boolean position ( GlyphPositioningState ps ) ;
int [ ] da = BidiTestData . readTestData ( ldPfx , i ) ;
testBidiAlgorithm ( i , da ) ;
fail ( "str" + i ) ;
assertEquals ( "str" , BidiTestData . NUM_TEST_SEQUENCES , passedSequences ) ;
private void testBidiAlgorithm ( int testSet , int [ ] da ) throws Exception {
fail ( "str" ) ;
fail ( "str" ) ;
if ( includeSequence ( testSet , testSequence ) ) {
assertEquals ( "str" , da . length , k ) ;
private boolean includeTestSet ( int testSet ) {
private boolean excludeSequence ( int testSet , int testSequence ) {
private boolean testBidiAlgorithm ( int testSet , int testSequence , int [ ] la , int [ ] ra , int [ ] ta , int bs ) throws Exception {
fail ( "str" + n + "str" + ra . length ) ;
fail ( "str" + n + "str" + ta . length ) ;
private boolean verifyResults ( int [ ] laExp , int [ ] laOut , int [ ] ta , int dl , int testSet , int testSequence ) {
fail ( "str" + laExp . length + "str" + laOut . length ) ;
assertEquals ( getMismatchMessage ( testSet , testSequence , i , dl ) , le , lo ) ;
private String getMismatchMessage ( int testSet , int testSequence , int seqIndex , int defaultLevel ) {
private ImageUtil ( ) {
if ( retString . length ( ) = = 0 ) {
return Integer . parseInt ( retString ) ;
public static boolean compareHexValues ( byte [ ] pattern , byte [ ] data , int searchAt ,
public static int getIntFromByteArray ( byte [ ] data , int startAt , int length ,
int overflow = computeInlinesOverflow ( line ) ;
private int computeInlinesOverflow ( LineArea line ) {
foParent . setBidiLevel ( bidiLevel ) ;
lineDataInfo . setX1 ( Math . round ( ( float ) at . getTranslateY ( ) + x ) ) ;
lineDataInfo . setX1 ( pageWidth - Math . round ( ( float ) at . getTranslateX ( ) - x ) ) ;
lineDataInfo . setX1 ( pageHeight - Math . round ( ( float ) at . getTranslateY ( ) - x ) ) ;
lineDataInfo . setX1 ( Math . round ( ( float ) at . getTranslateX ( ) + x ) ) ;
protected GlyphSubtable ( String lookupId , int sequence , int flags , int format , GlyphMappingTable mapping )
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" ) ;
public abstract boolean isCompatible ( GlyphSubtable subtable ) ;
public synchronized void setTable ( GlyphTable table ) throws IllegalStateException {
this . table = new WeakReference ( table ) ;
throw new IllegalStateException ( "str" ) ;
public void resolveLookupReferences ( Map lookupTables ) {
public int getCoverageIndex ( int gid ) {
return ( ( GlyphCoverageMapping ) mapping ) . getCoverageIndex ( gid ) ;
public boolean equals ( Object o ) {
return lookupId . equals ( st . lookupId ) & & ( sequence = = st . sequence ) ;
public int compareTo ( Object o ) {
if ( ( d = lookupId . compareTo ( st . lookupId ) ) = = 0 ) {
public static boolean usesReverseScan ( GlyphSubtable [ ] subtables ) {
public static int getFlags ( GlyphSubtable [ ] subtables ) throws IllegalStateException {
throw new IllegalStateException ( "str" + f + "str" + flags ) ;
return flags | ( usesReverseScan ( subtables ) ? LF_INTERNAL_USE_REVERSE_SCAN : 0 ) ;
protected Stack collectDelimitedTextRanges ( Stack ranges , DelimitedTextRange currentRange ) {
ranges = ( ( StaticContent ) fn ) . collectDelimitedTextRanges ( ranges ) ;
ranges = main . collectDelimitedTextRanges ( ranges ) ;
public RenderPagesModel ( FOUserAgent userAgent , String outputFormat ,
if ( ! isNameChar ( expr . charAt ( exprIndex ) ) ) {
public boolean isDelimitedTextRangeBoundary ( int boundary ) {
protected Stack collectDelimitedTextRanges ( Stack ranges , DelimitedTextRange currentRange ) {
currentRange . append ( CharUtilities . OBJECT_REPLACEMENT_CHARACTER , this ) ;
int [ ] dx = IFUtil . convertDPToDX ( dp ) ;
public TTFFile ( boolean useKerning , boolean useAdvanced ) {
public boolean equals ( Object o ) {
public int compareTo ( Object o ) {
= new OTFAdvancedTypographicTableReader ( this , in ) ;
log . warn (
public CachedRenderPagesModel ( FOUserAgent userAgent , String outputFormat ,
private void maybeAddLevelAttribute ( Area a ) {
addAttribute ( "str" , level ) ;
private void maybeAddPositionAdjustAttribute ( WordArea w ) {
addAttribute ( "str" , XMLUtil . encodePositionAdjustments ( adjustments ) ) ;
private void maybeAddReversedAttribute ( WordArea w , String text ) {
public Rectangle getViewportRectangle ( FODimension reldims ) {
protected Stack collectDelimitedTextRanges ( Stack ranges , DelimitedTextRange currentRange ) {
ranges = label . collectDelimitedTextRanges ( ranges ) ;
ranges = body . collectDelimitedTextRanges ( ranges ) ;
processWordForms ( new File ( datFilesDir ) ) ;
fail ( e . getMessage ( ) ) ;
private boolean hasPrefixFrom ( String name , String [ ] prefixes ) {
if ( name . startsWith ( p ) ) {
private void processWordForms ( String dpn ) {
fis = new FileInputStream ( dpn ) ;
ObjectInputStream ois = new ObjectInputStream ( fis ) ;
processWordForms ( data ) ;
throw new RuntimeException ( e . getMessage ( ) , e ) ;
throw new RuntimeException ( e . getMessage ( ) , e ) ;
throw new RuntimeException ( e . getMessage ( ) , e ) ;
private void processWordForms ( List < Object [ ] > data ) {
assertTrue ( gsub ! = null ) ;
assertTrue ( gpos ! = null ) ;
assertTrue ( widths ! = null ) ;
assertEquals ( "str" + wf + "str" + tfn + "str" , paa . length , 0 ) ;
assertEquals ( label + "str" + i + "str" + wf + "str" + tfn + "str" , e , a ) ;
assertEquals ( "str" + wf + "str" + tfn + "str" , ea . length , aa . length ) ;
assertEquals ( "str" + i + "str" + k + "str" + wf + "str" + tfn + "str" , e , a ) ;
private static int [ ] getGlyphs ( GlyphSequence gs ) {
gb . get ( ga ) ;
return new IFGraphicContext ( this ) ;
super ( blockProgressionOffset , bidiLevel ) ;
cell = new RtfTableCell ( this , writer , cellWidth , attrs , highestCell ) ;
public RtfTableCell newTableCellMergedHorizontally ( int cellWidth ,
int now = bookmark . length ( ) ;
this . bookmark = bookmark . substring ( 0 ,
public void writeRtfContent ( ) throws IOException {
private void startBookmark ( ) throws IOException {
writeRtfBookmark ( "str" ) ;
private void endBookmark ( ) throws IOException {
writeRtfBookmark ( "str" ) ;
private void writeRtfBookmark ( String tag ) throws IOException {
this . writeGroupMark ( true ) ;
this . writeStarControlWord ( tag ) ;
performSubstitutions ( ltSingle ) ;
performSubstitutions ( ltMultiple ) ;
performSubstitutions ( ltAlternate ) ;
performSubstitutions ( ltLigature ) ;
performSubstitutions ( ltContextual ) ;
performSubstitutions ( ltChainedContextual ) ;
private void performSubstitutions ( Object [ ] [ ] ts ) {
performSubstitutions ( tp , ts [ i ] ) ;
private void performSubstitutions ( Object [ ] tp , Object [ ] td ) {
private String findTTXPath ( String fid ) {
if ( fs [ 0 ] . equals ( fid ) ) {
TTXFile tf = TTXFile . getFromCache ( pn ) ;
fail ( e . getMessage ( ) ) ;
private ScriptContextTester findScriptContextTester ( String script , String language , String feature ) {
public GlyphContextTester getTester ( String feature ) {
public boolean test ( String script , String language , String feature , GlyphSequence gs , int index , int flags ) {
assertEquals ( "str" , gb1 . limit ( ) , gb2 . limit ( ) ) ;
assertEquals ( "str" , g1 , g2 ) ;
throw new UnsupportedOperationException ( "str" ) ;
String [ ] fa = line . split ( "str" ) ;
throw new Exception ( "str" + c ) ;
throw new Exception ( "str" + c ) ;
addInterval ( intervals , c , c , bidiClass ) ;
throw new Exception ( "str" + i ) ;
addInterval ( intervals , i , e , bidiClass ) ;
throw new Exception ( "str" + i ) ;
addInterval ( intervals , i , e , bidiClass ) ;
addInterval ( intervals , s , e , bidiClass ) ;
throw new Exception ( "str" + lineNumber + "str" + line ) ;
private static int [ ] parseInterval ( String interval ) throws Exception {
s = Integer . parseInt ( fa [ 0 ] , 16 ) ;
throw new Exception ( "str" + interval ) ;
throw new Exception ( "str" + interval ) ;
private static int parseBidiClass ( String bidiClass ) {
if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
throw new IllegalArgumentException ( "str" + bidiClass ) ;
private static void dumpData ( PrintWriter out ) {
out . println ( "str" ) ;
sb . append ( "str" ) ;
sb . append ( bcL1 [ i ] ) ;
out . println ( "str" ) ;
out . println ( "str" ) ;
sb . append ( "str" ) ;
sb . append ( bcR1 [ i ] ) ;
out . println ( "str" ) ;
out . println ( "str" ) ;
sb . append ( "str" ) ;
sb . append ( bcS1 [ i ] ) ;
out . println ( "str" ) ;
out . println ( "str" ) ;
sb . append ( "str" ) ;
sb . append ( bcE1 [ i ] ) ;
out . println ( "str" ) ;
out . println ( "str" ) ;
sb . append ( "str" ) ;
sb . append ( bcC1 [ i ] ) ;
out . println ( "str" ) ;
private static int getBidiClass ( int ch ) {
return getBidiClass ( ch , bcS1 , bcE1 , bcC1 ) ;
int bc = getBidiClass ( ch ) ;
throw new Exception ( "str" + Integer . toHexString ( ch ) + "str" + tc + "str" + bc ) ;
Interval ( int start , int end , int bidiClass ) {
public int compareTo ( Object o ) {
return this . controlWord . equals ( DEFAULT_PARAGRAPH ) ;
public DelimitedTextRange ( FONode fn ) {
public void append ( CharIterator it , FONode fn ) {
buffer . append ( c ) ;
intervals . add ( new TextInterval ( fn , s , e ) ) ;
public void append ( char c , FONode fn ) {
sb . append ( ti . toString ( ) ) ;
private void resolve ( Direction paragraphEmbeddingLevel ) {
intervalsNew . addAll ( assignLevels ( ti , levels ) ) ;
if ( ! intervalsNew . equals ( intervals ) ) {
private List assignLevels ( TextInterval ti , int [ ] levels ) {
ti . setLevel ( l ) ;
ti = new TextInterval ( fn , fnStart , s , e , l ) ;
log . debug ( "str" + l + "str" + ti ) ;
tiv . add ( ti ) ;
private void assignBlockLevel ( Direction paragraphEmbeddingLevel ) {
assignBlockLevel ( ti . getNode ( ) , defaultLevel ) ;
private void assignBlockLevel ( FONode node , int defaultLevel ) {
fo . setBidiLevel ( defaultLevel ) ;
BidiResolver . reorder ( lineArea ) ;
BidiResolver . reorder ( lineArea ) ;
private GlyphCoverageTable ( GlyphCoverageMapping cm ) {
public static GlyphCoverageTable createCoverageTable ( List entries ) {
return new GlyphCoverageTable ( cm ) ;
private static boolean isMappedCoverage ( List entries ) {
private static boolean isRangeCoverage ( List entries ) {
public int getCoverageIndex ( int gid ) {
entries . add ( Integer . valueOf ( map [ i ] ) ) ;
public int getMappedIndex ( int gid ) {
if ( ( i = Arrays . binarySearch ( map , gid ) ) > = 0 ) {
private void populate ( List entries ) {
log . info ( "str" + gid ) ;
throw new AdvancedTypographicTableFormatException ( "str" + gid ) ;
throw new AdvancedTypographicTableFormatException ( "str" + o ) ;
sb . append ( Integer . toString ( map [ i ] ) ) ;
public int getMappedIndex ( int gid , int s , int m ) {
RtfHyperLink newHyperLink ( String str , RtfAttributes attr ) throws IOException ;
UnflattenProcessor ( List < InlineArea > inlines ) {
process ( it . next ( ) ) ;
private void process ( List < InlineParent > ich , TextArea tc , InlineArea ia ) {
private boolean shouldFinishTextContainer ( TextArea tc , InlineArea ia ) {
finishTextContainer ( null , null ) ;
private void finishTextContainer ( TextArea tc , InlineArea ia ) {
updateIPD ( tcNew ) ;
icNew . peek ( ) . addChildArea ( tcNew ) ;
ilNew . add ( tcNew ) ;
private boolean shouldFinishInlineContainer ( List < InlineParent > ich , TextArea tc , InlineArea ia ) {
return ( ic ! = ic0 ) & & ! isInlineParentOf ( ic , ic0 ) ;
finishInlineContainer ( null , null , null ) ;
private void finishInlineContainer ( List < InlineParent > ich , TextArea tc , InlineArea ia ) {
ilNew . add ( icN0 ) ;
icNew . peek ( ) . addChildArea ( icN0 ) ;
ilNew . add ( icN0 ) ;
icNew . peek ( ) . addChildArea ( icN0 ) ;
pushInlineContainers ( ich ) ;
pushTextContainer ( tc , ia ) ;
pushNonTextInline ( ia ) ;
private boolean alreadyUnflattened ( InlineArea ia ) {
if ( ia . isAncestorOrSelf ( it . next ( ) ) ) {
private void pushInlineContainers ( List < InlineParent > ich ) {
if ( icOrig . search ( ic ) > = 0 ) {
icl . addFirst ( ic ) ;
private void pushTextContainer ( TextArea tc , InlineArea ia ) {
tcNew = generateTextContainer ( tc ) ;
tcNew . addChildArea ( ia ) ;
private void pushNonTextInline ( InlineArea ia ) {
ilNew . add ( ia ) ;
icNew . peek ( ) . addChildArea ( ia ) ;
private InlineParent generateInlineContainer ( InlineParent i ) {
return generateBasicLinkArea ( ( BasicLinkArea ) i ) ;
return generateFilledArea ( ( FilledArea ) i ) ;
return generateInlineContainer0 ( i ) ;
private InlineParent generateBasicLinkArea ( BasicLinkArea l ) {
private void initializeLinkArea ( BasicLinkArea lc , BasicLinkArea l ) {
private InlineParent generateFilledArea ( FilledArea f ) {
private void initializeFilledArea ( FilledArea fc , FilledArea f ) {
private InlineParent generateInlineContainer0 ( InlineParent i ) {
initializeInlineContainer ( ic , i ) ;
private void initializeInlineContainer ( InlineParent ic , InlineParent i ) {
private TextArea generateTextContainer ( TextArea t ) {
private void updateIPD ( TextArea tc ) {
tc . setIPD ( tc . getIPD ( ) + ( numAdjustable * tc . getTextWordSpaceAdjust ( ) ) ) ;
private TextArea findTextContainer ( InlineArea ia ) {
private List < InlineParent > findInlineContainers ( InlineArea ia ) {
ich . add ( ( InlineParent ) a ) ;
private boolean isInlineParentOf ( InlineParent ic0 , InlineParent ic1 ) {
leaderArea . setBidiLevel ( level ) ;
leaderArea . setBidiLevel ( level ) ;
leaderArea . setBidiLevel ( level ) ;
spacer . setBidiLevel ( level ) ;
spacer . setBidiLevel ( level ) ;
leaderArea . setBidiLevel ( fobj . getBidiLevelRecursive ( ) ) ;
public Rectangle getViewportRectangle ( FODimension reldims ) {
dp = IFUtil . convertDXToDP ( dx ) ;
public OTFAdvancedTypographicTableReader ( TTFFile ttf , FontFileReader in ) {
throw new AdvancedTypographicTableFormatException ( e . getMessage ( ) , e ) ;
fl . add ( "str" + fi ) ;
seLanguages . put ( langSysTag , new Object [ ] { rfi , fl } ) ;
ll . add ( lt ) ;
readLangSysTable ( tableTag , scriptTable + loa [ i ] , lta [ i ] ) ;
readLangSysTable ( tableTag , scriptTable + dl , dt ) ;
seScripts . put ( scriptTag , new Object [ ] { dt , ll , seLanguages } ) ;
readScriptTable ( tableTag , scriptList + soa [ i ] , sta [ i ] ) ;
lul . add ( "str" + li ) ;
seFeatures . put ( "str" + featureIndex , new Object [ ] { featureTag , lul } ) ;
readFeatureTable ( tableTag , featureList + foa [ i ] , fta [ i ] , i ) ;
public static int getSubtableType ( int lt ) {
public static int getSubtableType ( int lt ) {
sb . append ( "str" ) ;
sb . append ( "str" ) ;
sb . append ( "str" ) ;
sb . append ( "str" ) ;
sb . append ( "str" ) ;
sb . append ( "str" ) ;
sb . append ( "str" ) ;
sb . append ( "str" ) ;
sb . append ( "str" ) ;
sb . append ( "str" ) ;
sb . append ( "str" ) ;
in . skip ( 2 ) ;
entries . add ( Integer . valueOf ( g ) ) ;
return GlyphCoverageTable . createCoverageTable ( entries ) ;
in . skip ( 2 ) ;
entries . add ( new GlyphCoverageTable . MappingRange ( s , e , m ) ) ;
return GlyphCoverageTable . createCoverageTable ( entries ) ;
gct = readCoverageTableFormat1 ( label , tableOffset , cf ) ;
gct = readCoverageTableFormat2 ( label , tableOffset , cf ) ;
throw new AdvancedTypographicTableFormatException ( "str" + cf ) ;
in . seekSet ( cp ) ;
in . skip ( 2 ) ;
entries . add ( Integer . valueOf ( sg ) ) ;
entries . add ( Integer . valueOf ( gc ) ) ;
return GlyphClassTable . createClassTable ( entries ) ;
in . skip ( 2 ) ;
entries . add ( new GlyphClassTable . MappingRange ( s , e , m ) ) ;
return GlyphClassTable . createClassTable ( entries ) ;
gct = readClassDefTableFormat1 ( label , tableOffset , cf ) ;
gct = readClassDefTableFormat2 ( label , tableOffset , cf ) ;
throw new AdvancedTypographicTableFormatException ( "str" + cf ) ;
in . seekSet ( cp ) ;
in . skip ( 2 ) ;
in . skip ( 2 ) ;
seMapping = readCoverageTable ( tableTag + "str" , subtableOffset + co ) ;
seEntries . add ( Integer . valueOf ( gs ) ) ;
readSingleSubTableFormat1 ( lookupType , lookupFlags , subtableOffset , sf ) ;
readSingleSubTableFormat2 ( lookupType , lookupFlags , subtableOffset , sf ) ;
throw new AdvancedTypographicTableFormatException ( "str" + sf ) ;
in . skip ( 2 ) ;
seMapping = readCoverageTable ( tableTag + "str" , subtableOffset + co ) ;
log . debug ( tableTag + "str" + i + "str" + toString ( ga ) ) ;
seEntries . add ( gsa ) ;
readMultipleSubTableFormat1 ( lookupType , lookupFlags , subtableOffset , sf ) ;
throw new AdvancedTypographicTableFormatException ( "str" + sf ) ;
in . skip ( 2 ) ;
seMapping = readCoverageTable ( tableTag + "str" , subtableOffset + co ) ;
log . debug ( tableTag + "str" + i + "str" + toString ( ga ) ) ;
seEntries . add ( ga ) ;
readAlternateSubTableFormat1 ( lookupType , lookupFlags , subtableOffset , sf ) ;
throw new AdvancedTypographicTableFormatException ( "str" + sf ) ;
in . skip ( 2 ) ;
seMapping = readCoverageTable ( tableTag + "str" , subtableOffset + co ) ;
log . debug ( tableTag + "str" + i + "str" + lg + "str" + toString ( ca ) ) ;
ligs . add ( new GlyphSubstitutionTable . Ligature ( lg , ca ) ) ;
seEntries . add ( new GlyphSubstitutionTable . LigatureSet ( ligs ) ) ;
readLigatureSubTableFormat1 ( lookupType , lookupFlags , subtableOffset , sf ) ;
throw new AdvancedTypographicTableFormatException ( "str" + sf ) ;
la [ i ] = new GlyphTable . RuleLookup ( sequenceIndex , lookupIndex ) ;
in . skip ( 2 ) ;
ct = readCoverageTable ( tableTag + "str" , subtableOffset + co ) ;
in . seekSet ( subtableOffset + rso ) ;
in . seekSet ( subtableOffset + rso + ro ) ;
rs = new GlyphTable . HomogeneousRuleSet ( ra ) ;
seEntries . add ( rsa ) ;
in . skip ( 2 ) ;
ct = readCoverageTable ( tableTag + "str" , subtableOffset + co ) ;
cdt = readClassDefTable ( tableTag + "str" , subtableOffset + cdo ) ;
in . seekSet ( subtableOffset + cso ) ;
in . seekSet ( subtableOffset + cso + ro ) ;
rs = new GlyphTable . HomogeneousRuleSet ( ra ) ;
in . skip ( 2 ) ;
gct = readCoverageTable ( tableTag + "str" + i + "str" , subtableOffset + gco ) ;
GlyphTable . RuleLookup [ ] lookups = readRuleLookups ( nl , header ) ;
seEntries . add ( rsa ) ;
readContextualSubTableFormat1 ( lookupType , lookupFlags , subtableOffset , sf ) ;
readContextualSubTableFormat2 ( lookupType , lookupFlags , subtableOffset , sf ) ;
readContextualSubTableFormat3 ( lookupType , lookupFlags , subtableOffset , sf ) ;
throw new AdvancedTypographicTableFormatException ( "str" + sf ) ;
in . skip ( 2 ) ;
ct = readCoverageTable ( tableTag + "str" , subtableOffset + co ) ;
in . seekSet ( subtableOffset + rso ) ;
in . seekSet ( subtableOffset + rso + ro ) ;
rs = new GlyphTable . HomogeneousRuleSet ( ra ) ;
seEntries . add ( rsa ) ;
in . skip ( 2 ) ;
ct = readCoverageTable ( tableTag + "str" , subtableOffset + co ) ;
bcdt = readClassDefTable ( tableTag + "str" , subtableOffset + bcdo ) ;
icdt = readClassDefTable ( tableTag + "str" , subtableOffset + icdo ) ;
lcdt = readClassDefTable ( tableTag + "str" , subtableOffset + lcdo ) ;
in . seekSet ( subtableOffset + cso ) ;
in . seekSet ( subtableOffset + cso + ro ) ;
rs = new GlyphTable . HomogeneousRuleSet ( ra ) ;
in . skip ( 2 ) ;
bgct = readCoverageTable ( tableTag + "str" + i + "str" , subtableOffset + bgco ) ;
igct = readCoverageTable ( tableTag + "str" + i + "str" , subtableOffset + igco ) ;
lgct = readCoverageTable ( tableTag + "str" + i + "str" , subtableOffset + lgco ) ;
GlyphTable . RuleLookup [ ] lookups = readRuleLookups ( nl , header ) ;
seEntries . add ( rsa ) ;
readChainedContextualSubTableFormat1 ( lookupType , lookupFlags , subtableOffset , sf ) ;
readChainedContextualSubTableFormat2 ( lookupType , lookupFlags , subtableOffset , sf ) ;
readChainedContextualSubTableFormat3 ( lookupType , lookupFlags , subtableOffset , sf ) ;
throw new AdvancedTypographicTableFormatException ( "str" + sf ) ;
in . skip ( 2 ) ;
readGSUBSubtable ( lt , lookupFlags , lookupSequence , subtableSequence , subtableOffset + eo ) ;
readExtensionSubTableFormat1 ( lookupType , lookupFlags , lookupSequence , subtableSequence , subtableOffset , sf ) ;
throw new AdvancedTypographicTableFormatException ( "str" + sf ) ;
in . skip ( 2 ) ;
GlyphCoverageTable ct = readCoverageTable ( tableTag + "str" , subtableOffset + co ) ;
bgct = readCoverageTable ( tableTag + "str" + i + "str" , subtableOffset + bgco ) ;
lgct = readCoverageTable ( tableTag + "str" + i + "str" , subtableOffset + lgco ) ;
readReverseChainedSingleSubTableFormat1 ( lookupType , lookupFlags , subtableOffset , sf ) ;
throw new AdvancedTypographicTableFormatException ( "str" + sf ) ;
subtableFormat = readSingleSubTable ( lookupType , lookupFlags , subtableOffset ) ;
subtableFormat = readMultipleSubTable ( lookupType , lookupFlags , subtableOffset ) ;
subtableFormat = readAlternateSubTable ( lookupType , lookupFlags , subtableOffset ) ;
subtableFormat = readLigatureSubTable ( lookupType , lookupFlags , subtableOffset ) ;
subtableFormat = readContextualSubTable ( lookupType , lookupFlags , subtableOffset ) ;
subtableFormat = readChainedContextualSubTable ( lookupType , lookupFlags , subtableOffset ) ;
subtableFormat = readReverseChainedSingleSubTable ( lookupType , lookupFlags , subtableOffset ) ;
subtableFormat = readExtensionSubTable ( lookupType , lookupFlags , lookupSequence , subtableSequence , subtableOffset ) ;
extractSESubState ( GlyphTable . GLYPH_TABLE_TYPE_SUBSTITUTION , lookupType , lookupFlags , lookupSequence , subtableSequence , subtableFormat ) ;
log . debug ( "str" + df + "str" ) ;
log . debug ( "str" + n + "str" ) ;
return new GlyphPositioningTable . DeviceTable ( ss , es , da ) ;
xp = ttf . convertTTFUnit2PDFUnit ( in . readTTFShort ( ) ) ;
yp = ttf . convertTTFUnit2PDFUnit ( in . readTTFShort ( ) ) ;
xa = ttf . convertTTFUnit2PDFUnit ( in . readTTFShort ( ) ) ;
ya = ttf . convertTTFUnit2PDFUnit ( in . readTTFShort ( ) ) ;
xpd = readPosDeviceTable ( subtableOffset , xpdo ) ;
ypd = readPosDeviceTable ( subtableOffset , ypdo ) ;
xad = readPosDeviceTable ( subtableOffset , xado ) ;
yad = readPosDeviceTable ( subtableOffset , yado ) ;
return new GlyphPositioningTable . Value ( xp , yp , xa , ya , xpd , ypd , xad , yad ) ;
in . skip ( 2 ) ;
GlyphPositioningTable . Value v = readPosValue ( subtableOffset , vf ) ;
GlyphCoverageTable ct = readCoverageTable ( tableTag + "str" , subtableOffset + co ) ;
seEntries . add ( v ) ;
in . skip ( 2 ) ;
GlyphCoverageTable ct = readCoverageTable ( tableTag + "str" , subtableOffset + co ) ;
GlyphPositioningTable . Value pv = readPosValue ( subtableOffset , vf ) ;
seEntries . add ( pva ) ;
readSinglePosTableFormat1 ( lookupType , lookupFlags , subtableOffset , sf ) ;
readSinglePosTableFormat2 ( lookupType , lookupFlags , subtableOffset , sf ) ;
throw new AdvancedTypographicTableFormatException ( "str" + sf ) ;
v1 = readPosValue ( subtableOffset , vf1 ) ;
v2 = readPosValue ( subtableOffset , vf2 ) ;
return new GlyphPositioningTable . PairValues ( glyph , v1 , v2 ) ;
GlyphPositioningTable . PairValues pv = readPosPairValues ( subtableOffset , true , vf1 , vf2 ) ;
in . skip ( 2 ) ;
GlyphCoverageTable ct = readCoverageTable ( tableTag + "str" , subtableOffset + co ) ;
pvm [ i ] = readPosPairSetTable ( subtableOffset , pso , vf1 , vf2 ) ;
seEntries . add ( pvm ) ;
in . skip ( 2 ) ;
GlyphCoverageTable ct = readCoverageTable ( tableTag + "str" , subtableOffset + co ) ;
GlyphClassTable cdt1 = readClassDefTable ( tableTag + "str" , subtableOffset + cd1o ) ;
GlyphClassTable cdt2 = readClassDefTable ( tableTag + "str" , subtableOffset + cd2o ) ;
GlyphPositioningTable . PairValues pv = readPosPairValues ( subtableOffset , false , vf1 , vf2 ) ;
readPairPosTableFormat1 ( lookupType , lookupFlags , subtableOffset , sf ) ;
readPairPosTableFormat2 ( lookupType , lookupFlags , subtableOffset , sf ) ;
throw new AdvancedTypographicTableFormatException ( "str" + sf ) ;
int x = ttf . convertTTFUnit2PDFUnit ( in . readTTFShort ( ) ) ;
int x = ttf . convertTTFUnit2PDFUnit ( in . readTTFShort ( ) ) ;
int y = ttf . convertTTFUnit2PDFUnit ( in . readTTFShort ( ) ) ;
a = new GlyphPositioningTable . Anchor ( x , y , ap ) ;
int x = ttf . convertTTFUnit2PDFUnit ( in . readTTFShort ( ) ) ;
int y = ttf . convertTTFUnit2PDFUnit ( in . readTTFShort ( ) ) ;
xd = readPosDeviceTable ( cp , xdo ) ;
yd = readPosDeviceTable ( cp , ydo ) ;
a = new GlyphPositioningTable . Anchor ( x , y , xd , yd ) ;
throw new AdvancedTypographicTableFormatException ( "str" + af ) ;
in . skip ( 2 ) ;
GlyphCoverageTable ct = readCoverageTable ( tableTag + "str" , subtableOffset + co ) ;
ena = readPosAnchor ( subtableOffset + eno ) ;
exa = readPosAnchor ( subtableOffset + exo ) ;
seEntries . add ( aa ) ;
readCursivePosTableFormat1 ( lookupType , lookupFlags , subtableOffset , sf ) ;
throw new AdvancedTypographicTableFormatException ( "str" + sf ) ;
in . skip ( 2 ) ;
GlyphCoverageTable mct = readCoverageTable ( tableTag + "str" , subtableOffset + mco ) ;
GlyphCoverageTable bct = readCoverageTable ( tableTag + "str" , subtableOffset + bco ) ;
a = readPosAnchor ( subtableOffset + mao + ao ) ;
ma = new GlyphPositioningTable . MarkAnchor ( mc , a ) ;
a = readPosAnchor ( subtableOffset + bao + ao ) ;
readMarkToBasePosTableFormat1 ( lookupType , lookupFlags , subtableOffset , sf ) ;
throw new AdvancedTypographicTableFormatException ( "str" + sf ) ;
in . skip ( 2 ) ;
GlyphCoverageTable mct = readCoverageTable ( tableTag + "str" , subtableOffset + mco ) ;
GlyphCoverageTable lct = readCoverageTable ( tableTag + "str" , subtableOffset + lco ) ;
a = readPosAnchor ( subtableOffset + mao + ao ) ;
ma = new GlyphPositioningTable . MarkAnchor ( mc , a ) ;
in . seekSet ( subtableOffset + lao + lato ) ;
in . seekSet ( subtableOffset + lao + lato ) ;
a = readPosAnchor ( subtableOffset + lao + lato + ao ) ;
readMarkToLigaturePosTableFormat1 ( lookupType , lookupFlags , subtableOffset , sf ) ;
throw new AdvancedTypographicTableFormatException ( "str" + sf ) ;
in . skip ( 2 ) ;
GlyphCoverageTable mct1 = readCoverageTable ( tableTag + "str" , subtableOffset + m1co ) ;
GlyphCoverageTable mct2 = readCoverageTable ( tableTag + "str" , subtableOffset + m2co ) ;
a = readPosAnchor ( subtableOffset + m1ao + ao ) ;
ma = new GlyphPositioningTable . MarkAnchor ( mc , a ) ;
a = readPosAnchor ( subtableOffset + m2ao + ao ) ;
readMarkToMarkPosTableFormat1 ( lookupType , lookupFlags , subtableOffset , sf ) ;
throw new AdvancedTypographicTableFormatException ( "str" + sf ) ;
in . skip ( 2 ) ;
ct = readCoverageTable ( tableTag + "str" , subtableOffset + co ) ;
in . seekSet ( subtableOffset + rso ) ;
in . seekSet ( subtableOffset + rso + ro ) ;
rs = new GlyphTable . HomogeneousRuleSet ( ra ) ;
seEntries . add ( rsa ) ;
in . skip ( 2 ) ;
ct = readCoverageTable ( tableTag + "str" , subtableOffset + co ) ;
cdt = readClassDefTable ( tableTag + "str" , subtableOffset + cdo ) ;
in . seekSet ( subtableOffset + cso ) ;
in . seekSet ( subtableOffset + cso + ro ) ;
rs = new GlyphTable . HomogeneousRuleSet ( ra ) ;
in . skip ( 2 ) ;
gct = readCoverageTable ( tableTag + "str" + i + "str" , subtableOffset + gcoa [ i ] ) ;
GlyphTable . RuleLookup [ ] lookups = readRuleLookups ( nl , header ) ;
seEntries . add ( rsa ) ;
readContextualPosTableFormat1 ( lookupType , lookupFlags , subtableOffset , sf ) ;
readContextualPosTableFormat2 ( lookupType , lookupFlags , subtableOffset , sf ) ;
readContextualPosTableFormat3 ( lookupType , lookupFlags , subtableOffset , sf ) ;
throw new AdvancedTypographicTableFormatException ( "str" + sf ) ;
in . skip ( 2 ) ;
ct = readCoverageTable ( tableTag + "str" , subtableOffset + co ) ;
in . seekSet ( subtableOffset + rso ) ;
in . seekSet ( subtableOffset + rso + ro ) ;
rs = new GlyphTable . HomogeneousRuleSet ( ra ) ;
seEntries . add ( rsa ) ;
in . skip ( 2 ) ;
ct = readCoverageTable ( tableTag + "str" , subtableOffset + co ) ;
bcdt = readClassDefTable ( tableTag + "str" , subtableOffset + bcdo ) ;
icdt = readClassDefTable ( tableTag + "str" , subtableOffset + icdo ) ;
lcdt = readClassDefTable ( tableTag + "str" , subtableOffset + lcdo ) ;
in . seekSet ( subtableOffset + cso ) ;
in . seekSet ( subtableOffset + cso + ro ) ;
rs = new GlyphTable . HomogeneousRuleSet ( ra ) ;
in . skip ( 2 ) ;
bgct = readCoverageTable ( tableTag + "str" + i + "str" , subtableOffset + bgco ) ;
igct = readCoverageTable ( tableTag + "str" + i + "str" , subtableOffset + igco ) ;
lgct = readCoverageTable ( tableTag + "str" + i + "str" , subtableOffset + lgco ) ;
GlyphTable . RuleLookup [ ] lookups = readRuleLookups ( nl , header ) ;
seEntries . add ( rsa ) ;
readChainedContextualPosTableFormat1 ( lookupType , lookupFlags , subtableOffset , sf ) ;
readChainedContextualPosTableFormat2 ( lookupType , lookupFlags , subtableOffset , sf ) ;
readChainedContextualPosTableFormat3 ( lookupType , lookupFlags , subtableOffset , sf ) ;
throw new AdvancedTypographicTableFormatException ( "str" + sf ) ;
in . skip ( 2 ) ;
readGPOSSubtable ( lt , lookupFlags , lookupSequence , subtableSequence , subtableOffset + eo ) ;
readExtensionPosTableFormat1 ( lookupType , lookupFlags , lookupSequence , subtableSequence , subtableOffset , sf ) ;
throw new AdvancedTypographicTableFormatException ( "str" + sf ) ;
subtableFormat = readSinglePosTable ( lookupType , lookupFlags , subtableOffset ) ;
subtableFormat = readPairPosTable ( lookupType , lookupFlags , subtableOffset ) ;
subtableFormat = readCursivePosTable ( lookupType , lookupFlags , subtableOffset ) ;
subtableFormat = readMarkToBasePosTable ( lookupType , lookupFlags , subtableOffset ) ;
subtableFormat = readMarkToLigaturePosTable ( lookupType , lookupFlags , subtableOffset ) ;
subtableFormat = readMarkToMarkPosTable ( lookupType , lookupFlags , subtableOffset ) ;
subtableFormat = readContextualPosTable ( lookupType , lookupFlags , subtableOffset ) ;
subtableFormat = readChainedContextualPosTable ( lookupType , lookupFlags , subtableOffset ) ;
subtableFormat = readExtensionPosTable ( lookupType , lookupFlags , lookupSequence , subtableSequence , subtableOffset ) ;
extractSESubState ( GlyphTable . GLYPH_TABLE_TYPE_POSITIONING , lookupType , lookupFlags , lookupSequence , subtableSequence , subtableFormat ) ;
lts = GSUBLookupType . toString ( lt ) ;
lts = GPOSLookupType . toString ( lt ) ;
log . debug ( tableTag + "str" + lf + "str" + LookupFlag . toString ( lf ) + "str" ) ;
readGSUBSubtable ( lt , lf , lookupSequence , i , lookupTable + so ) ;
readGPOSSubtable ( lt , lf , lookupSequence , i , lookupTable + so ) ;
readLookupTable ( tableTag , i , lookupList + loa [ i ] ) ;
readScriptList ( tableTag , scriptList ) ;
readFeatureList ( tableTag , featureList ) ;
readLookupList ( tableTag , lookupList ) ;
GlyphClassTable ct = readClassDefTable ( tableTag + "str" , subtableOffset ) ;
extractSESubState ( GlyphTable . GLYPH_TABLE_TYPE_DEFINITION , GDEFLookupType . GLYPH_CLASS , 0 , lookupSequence , 0 , 1 ) ;
GlyphCoverageTable ct = readCoverageTable ( tableTag + "str" , subtableOffset + co ) ;
extractSESubState ( GlyphTable . GLYPH_TABLE_TYPE_DEFINITION , GDEFLookupType . ATTACHMENT_POINT , 0 , lookupSequence , 0 , 1 ) ;
GlyphCoverageTable ct = readCoverageTable ( tableTag + "str" , subtableOffset + co ) ;
extractSESubState ( GlyphTable . GLYPH_TABLE_TYPE_DEFINITION , GDEFLookupType . LIGATURE_CARET , 0 , lookupSequence , 0 , 1 ) ;
GlyphClassTable ct = readClassDefTable ( tableTag + "str" , subtableOffset ) ;
extractSESubState ( GlyphTable . GLYPH_TABLE_TYPE_DEFINITION , GDEFLookupType . MARK_ATTACHMENT , 0 , lookupSequence , 0 , 1 ) ;
in . skip ( 2 ) ;
msca [ i ] = readCoverageTable ( tableTag + "str" + i + "str" , subtableOffset + mso [ i ] ) ;
GlyphClassTable ct = GlyphClassTable . createClassTable ( Arrays . asList ( msca ) ) ;
extractSESubState ( GlyphTable . GLYPH_TABLE_TYPE_DEFINITION , GDEFLookupType . MARK_ATTACHMENT , 0 , lookupSequence , 0 , 1 ) ;
readGDEFMarkGlyphsTableFormat1 ( tableTag , lookupSequence , subtableOffset , sf ) ;
throw new AdvancedTypographicTableFormatException ( "str" + sf ) ;
readGDEFClassDefTable ( tableTag , seqno + + , to + cdo ) ;
readGDEFAttachmentTable ( tableTag , seqno + + , to + apo ) ;
readGDEFLigatureCaretTable ( tableTag , seqno + + , to + lco ) ;
readGDEFMarkAttachmentTable ( tableTag , seqno + + , to + mao ) ;
readGDEFMarkGlyphsTable ( tableTag , seqno + + , to + mgo ) ;
TTFDirTabEntry dirTab = ttf . getDirectoryEntry ( tableTag ) ;
readCommonLayoutTables ( tableTag , to + slo , to + flo , to + llo ) ;
TTFDirTabEntry dirTab = ttf . getDirectoryEntry ( tableTag ) ;
readCommonLayoutTables ( tableTag , to + slo , to + flo , to + llo ) ;
gdef = new GlyphDefinitionTable ( subtables ) ;
gsub = new GlyphSubstitutionTable ( gdef , lookups , subtables ) ;
gpos = new GlyphPositioningTable ( gdef , lookups , subtables ) ;
private void constructLookupsFeatures ( Map lookups , String st , String lt , List fids ) {
constructLookupsFeature ( lookups , st , lt , fid ) ;
constructLookupsFeature ( lookups , st , lt , ( String ) lp [ 0 ] ) ;
constructLookupsFeatures ( lookups , st , lt , ( List ) lp [ 1 ] ) ;
private void constructLookupsLanguages ( Map lookups , String st , List ll , Map languages ) {
constructLookupsLanguage ( lookups , st , lt , languages ) ;
Object [ ] sp = ( Object [ ] ) seScripts . get ( st ) ;
constructLookupsLanguage ( lookups , st , ( String ) sp [ 0 ] , languages ) ;
constructLookupsLanguages ( lookups , st , ( List ) sp [ 1 ] , languages ) ;
private GlyphSubtable constructGDEFSubtable ( Object [ ] stp ) {
int type = GDEFLookupType . getSubtableType ( lt . intValue ( ) ) ;
st = GlyphDefinitionTable . createSubtable ( type , lid , sequence , flags , format , mapping , entries ) ;
private GlyphSubtable constructGSUBSubtable ( Object [ ] stp ) {
int type = GSUBLookupType . getSubtableType ( lt . intValue ( ) ) ;
st = GlyphSubstitutionTable . createSubtable ( type , lid , sequence , flags , format , coverage , entries ) ;
private GlyphSubtable constructGPOSSubtable ( Object [ ] stp ) {
int type = GSUBLookupType . getSubtableType ( lt . intValue ( ) ) ;
st = GlyphPositioningTable . createSubtable ( type , lid , sequence , flags , format , coverage , entries ) ;
private void extractSESubState ( int tableType , int lookupType , int lookupFlags , int lookupSequence , int subtableSequence , int subtableFormat ) {
private String toString ( int [ ] ia ) {
sb . append ( "str" ) ;
sb . append ( "str" ) ;
sb . append ( ia [ i ] ) ;
RtfAttributes attr = new RtfAttributes ( ) ;
RtfParagraph p = sect . newParagraph ( attr ) ;
p . newText ( "str" ) ;
attr = new RtfAttributes ( ) ;
p = sect . newParagraph ( attr ) ;
p . newText ( "str" ) ;
attr = new RtfAttributes ( ) ;
p = sect . newParagraph ( attr ) ;
p . newText ( "str" ) ;
public boolean isDelimitedTextRangeBoundary ( int boundary ) {
protected Stack collectDelimitedTextRanges ( Stack ranges , DelimitedTextRange currentRange ) {
currentRange . append ( CharUtilities . OBJECT_REPLACEMENT_CHARACTER , this ) ;
int [ ] [ ] performPositioning ( CharSequence cs , String script , String language , int fontSize ) ;
int [ ] [ ] performPositioning ( CharSequence cs , String script , String language ) ;
CharSequence performSubstitution ( CharSequence cs , String script , String language ) ;
CharSequence reorderCombiningMarks ( CharSequence cs , int [ ] [ ] gpa , String script , String language ) ;
public void setBidiLevel ( int bidiLevel ) {
public void setTraits ( Map traits ) {
RtfParagraph p = sect . newParagraph ( ) ;
p = sect . newParagraph ( ) ;
p . newText ( "str" ) ;
return GlyphDefinitionTable . getLookupTypeName ( getType ( ) ) ;
public boolean hasDefinition ( int gi ) {
if ( cvm . getCoverageIndex ( gi ) > = 0 ) {
if ( clm . getClassIndex ( gi , 0 ) > = 0 ) {
sb . setCharAt ( i , ( char ) mirror ( sb . charAt ( i ) ) ) ;
public GlyphSequence ( IntBuffer characters , IntBuffer glyphs , List associations , boolean predications ) {
characters = IntBuffer . allocate ( DEFAULT_CHARS_CAPACITY ) ;
glyphs = IntBuffer . allocate ( characters . capacity ( ) ) ;
associations = makeIdentityAssociations ( characters . limit ( ) , glyphs . limit ( ) ) ;
public GlyphSequence ( IntBuffer characters , IntBuffer glyphs , List associations ) {
public int [ ] getCharacterArray ( boolean copy ) {
return toArray ( characters ) ;
public void setGlyph ( int index , int gi ) throws IndexOutOfBoundsException {
glyphs . put ( index , gi ) ;
public int [ ] getGlyphs ( int offset , int count ) {
ga [ k + + ] = glyphs . get ( i ) ;
public int [ ] getGlyphArray ( boolean copy ) {
return toArray ( glyphs ) ;
public CharAssociation [ ] getAssociations ( int offset , int count ) {
aa [ k + + ] = ( CharAssociation ) associations . get ( i ) ;
public void setPredications ( boolean enable ) {
public void setPredication ( int offset , String key , Object value ) {
CharAssociation [ ] aa = getAssociations ( offset , 1 ) ;
ca . setPredication ( key , value ) ;
public Object getPredication ( int offset , String key ) {
CharAssociation [ ] aa = getAssociations ( offset , 1 ) ;
return ca . getPredication ( key ) ;
public int compareGlyphs ( IntBuffer gb ) {
public static boolean sameGlyphs ( int [ ] ga1 , int [ ] ga2 ) {
public static IntBuffer concatGlyphs ( int [ ] bga , int [ ] iga , int [ ] lga ) {
IntBuffer gb = IntBuffer . allocate ( ng ) ;
gb . put ( bga ) ;
gb . put ( iga ) ;
gb . put ( lga ) ;
public static List concatAssociations ( CharAssociation [ ] baa , CharAssociation [ ] iaa , CharAssociation [ ] laa ) {
List gl = new ArrayList ( na ) ;
gl . add ( baa [ i ] ) ;
gl . add ( iaa [ i ] ) ;
gl . add ( laa [ i ] ) ;
public static GlyphSequence join ( GlyphSequence gs , GlyphSequence [ ] sa ) {
return new GlyphSequence ( gs . getCharacters ( ) , uga , ual , gs . getPredications ( ) ) ;
public static GlyphSequence reorder ( GlyphSequence gs , int source , int count , int target ) {
int [ ] ga = gs . getGlyphArray ( false ) ;
GlyphSequence . CharAssociation [ ] aa = gs . getAssociations ( 0 , ng ) ;
return new GlyphSequence ( gs , null , nga , null , null , naa , null ) ;
private static int [ ] toArray ( IntBuffer ib ) {
ib . get ( ia , 0 , n ) ;
private static List makeIdentityAssociations ( int numChars , int numGlyphs ) {
List av = new ArrayList ( ng ) ;
av . add ( new CharAssociation ( i , ( k = = nc ) ? 0 : 1 ) ) ;
private static IntBuffer copyBuffer ( IntBuffer ib ) {
private static List copyAssociations ( List ca ) {
return new ArrayList ( ca ) ;
Object merge ( String key , Object v1 , Object v2 ) ;
public CharAssociation ( int offset , int count , int [ ] subIntervals ) {
public CharAssociation ( int offset , int count ) {
public boolean contained ( int offset , int count ) {
public void setPredication ( String key , Object value ) {
predications . put ( key , value ) ;
public Object getPredication ( String key ) {
return predications . get ( key ) ;
public void mergePredication ( String key , Object value ) {
predications . put ( key , mergePredicationValues ( key , v1 , v2 ) ) ;
predications . put ( key , value ) ;
return pm . merge ( key , v1 , v2 ) ;
public void mergePredications ( CharAssociation ca ) {
mergePredication ( e . getKey ( ) , e . getValue ( ) ) ;
ca . predications = new HashMap < String , Object > ( predications ) ;
public static void setPredicationMerger ( String key , PredicationMerger pm ) {
predicationMergers . put ( key , pm ) ;
public static PredicationMerger getPredicationMerger ( String key ) {
return predicationMergers . get ( key ) ;
public static CharAssociation [ ] replicate ( CharAssociation a , int repeat ) {
public static CharAssociation join ( CharAssociation [ ] aa ) {
int [ ] ia = extractIntervals ( aa ) ;
ca = new CharAssociation ( 0 , 0 ) ;
ca = new CharAssociation ( s , e - s ) ;
ca = new CharAssociation ( mergeIntervals ( ia ) ) ;
return mergePredicates ( ca , aa ) ;
private static CharAssociation mergePredicates ( CharAssociation ca , CharAssociation [ ] aa ) {
ca . mergePredications ( a ) ;
private static int getSubIntervalsStart ( int [ ] ia ) {
private static int getSubIntervalsLength ( int [ ] ia ) {
private static int [ ] extractIntervals ( CharAssociation [ ] aa ) {
return sortIntervals ( sa , ea ) ;
private static int [ ] sortIntervals ( int [ ] sa , int [ ] ea ) {
private static int [ ] mergeIntervals ( int [ ] ia ) {
viewportBlockArea . setBidiLevel ( level ) ;
referenceArea . setBidiLevel ( level ) ;
init ( ) ;
public static RtfFontManager getInstance ( ) {
instance = new RtfFontManager ( ) ;
private void init ( ) {
public int getFontNumber ( String family ) {
addFont ( family ) ;
int len = fontTable . size ( ) ;
header . write ( "str" + ( String ) fontTable . elementAt ( i ) ) ;
public boolean isDelimitedTextRangeBoundary ( int boundary ) {
writeAttributes ( attrib , ITableAttributes . CELL_COLOR ) ;
writeAttributes ( attrib , ITableAttributes . CELL_VERT_ALIGN ) ;
public void setInlineAreas ( List inlineAreas ) {
ia . setParentArea ( this ) ;
return GlyphSubstitutionTable . getLookupTypeName ( getType ( ) ) ;
public boolean isCompatible ( GlyphSubtable subtable ) {
public boolean substitute ( GlyphSubstitutionState ss ) {
public static final GlyphSequence substitute ( GlyphSubstitutionState ss , GlyphSubstitutionSubtable [ ] sta , int sequenceIndex ) {
applied = ss . apply ( sta [ i ] ) ;
applied = ss . apply ( sta [ i ] ) ;
public static final GlyphSequence substitute ( GlyphSequence gs , String script , String language , String feature , GlyphSubstitutionSubtable [ ] sta , ScriptContextTester sct ) {
return substitute ( state . reset ( gs , script , language , feature , sct ) , sta , - 1 ) ;
fail ( e . getMessage ( ) ) ;
this . wmTraits = WritingModeTraits . getWritingModeTraitsGetter ( table ) ;
return getKernValue ( ( char ) ch1 , ( char ) ch2 ) ;
return getCharWidth ( ( char ) c ) ;
public CharSequence performSubstitution ( CharSequence cs , String script , String language ) {
return s . performSubstitution ( cs , script , language ) ;
public CharSequence reorderCombiningMarks ( CharSequence cs , int [ ] [ ] gpa , String script , String language ) {
return s . reorderCombiningMarks ( cs , gpa , script , language ) ;
public int [ ] [ ] performPositioning ( CharSequence cs , String script , String language , int fontSize ) {
return p . performPositioning ( cs , script , language , fontSize ) ;
private void copyAdvanced ( TTFFile ttf ) {
boolean test ( int gi , int flags ) ;
args . add ( p ) ;
throw new PropertyException ( "str" + i ) ;
args . add ( function . getOptionalArgDefault ( i , propInfo ) ) ;
return ( Property [ ] ) args . toArray ( new Property [ args . size ( ) ] ) ;
public void setAlternates ( int [ ] alternates ) {
public int getAlternatesIndex ( int ci ) {
public void putGlyph ( int glyph , GlyphSequence . CharAssociation a , Object predication ) {
ogb = growBuffer ( ogb ) ;
ogb . put ( glyph ) ;
a . setPredication ( feature , predication ) ;
oal . add ( a ) ;
public void putGlyphs ( int [ ] glyphs , GlyphSequence . CharAssociation [ ] associations , Object predication ) {
putGlyph ( glyphs [ i ] , associations [ i ] , predication ) ;
ogb . limit ( position ) ;
return new GlyphSequence ( igs . getCharacters ( ) , ogb , oal ) ;
public boolean apply ( GlyphSubstitutionSubtable st ) {
public boolean apply ( GlyphTable . RuleLookup [ ] lookups , int nig ) {
GlyphSubstitutionState ss = new GlyphSubstitutionState ( this ) ;
GlyphSequence gs = lt . substitute ( ss , l . getSequenceIndex ( ) ) ;
if ( replaceInput ( 0 , - 1 , gs ) ) {
putGlyphs ( getGlyphs ( 0 , nog , false , null , null , null ) , getAssociations ( 0 , nog , false , null , null , null ) , null ) ;
consume ( nog ) ;
putGlyph ( gi , getAssociation ( ) , null ) ;
private static IntBuffer growBuffer ( IntBuffer ib ) {
IntBuffer ibNew = IntBuffer . allocate ( capacityNew ) ;
return ibNew . put ( ib ) ;
public static void resolveInlineDirectionality ( PageSequence ps ) {
log . debug ( "str" + ps ) ;
public static void reorder ( LineArea la ) {
List runs = collectRuns ( la . getInlineAreas ( ) , new Vector ( ) ) ;
dumpRuns ( "str" , runs ) ;
runs = splitRuns ( runs ) ;
dumpRuns ( "str" , runs ) ;
int [ ] mm = computeMinMaxLevel ( runs , null ) ;
runs = reorderRuns ( runs , l1 ) ;
dumpRuns ( "str" , runs ) ;
reverseWords ( runs , mirror ) ;
dumpRuns ( "str" , runs ) ;
replaceInlines ( la , replicateSplitWords ( runs ) ) ;
private static void resolveInlineDirectionality ( List ranges ) {
log . debug ( r ) ;
private static List collectRuns ( List inlines , List runs ) {
runs = ia . collectInlineRuns ( runs ) ;
private static List splitRuns ( List runs ) {
runsNew . add ( ir ) ;
runsNew . addAll ( ir . split ( ) ) ;
if ( ! runsNew . equals ( runs ) ) {
private static int [ ] computeMinMaxLevel ( List runs , int [ ] mm ) {
ir . updateMinMax ( mm ) ;
private static List reorderRuns ( List runs , int level ) {
runsNew . add ( iri ) ;
runsNew . addAll ( reverseRuns ( runs , s , e ) ) ;
if ( ! runsNew . equals ( runs ) ) {
private static List reverseRuns ( List runs , int s , int e ) {
Vector runsNew = new Vector ( n ) ;
runsNew . add ( ir ) ;
private static void reverseWords ( List runs , boolean mirror ) {
ir . maybeReverseWord ( mirror ) ;
private static List replicateSplitWords ( List runs ) {
private static void replaceInlines ( LineArea la , List runs ) {
inlines . add ( ir . getInline ( ) ) ;
la . setInlineAreas ( unflattenInlines ( inlines ) ) ;
log . debug ( ir ) ;
private static List pruneEmptyRanges ( Stack ranges ) {
rv . add ( r ) ;
List < FontTriplet > foundTriplets = new ArrayList < FontTriplet > ( ) ;
void setRtfExternalGraphicCompressionRate ( int percent ) ;
int getRtfExternalGraphicCompressionRate ( ) ;
throw new AdvancedTypographicTableFormatException ( "str" ) ;
addSubtable ( ( GlyphSubtable ) o ) ;
throw new AdvancedTypographicTableFormatException ( "str" ) ;
public GlyphSequence substitute ( GlyphSequence gs , String script , String language ) {
Map lookups = matchLookups ( script , language , "str" ) ;
public static int getLookupTypeFromName ( String name ) {
if ( "str" . equals ( s ) ) {
} else if ( "str" . equals ( s ) ) {
} else if ( "str" . equals ( s ) ) {
} else if ( "str" . equals ( s ) ) {
} else if ( "str" . equals ( s ) ) {
} else if ( "str" . equals ( s ) ) {
} else if ( "str" . equals ( s ) ) {
} else if ( "str" . equals ( s ) ) {
public static String getLookupTypeName ( int type ) {
public static GlyphSubtable createSubtable ( int type , String id , int sequence , int flags , int format , GlyphCoverageTable coverage , List entries ) {
st = SingleSubtable . create ( id , sequence , flags , format , coverage , entries ) ;
st = MultipleSubtable . create ( id , sequence , flags , format , coverage , entries ) ;
st = AlternateSubtable . create ( id , sequence , flags , format , coverage , entries ) ;
st = LigatureSubtable . create ( id , sequence , flags , format , coverage , entries ) ;
st = ContextualSubtable . create ( id , sequence , flags , format , coverage , entries ) ;
st = ChainedContextualSubtable . create ( id , sequence , flags , format , coverage , entries ) ;
st = ReverseChainedSingleSubtable . create ( id , sequence , flags , format , coverage , entries ) ;
public boolean isCompatible ( GlyphSubtable subtable ) {
public boolean substitute ( GlyphSubstitutionState ss ) {
if ( ( ci = getCoverageIndex ( gi ) ) < 0 ) {
int go = getGlyphForCoverageIndex ( ci , gi ) ;
ss . putGlyph ( go , ss . getAssociation ( ) , Boolean . TRUE ) ;
return new SingleSubtableFormat1 ( id , sequence , flags , format , coverage , entries ) ;
return new SingleSubtableFormat2 ( id , sequence , flags , format , coverage , entries ) ;
public int getGlyphForCoverageIndex ( int ci , int gi ) throws IllegalArgumentException {
throw new IllegalArgumentException ( "str" + ci + "str" + ciMax ) ;
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + o ) ;
List entries = new ArrayList ( glyphs . length ) ;
entries . add ( Integer . valueOf ( glyphs [ i ] ) ) ;
public int getGlyphForCoverageIndex ( int ci , int gi ) throws IllegalArgumentException {
throw new IllegalArgumentException ( "str" + ci + "str" + glyphs . length ) ;
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" + gid ) ;
throw new AdvancedTypographicTableFormatException ( "str" + o ) ;
public boolean isCompatible ( GlyphSubtable subtable ) {
public boolean substitute ( GlyphSubstitutionState ss ) {
if ( ( ci = getCoverageIndex ( gi ) ) < 0 ) {
int [ ] ga = getGlyphsForCoverageIndex ( ci , gi ) ;
ss . putGlyphs ( ga , GlyphSequence . CharAssociation . replicate ( ss . getAssociation ( ) , ga . length ) , Boolean . TRUE ) ;
return new MultipleSubtableFormat1 ( id , sequence , flags , format , coverage , entries ) ;
public int [ ] getGlyphsForCoverageIndex ( int ci , int gi ) throws IllegalArgumentException {
throw new IllegalArgumentException ( "str" + ci + "str" + gsa . length ) ;
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + entries . size ( ) + "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
public boolean isCompatible ( GlyphSubtable subtable ) {
public boolean substitute ( GlyphSubstitutionState ss ) {
if ( ( ci = getCoverageIndex ( gi ) ) < 0 ) {
ss . putGlyph ( go , ss . getAssociation ( ) , Boolean . TRUE ) ;
return new AlternateSubtableFormat1 ( id , sequence , flags , format , coverage , entries ) ;
List entries = new ArrayList ( gaa . length ) ;
entries . add ( gaa [ i ] ) ;
public int [ ] getAlternatesForCoverageIndex ( int ci , int gi ) throws IllegalArgumentException {
throw new IllegalArgumentException ( "str" + ci + "str" + gaa . length ) ;
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" + o ) ;
public boolean isCompatible ( GlyphSubtable subtable ) {
public boolean substitute ( GlyphSubstitutionState ss ) {
if ( ( ci = getCoverageIndex ( gi ) ) < 0 ) {
LigatureSet ls = getLigatureSetForCoverageIndex ( ci , gi ) ;
int [ ] counts = ss . getGlyphsAvailable ( 0 , reverse , ignores ) ;
ss . getGlyphs ( 0 , nmg , reverse , ignores , null , counts ) ;
GlyphSequence . CharAssociation [ ] laa = ss . getAssociations ( 0 , nga ) ;
ss . putGlyph ( go , GlyphSequence . CharAssociation . join ( laa ) , Boolean . TRUE ) ;
ss . putGlyphs ( ss . getIgnoredGlyphs ( 0 , ngi ) , ss . getIgnoredAssociations ( 0 , ngi ) , null ) ;
ss . consume ( nga + ngi ) ;
private Ligature findLigature ( LigatureSet ls , int [ ] glyphs ) {
if ( l . matchesComponents ( glyphs ) ) {
return new LigatureSubtableFormat1 ( id , sequence , flags , format , coverage , entries ) ;
List entries = new ArrayList ( ligatureSets . length ) ;
entries . add ( ligatureSets [ i ] ) ;
public LigatureSet getLigatureSetForCoverageIndex ( int ci , int gi ) throws IllegalArgumentException {
throw new IllegalArgumentException ( "str" + ci + "str" + ligatureSets . length ) ;
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" + o ) ;
public boolean isCompatible ( GlyphSubtable subtable ) {
public boolean substitute ( GlyphSubstitutionState ss ) {
if ( ( ci = getCoverageIndex ( gi ) ) < 0 ) {
RuleLookup [ ] la = getLookups ( ci , gi , ss , rv ) ;
ss . apply ( la , rv [ 0 ] ) ;
return new ContextualSubtableFormat1 ( id , sequence , flags , format , coverage , entries ) ;
return new ContextualSubtableFormat2 ( id , sequence , flags , format , coverage , entries ) ;
return new ContextualSubtableFormat3 ( id , sequence , flags , format , coverage , entries ) ;
public RuleLookup [ ] getLookups ( int ci , int gi , GlyphSubstitutionState ss , int [ ] rv ) {
static boolean matches ( GlyphSubstitutionState ss , int [ ] glyphs , int offset , int [ ] rv ) {
int [ ] counts = ss . getGlyphsAvailable ( offset , reverse , ignores ) ;
int [ ] ga = ss . getGlyphs ( offset , ngm , reverse , ignores , null , counts ) ;
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + entries . size ( ) + "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
public RuleLookup [ ] getLookups ( int ci , int gi , GlyphSubstitutionState ss , int [ ] rv ) {
static boolean matches ( GlyphSubstitutionState ss , GlyphClassTable cdt , int [ ] classes , int offset , int [ ] rv ) {
int [ ] counts = ss . getGlyphsAvailable ( offset , reverse , ignores ) ;
int [ ] ga = ss . getGlyphs ( offset , ngm , reverse , ignores , null , counts ) ;
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + entries . size ( ) + "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + rsa . length + "str" + ngc + "str" ) ;
public RuleLookup [ ] getLookups ( int ci , int gi , GlyphSubstitutionState ss , int [ ] rv ) {
if ( matches ( ss , gca , 0 , rv ) ) {
static boolean matches ( GlyphSubstitutionState ss , GlyphCoverageTable [ ] gca , int offset , int [ ] rv ) {
int [ ] counts = ss . getGlyphsAvailable ( offset , reverse , ignores ) ;
int [ ] ga = ss . getGlyphs ( offset , ngm , reverse , ignores , null , counts ) ;
if ( ct . getCoverageIndex ( ga [ k ] ) < 0 ) {
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + entries . size ( ) + "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
public boolean isCompatible ( GlyphSubtable subtable ) {
public boolean substitute ( GlyphSubstitutionState ss ) {
if ( ( ci = getCoverageIndex ( gi ) ) < 0 ) {
RuleLookup [ ] la = getLookups ( ci , gi , ss , rv ) ;
ss . apply ( la , rv [ 0 ] ) ;
return new ChainedContextualSubtableFormat1 ( id , sequence , flags , format , coverage , entries ) ;
return new ChainedContextualSubtableFormat2 ( id , sequence , flags , format , coverage , entries ) ;
return new ChainedContextualSubtableFormat3 ( id , sequence , flags , format , coverage , entries ) ;
public RuleLookup [ ] getLookups ( int ci , int gi , GlyphSubstitutionState ss , int [ ] rv ) {
if ( matches ( ss , bga , - 1 , null ) ) {
if ( matches ( ss , lga , rv [ 0 ] , null ) ) {
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + entries . size ( ) + "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
public RuleLookup [ ] getLookups ( int ci , int gi , GlyphSubstitutionState ss , int [ ] rv ) {
if ( matches ( ss , bcdt , bca , - 1 , null ) ) {
if ( matches ( ss , lcdt , lca , rv [ 0 ] , null ) ) {
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + entries . size ( ) + "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + o . getClass ( ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + o . getClass ( ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + rsa . length + "str" + ngc + "str" ) ;
public RuleLookup [ ] getLookups ( int ci , int gi , GlyphSubstitutionState ss , int [ ] rv ) {
if ( matches ( ss , igca , 0 , rv ) ) {
if ( matches ( ss , bgca , - 1 , null ) ) {
if ( matches ( ss , lgca , rv [ 0 ] , null ) ) {
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + entries . size ( ) + "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
public boolean isCompatible ( GlyphSubtable subtable ) {
static GlyphSubstitutionSubtable create ( String id , int sequence , int flags , int format , GlyphCoverageTable coverage , List entries ) {
return new ReverseChainedSingleSubtableFormat1 ( id , sequence , flags , format , coverage , entries ) ;
private void populate ( List entries ) {
public Ligature ( int ligature , int [ ] components ) {
throw new AdvancedTypographicTableFormatException ( "str" + ligature ) ;
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + gc ) ;
public boolean matchesComponents ( int [ ] glyphs ) {
public LigatureSet ( Ligature [ ] ligatures ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
return new DevanagariScriptProcessor ( script ) ;
return new GujaratiScriptProcessor ( script ) ;
return new GurmukhiScriptProcessor ( script ) ;
return new IndicScriptProcessor ( script ) ;
public GlyphSequence substitute ( GlyphSequence gs , String script , String language , GlyphTable . UseSpec [ ] usa , ScriptContextTester sct ) {
GlyphSequence [ ] sa = syllabize ( gs , script , language ) ;
s = reorderPreBaseMatra ( s ) ;
s = reorderReph ( s ) ;
return unsyllabize ( gs , sa ) ;
basicShapingFeatures . add ( s ) ;
private boolean isBasicShapingUse ( GlyphTable . UseSpec us ) {
return basicShapingFeatures . contains ( us . getFeature ( ) ) ;
presentationFeatures . add ( s ) ;
private boolean isPresentationUse ( GlyphTable . UseSpec us ) {
return presentationFeatures . contains ( us . getFeature ( ) ) ;
private GlyphSequence reorderPreBaseMatra ( GlyphSequence gs ) {
if ( ( source = findPreBaseMatra ( gs ) ) > = 0 ) {
if ( ( target = findPreBaseMatraTarget ( gs , source ) ) > = 0 ) {
gs = reorder ( gs , source , target ) ;
protected int findPreBaseMatra ( GlyphSequence gs ) {
protected int findPreBaseMatraTarget ( GlyphSequence gs , int source ) {
private GlyphSequence reorderReph ( GlyphSequence gs ) {
if ( ( source = findReph ( gs ) ) > = 0 ) {
if ( ( target = findRephTarget ( gs , source ) ) > = 0 ) {
gs = reorder ( gs , source , target ) ;
protected int findReph ( GlyphSequence gs ) {
protected int findRephTarget ( GlyphSequence gs , int source ) {
Syllabizer ( String script , String language ) {
abstract GlyphSequence [ ] syllabize ( GlyphSequence gs ) ;
public boolean equals ( Object o ) {
if ( ! s . script . equals ( script ) ) {
} else if ( ! s . language . equals ( language ) ) {
public int compareTo ( Object o ) {
syllabizers . put ( sid , s ) ;
static String makeSyllabizerId ( String script , String language ) {
static Syllabizer makeSyllabizer ( String script , String language , Class < ? extends Syllabizer > syllabizerClass ) {
return segmentize ( gs , segmentize ( ca , nc ) ) ;
if ( ( i = findStartOfSyllable ( ca , s , e ) ) > s ) {
sv . add ( new Segment ( s , i , Segment . OTHER ) ) ;
sv . add ( new Segment ( s , e , Segment . OTHER ) ) ;
if ( ( i = findEndOfSyllable ( ca , s , e ) ) > s ) {
sv . add ( new Segment ( s , i , Segment . SYLLABLE ) ) ;
sv . add ( new Segment ( s , e , Segment . OTHER ) ) ;
return sv . toArray ( new Segment [ sv . size ( ) ] ) ;
protected GlyphSequence [ ] segmentize ( GlyphSequence gs , Segment [ ] sa ) {
nsv . add ( new GlyphSequence ( gs , null , toIntArray ( ngv ) , null , null , nav . toArray ( new GlyphSequence . CharAssociation [ nav . size ( ) ] ) , null ) ) ;
return nsv . toArray ( new GlyphSequence [ nsv . size ( ) ] ) ;
protected int findStartOfSyllable ( int [ ] ca , int s , int e ) {
protected int findEndOfSyllable ( int [ ] ca , int s , int e ) {
private static int [ ] toIntArray ( Vector < Integer > iv ) {
ia [ i ] = ( int ) iv . get ( i ) ;
Segment ( int start , int end , int type ) {
int getCoverageIndex ( int gid ) ;
super ( container , writer ) ;
super ( container , writer , attributes ) ;
private void computeImageSize ( ) {
private void writeSizeInfo ( ) throws IOException {
tmpUrl = new URL ( urlString ) ;
tmpUrl = new File ( urlString ) . toURI ( ) . toURL ( ) ;
public int getCompressionRate ( ) {
public boolean setCompressionRate ( int percent ) {
public boolean isDelimitedTextRangeBoundary ( int boundary ) {
public void setBidiLevel ( int level , int start , int end ) {
( ( FObj ) parent ) . setBidiLevel ( level ) ;
public int [ ] getBidiLevels ( int start , int end ) {
public int bidiLevelAt ( int position ) throws IndexOutOfBoundsException {
public void addMapping ( int start , int end , CharSequence mappedChars ) {
mappings . put ( new MapRange ( start , end ) , mappedChars . toString ( ) ) ;
public String getMapping ( int start , int end ) {
return ( String ) mappings . get ( new MapRange ( start , end ) ) ;
public int getMappingLength ( int start , int end ) {
return ( ( String ) mappings . get ( new MapRange ( start , end ) ) ) . length ( ) ;
System . arraycopy ( la , 0 , ma , 0 , la . length ) ;
System . arraycopy ( la , 0 , ma , 0 , ma . length ) ;
return getBidiLevels ( start , end ) ;
protected Stack collectDelimitedTextRanges ( Stack ranges , DelimitedTextRange currentRange ) {
currentRange . append ( charIterator ( ) , this ) ;
public boolean equals ( Object o ) {
public boolean isDelimitedTextRangeBoundary ( int boundary ) {
int [ ] dx = IFUtil . convertDPToDX ( dp ) ;
protected int findPreBaseMatra ( GlyphSequence gs ) {
if ( containsPreBaseMatra ( gs , k ) ) {
protected int findPreBaseMatraTarget ( GlyphSequence gs , int source ) {
if ( isPreM ( ca [ i ] ) ) {
if ( isC ( ca [ i ] ) ) {
protected int findReph ( GlyphSequence gs ) {
if ( containsReph ( gs , i ) ) {
protected int findRephTarget ( GlyphSequence gs , int source ) {
if ( containsMatra ( gs , i ) & & ! containsPreBaseMatra ( gs , i ) ) {
} else if ( containsOtherMark ( gs , i ) ) {
if ( isM ( ca [ i ] ) ) {
switch ( typeOf ( ca [ i ] ) ) {
protected int findStartOfSyllable ( int [ ] ca , int s , int e ) {
if ( isC ( c ) ) {
protected int findEndOfSyllable ( int [ ] ca , int s , int e ) {
while ( ( i = isDeadConsonant ( ca , s , e ) ) > s ) {
if ( ( i = isLiveConsonant ( ca , s , e ) ) > s ) {
private int isDeadConsonant ( int [ ] ca , int s , int e ) {
if ( isC ( c ) ) {
if ( isN ( c ) ) {
if ( isH ( c ) ) {
private int isLiveConsonant ( int [ ] ca , int s , int e ) {
if ( isC ( c ) ) {
} else if ( isV ( c ) ) {
if ( isN ( c ) ) {
if ( isX ( c ) ) {
if ( isH ( c ) ) {
return typeOf ( c ) = = t ;
switch ( typeOf ( c ) ) {
public static void main ( String [ ] args ) {
protected Stack collectDelimitedTextRanges ( Stack ranges , DelimitedTextRange currentRange ) {
ranges = super . collectDelimitedTextRanges ( ranges , currentRange ) ;
currentRange . append ( CharUtilities . OBJECT_REPLACEMENT_CHARACTER , this ) ;
public Rectangle getViewportRectangle ( FODimension reldims ) {
public RtfAttributes set ( RtfAttributes attrs ) {
Integer value = ( Integer ) attrs . getValue ( name ) ;
set ( name ) ;
set ( name , value . intValue ( ) ) ;
String value = ( String ) attrs . getValue ( name ) ;
set ( name ) ;
set ( name , value ) ;
set ( name ) ;
if ( Math . abs ( alg . getIPDdifference ( ) ) > 1 ) {
public boolean isDelimitedTextRangeBoundary ( int boundary ) {
s . setWritingModeTraits ( wmtg ) ;
protected Stack collectDelimitedTextRanges ( Stack ranges , DelimitedTextRange currentRange ) {
currentRange . append ( pfx , this ) ;
ranges = ( ( FONode ) it . next ( ) ) . collectDelimitedTextRanges ( ranges ) ;
currentRange . append ( sfx , this ) ;
attr = ( RtfAttributes ) attrib . clone ( ) ;
attr . set ( attrs ) ;
public ExternalGraphic ( ) {
p . newText ( "str" ) ;
p . newText ( "str" ) ;
p . newText ( "str" ) ;
p . newText ( "str"
p . newText ( "str" ) ;
public void parse ( File f ) {
sp . parse ( f , new Handler ( ) ) ;
throw new RuntimeException ( e . getMessage ( ) ) ;
throw new RuntimeException ( e . getMessage ( ) ) ;
throw new RuntimeException ( e . getMessage ( ) ) ;
throw new RuntimeException ( e . getMessage ( ) ) ;
int g = mapCharToGlyph ( ( int ) c ) ;
throw new IllegalArgumentException ( "str" + CharUtilities . format ( c ) + "str" ) ;
return new GlyphSequence ( cb , gb , null ) ;
public int mapCharToGlyph ( int c ) {
Integer g = cmap . get ( Integer . valueOf ( c ) ) ;
public GlyphSequence getGlyphSequence ( String [ ] gids ) {
int g = mapGlyphId0 ( gid ) ;
int c = mapGlyphIdToChar ( gid ) ;
throw new IllegalArgumentException ( "str" + gid + "str" ) ;
return new GlyphSequence ( cb , gb , null ) ;
public int [ ] getWidths ( String [ ] gids ) {
int g = mapGlyphId0 ( gid ) ;
widths [ i ] = getPDFWidth ( hmtx [ i ] [ 0 ] , upem ) ;
public static int getPDFWidth ( int tw , int upem ) {
public static synchronized TTXFile getFromCache ( String filename ) {
if ( ( f = ( TTXFile ) cache . get ( filename ) ) = = null ) {
public void setDocumentLocator ( Locator locator ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
String format = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
sf = Integer . parseInt ( format ) ;
unsupportedFormat ( en , sf ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
ci = Integer . parseInt ( index ) ;
String format = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
cf = Integer . parseInt ( format ) ;
unsupportedFormat ( en , cf ) ;
notPermittedInElementContext ( en , getParent ( ) , pnx ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
String format = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
cf = Integer . parseInt ( format ) ;
unsupportedFormat ( en , cf ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) | | en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
String format = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
sf = Integer . parseInt ( format ) ;
unsupportedFormat ( en , sf ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
v = Integer . parseInt ( value ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
String glyphClass = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
glyphClasses . put ( glyph , Integer . parseInt ( glyphClass ) ) ;
glyphClasses . put ( glyph , Integer . parseInt ( glyphClass ) ) ;
notPermittedInElementContext ( en , getParent ( ) , pnx ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
cf = Integer . parseInt ( format ) ;
unsupportedFormat ( en , cf ) ;
notPermittedInElementContext ( en , getParent ( ) , pnx ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
String format = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
sf = Integer . parseInt ( format ) ;
unsupportedFormat ( en , sf ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
String value = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
v = Integer . parseInt ( value ) ;
languageFeatures . add ( null ) ;
languageFeatures . add ( makeFeatureId ( v ) ) ;
notPermittedInElementContext ( en , getParent ( ) , pnx ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
fi = Integer . parseInt ( index ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
if ( isParent ( pn ) ) {
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
if ( isParent ( pn ) ) {
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
if ( isParent ( pn ) ) {
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pnx ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
sf = Integer . parseInt ( format ) ;
unsupportedFormat ( en , sf ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
gid = Integer . parseInt ( id ) ;
String name = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
glyphIds . put ( name , gid ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
ci = Integer . parseInt ( index ) ;
String format = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
cf = Integer . parseInt ( format ) ;
unsupportedFormat ( en , cf ) ;
notPermittedInElementContext ( en , getParent ( ) , pnx ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
String format = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
cf = Integer . parseInt ( format ) ;
unsupportedFormat ( en , cf ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
String format = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
sf = Integer . parseInt ( format ) ;
unsupportedFormat ( en , sf ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
ci = Integer . parseInt ( index ) ;
String format = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
cf = Integer . parseInt ( format ) ;
unsupportedFormat ( en , cf ) ;
notPermittedInElementContext ( en , getParent ( ) , pnx ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
li = Integer . parseInt ( index ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
lf = Integer . parseInt ( value ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
v = Integer . parseInt ( value ) ;
if ( isParent ( pny ) ) {
featureLookups . add ( makeLookupId ( v ) ) ;
notPermittedInElementContext ( en , getParent ( ) , pnx ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
cf = Integer . parseInt ( format ) ;
unsupportedFormat ( en , cf ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
cf = Integer . parseInt ( format ) ;
unsupportedFormat ( en , cf ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
sf = Integer . parseInt ( format ) ;
unsupportedFormat ( en , sf ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
String format = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
sf = Integer . parseInt ( format ) ;
unsupportedFormat ( en , sf ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
cf = Integer . parseInt ( format ) ;
unsupportedFormat ( en , cf ) ;
notPermittedInElementContext ( en , getParent ( ) , pnx ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
String format = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
sf = Integer . parseInt ( format ) ;
unsupportedFormat ( en , sf ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
String format = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
sf = Integer . parseInt ( format ) ;
unsupportedFormat ( en , sf ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pnx ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
String format = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
sf = Integer . parseInt ( format ) ;
unsupportedFormat ( en , sf ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
String format = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
sf = Integer . parseInt ( format ) ;
unsupportedFormat ( en , sf ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
psi = Integer . parseInt ( index ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pnx ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
v = Integer . parseInt ( value ) ;
fid = makeFeatureId ( v ) ;
languageFeatures . add ( fid ) ;
notPermittedInElementContext ( en , getParent ( ) , pnx ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
} else if ( en [ 1 ] . equals ( "str" ) ) {
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
int gid = mapGlyphId ( value , en ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
int i = Integer . parseInt ( index ) ;
invalidIndex ( en , i , subtableEntries . size ( ) ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
v = Integer . parseInt ( value ) ;
notPermittedInElementContext ( en , getParent ( ) , pnx ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
String format = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
sf = Integer . parseInt ( format ) ;
unsupportedFormat ( en , sf ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
String format = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
sf = Integer . parseInt ( format ) ;
unsupportedFormat ( en , sf ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
int i = Integer . parseInt ( index ) ;
invalidIndex ( en , i , substitutes . size ( ) ) ;
String value = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
igid = mapGlyphId ( in , en ) ;
String out = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
ogid = mapGlyphId ( out , en ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingParameter ( en , "str" ) ;
subtableEntries . add ( parseValue ( en , attrs , vf1 ) ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
if ( isParent ( pn ) ) {
missingParameter ( en , "str" ) ;
v1 = parseValue ( en , attrs , vf1 ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
if ( isParent ( pn ) ) {
missingParameter ( en , "str" ) ;
v2 = parseValue ( en , attrs , vf2 ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
vf = Integer . parseInt ( value ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
vf = Integer . parseInt ( value ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
vf = Integer . parseInt ( value ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pnx ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
x = Integer . parseInt ( value ) ;
notPermittedInElementContext ( en , getParent ( ) , pnx ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
y = Integer . parseInt ( value ) ;
notPermittedInElementContext ( en , getParent ( ) , pnx ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
String platEncID = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
String language = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
pid = Integer . parseInt ( platformID ) ;
String platEncID = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
eid = Integer . parseInt ( platEncID ) ;
String language = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
lid = Integer . parseInt ( language ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
} else if ( en [ 1 ] . equals ( "str" ) ) {
hmtxEntries . setSize ( glyphIdMax + 1 ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
cid = Integer . parseInt ( code , 10 ) ;
String name = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
gid = mapGlyphId ( name , en ) ;
cmapEntries . add ( new int [ ] { cid , gid } ) ;
notPermittedInElementContext ( en , getParent ( ) , pnx ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
gid = mapGlyphId ( name , en ) ;
String width = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
w = Integer . parseInt ( width ) ;
String lsb = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
l = Integer . parseInt ( lsb ) ;
hmtxEntries . set ( gid , new int [ ] { w , l } ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pnx ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
String ttLibVersion = attrs . getValue ( "str" ) ;
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , null ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
v = Integer . parseInt ( value ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingRequiredAttribute ( en , "str" ) ;
notPermittedInElementContext ( en , getParent ( ) , pn ) ;
unsupportedElement ( en ) ;
elements . push ( en ) ;
public void endElement ( String uri , String localName , String qName ) throws SAXException {
throw new SAXException ( "str" ) ;
throw new SAXException ( "str" ) ;
missingParameter ( en , "str" ) ;
missingParameter ( en , "str" ) ;
if ( en [ 1 ] . equals ( "str" ) ) {
duplicateParameter ( en , "str" ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
duplicateParameter ( en , "str" ) ;
anchors . add ( null ) ;
anchors . add ( new GlyphPositioningTable . Anchor ( xCoord , yCoord ) ) ;
subtableEntries . add ( rsa ) ;
unsupportedFormat ( en , stFormat ) ;
languages . put ( languageTag , extractLanguageFeatures ( ) ) ;
missingParameter ( en , "str" ) ;
subtableEntries . add ( extractAttachmentAnchors ( ) ) ;
unsupportedFormat ( en , stFormat ) ;
missingParameter ( en , "str" ) ;
anchors . add ( null ) ;
duplicateParameter ( en , "str" ) ;
mismatchedIndex ( en , "str" , flIndex , flSequence ) ;
missingTag ( en , "str" ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
gdef = new GlyphDefinitionTable ( subtables ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
gpos = new GlyphPositioningTable ( gdef , extractLookups ( ) , subtables ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
gsub = new GlyphSubstitutionTable ( gdef , extractLookups ( ) , subtables ) ;
coverages . put ( ck , extractCoverage ( ) ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
mismatchedIndex ( en , "str" , ltIndex , ltSequence ) ;
missingParameter ( en , "str" ) ;
missingParameter ( en , "str" ) ;
unsupportedFormat ( en , stFormat ) ;
missingParameter ( en , "str" ) ;
missingParameter ( en , "str" ) ;
missingParameter ( en , "str" ) ;
missingParameter ( en , "str" ) ;
unsupportedFormat ( en , stFormat ) ;
missingParameter ( en , "str" ) ;
missingParameter ( en , "str" ) ;
duplicateParameter ( en , "str" ) ;
markAnchors . add ( new GlyphPositioningTable . MarkAnchor ( markClass , anchors . get ( 0 ) ) ) ;
missingParameter ( en , "str" ) ;
subtableEntries . add ( extractPairSets ( ) ) ;
unsupportedFormat ( en , stFormat ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
invalidIndex ( en , psIndex , pairSets . size ( ) ) ;
pairSets . add ( extractPairs ( ) ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingParameter ( en , "str" ) ;
missingParameter ( en , "str" ) ;
pairs . add ( new PairValues ( g2 , v1 , v2 ) ) ;
} else if ( en [ 1 ] . equals ( "str" ) | | en [ 1 ] . equals ( "str" ) ) {
missingParameter ( en , "str" ) ;
missingParameter ( en , "str" ) ;
ruleLookups . add ( new GlyphTable . RuleLookup ( rlSequence , rlLookup ) ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
scripts . put ( scriptTag , extractLanguages ( ) ) ;
missingParameter ( en , "str" ) ;
duplicateParameter ( en , "str" ) ;
GlyphPositioningTable . Value [ ] pva = ( GlyphPositioningTable . Value [ ] ) subtableEntries . toArray ( new GlyphPositioningTable . Value [ nv ] ) ;
subtableEntries . add ( pva ) ;
} else if ( en [ 1 ] . equals ( "str" ) ) {
} else if ( en [ 1 ] . equals ( "str" ) ) {
} else if ( en [ 1 ] . equals ( "str" ) ) {
missingParameter ( en , "str" ) ;
missingParameter ( en , "str" ) ;
public void characters ( char [ ] chars , int start , int length ) {
private boolean isParent ( Object enx ) {
if ( isParent ( en ) ) {
return ( pn ! = null ) & & sameExpandedName ( en , pn ) ;
} else if ( ln . equals ( "str" ) ) {
} else if ( ln . equals ( "str" ) ) {
} else if ( ln . equals ( "str" ) ) {
} else if ( ln . equals ( "str" ) ) {
} else if ( ln . equals ( "str" ) ) {
private GlyphClassTable extractClassDefMapping ( Map < String , Integer > glyphClasses , int format , boolean clearSourceMap ) {
ct = extractClassDefMapping1 ( extractClassMappings ( glyphClasses , clearSourceMap ) ) ;
ct = extractClassDefMapping2 ( extractClassMappings ( glyphClasses , clearSourceMap ) ) ;
private GlyphClassTable extractClassDefMapping1 ( int [ ] [ ] cma ) {
entries . add ( Integer . valueOf ( s ) ) ;
entries . add ( zero ) ;
entries . add ( Integer . valueOf ( c ) ) ;
return GlyphClassTable . createClassTable ( entries ) ;
private GlyphClassTable extractClassDefMapping2 ( int [ ] [ ] cma ) {
entries . add ( new GlyphClassTable . MappingRange ( s , e , l ) ) ;
return GlyphClassTable . createClassTable ( entries ) ;
private int [ ] [ ] extractClassMappings ( Map < String , Integer > glyphClasses , boolean clearSourceMap ) {
Integer gid = glyphIds . get ( e . getKey ( ) ) ;
return sortClassMappings ( cma ) ;
private boolean sortEntries ( List cel , List sel ) {
private String makeCoverageKey ( String prefix , int index ) {
return prefix + CharUtilities . padLeft ( Integer . toString ( index , 10 ) , 2 , "str" ) ;
List entries = new ArrayList < Integer > ( coverageEntries ) ;
GlyphCoverageTable coverage = GlyphCoverageTable . createCoverageTable ( extractCoverageEntries ( ) ) ;
private GlyphCoverageTable [ ] getCoveragesWithPrefix ( String prefix ) {
gca [ i ] = coverages . get ( k ) ;
private boolean hasMissingCoverage ( GlyphCoverageTable [ ] gca ) {
private String makeFeatureId ( int fid ) {
private String makeLookupId ( int lid ) {
Map < String , List < String > > lm = new HashMap ( languages ) ;
List lookups = new ArrayList < String > ( featureLookups ) ;
Map < String , List < String > > lm = scripts . get ( st ) ;
List < String > fids = lm . get ( lt ) ;
Object [ ] fa = features . get ( fid ) ;
List entries = new ArrayList ( subtableEntries ) ;
LigatureSet ls = new LigatureSet ( ligatures ) ;
entries . add ( sa ) ;
RuleLookup [ ] lookups = ( RuleLookup [ ] ) ruleLookups . toArray ( new RuleLookup [ ruleLookups . size ( ) ] ) ;
xp = Integer . parseInt ( xPlacement ) ;
missingParameter ( en , "str" ) ;
String yPlacement = attrs . getValue ( "str" ) ;
yp = Integer . parseInt ( yPlacement ) ;
missingParameter ( en , "str" ) ;
String xAdvance = attrs . getValue ( "str" ) ;
xa = Integer . parseInt ( xAdvance ) ;
missingParameter ( en , "str" ) ;
String yAdvance = attrs . getValue ( "str" ) ;
ya = Integer . parseInt ( yAdvance ) ;
missingParameter ( en , "str" ) ;
return new GlyphPositioningTable . Value ( xp , yp , xa , ya , null , null , null , null ) ;
PairValues [ ] pva = ( PairValues [ ] ) pairs . toArray ( new PairValues [ pairs . size ( ) ] ) ;
PairValues [ ] [ ] pvm = ( PairValues [ ] [ ] ) pairSets . toArray ( new PairValues [ pairSets . size ( ) ] [ ] ) ;
Anchor [ ] aa = ( Anchor [ ] ) anchors . toArray ( new Anchor [ anchors . size ( ) ] ) ;
maa = ( MarkAnchor [ ] ) markAnchors . toArray ( new MarkAnchor [ maa . length ] ) ;
private Integer computeClassCount ( Anchor [ ] [ ] am ) {
return Integer . valueOf ( ncMax ) ;
cam = ( Anchor [ ] [ ] ) components . toArray ( new Anchor [ cam . length ] [ ] ) ;
private Integer computeLigaturesClassCount ( Anchor [ ] [ ] [ ] lam ) {
return Integer . valueOf ( ncMax ) ;
private Integer computeLigaturesComponentCount ( Anchor [ ] [ ] [ ] lam ) {
return Integer . valueOf ( nxMax ) ;
private int mapGlyphId0 ( String glyph ) {
Integer gid = glyphIds . get ( glyph ) ;
unsupportedGlyph ( currentElement , glyph ) ;
private int [ ] mapGlyphIds ( String glyphs , String [ ] currentElement ) throws SAXException {
gids [ i + + ] = mapGlyphId ( glyph , currentElement ) ;
private int mapGlyphIdToChar ( String glyph ) {
Integer gid = glyphIds . get ( glyph ) ;
Integer cid = gmap . get ( gid ) ;
private void notPermittedInElementContext ( String [ ] en , String [ ] cn , Object xns ) throws SAXException {
s + = formatExpandedName ( xn ) ;
s + = "str" + formatExpandedName ( ( String [ ] ) xns ) ;
throw new SAXException ( formatLocator ( ) + "str" + s ) ;
private static String [ ] makeExpandedName ( String uri , String localName , String qName ) {
private static String extractPrefix ( String qName ) {
private static String extractLocalName ( String qName ) {
private static boolean sameExpandedName ( String [ ] n1 , String [ ] n2 ) {
if ( ! u1 . equals ( u2 ) ) {
if ( ! l1 . equals ( l2 ) ) {
private static String formatExpandedName ( String [ ] n ) {
getMainReference ( ) . setWritingModeTraits ( wmtg ) ;
performPositioning ( ltSingle ) ;
performPositioning ( ltPair ) ;
performPositioning ( ltCursive ) ;
performPositioning ( ltMarkToBase ) ;
performPositioning ( ltMarkToLigature ) ;
performPositioning ( ltMarkToMark ) ;
performPositioning ( ltContextual ) ;
performPositioning ( ltChainedContextual ) ;
private void performPositioning ( Object [ ] [ ] ts ) {
performPositioning ( tp , ts [ i ] ) ;
private void performPositioning ( Object [ ] tp , Object [ ] td ) {
GlyphSequence igs = tf . getGlyphSequence ( igia ) ;
private String findTTXPath ( String fid ) {
if ( fs [ 0 ] . equals ( fid ) ) {
TTXFile tf = TTXFile . getFromCache ( pn ) ;
fail ( e . getMessage ( ) ) ;
private ScriptContextTester findScriptContextTester ( String script , String language , String feature ) {
public GlyphContextTester getTester ( String feature ) {
public boolean test ( String script , String language , String feature , GlyphSequence gs , int index , int flags ) {
assertEquals ( "str" , p1 , p2 ) ;
drawTextWithDP ( x , y , text , triplet , letterSpacing ,
private void drawTextWithDP ( int x , int y , String text , FontTriplet triplet ,
char ch = text . charAt ( i ) ;
double xa = f . getCharWidth ( ch ) + maybeWordOffsetX ( wox , ch , null ) ;
private double maybeWordOffsetX ( double wox , char ch , Direction dir ) {
& & CharUtilities . isAdjustableSpace ( ch )
public GlyphTable ( GlyphTable gdef , Map lookups ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" ) ;
return matchLookupSpecs ( "str" , "str" , "str" ) ;
ltl . add ( lookupTables . get ( lid ) ) ;
protected void addSubtable ( GlyphSubtable subtable ) {
throw new IllegalStateException ( "str" ) ;
subtable . setTable ( this ) ;
lt . freezeSubtables ( lookupTables ) ;
public List matchLookupSpecs ( String script , String language , String feature ) {
if ( ! ls . getScript ( ) . equals ( script ) ) {
if ( ! ls . getLanguage ( ) . equals ( language ) ) {
if ( ! ls . getFeature ( ) . equals ( feature ) ) {
matches . add ( ls ) ;
List lsl = matchLookupSpecs ( script , language , feature ) ;
lm . put ( ls , findLookupTables ( ls ) ) ;
matchedLookups . put ( lsm , lm ) ;
public List findLookupTables ( LookupSpec ls ) {
if ( ( ids = ( List ) lookups . get ( ls ) ) ! = null ) {
return new ArrayList ( lts ) ;
public UseSpec [ ] assembleLookups ( String [ ] features , Map lookups ) {
if ( ls . getFeature ( ) . equals ( feature ) ) {
uss . add ( new UseSpec ( lt , feature ) ) ;
return ( UseSpec [ ] ) uss . toArray ( new UseSpec [ uss . size ( ) ] ) ;
public static int getTableTypeFromName ( String name ) {
if ( "str" . equals ( s ) ) {
} else if ( "str" . equals ( s ) ) {
} else if ( "str" . equals ( s ) ) {
} else if ( "str" . equals ( s ) ) {
} else if ( "str" . equals ( s ) ) {
public static void resolveLookupReferences ( RuleSet [ ] rsa , Map lookupTables ) {
rs . resolveLookupReferences ( lookupTables ) ;
public LookupSpec ( String script , String language , String feature ) {
LookupSpec ( String script , String language , String feature , boolean permitEmpty , boolean permitWildcard ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" ) ;
public boolean equals ( Object o ) {
if ( ! l . script . equals ( script ) ) {
} else if ( ! l . language . equals ( language ) ) {
} else if ( ! l . feature . equals ( feature ) ) {
public int compareTo ( Object o ) {
public LookupTable ( String id , List subtables ) {
assert id . startsWith ( "str" ) ;
this . idOrdinal = Integer . parseInt ( id . substring ( 2 ) ) ;
addSubtable ( st ) ;
return ( GlyphSubtable [ ] ) subtables . toArray ( new GlyphSubstitutionSubtable [ subtables . size ( ) ] ) ;
return ( GlyphSubtable [ ] ) subtables . toArray ( new GlyphPositioningSubtable [ subtables . size ( ) ] ) ;
public boolean addSubtable ( GlyphSubtable subtable ) {
throw new IllegalStateException ( "str" ) ;
validateSubtable ( subtable ) ;
if ( ( d = subtable . compareTo ( st ) ) < 0 ) {
subtables . add ( subtable ) ;
private void validateSubtable ( GlyphSubtable subtable ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + subtable ) ;
throw new AdvancedTypographicTableFormatException ( "str" + subtable ) ;
public void freezeSubtables ( Map lookupTables ) {
resolveLookupReferences ( sta , lookupTables ) ;
private void resolveLookupReferences ( GlyphSubtable [ ] subtables , Map lookupTables ) {
st . resolveLookupReferences ( lookupTables ) ;
public GlyphSequence substitute ( GlyphSequence gs , String script , String language , String feature , ScriptContextTester sct ) {
return GlyphSubstitutionSubtable . substitute ( gs , script , language , feature , ( GlyphSubstitutionSubtable [ ] ) subtablesArray , sct ) ;
public GlyphSequence substitute ( GlyphSubstitutionState ss , int sequenceIndex ) {
return GlyphSubstitutionSubtable . substitute ( ss , ( GlyphSubstitutionSubtable [ ] ) subtablesArray , sequenceIndex ) ;
public boolean position ( GlyphSequence gs , String script , String language , String feature , int fontSize , int [ ] widths , int [ ] [ ] adjustments , ScriptContextTester sct ) {
return GlyphPositioningSubtable . position ( gs , script , language , feature , fontSize , ( GlyphPositioningSubtable [ ] ) subtablesArray , widths , adjustments , sct ) ;
public boolean position ( GlyphPositioningState ps , int sequenceIndex ) {
return GlyphPositioningSubtable . position ( ps , ( GlyphPositioningSubtable [ ] ) subtablesArray , sequenceIndex ) ;
public boolean equals ( Object o ) {
public int compareTo ( Object o ) {
private static List makeSingleton ( GlyphSubtable subtable ) {
public UseSpec ( LookupTable lookupTable , String feature ) {
public boolean equals ( Object o ) {
return lookupTable . equals ( u . lookupTable ) ;
public int compareTo ( Object o ) {
return lookupTable . compareTo ( u . lookupTable ) ;
public RuleLookup ( int sequenceIndex , int lookupIndex ) {
public void resolveLookupReferences ( Map lookupTables ) {
log . warn ( "str" + lid + "str" + lookupTables . values ( ) ) ;
protected Rule ( RuleLookup [ ] lookups , int inputSequenceLength ) {
public void resolveLookupReferences ( Map lookupTables ) {
l . resolveLookupReferences ( lookupTables ) ;
return "str" + Arrays . toString ( lookups ) + "str" + inputSequenceLength + "str" ;
public int [ ] getGlyphs ( int firstGlyph ) {
System . arraycopy ( glyphs , 0 , ga , 1 , glyphs . length ) ;
public int [ ] getClasses ( int firstClass ) {
System . arraycopy ( classes , 0 , ca , 1 , classes . length ) ;
public RuleSet ( Rule [ ] rules ) throws AdvancedTypographicTableFormatException {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
public void resolveLookupReferences ( Map lookupTables ) {
r . resolveLookupReferences ( lookupTables ) ;
return "str" + Arrays . toString ( rules ) + "str" ;
public int getWidth ( int gi ) {
public boolean adjust ( GlyphPositioningTable . Value v , int offset ) {
return v . adjust ( adjustments [ index + offset ] , fontSize ) ;
return getAdjustment ( 0 ) ;
public int [ ] getAdjustment ( int offset ) throws IndexOutOfBoundsException {
public boolean apply ( GlyphPositioningSubtable st ) {
public boolean apply ( GlyphTable . RuleLookup [ ] lookups , int nig ) {
GlyphPositioningState ps = new GlyphPositioningState ( this ) ;
consume ( nig ) ;
public void setAdjusted ( boolean adjusted ) {
RtfExternalGraphic newImage ( ) throws IOException ;
updateLevel ( childArea . getBidiLevel ( ) ) ;
public List collectInlineRuns ( List runs ) {
runs = ia . collectInlineRuns ( runs ) ;
private void updateLevel ( int newLevel ) {
setBidiLevel ( newLevel ) ;
setBidiLevel ( newLevel ) ;
protected InlineArea ( int blockProgressionOffset , int bidiLevel ) {
public List collectInlineRuns ( List runs ) {
runs . add ( new InlineRun ( this , new int [ ] { getBidiLevel ( ) } ) ) ;
public boolean isAncestor ( InlineArea ia ) {
public static int [ ] convertDPToDX ( int [ ] [ ] dp , int count ) {
public static int [ ] [ ] convertDXToDP ( int [ ] dx , int count ) {
public static boolean isPAIdentity ( int [ ] pa ) {
public static boolean isDPIdentity ( int [ ] [ ] dp ) {
if ( ! isPAIdentity ( dp [ i ] ) ) {
public static boolean isDPOnlyDX ( int [ ] [ ] dp ) {
public static void adjustPA ( int [ ] paDst , int [ ] paSrc ) {
public static int [ ] [ ] copyDP ( int [ ] [ ] dp , int offset , int count ) {
performLookups ( ltGlyphClass ) ;
performLookups ( ltAttachmentPoint ) ;
performLookups ( ltLigatureCaret ) ;
performLookups ( ltMarkAttachment ) ;
private void performLookups ( Object [ ] [ ] ts ) {
performLookups ( tp , ts [ i ] ) ;
private void performLookups ( Object [ ] tp , Object [ ] td ) {
assertTrue ( gdef ! = null ) ;
performGlyphClassLookups ( tf , lid , tia ) ;
performAttachmentPointLookups ( tf , lid , tia ) ;
performLigatureCaretLookups ( tf , lid , tia ) ;
performMarkAttachmentLookups ( tf , lid , tia ) ;
assertTrue ( "str" , false ) ;
private void performGlyphClassLookups ( TTXFile tf , String lid , String [ ] [ ] tia ) {
private void performAttachmentPointLookups ( TTXFile tf , String lid , String [ ] [ ] tia ) {
private void performLigatureCaretLookups ( TTXFile tf , String lid , String [ ] [ ] tia ) {
private void performMarkAttachmentLookups ( TTXFile tf , String lid , String [ ] [ ] tia ) {
private String findTTXPath ( String fid ) {
if ( fs [ 0 ] . equals ( fid ) ) {
TTXFile tf = TTXFile . getFromCache ( pn ) ;
fail ( e . getMessage ( ) ) ;
public void setParentITableColumnsInfo ( ITableColumnsInfo parentITableColumnsInfo ) {
protected GlyphProcessingState ( GlyphSequence gs , String script , String language , String feature , ScriptContextTester sct ) {
this . gct = ( sct ! = null ) ? sct . getTester ( feature ) : null ;
protected GlyphProcessingState reset ( GlyphSequence gs , String script , String language , String feature , ScriptContextTester sct ) {
this . gct = ( sct ! = null ) ? sct . getTester ( feature ) : null ;
public void setGDEF ( GlyphDefinitionTable gdef ) {
public void setLookupFlags ( int flags ) {
public int getClassMatchSet ( int gi ) {
public void setIgnoreDefault ( GlyphTester ignoreDefault ) {
public void updateSubtableState ( GlyphSubtable st ) {
public void setPosition ( int index ) throws IndexOutOfBoundsException {
return hasNext ( 1 ) ;
public boolean hasNext ( int count ) {
return hasPrev ( 1 ) ;
public boolean hasPrev ( int count ) {
public int consume ( int count ) throws IndexOutOfBoundsException {
public int getGlyph ( int offset ) throws IndexOutOfBoundsException {
return igs . getGlyph ( i ) ;
throw new IndexOutOfBoundsException ( "str" + i ) ;
return getGlyph ( 0 ) ;
public void setGlyph ( int offset , int glyph ) throws IndexOutOfBoundsException {
igs . setGlyph ( i , glyph ) ;
throw new IndexOutOfBoundsException ( "str" + i ) ;
public GlyphSequence . CharAssociation getAssociation ( int offset ) throws IndexOutOfBoundsException {
return igs . getAssociation ( i ) ;
throw new IndexOutOfBoundsException ( "str" + i ) ;
return getAssociation ( 0 ) ;
public int [ ] getGlyphs ( int offset , int count , boolean reverseOrder , GlyphTester ignoreTester , int [ ] glyphs , int [ ] counts ) throws IndexOutOfBoundsException {
count = getGlyphsAvailable ( offset , reverseOrder , ignoreTester ) [ 0 ] ;
throw new IndexOutOfBoundsException ( "str" + start ) ;
throw new IndexOutOfBoundsException ( "str" + ( start + count ) ) ;
throw new IndexOutOfBoundsException ( "str" + ( start - count ) ) ;
throw new IllegalArgumentException ( "str" + glyphs . length + "str" + count + "str" ) ;
return getGlyphsForward ( start , count , ignoreTester , glyphs , counts ) ;
return getGlyphsReverse ( start , count , ignoreTester , glyphs , counts ) ;
private int [ ] getGlyphsForward ( int start , int count , GlyphTester ignoreTester , int [ ] glyphs , int [ ] counts ) throws IndexOutOfBoundsException {
int gi = getGlyph ( i - index ) ;
if ( ( ignoreTester = = null ) | | ! ignoreTester . test ( gi , getLookupFlags ( ) ) ) {
private int [ ] getGlyphsReverse ( int start , int count , GlyphTester ignoreTester , int [ ] glyphs , int [ ] counts ) throws IndexOutOfBoundsException {
int gi = getGlyph ( i - index ) ;
if ( ( ignoreTester = = null ) | | ! ignoreTester . test ( gi , getLookupFlags ( ) ) ) {
return getGlyphs ( 0 , indexLast - index , false , null , null , null ) ;
return isIgnoredGlyph ( getPosition ( ) ) ;
public int [ ] getGlyphsAvailable ( int offset , boolean reverseOrder , GlyphTester ignoreTester ) throws IndexOutOfBoundsException {
return getGlyphsAvailableForward ( start , ignoreTester ) ;
return getGlyphsAvailableReverse ( start , ignoreTester ) ;
private int [ ] getGlyphsAvailableForward ( int start , GlyphTester ignoreTester ) throws IndexOutOfBoundsException {
int gi = getGlyph ( i - index ) ;
if ( ignoreTester . test ( gi , getLookupFlags ( ) ) ) {
private int [ ] getGlyphsAvailableReverse ( int start , GlyphTester ignoreTester ) throws IndexOutOfBoundsException {
int gi = getGlyph ( i - index ) ;
if ( ignoreTester . test ( gi , getLookupFlags ( ) ) ) {
public GlyphSequence . CharAssociation [ ] getAssociations ( int offset , int count , boolean reverseOrder , GlyphTester ignoreTester , GlyphSequence . CharAssociation [ ] associations , int [ ] counts )
count = getGlyphsAvailable ( offset , reverseOrder , ignoreTester ) [ 0 ] ;
throw new IndexOutOfBoundsException ( "str" + start ) ;
throw new IndexOutOfBoundsException ( "str" + ( start + count ) ) ;
throw new IndexOutOfBoundsException ( "str" + ( start - count ) ) ;
throw new IllegalArgumentException ( "str" + associations . length + "str" + count + "str" ) ;
return getAssociationsForward ( start , count , ignoreTester , associations , counts ) ;
return getAssociationsReverse ( start , count , ignoreTester , associations , counts ) ;
private GlyphSequence . CharAssociation [ ] getAssociationsForward ( int start , int count , GlyphTester ignoreTester , GlyphSequence . CharAssociation [ ] associations , int [ ] counts )
int gi = getGlyph ( i - index ) ;
if ( ( ignoreTester = = null ) | | ! ignoreTester . test ( gi , getLookupFlags ( ) ) ) {
associations [ k + + ] = getAssociation ( i - index ) ;
private GlyphSequence . CharAssociation [ ] getAssociationsReverse ( int start , int count , GlyphTester ignoreTester , GlyphSequence . CharAssociation [ ] associations , int [ ] counts )
int gi = getGlyph ( i - index ) ;
if ( ( ignoreTester = = null ) | | ! ignoreTester . test ( gi , getLookupFlags ( ) ) ) {
associations [ k + + ] = getAssociation ( i - index ) ;
public GlyphSequence . CharAssociation [ ] getIgnoredAssociations ( int offset , int count , boolean reverseOrder , GlyphTester ignoreTester , GlyphSequence . CharAssociation [ ] associations , int [ ] counts )
return getAssociations ( offset , count , reverseOrder , new NotGlyphTester ( ignoreTester ) , associations , counts ) ;
public boolean replaceInput ( int offset , int count , GlyphSequence gs , int gsOffset , int gsCount ) throws IndexOutOfBoundsException {
public int erase ( int offset , int [ ] glyphs ) throws IndexOutOfBoundsException {
throw new IndexOutOfBoundsException ( "str" + start ) ;
int gi = getGlyph ( i ) ;
setGlyph ( i , 65535 ) ;
return gct . test ( script , language , feature , igs , index , getLookupFlags ( ) ) ;
public boolean isBase ( int gi ) {
return gdef . isGlyphClass ( gi , GlyphDefinitionTable . GLYPH_CLASS_BASE ) ;
public boolean isLigature ( int gi ) {
return gdef . isGlyphClass ( gi , GlyphDefinitionTable . GLYPH_CLASS_LIGATURE ) ;
public boolean isMark ( int gi ) {
return gdef . isGlyphClass ( gi , GlyphDefinitionTable . GLYPH_CLASS_MARK ) ;
public boolean isIgnoredMark ( int gi , int flags ) {
return isMark ( gi ) ;
int gac = gdef . getMarkAttachClass ( gi ) ;
public GlyphTester getIgnoreTester ( int flags ) {
return getCombinedIgnoreTester ( flags ) ;
return getCombinedIgnoreTester ( flags ) ;
return getCombinedIgnoreTester ( flags ) ;
public GlyphTester getCombinedIgnoreTester ( int flags ) {
return getCombinedOrTester ( gta , ngt ) ;
public GlyphTester getCombinedOrTester ( GlyphTester [ ] gta , int ngt ) {
return new CombinedOrGlyphTester ( gta , ngt ) ;
public GlyphTester getCombinedAndTester ( GlyphTester [ ] gta , int ngt ) {
return new CombinedAndGlyphTester ( gta , ngt ) ;
CombinedOrGlyphTester ( GlyphTester [ ] gta , int ngt ) {
public boolean test ( int gi , int flags ) {
if ( gt . test ( gi , flags ) ) {
CombinedAndGlyphTester ( GlyphTester [ ] gta , int ngt ) {
public boolean test ( int gi , int flags ) {
if ( ! gt . test ( gi , flags ) ) {
NotGlyphTester ( GlyphTester gt ) {
public boolean test ( int gi , int flags ) {
if ( gt . test ( gi , flags ) ) {
void clipBackground ( Rectangle rect ,
TextInterval ( FONode fn , int start , int end ) {
TextInterval ( FONode fn , int textStart , int start , int end , int level ) {
void setLevel ( int level ) {
return new String ( new char [ ] { ( ( Character ) fn ) . getCharacter ( ) } ) ;
( ( FOText ) fn ) . setBidiLevel ( level , start - textStart , end - textStart ) ;
( ( Character ) fn ) . setBidiLevel ( level ) ;
( ( AbstractPageNumberCitation ) fn ) . setBidiLevel ( level ) ;
( ( AbstractGraphics ) fn ) . setBidiLevel ( level ) ;
( ( Leader ) fn ) . setBidiLevel ( level ) ;
public boolean equals ( Object o ) {
dumpData ( out , outFileName ) ;
parseTypeProperties ( line , sm , im ) ;
List tdl = processTypeData ( sm , im , new ArrayList ( ) ) ;
td = ( int [ ] [ ] ) tdl . toArray ( new int [ tdl . size ( ) ] [ ] ) ;
private static void parseTypeProperties ( String line , Map sm , Map im ) {
throw new IllegalArgumentException ( "str" + ucBlock + "str" + line ) ;
throw new IllegalArgumentException ( "str" + ucBlock + "str" + line ) ;
throw new IllegalArgumentException ( "str" + ucBlock + "str" + line ) ;
Integer k = Integer . valueOf ( bc ) ;
if ( ! sm . containsKey ( k ) ) {
sm . put ( k , sl ) ;
sl = ( List ) sm . get ( k ) ;
sl . add ( Integer . valueOf ( uc ) ) ;
throw new IllegalArgumentException ( "str" + sa [ 4 ] + "str" + line ) ;
throw new IllegalArgumentException ( "str" + line ) ;
private static boolean isBlockStart ( String s ) {
private static boolean isBlockEnd ( String s ) {
private static List processTypeData ( Map sm , Map im , List tdl ) {
List sl = ( List ) sm . get ( Integer . valueOf ( i ) ) ;
rm . put ( Integer . valueOf ( uc ) , Integer . valueOf ( uc + 1 ) ) ;
rm . put ( Integer . valueOf ( ba [ 0 ] ) , Integer . valueOf ( ba [ 1 ] + 1 ) ) ;
tdl . add ( createTypeData ( i , extractRanges ( rm ) ) ) ;
private static List extractRanges ( Map rm ) {
ranges . add ( new int [ ] { sLast , eLast } ) ;
ranges . add ( new int [ ] { sLast , eLast } ) ;
if ( ( n = readType ( line , b , lines ) ) < 0 ) {
tdl . add ( parseType ( lines ) ) ;
if ( ( n = readLevels ( line , b , lines ) ) < 0 ) {
ldl . add ( parseLevels ( lines ) ) ;
td = ( int [ ] [ ] ) tdl . toArray ( new int [ tdl . size ( ) ] [ ] ) ;
ld = ( int [ ] [ ] ) ldl . toArray ( new int [ ldl . size ( ) ] [ ] ) ;
private static int readLevels ( String line , BufferedReader b , List lines ) throws IOException {
lines . add ( line ) ;
switch ( testPrefix ( b , PFX_LEVELS ) ) {
lines . add ( line ) ;
private static int testPrefix ( BufferedReader b , String pfx ) throws IOException {
b . mark ( pfxLen ) ;
} else if ( c ! = pfx . charAt ( i ) ) {
private static int [ ] parseType ( List lines ) {
String [ ] sa = line . split ( "str" ) ;
private static int [ ] createTypeData ( int bc , List ranges ) {
private static int parseBidiClass ( String bidiClass ) {
if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
} else if ( "str" . equals ( bidiClass ) ) {
throw new IllegalArgumentException ( "str" + bidiClass ) ;
private static int parseBidiClassAny ( String bidiClass ) {
return parseBidiClass ( bidiClass ) ;
private static List parseCharacterRanges ( String charRanges ) {
CharacterIterator ci = new StringCharacterIterator ( charRanges ) ;
badRangeSpec ( "str" , charRanges ) ;
badRangeSpec ( "str" + s + "str" , charRanges ) ;
ranges = complementRanges ( ranges ) ;
return removeSurrogates ( ranges ) ;
private static boolean atEnd ( CharacterIterator ci ) {
if ( ! Character . isWhitespace ( c ) ) {
private static int [ ] maybeReadItem ( CharacterIterator ci ) {
badRangeSpec ( "str" , ci ) ;
return Integer . parseInt ( s , 16 ) ;
badRangeSpec ( "str" , ci ) ;
return Integer . parseInt ( s , 16 ) ;
badRangeSpec ( "str" , ci ) ;
badRangeSpec ( "str" , ci ) ;
private static String maybeReadHexDigits ( CharacterIterator ci , int numDigits ) {
if ( isHexDigit ( c ) ) {
sb . append ( c ) ;
private static boolean isHexDigit ( char c ) {
private static List complementRanges ( List ranges ) {
rm . put ( Integer . valueOf ( r [ 0 ] ) , Integer . valueOf ( r [ 1 ] ) ) ;
List compRanges = new ArrayList ( rm . size ( ) + 1 ) ;
compRanges . add ( new int [ ] { cs , s } ) ;
compRanges . add ( new int [ ] { cs , 0x110000 } ) ;
rsl . add ( r ) ;
private static boolean intersectsRange ( int [ ] r1 , int [ ] r2 ) {
private static List removeRange ( int [ ] r1 , int [ ] r2 ) {
rl . add ( r1 ) ;
rl . add ( r1 ) ;
rl . add ( new int [ ] { r1 [ 0 ] , r2 [ 0 ] } ) ;
rl . add ( new int [ ] { r2 [ 1 ] , r1 [ 1 ] } ) ;
private static void badRangeSpec ( String reason , String charRanges ) throws IllegalArgumentException {
throw new IllegalArgumentException ( "str" + reason + "str" + charRanges + "str" ) ;
private static void badRangeSpec ( String reason , CharacterIterator ci ) throws IllegalArgumentException {
throw new IllegalArgumentException ( "str" + reason + "str" + remainder ( ci ) + "str" ) ;
private static String remainder ( CharacterIterator ci ) {
sb . append ( c ) ;
private static int [ ] parseLevels ( List lines ) {
la = parseLevelSpec ( line ) ;
throw new IllegalArgumentException ( "str" + line + "str" ) ;
throw new IllegalArgumentException ( "str" + line + "str" ) ;
ra = parseReorderSpec ( line , la ) ;
throw new IllegalArgumentException ( "str" + line + "str" ) ;
int [ ] ta = parseTestSpec ( line , la ) ;
tal . add ( ta ) ;
throw new IllegalArgumentException ( "str" + line + "str" ) ;
throw new IllegalArgumentException ( "str" + line + "str" ) ;
return createLevelData ( la , ra , tal ) ;
private static int [ ] createLevelData ( int [ ] la , int [ ] ra , List tal ) {
throw new IllegalStateException ( "str" ) ;
throw new IllegalStateException ( "str" + ( nl + 1 ) + "str" + ta . length + "str" ) ;
badLevelSpec ( "str" , ci ) ;
return createLevelsArray ( ll ) ;
private static Integer maybeReadInteger ( CharacterIterator ci ) {
if ( maybeReadNext ( ci , "str" ) ) {
if ( ( c ! = CharacterIterator . DONE ) & & isDigit ( c ) ) {
sb . append ( c ) ;
int value = Integer . parseInt ( sb . toString ( ) ) ;
return Integer . valueOf ( value ) ;
private static boolean isDigit ( char c ) {
private static boolean maybeReadToken ( CharacterIterator ci , String s ) {
char c = s . charAt ( i ) ;
ci . setIndex ( startIndex ) ;
private static void badLevelSpec ( String reason , CharacterIterator ci ) throws IllegalArgumentException {
throw new IllegalArgumentException ( "str" + reason + "str" + remainder ( ci ) + "str" ) ;
private static int [ ] createLevelsArray ( List levels ) {
skipSpace ( ci ) ;
return createReorderArray ( rl , levels ) ;
private static void badReorderSpec ( String reason , CharacterIterator ci ) throws IllegalArgumentException {
throw new IllegalArgumentException ( "str" + reason + "str" + remainder ( ci ) + "str" ) ;
private static int [ ] createReorderArray ( List reorders , int [ ] levels ) {
throw new IllegalArgumentException ( "str" + nl + "str" + nr + "str" ) ;
skipSpace ( ci ) ;
badTestSpec ( "str" , ci ) ;
return createTestArray ( cl , bs , levels ) ;
private static String maybeReadIdentifier ( CharacterIterator ci ) {
if ( Character . isUnicodeIdentifierStart ( c ) ) {
sb . append ( c ) ;
if ( Character . isUnicodeIdentifierPart ( c ) ) {
sb . append ( c ) ;
private static int maybeReadBidiClass ( CharacterIterator ci ) {
if ( ( s = maybeReadIdentifier ( ci ) ) ! = null ) {
bc = parseBidiClass ( s ) ;
ci . setIndex ( i ) ;
private static void badTestSpec ( String reason , CharacterIterator ci ) throws IllegalArgumentException {
throw new IllegalArgumentException ( "str" + reason + "str" + remainder ( ci ) + "str" ) ;
private static int [ ] createTestArray ( List classes , int bitset , int [ ] levels ) {
throw new IllegalArgumentException ( "str" + levels . length + "str" + nc + "str" ) ;
returnList . add (
public static boolean isPunctuation ( int c ) {
public static boolean isDigit ( int c ) {
public static boolean isHebrew ( int c ) {
public static boolean isMongolian ( int c ) {
public static boolean isArabic ( int c ) {
public static boolean isGreek ( int c ) {
public static boolean isLatin ( int c ) {
public static boolean isCyrillic ( int c ) {
public static boolean isGeorgian ( int c ) {
public static boolean isHangul ( int c ) {
public static boolean isGurmukhi ( int c ) {
public static boolean isDevanagari ( int c ) {
public static boolean isGujarati ( int c ) {
public static boolean isBengali ( int c ) {
public static boolean isOriya ( int c ) {
public static boolean isTibetan ( int c ) {
public static boolean isTelugu ( int c ) {
public static boolean isKannada ( int c ) {
public static boolean isTamil ( int c ) {
public static boolean isMalayalam ( int c ) {
public static boolean isSinhalese ( int c ) {
public static boolean isBurmese ( int c ) {
public static boolean isThai ( int c ) {
public static boolean isKhmer ( int c ) {
public static boolean isLao ( int c ) {
public static boolean isEthiopic ( int c ) {
public static boolean isHan ( int c ) {
public static boolean isBopomofo ( int c ) {
public static boolean isHiragana ( int c ) {
public static boolean isKatakana ( int c ) {
} else if ( isPunctuation ( c ) ) {
} else if ( isDigit ( c ) ) {
} else if ( isLatin ( c ) ) {
} else if ( isCyrillic ( c ) ) {
} else if ( isGreek ( c ) ) {
} else if ( isHan ( c ) ) {
} else if ( isBopomofo ( c ) ) {
} else if ( isKatakana ( c ) ) {
} else if ( isHiragana ( c ) ) {
} else if ( isHangul ( c ) ) {
} else if ( isArabic ( c ) ) {
} else if ( isHebrew ( c ) ) {
} else if ( isMongolian ( c ) ) {
} else if ( isGeorgian ( c ) ) {
} else if ( isBurmese ( c ) ) {
} else if ( isThai ( c ) ) {
} else if ( isKhmer ( c ) ) {
} else if ( isLao ( c ) ) {
} else if ( isEthiopic ( c ) ) {
public static int useV2IndicRules ( int sc ) {
public static int [ ] scriptsOf ( CharSequence cs ) {
s . add ( Integer . valueOf ( scriptOf ( cs . charAt ( i ) ) ) ) ;
Arrays . sort ( sa ) ;
public static int dominantScript ( CharSequence cs ) {
m . put ( k , Integer . valueOf ( v . intValue ( ) + 1 ) ) ;
m . put ( k , Integer . valueOf ( 0 ) ) ;
public static boolean isIndicScript ( int script ) {
public static String scriptTagFromCode ( int code ) {
if ( ( tag = m . get ( Integer . valueOf ( code ) ) ) ! = null ) {
public static int scriptCodeFromTag ( String tag ) {
if ( ( c = m . get ( tag ) ) ! = null ) {
private static void putScriptTag ( Map tm , Map cm , int code , String tag ) {
public NumberConverter ( String format , int groupingSeparator , int groupingSize , int letterValue , String features , String language , String country )
parseFormatTokens ( format ) ;
public String convert ( long number ) {
public String convert ( List < Long > numbers ) {
appendScalars ( scalars , prefix ) ;
convertNumbers ( scalars , numbers ) ;
appendScalars ( scalars , suffix ) ;
return scalarsToString ( scalars ) ;
private void parseFormatTokens ( String format ) throws IllegalArgumentException {
Integer [ ] ca = UTF32 . toUTF32 ( format , 0 , true ) ;
int tokenTypeNew = isAlphaNumeric ( c ) ? TOKEN_ALPHANUMERIC : TOKEN_NONALPHANUMERIC ;
tokens . add ( token . toArray ( new Integer [ token . size ( ) ] ) ) ;
separators . add ( token . toArray ( new Integer [ token . size ( ) ] ) ) ;
token . add ( c ) ;
tokens . add ( token . toArray ( new Integer [ token . size ( ) ] ) ) ;
separators . add ( token . toArray ( new Integer [ token . size ( ) ] ) ) ;
this . prefix = separators . remove ( 0 ) ;
this . suffix = separators . remove ( separators . size ( ) - 1 ) ;
private void convertNumbers ( List < Integer > scalars , List < Long > numbers ) {
appendScalars ( scalars , convertNumber ( number , sep , tkn ) ) ;
private Integer [ ] convertNumber ( long number , Integer [ ] separator , Integer [ ] token ) {
appendScalars ( sl , separator ) ;
appendScalars ( sl , formatNumber ( number , token ) ) ;
return sl . toArray ( new Integer [ sl . size ( ) ] ) ;
private Integer [ ] formatNumber ( long number , Integer [ ] token ) {
throw new IllegalArgumentException ( "str" ) ;
fn = formatNumberAsDecimal ( number , ( int ) "str" , 1 ) ;
fn = formatNumberAsWord ( number , ( s = = ( int ) "str" ) ? Character . UPPERCASE_LETTER : Character . LOWERCASE_LETTER ) ;
fn = formatNumberAsDecimal ( number , s , token . length ) ;
throw new IllegalArgumentException ( "str" + UTF32 . fromUTF32 ( token ) + "str" ) ;
fn = formatNumber ( number , DEFAULT_TOKEN ) ;
sl . add ( 0 , zero + ( int ) digit ) ;
sl . add ( 0 , zero ) ;
sl = performGrouping ( sl , groupingSize , groupingSeparator ) ;
return sl . toArray ( new Integer [ sl . size ( ) ] ) ;
private static List < Integer > performGrouping ( List < Integer > sl , int groupingSize , int groupingSeparator ) {
gl . add ( 0 , groupingSeparator ) ;
gl . add ( 0 , sl . get ( k ) ) ;
private Integer [ ] formatNumberAsSequence ( long number , int one , int base , int [ ] map ) {
sl . add ( 0 , s ) ;
return sl . toArray ( new Integer [ sl . size ( ) ] ) ;
return f . format ( number , one , letterValue , features , language , country ) ;
private Integer [ ] formatNumberAsWord ( long number , int caseType ) {
f = new EnglishNumberAsWordFormatter ( caseType ) ;
return f . format ( number , 0 , letterValue , features , language , country ) ;
private boolean isLanguage ( String iso3Code ) {
} else if ( language . equals ( iso3Code ) ) {
return isSameLanguage ( iso3Code , language ) ;
private static boolean isSameLanguage ( String i3c , String lc ) {
if ( el [ 0 ] . equals ( i3c ) ) {
if ( el [ i ] . equals ( lc ) ) {
private static boolean hasFeature ( String features , String feature ) {
if ( fn . equals ( feature ) ) {
private static void appendScalars ( List < Integer > scalars , Integer [ ] sa ) {
scalars . add ( s ) ;
if ( getDecimalValue ( token [ i ] ) ! = 0 ) {
private static int getDecimalValue ( Integer scalar ) {
private static boolean isStartOfAlphabeticSequence ( int s ) {
private static int getSequenceBase ( int s ) {
private static boolean isStartOfNumericSpecial ( int s ) {
private SpecialNumberFormatter getSpecialFormatter ( int one , int letterValue , String features , String language , String country ) {
private static Integer [ ] toUpperCase ( Integer [ ] sa ) {
sa [ i ] = Character . toUpperCase ( s ) ;
private static Integer [ ] toLowerCase ( Integer [ ] sa ) {
sa [ i ] = Character . toLowerCase ( s ) ;
private static List < String > convertWordCase ( List < String > words , int caseType ) {
wl . add ( convertWordCase ( w , caseType ) ) ;
private static String convertWordCase ( String word , int caseType ) {
String s = word . substring ( i , i + 1 ) ;
sb . append ( s . toUpperCase ( ) ) ;
sb . append ( s . toLowerCase ( ) ) ;
private static String joinWords ( List < String > words , String separator ) {
sb . append ( separator ) ;
sb . append ( w ) ;
Integer [ ] format ( long number , int one , int letterValue , String features , String language , String country ) ;
EnglishNumberAsWordFormatter ( int caseType ) {
public Integer [ ] format ( long number , int one , int letterValue , String features , String language , String country ) {
boolean ordinal = hasFeature ( features , "str" ) ;
wl . add ( englishWordOnes [ 0 ] ) ;
wl . add ( englishWordOnesOrd [ ( int ) number ] ) ;
wl = formatOnesInThousand ( wl , billions ) ;
wl . add ( englishWordOthersOrd [ 3 ] ) ;
wl . add ( englishWordOthers [ 3 ] ) ;
wl = formatOnesInThousand ( wl , millions ) ;
wl . add ( englishWordOthersOrd [ 2 ] ) ;
wl . add ( englishWordOthers [ 2 ] ) ;
wl = formatOnesInThousand ( wl , thousands ) ;
wl . add ( englishWordOthersOrd [ 1 ] ) ;
wl . add ( englishWordOthers [ 1 ] ) ;
wl = formatOnesInThousand ( wl , ones , ordinal ) ;
private List < String > formatOnesInThousand ( List < String > wl , int number , boolean ordinal ) {
wl . add ( englishWordOnes [ hundreds ] ) ;
wl . add ( englishWordOthersOrd [ 0 ] ) ;
wl . add ( englishWordOthers [ 0 ] ) ;
wl . add ( englishWordTeensOrd [ ones ] ) ;
wl . add ( englishWordTeens [ ones ] ) ;
wl . add ( englishWordTensOrd [ tens ] ) ;
wl . add ( englishWordTens [ tens ] ) ;
wl . add ( englishWordOnesOrd [ ones ] ) ;
wl . add ( englishWordOnes [ ones ] ) ;
wl . add ( englishWordOnesOrd [ ones ] ) ;
wl . add ( englishWordOnes [ ones ] ) ;
FrenchNumberAsWordFormatter ( int caseType ) {
public Integer [ ] format ( long number , int one , int letterValue , String features , String language , String country ) {
boolean ordinal = hasFeature ( features , "str" ) ;
wl . add ( frenchWordOnes [ 0 ] ) ;
boolean female = hasFeature ( features , "str" ) ;
wl . add ( frenchWordOnesOrdFemale [ ( int ) number ] ) ;
wl . add ( frenchWordOnesOrdMale [ ( int ) number ] ) ;
wl = formatOnesInThousand ( wl , billions ) ;
wl . add ( frenchWordOthers [ 5 ] ) ;
wl . add ( frenchWordOthers [ 6 ] ) ;
wl = formatOnesInThousand ( wl , millions ) ;
wl . add ( frenchWordOthers [ 3 ] ) ;
wl . add ( frenchWordOthers [ 4 ] ) ;
wl = formatOnesInThousand ( wl , thousands ) ;
wl . add ( frenchWordOthers [ 2 ] ) ;
wl = formatOnesInThousand ( wl , ones ) ;
private List < String > formatOnesInThousand ( List < String > wl , int number ) {
wl . add ( frenchWordOnes [ hundreds ] ) ;
wl . add ( frenchWordOthers [ 1 ] ) ;
wl . add ( frenchWordOthers [ 0 ] ) ;
wl . add ( frenchWordTeens [ ones ] ) ;
sb . append ( frenchWordTens [ tens ] ) ;
wl . add ( sb . toString ( ) ) ;
sb . append ( frenchWordTens [ tens ] ) ;
sb . append ( "str" ) ;
wl . add ( sb . toString ( ) ) ;
wl . add ( frenchWordOnes [ ones ] ) ;
SpanishNumberAsWordFormatter ( int caseType ) {
public Integer [ ] format ( long number , int one , int letterValue , String features , String language , String country ) {
boolean ordinal = hasFeature ( features , "str" ) ;
wl . add ( spanishWordOnes [ 0 ] ) ;
boolean female = hasFeature ( features , "str" ) ;
wl . add ( spanishWordOnesOrdFemale [ ( int ) number ] ) ;
wl . add ( spanishWordOnesOrdMale [ ( int ) number ] ) ;
wl = formatOnesInThousand ( wl , billions ) ;
wl . add ( spanishWordOthers [ 0 ] ) ;
wl = formatOnesInThousand ( wl , millions ) ;
wl . add ( spanishWordOthers [ 4 ] ) ;
wl . add ( spanishWordOthers [ 3 ] ) ;
wl = formatOnesInThousand ( wl , thousands ) ;
wl . add ( spanishWordOthers [ 2 ] ) ;
wl = formatOnesInThousand ( wl , ones ) ;
private List < String > formatOnesInThousand ( List < String > wl , int number ) {
wl . add ( spanishWordOthers [ 1 ] ) ;
wl . add ( spanishWordHundreds [ hundreds ] ) ;
wl . add ( spanishWordTeens [ ones ] ) ;
wl . add ( spanishWordTweens [ ones ] ) ;
wl . add ( spanishWordTens [ tens ] ) ;
wl . add ( spanishWordOnes [ ones ] ) ;
public Integer [ ] format ( long number , int one , int letterValue , String features , String language , String country ) {
if ( hasFeature ( features , "str" ) ) {
} else if ( hasFeature ( features , "str" ) ) {
appendScalars ( sl , UTF32 . toUTF32 ( forms [ i ] , 0 , true ) ) ;
return toUpperCase ( sl . toArray ( new Integer [ sl . size ( ) ] ) ) ;
return toLowerCase ( sl . toArray ( new Integer [ sl . size ( ) ] ) ) ;
public Integer [ ] format ( long number , int one , int letterValue , String features , String language , String country ) {
public Integer [ ] format ( long number , int one , int letterValue , String features , String language , String country ) {
return formatNumberAsSequence ( number , one , hebrewGematriaAlphabeticMap . length , hebrewGematriaAlphabeticMap ) ;
return formatAsGematriaNumber ( number , features , language , country ) ;
private Integer [ ] formatAsGematriaNumber ( long number , String features , String language , String country ) {
sl . add ( map [ 18 + ( hundreds - 1 ) ] ) ;
sl . add ( map [ 9 + ( tens - 1 ) ] ) ;
sl . add ( map [ 0 + ( ones - 1 ) ] ) ;
return sl . toArray ( new Integer [ sl . size ( ) ] ) ;
public Integer [ ] format ( long number , int one , int letterValue , String features , String language , String country ) {
return formatNumberAsSequence ( number , one , map . length , map ) ;
return formatAsAbjadiNumber ( number , features , language , country ) ;
private Integer [ ] formatAsAbjadiNumber ( long number , String features , String language , String country ) {
sl . add ( map [ 27 + ( thousands - 1 ) ] ) ;
sl . add ( map [ 18 + ( hundreds - 1 ) ] ) ;
sl . add ( map [ 9 + ( tens - 1 ) ] ) ;
sl . add ( map [ 0 + ( ones - 1 ) ] ) ;
return sl . toArray ( new Integer [ sl . size ( ) ] ) ;
public Integer [ ] format ( long number , int one , int letterValue , String features , String language , String country ) {
return formatNumberAsSequence ( number , one , hiraganaGojuonAlphabeticMap . length , hiraganaGojuonAlphabeticMap ) ;
return formatNumberAsSequence ( number , one , katakanaGojuonAlphabeticMap . length , katakanaGojuonAlphabeticMap ) ;
public Integer [ ] format ( long number , int one , int letterValue , String features , String language , String country ) {
return formatNumberAsSequence ( number , one , thaiAlphabeticMap . length , thaiAlphabeticMap ) ;
private void setLogOption ( String option , String level ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
addSubtable ( ( GlyphSubtable ) o ) ;
throw new AdvancedTypographicTableFormatException ( "str" ) ;
protected void addSubtable ( GlyphSubtable subtable ) {
throw new UnsupportedOperationException ( "str" + subtable ) ;
public boolean isGlyphClass ( int gid , int gc ) {
return gct . isGlyphClass ( gid , gc ) ;
public int getGlyphClass ( int gid ) {
return gct . getGlyphClass ( gid ) ;
public boolean isMarkAttachClass ( int gid , int mac ) {
return mat . isMarkAttachClass ( gid , mac ) ;
public int getMarkAttachClass ( int gid ) {
return mat . getMarkAttachClass ( gid ) ;
public static int getLookupTypeFromName ( String name ) {
if ( "str" . equals ( s ) ) {
} else if ( "str" . equals ( s ) ) {
} else if ( "str" . equals ( s ) ) {
} else if ( "str" . equals ( s ) ) {
public static String getLookupTypeName ( int type ) {
public static GlyphSubtable createSubtable ( int type , String id , int sequence , int flags , int format , GlyphMappingTable mapping , List entries ) {
st = GlyphClassSubtable . create ( id , sequence , flags , format , mapping , entries ) ;
st = AttachmentPointSubtable . create ( id , sequence , flags , format , mapping , entries ) ;
st = LigatureCaretSubtable . create ( id , sequence , flags , format , mapping , entries ) ;
st = MarkAttachmentSubtable . create ( id , sequence , flags , format , mapping , entries ) ;
public abstract boolean isGlyphClass ( int gid , int gc ) ;
return new GlyphClassSubtableFormat1 ( id , sequence , flags , format , mapping , entries ) ;
public boolean isCompatible ( GlyphSubtable subtable ) {
public boolean isGlyphClass ( int gid , int gc ) {
return cm . getClassIndex ( gid , 0 ) = = gc ;
public int getGlyphClass ( int gid ) {
return cm . getClassIndex ( gid , 0 ) ;
static GlyphDefinitionSubtable create ( String id , int sequence , int flags , int format , GlyphMappingTable mapping , List entries ) {
return new AttachmentPointSubtableFormat1 ( id , sequence , flags , format , mapping , entries ) ;
public boolean isCompatible ( GlyphSubtable subtable ) {
static GlyphDefinitionSubtable create ( String id , int sequence , int flags , int format , GlyphMappingTable mapping , List entries ) {
return new LigatureCaretSubtableFormat1 ( id , sequence , flags , format , mapping , entries ) ;
public boolean isCompatible ( GlyphSubtable subtable ) {
public abstract boolean isMarkAttachClass ( int gid , int mac ) ;
return new MarkAttachmentSubtableFormat1 ( id , sequence , flags , format , mapping , entries ) ;
public boolean isCompatible ( GlyphSubtable subtable ) {
public boolean isMarkAttachClass ( int gid , int mac ) {
return cm . getClassIndex ( gid , 0 ) = = mac ;
public int getMarkAttachClass ( int gid ) {
return cm . getClassIndex ( gid , 0 ) ;
public GlyphSequence reorderCombiningMarks ( GlyphDefinitionTable gdef , GlyphSequence gs , int [ ] [ ] gpa , String script , String language ) {
if ( ! hasFinalPrecedingContext ( ca , nc , s , e ) ) {
} else if ( forcesFinalThisContext ( ca , nc , s , e ) ) {
} else if ( ! hasFinalFollowingContext ( ca , nc , s , e ) ) {
if ( ! hasInitialPrecedingContext ( ca , nc , s , e ) ) {
} else if ( ! hasInitialFollowingContext ( ca , nc , s , e ) ) {
if ( ! hasLigaturePrecedingContext ( ca , nc , s , e ) ) {
} else if ( ! hasLigatureFollowingContext ( ca , nc , s , e ) ) {
if ( ! hasMedialPrecedingContext ( ca , nc , s , e ) ) {
} else if ( ! hasMedialThisContext ( ca , nc , s , e ) ) {
} else if ( ! hasMedialFollowingContext ( ca , nc , s , e ) ) {
private static boolean hasFinalPrecedingContext ( int [ ] ca , int nc , int s , int e ) {
clp = BidiClass . getBidiClass ( chp ) ;
} else if ( hasIsolateInitial ( chp ) ) {
private static boolean forcesFinalThisContext ( int [ ] ca , int nc , int s , int e ) {
cll = BidiClass . getBidiClass ( chl ) ;
if ( hasIsolateInitial ( chl ) ) {
private static boolean hasFinalFollowingContext ( int [ ] ca , int nc , int s , int e ) {
clf = BidiClass . getBidiClass ( chf ) ;
} else if ( hasIsolateFinal ( chf ) ) {
private static boolean hasInitialPrecedingContext ( int [ ] ca , int nc , int s , int e ) {
clp = BidiClass . getBidiClass ( chp ) ;
} else if ( hasIsolateInitial ( chp ) ) {
private static boolean hasInitialFollowingContext ( int [ ] ca , int nc , int s , int e ) {
clf = BidiClass . getBidiClass ( chf ) ;
} else if ( hasIsolateFinal ( chf ) ) {
private static boolean hasMedialPrecedingContext ( int [ ] ca , int nc , int s , int e ) {
clp = BidiClass . getBidiClass ( chp ) ;
} else if ( hasIsolateInitial ( chp ) ) {
private static boolean hasMedialThisContext ( int [ ] ca , int nc , int s , int e ) {
clf = BidiClass . getBidiClass ( chf ) ;
cll = BidiClass . getBidiClass ( chl ) ;
if ( hasIsolateFinal ( chf ) ) {
} else if ( hasIsolateInitial ( chl ) ) {
private static boolean hasMedialFollowingContext ( int [ ] ca , int nc , int s , int e ) {
clf = BidiClass . getBidiClass ( chf ) ;
} else if ( hasIsolateFinal ( chf ) ) {
private static boolean hasLigaturePrecedingContext ( int [ ] ca , int nc , int s , int e ) {
private static boolean hasLigatureFollowingContext ( int [ ] ca , int nc , int s , int e ) {
clf = BidiClass . getBidiClass ( chf ) ;
if ( ( siblings . indexOf ( this ) + 1 ) < siblings . size ( ) ) {
throw new IllegalArgumentException ( "str" + i + "str" ) ;
int [ ] dx = IFUtil . convertDPToDX ( dp ) ;
int [ ] dx = IFUtil . convertDPToDX ( dp ) ;
int getClassSize ( int set ) ;
int getClassIndex ( int gid , int set ) ;
public static int classOf ( int c ) {
public static boolean isBreakableSpace ( int c ) {
public static boolean isZeroWidthSpace ( int c ) {
public static boolean isFixedWidthSpace ( int c ) {
public static boolean isNonBreakableSpace ( int c ) {
public static boolean isAdjustableSpace ( int c ) {
public static boolean isAnySpace ( int c ) {
public static boolean isAlphabetic ( int c ) {
public static boolean isExplicitBreak ( int c ) {
public static String charToNCRef ( int c ) {
sb . append ( hd ) ;
public static String toNCRefs ( String s ) {
sb . append ( "str" ) ;
sb . append ( "str" ) ;
sb . append ( "str" ) ;
sb . append ( c ) ;
sb . append ( charToNCRef ( c ) ) ;
public static String padLeft ( String s , int width , char pad ) {
sb . append ( s ) ;
public static String format ( int c ) {
return "str" + padLeft ( Integer . toString ( c , 16 ) , ( c < 65536 ) ? 4 : 6 , "str" ) ;
public static boolean isSameSequence ( CharSequence cs1 , CharSequence cs2 ) {
public boolean isDelimitedTextRangeBoundary ( int boundary ) {
public int computeXOffset ( int ipd , int cwidth ) {
public InlineRun ( InlineArea inline , int [ ] levels ) {
setMinMax ( levels ) ;
private void setMinMax ( int [ ] levels ) {
runs . add ( new InlineRun ( inline , l , e - s ) ) ;
public void updateMinMax ( int [ ] mm ) {
public void maybeReverseWord ( boolean mirror ) {
w . reverse ( mirror ) ;
public boolean equals ( Object o ) {
private String generateLevels ( int [ ] levels ) {
lb . append ( ( char ) ( "str" + levels [ i ] ) ) ;
lb . append ( levels [ i ] ) ;
private static int [ ] makeLevels ( int level , int count ) {
Arrays . fill ( levels , level ) ;
super ( blockProgressionOffset , level ) ;
public int [ ] getBidiLevels ( int start , int end ) {
public int bidiLevelAt ( int position ) {
public List collectInlineRuns ( List runs ) {
r = new InlineRun ( this , getBidiLevels ( ) ) ;
r = new InlineRun ( this , - 1 , word . length ( ) ) ;
runs . add ( r ) ;
public int [ ] glyphPositionAdjustmentsAt ( int position ) {
public void reverse ( boolean mirror ) {
word = ( ( new StringBuffer ( word ) ) . reverse ( ) ) . toString ( ) ;
reverse ( levels ) ;
reverse ( gposAdjustments ) ;
word = CharMirror . mirror ( word ) ;
word = CharMirror . mirror ( word ) ;
private static int [ ] maybeAdjustLength ( int [ ] ia , int length ) {
private static int [ ] [ ] maybeAdjustLength ( int [ ] [ ] im , int length ) {
private static int [ ] maybePopulateLevels ( int [ ] levels , int level , int count ) {
Arrays . fill ( levels , level ) ;
return maybeAdjustLength ( levels , count ) ;
private static void reverse ( int [ ] a ) {
private static void reverse ( int [ ] [ ] aa ) {
protected int findPreBaseMatra ( GlyphSequence gs ) {
if ( containsPreBaseMatra ( gs , k ) ) {
protected int findPreBaseMatraTarget ( GlyphSequence gs , int source ) {
if ( isPreM ( ca [ i ] ) ) {
if ( isC ( ca [ i ] ) ) {
protected int findReph ( GlyphSequence gs ) {
if ( containsReph ( gs , i ) ) {
protected int findRephTarget ( GlyphSequence gs , int source ) {
if ( containsMatra ( gs , i ) & & ! containsPreBaseMatra ( gs , i ) ) {
} else if ( containsOtherMark ( gs , i ) ) {
if ( isM ( ca [ i ] ) ) {
switch ( typeOf ( ca [ i ] ) ) {
protected int findStartOfSyllable ( int [ ] ca , int s , int e ) {
if ( isC ( c ) ) {
protected int findEndOfSyllable ( int [ ] ca , int s , int e ) {
while ( ( i = isDeadConsonant ( ca , s , e ) ) > s ) {
if ( ( i = isLiveConsonant ( ca , s , e ) ) > s ) {
private int isDeadConsonant ( int [ ] ca , int s , int e ) {
if ( isC ( c ) ) {
if ( isN ( c ) ) {
if ( isH ( c ) ) {
private int isLiveConsonant ( int [ ] ca , int s , int e ) {
if ( isC ( c ) ) {
} else if ( isV ( c ) ) {
if ( isN ( c ) ) {
if ( isX ( c ) ) {
if ( isH ( c ) ) {
return typeOf ( c ) = = t ;
switch ( typeOf ( c ) ) {
boolean substitute ( GlyphSubstitutionState ss ) ;
RtfBookmark newBookmark ( String bookmark ) throws IOException ;
curBlockArea . setBidiLevel ( getBlockFO ( ) . getBidiLevel ( ) ) ;
public List collectInlineRuns ( List runs ) {
runs . add ( new InlineRun ( this , new int [ ] { getBidiLevel ( ) } ) ) ;
return getPropertyName ( pi ) ;
return super . getOptionalArgDefault ( index , pi ) ;
public int compare ( Object obj1 , Object obj2 ) {
return getPropertyName ( pi ) ;
return super . getOptionalArgDefault ( index , pi ) ;
protected void clipBackground ( float startx , float starty ,
return new CTM ( ( premult . a * a ) + ( premult . b * c ) ,
RtfPageNumberCitation ( RtfContainer parent , Writer w , String id )
RtfPageNumberCitation ( RtfParagraph parent , Writer w , String id )
protected int findPreBaseMatra ( GlyphSequence gs ) {
if ( containsPreBaseMatra ( gs , k ) ) {
protected int findPreBaseMatraTarget ( GlyphSequence gs , int source ) {
if ( isPreM ( ca [ i ] ) ) {
if ( isC ( ca [ i ] ) ) {
protected int findReph ( GlyphSequence gs ) {
if ( containsReph ( gs , i ) ) {
protected int findRephTarget ( GlyphSequence gs , int source ) {
if ( containsMatra ( gs , i ) & & ! containsPreBaseMatra ( gs , i ) ) {
} else if ( containsOtherMark ( gs , i ) ) {
if ( isM ( ca [ i ] ) ) {
switch ( typeOf ( ca [ i ] ) ) {
protected int findStartOfSyllable ( int [ ] ca , int s , int e ) {
if ( isC ( c ) ) {
protected int findEndOfSyllable ( int [ ] ca , int s , int e ) {
while ( ( i = isDeadConsonant ( ca , s , e ) ) > s ) {
if ( ( i = isLiveConsonant ( ca , s , e ) ) > s ) {
private int isDeadConsonant ( int [ ] ca , int s , int e ) {
if ( isC ( c ) ) {
if ( isN ( c ) ) {
if ( isH ( c ) ) {
private int isLiveConsonant ( int [ ] ca , int s , int e ) {
if ( isC ( c ) ) {
} else if ( isV ( c ) ) {
if ( isN ( c ) ) {
if ( isX ( c ) ) {
if ( isH ( c ) ) {
return typeOf ( c ) = = t ;
switch ( typeOf ( c ) ) {
public boolean isDelimitedTextRangeBoundary ( int boundary ) {
protected Stack collectDelimitedTextRanges ( Stack ranges , DelimitedTextRange currentRange ) {
currentRange . append ( charIterator ( ) , this ) ;
lineDataInfo . setX2 ( Math . round ( x2 ) ) ;
lineDataInfo . setColor ( borderPaintInfo . getColor ( ) ) ;
lineDataInfo . setColor ( ColorUtil . lightenColor ( borderPaintInfo . getColor ( ) , colFactor ) ) ;
return getPropertyName ( pi ) ;
return super . getOptionalArgDefault ( index , pi ) ;
private static ResourceBundle getBundle ( String groupID , Locale locale ) {
bundle = XMLResourceBundle . getXMLBundle ( baseName , locale , classLoader ) ;
log . trace ( "str" + baseName + "str" ) ;
return format ( event , getBundle ( event . getEventGroupID ( ) , locale ) ) ;
private static String format ( Event event , ResourceBundle bundle ) {
template = bundle . getString ( key ) ;
return format ( event , processIncludes ( template , bundle ) ) ;
ResourceBundle bundle = getBundle ( groupID , locale ) ;
private RtfTemplate ( ) {
public static RtfTemplate getInstance ( ) {
public void writeTemplate ( RtfHeader header ) throws IOException {
header . writeGroupMark ( false ) ;
protected ScriptProcessor ( String script ) {
throw new IllegalArgumentException ( "str" ) ;
public GlyphSequence substitute ( GlyphSequence gs , String script , String language , GlyphTable . UseSpec [ ] usa , ScriptContextTester sct ) {
gs = us . substitute ( gs , script , language , sct ) ;
public GlyphSequence reorderCombiningMarks ( GlyphDefinitionTable gdef , GlyphSequence gs , int [ ] [ ] gpa , String script , String language ) {
public boolean position ( GlyphSequence gs , String script , String language , int fontSize , GlyphTable . UseSpec [ ] usa , int [ ] widths , int [ ] [ ] adjustments , ScriptContextTester sct ) {
if ( us . position ( gs , script , language , fontSize , widths , adjustments , sct ) ) {
if ( ( usa = assembledLookupsGet ( key ) ) ! = null ) {
return assembledLookupsPut ( key , table . assembleLookups ( features , lookups ) ) ;
public static synchronized ScriptProcessor getInstance ( String script ) {
private static ScriptProcessor createProcessor ( String script ) {
int sc = CharScript . scriptCodeFromTag ( script ) ;
sp = new DefaultScriptProcessor ( script ) ;
AssembledLookupsKey ( GlyphTable table , String [ ] features , Map lookups ) {
hc = 11 * hc + ( hc ^ Arrays . hashCode ( features ) ) ;
public boolean equals ( Object o ) {
if ( ! table . equals ( k . table ) ) {
} else if ( ! Arrays . equals ( features , k . features ) ) {
} else if ( ! lookups . equals ( k . lookups ) ) {
public void setInlineProgressionDirection ( Direction direction ) {
public void setBlockProgressionDirection ( Direction direction ) {
public void setColumnProgressionDirection ( Direction direction ) {
public void setRowProgressionDirection ( Direction direction ) {
public void setShiftDirection ( Direction direction ) {
public void setWritingMode ( WritingMode writingMode ) {
getWritingModeTraitsGetter ( org . apache . fop . fo . FONode fn ) {
spaceArea . setIPD ( ipd ) ;
private void updateLevel ( int newLevel ) {
setBidiLevel ( newLevel ) ;
setBidiLevel ( newLevel ) ;
private static int findMinLevel ( int [ ] levels ) {
private int [ ] makeLevels ( int level , int count ) {
Arrays . fill ( levels , level ) ;
boolean hasDefinition ( int gi ) ;
return getPropertyName ( pi ) ;
return super . getOptionalArgDefault ( index , pi ) ;
private GlyphClassTable ( GlyphClassMapping cm ) {
public static GlyphClassTable createClassTable ( List entries ) {
return new GlyphClassTable ( cm ) ;
private static boolean isMappedClass ( List entries ) {
private static boolean isRangeClass ( List entries ) {
private static boolean isCoverageSetClass ( List entries ) {
public int getClassSize ( int set ) {
public int getClassIndex ( int gid , int set ) {
entries . add ( Integer . valueOf ( firstGlyph ) ) ;
entries . add ( Integer . valueOf ( gca [ i ] ) ) ;
public int getMappedIndex ( int gid ) {
public int getClassSize ( int set ) {
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" + o ) ;
throw new AdvancedTypographicTableFormatException ( "str" + o ) ;
sb . append ( Integer . toString ( gca [ i ] ) ) ;
public int getMappedIndex ( int gid , int s , int m ) {
public int getClassSize ( int set ) {
public int getClassSize ( int set ) {
public int getClassIndex ( int gid , int set ) {
int [ ] da = BidiTestData . readTestData ( tdPfx , i ) ;
testBidiClass ( da ) ;
fail ( "str" + i ) ;
private void testBidiClass ( int [ ] da ) throws Exception {
RtfFontManager . getInstance ( ) . writeFonts ( ( RtfHeader ) parent ) ;
public Rectangle getViewportRectangle ( FODimension reldims ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
addSubtable ( ( GlyphSubtable ) o ) ;
throw new AdvancedTypographicTableFormatException ( "str" ) ;
public static int getLookupTypeFromName ( String name ) {
if ( "str" . equals ( s ) ) {
} else if ( "str" . equals ( s ) ) {
} else if ( "str" . equals ( s ) ) {
} else if ( "str" . equals ( s ) ) {
} else if ( "str" . equals ( s ) ) {
} else if ( "str" . equals ( s ) ) {
} else if ( "str" . equals ( s ) ) {
} else if ( "str" . equals ( s ) ) {
} else if ( "str" . equals ( s ) ) {
public static String getLookupTypeName ( int type ) {
public static GlyphSubtable createSubtable ( int type , String id , int sequence , int flags , int format , GlyphCoverageTable coverage , List entries ) {
st = SingleSubtable . create ( id , sequence , flags , format , coverage , entries ) ;
st = PairSubtable . create ( id , sequence , flags , format , coverage , entries ) ;
st = CursiveSubtable . create ( id , sequence , flags , format , coverage , entries ) ;
st = MarkToBaseSubtable . create ( id , sequence , flags , format , coverage , entries ) ;
st = MarkToLigatureSubtable . create ( id , sequence , flags , format , coverage , entries ) ;
st = MarkToMarkSubtable . create ( id , sequence , flags , format , coverage , entries ) ;
st = ContextualSubtable . create ( id , sequence , flags , format , coverage , entries ) ;
st = ChainedContextualSubtable . create ( id , sequence , flags , format , coverage , entries ) ;
public boolean isCompatible ( GlyphSubtable subtable ) {
public boolean position ( GlyphPositioningState ps ) {
if ( ( ci = getCoverageIndex ( gi ) ) < 0 ) {
Value v = getValue ( ci , gi ) ;
ps . setAdjusted ( true ) ;
return new SingleSubtableFormat1 ( id , sequence , flags , format , coverage , entries ) ;
return new SingleSubtableFormat2 ( id , sequence , flags , format , coverage , entries ) ;
public Value getValue ( int ci , int gi ) {
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
List entries = new ArrayList ( values . length ) ;
entries . add ( values [ i ] ) ;
public Value getValue ( int ci , int gi ) {
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + entries . size ( ) + "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + entries . size ( ) + "str" + getCoverageSize ( ) + "str" ) ;
public boolean isCompatible ( GlyphSubtable subtable ) {
public boolean position ( GlyphPositioningState ps ) {
int [ ] iga = ps . getGlyphs ( 0 , 2 , null , counts ) ;
PairValues pv = getPairValues ( ci , iga [ 0 ] , iga [ 1 ] ) ;
if ( ! ps . isIgnoredGlyph ( offset ) ) {
ps . setAdjusted ( true ) ;
if ( ! ps . isIgnoredGlyph ( offset ) ) {
ps . setAdjusted ( true ) ;
return new PairSubtableFormat1 ( id , sequence , flags , format , coverage , entries ) ;
return new PairSubtableFormat2 ( id , sequence , flags , format , coverage , entries ) ;
public PairValues getPairValues ( int ci , int gi1 , int gi2 ) {
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + entries . size ( ) + "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
public PairValues getPairValues ( int ci , int gi1 , int gi2 ) {
int c1 = cdt1 . getClassIndex ( gi1 , 0 ) ;
int c2 = cdt2 . getClassIndex ( gi2 , 0 ) ;
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + entries . size ( ) + "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
public boolean isCompatible ( GlyphSubtable subtable ) {
public boolean position ( GlyphPositioningState ps ) {
int [ ] iga = ps . getGlyphs ( 0 , 2 , null , counts ) ;
int enw = ps . getWidth ( gi2 ) ;
ps . consume ( 1 ) ;
return new CursiveSubtableFormat1 ( id , sequence , flags , format , coverage , entries ) ;
public Anchor [ ] getExitEntryAnchors ( int ci1 , int ci2 ) {
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + entries . size ( ) + "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( Anchor [ ] ) o ) . length ) ;
public boolean isCompatible ( GlyphSubtable subtable ) {
public boolean position ( GlyphPositioningState ps ) {
Anchor a = getBaseAnchor ( gi , ma . getMarkClass ( ) ) ;
Value v = a . getAlignmentAdjustment ( ma ) ;
v . adjust ( 0 , 0 , - ps . getWidth ( giMark ) , 0 ) ;
public abstract MarkAnchor getMarkAnchor ( int ciMark , int giMark ) ;
return new MarkToBaseSubtableFormat1 ( id , sequence , flags , format , coverage , entries ) ;
public MarkAnchor getMarkAnchor ( int ciMark , int giMark ) {
public Anchor getBaseAnchor ( int giBase , int markClass ) {
if ( ( bct ! = null ) & & ( ( ciBase = bct . getCoverageIndex ( giBase ) ) > = 0 ) ) {
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + entries . size ( ) + "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
public boolean isCompatible ( GlyphSubtable subtable ) {
public boolean position ( GlyphPositioningState ps ) {
Anchor a = getLigatureAnchor ( gi , mxc , i , ma . getMarkClass ( ) ) ;
public abstract MarkAnchor getMarkAnchor ( int ciMark , int giMark ) ;
return new MarkToLigatureSubtableFormat1 ( id , sequence , flags , format , coverage , entries ) ;
public MarkAnchor getMarkAnchor ( int ciMark , int giMark ) {
public Anchor getLigatureAnchor ( int giLig , int maxComponents , int component , int markClass ) {
if ( ( lct ! = null ) & & ( ( ciLig = lct . getCoverageIndex ( giLig ) ) > = 0 ) ) {
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + entries . size ( ) + "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
public boolean isCompatible ( GlyphSubtable subtable ) {
public boolean position ( GlyphPositioningState ps ) {
Anchor a = getMark2Anchor ( ps . getGlyph ( - 1 ) , ma . getMarkClass ( ) ) ;
public abstract MarkAnchor getMark1Anchor ( int ciMark1 , int giMark1 ) ;
return new MarkToMarkSubtableFormat1 ( id , sequence , flags , format , coverage , entries ) ;
public MarkAnchor getMark1Anchor ( int ciMark1 , int giMark1 ) {
public Anchor getMark2Anchor ( int giMark2 , int markClass ) {
if ( ( mct2 ! = null ) & & ( ( ciMark2 = mct2 . getCoverageIndex ( giMark2 ) ) > = 0 ) ) {
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + entries . size ( ) + "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
public boolean isCompatible ( GlyphSubtable subtable ) {
public boolean position ( GlyphPositioningState ps ) {
if ( ( ci = getCoverageIndex ( gi ) ) > = 0 ) {
RuleLookup [ ] la = getLookups ( ci , gi , ps , rv ) ;
ps . apply ( la , rv [ 0 ] ) ;
return new ContextualSubtableFormat1 ( id , sequence , flags , format , coverage , entries ) ;
return new ContextualSubtableFormat2 ( id , sequence , flags , format , coverage , entries ) ;
return new ContextualSubtableFormat3 ( id , sequence , flags , format , coverage , entries ) ;
public RuleLookup [ ] getLookups ( int ci , int gi , GlyphPositioningState ps , int [ ] rv ) {
static boolean matches ( GlyphPositioningState ps , int [ ] glyphs , int offset , int [ ] rv ) {
int [ ] counts = ps . getGlyphsAvailable ( offset , reverse , ignores ) ;
int [ ] ga = ps . getGlyphs ( offset , ngm , reverse , ignores , null , counts ) ;
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + entries . size ( ) + "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
public RuleLookup [ ] getLookups ( int ci , int gi , GlyphPositioningState ps , int [ ] rv ) {
static boolean matches ( GlyphPositioningState ps , GlyphClassTable cdt , int [ ] classes , int offset , int [ ] rv ) {
int [ ] counts = ps . getGlyphsAvailable ( offset , reverse , ignores ) ;
int [ ] ga = ps . getGlyphs ( offset , ngm , reverse , ignores , null , counts ) ;
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + entries . size ( ) + "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + rsa . length + "str" + ngc + "str" ) ;
public RuleLookup [ ] getLookups ( int ci , int gi , GlyphPositioningState ps , int [ ] rv ) {
if ( matches ( ps , gca , 0 , rv ) ) {
static boolean matches ( GlyphPositioningState ps , GlyphCoverageTable [ ] gca , int offset , int [ ] rv ) {
int [ ] counts = ps . getGlyphsAvailable ( offset , reverse , ignores ) ;
int [ ] ga = ps . getGlyphs ( offset , ngm , reverse , ignores , null , counts ) ;
if ( ct . getCoverageIndex ( ga [ k ] ) < 0 ) {
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + entries . size ( ) + "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
public boolean isCompatible ( GlyphSubtable subtable ) {
public boolean position ( GlyphPositioningState ps ) {
if ( ( ci = getCoverageIndex ( gi ) ) > = 0 ) {
RuleLookup [ ] la = getLookups ( ci , gi , ps , rv ) ;
ps . apply ( la , rv [ 0 ] ) ;
return new ChainedContextualSubtableFormat1 ( id , sequence , flags , format , coverage , entries ) ;
return new ChainedContextualSubtableFormat2 ( id , sequence , flags , format , coverage , entries ) ;
return new ChainedContextualSubtableFormat3 ( id , sequence , flags , format , coverage , entries ) ;
public RuleLookup [ ] getLookups ( int ci , int gi , GlyphPositioningState ps , int [ ] rv ) {
if ( matches ( ps , bga , - 1 , null ) ) {
if ( matches ( ps , lga , rv [ 0 ] , null ) ) {
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + entries . size ( ) + "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
public RuleLookup [ ] getLookups ( int ci , int gi , GlyphPositioningState ps , int [ ] rv ) {
if ( matches ( ps , bcdt , bca , - 1 , null ) ) {
if ( matches ( ps , lcdt , lca , rv [ 0 ] , null ) ) {
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + entries . size ( ) + "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + o . getClass ( ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + o . getClass ( ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
throw new AdvancedTypographicTableFormatException ( "str" + rsa . length + "str" + ngc + "str" ) ;
public RuleLookup [ ] getLookups ( int ci , int gi , GlyphPositioningState ps , int [ ] rv ) {
if ( matches ( ps , igca , 0 , rv ) ) {
if ( matches ( ps , bgca , - 1 , null ) ) {
if ( matches ( ps , lgca , rv [ 0 ] , null ) ) {
private void populate ( List entries ) {
throw new AdvancedTypographicTableFormatException ( "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + entries . size ( ) + "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + ( ( o ! = null ) ? o . getClass ( ) : null ) ) ;
public DeviceTable ( int startSize , int endSize , int [ ] deltas ) {
public int findAdjustment ( int fontSize ) {
return "str" + startSize + "str" + endSize + "str" + Arrays . toString ( deltas ) + "str" ;
public Value ( int xPlacement , int yPlacement , int xAdvance , int yAdvance , DeviceTable xPlaDevice , DeviceTable yPlaDevice , DeviceTable xAdvDevice , DeviceTable yAdvDevice ) {
public void adjust ( int xPlacement , int yPlacement , int xAdvance , int yAdvance ) {
public boolean adjust ( int [ ] adjustments , int fontSize ) {
if ( ( dv = dt . findAdjustment ( fontSize ) ) ! = 0 ) {
if ( ( dv = dt . findAdjustment ( fontSize ) ) ! = 0 ) {
if ( ( dv = dt . findAdjustment ( fontSize ) ) ! = 0 ) {
if ( ( dv = dt . findAdjustment ( fontSize ) ) ! = 0 ) {
sb . append ( "str" ) ;
sb . append ( "str" ) ;
sb . append ( "str" + xPlacement ) ;
sb . append ( "str" ) ;
sb . append ( "str" + yPlacement ) ;
sb . append ( "str" ) ;
sb . append ( "str" + xAdvance ) ;
sb . append ( "str" ) ;
sb . append ( "str" + yAdvance ) ;
sb . append ( "str" ) ;
sb . append ( "str" + xPlaDevice ) ;
sb . append ( "str" ) ;
sb . append ( "str" + yPlaDevice ) ;
sb . append ( "str" ) ;
sb . append ( "str" + xAdvDevice ) ;
sb . append ( "str" ) ;
sb . append ( "str" + yAdvDevice ) ;
public PairValues ( int glyph , Value value1 , Value value2 ) {
sb . append ( "str" ) ;
sb . append ( "str" ) ;
sb . append ( "str" + glyph ) ;
sb . append ( "str" ) ;
sb . append ( "str" + value1 ) ;
sb . append ( "str" ) ;
sb . append ( "str" + value2 ) ;
public Anchor ( int x , int y ) {
public Anchor ( int x , int y , int anchorPoint ) {
public Anchor ( int x , int y , DeviceTable xDevice , DeviceTable yDevice ) {
protected Anchor ( Anchor a ) {
private Anchor ( int x , int y , int anchorPoint , DeviceTable xDevice , DeviceTable yDevice ) {
public Value getAlignmentAdjustment ( Anchor a ) {
return new Value ( x - a . x , y - a . y , 0 , 0 , null , null , null , null ) ;
sb . append ( "str" + x + "str" + y + "str" ) ;
sb . append ( "str" + anchorPoint ) ;
sb . append ( "str" + xDevice ) ;
sb . append ( "str" + yDevice ) ;
public static RtfStyleSheetTable getInstance ( ) {
instance = new RtfStyleSheetTable ( ) ;
public void setDefaultStyle ( String styleName ) {
if ( attrTable . get ( STANDARD_STYLE ) ! = null ) {
attrTable . put ( name , attrs ) ;
styles . put ( name , new Integer ( nameTable . size ( ) - 1 + startIndex ) ) ;
public int addStyleToAttributes ( String name , RtfAttributes attr ) {
Integer style = ( Integer ) styles . get ( name ) ;
if ( style = = null & & ! name . equals ( defaultStyleName ) ) {
style = ( Integer ) styles . get ( name ) ;
attr . set ( "str" , style . intValue ( ) ) ;
Object o = attrTable . get ( name ) ;
attr . set ( attrName ) ;
attr . set ( attrName , i . intValue ( ) ) ;
int number = nameTable . size ( ) ;
Object o = attrTable . get ( name ) ;
header . writeGroupMark ( false ) ;
void setInlineProgressionDirection ( Direction direction ) ;
void setBlockProgressionDirection ( Direction direction ) ;
void setColumnProgressionDirection ( Direction direction ) ;
void setRowProgressionDirection ( Direction direction ) ;
void setShiftDirection ( Direction direction ) ;
void setWritingMode ( WritingMode writingMode ) ;
void assignWritingModeTraits ( WritingMode writingMode ) ;
ls . setBidiLevel ( level ) ;
public Rectangle getViewportRectangle ( FODimension reldims ) {
private Property calcWritingModeDependent ( int pv , int wm ) {
return makeWritingModeDependentEnum ( pv ) ;
private Property makeWritingModeDependentEnum ( int pv ) {
return getEnumProperty ( EN_START , "str" ) ;
return getEnumProperty ( EN_END , "str" ) ;
Arrays . fill ( wordLevels , - 1 ) ;
addWordLevels ( foText . getBidiLevels ( s , e ) ) ;
private void addWordLevels ( int [ ] levels ) {
System . arraycopy ( levels , 0 , wordLevels , wordLevelsIndex , numLevels ) ;
LOG . debug ( "str" + nextStart + "str" + foText . length ( ) + "str" ) ;
LOG . debug ( "str"
+ "str" + CharUtilities . charToNCRef ( ch )
LOG . debug ( "str" + thisStart + "str" + nextStart + "str" ) ;
LOG . debug ( "str" + thisStart + "str" + lastIndex + "str"
CharSequence ics = foText . subSequence ( s , e ) ;
script = CharScript . scriptTagFromCode ( CharScript . dominantScript ( ics ) ) ;
CharSequence mcs = font . performSubstitution ( ics , script , language ) ;
gpa = font . performPositioning ( mcs , script , language ) ;
gpa = getKerningAdjustments ( mcs , font ) ;
mcs = font . reorderCombiningMarks ( mcs , gpa , script , language ) ;
int c = mcs . charAt ( i ) ;
int w = font . getCharWidth ( c ) ;
ipd = ipd . plus ( w ) ;
private int [ ] [ ] getKerningAdjustments ( CharSequence mcs , final Font font ) {
int c = mcs . charAt ( i ) ;
ka [ i ] = font . getKernValue ( cPrev , c ) ;
LOG . debug ( "str" + thisStart + "str" + lastIndex + "str"
+ CharUtilities . toNCRefs ( foText . getCharSequence ( ) . toString ( ) )
String prefix = getNodePrefix ( namespaceURI ) ;
String prefix = getNodePrefix ( nsURI ) ;
public boolean isDelimitedTextRangeBoundary ( int boundary ) {
public Stack collectDelimitedTextRanges ( Stack ranges ) {
maybeNewRange ( ranges ) ;
ranges = collectDelimitedTextRanges ( ranges , currentRange ) ;
maybeNewRange ( ranges ) ;
protected Stack collectDelimitedTextRanges ( Stack ranges , DelimitedTextRange currentRange ) {
ranges = ( ( FONode ) it . next ( ) ) . collectDelimitedTextRanges ( ranges ) ;
private DelimitedTextRange maybeNewRange ( Stack ranges ) {
if ( ! rCur . isEmpty ( ) | | ! isSelfOrDescendent ( rCur . getNode ( ) , this ) ) {
ranges . push ( rNew ) ;
return isDelimitedTextRangeBoundary ( Constants . EN_BEFORE ) ;
return isDelimitedTextRangeBoundary ( Constants . EN_AFTER ) ;
private static boolean isSelfOrDescendent ( FONode n1 , FONode n2 ) {
public static int [ ] readTestData ( String prefix , int index ) {
private int createPrivateUseMapping ( int gi ) {
addPrivateUseMapping ( pu , gi ) ;
log . warn ( "str"
private int findCharacterFromGlyphIndex ( int gi , boolean augment ) {
cc = createPrivateUseMapping ( gi ) ;
public void setGDEF ( GlyphDefinitionTable gdef ) {
throw new IllegalStateException ( "str" ) ;
public void setGSUB ( GlyphSubstitutionTable gsub ) {
throw new IllegalStateException ( "str" ) ;
public void setGPOS ( GlyphPositioningTable gpos ) {
throw new IllegalStateException ( "str" ) ;
public CharSequence performSubstitution ( CharSequence cs , String script , String language ) {
performPositioning ( CharSequence cs , String script , String language , int fontSize ) {
GlyphSequence gs = mapCharsToGlyphs ( cs ) ;
public int [ ] [ ] performPositioning ( CharSequence cs , String script , String language ) {
private int [ ] [ ] scaleAdjustments ( int [ ] [ ] adjustments , int fontSize ) {
int giMissing = findGlyphIndex ( Typeface . NOT_FOUND ) ;
int cc = cs . charAt ( i ) ;
int sl = cs . charAt ( + + i ) ;
gi = findGlyphIndex ( cc ) ;
warnMissingGlyph ( ( char ) cc ) ;
return new GlyphSequence ( cb , gb , null ) ;
private CharSequence mapGlyphsToChars ( GlyphSequence gs ) {
CharBuffer cb = CharBuffer . allocate ( ng ) ;
cb . put ( ( char ) cc ) ;
RtfBookmarkContainerImpl ( RtfContainer parent , Writer w , RtfAttributes attr ) throws IOException
super ( parent , w , attr ) ;
public RtfBookmark newBookmark ( String bookmark ) throws IOException {
mBookmark . close ( ) ;
mBookmark = new RtfBookmark ( this , writer , bookmark ) ;
public CharSequence performSubstitution ( CharSequence cs , String script , String language ) {
performPositioning ( CharSequence cs , String script , String language , int fontSize ) {
performPositioning ( CharSequence cs , String script , String language ) {
performConversions ( formatAlphabeticHebrew ) ;
performConversions ( formatAlphabeticThai ) ;
performConversions ( formatNumeralArabicAbjadi ) ;
performConversions ( formatNumeralHebrewGematria ) ;
private void performConversions ( String [ ] [ ] ts ) {
groupingSize = Integer . parseInt ( s ) ;
NumberConverter nc = new NumberConverter ( format , groupingSeparator , groupingSize , letterValue , features , language , country ) ;
numbers . add ( Long . valueOf ( s ) ) ;
public int getMappedIndex ( int gid ) {
public EmptyMappingTable ( List entries ) {
public int getMappedIndex ( int gid ) {
entries . add ( new MappingRange ( sa [ i ] , ea [ i ] , ma [ i ] ) ) ;
public int getMappedIndex ( int gid ) {
mi = getMappedIndex ( gid , sa [ i ] , ma [ i ] ) ;
throw new AdvancedTypographicTableFormatException ( "str" + gs + "str" + ge + "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + gs + "str" + ge + "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + gs + "str" + ge + "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + gs + "str" + ge + "str" ) ;
throw new AdvancedTypographicTableFormatException ( "str" + mi ) ;
throw new AdvancedTypographicTableFormatException ( "str" + o ) ;
public MappingRange ( int gidStart , int gidEnd , int index ) {
public int [ ] getInterval ( int [ ] interval ) {
public GlyphSequence reorderCombiningMarks ( GlyphDefinitionTable gdef , GlyphSequence gs , int [ ] [ ] gpa , String script , String language ) {
int [ ] ga = gs . getGlyphArray ( false ) ;
if ( gdef . isGlyphClass ( gid , GlyphDefinitionTable . GLYPH_CLASS_MARK ) ) {
GlyphSequence . CharAssociation [ ] aa = gs . getAssociations ( 0 , - 1 ) ;
if ( gdef . isGlyphClass ( gid , GlyphDefinitionTable . GLYPH_CLASS_MARK ) ) {
System . arraycopy ( npa , 0 , gpa , 0 , ng ) ;
return new GlyphSequence ( gs , null , nga , null , null , naa , null ) ;
public static Integer [ ] toUTF32 ( String s , int substitution , boolean errorOnSubstitution )
int s2 = ( ( i + 1 ) < n ) ? ( int ) s . charAt ( i + 1 ) : 0 ;
System . arraycopy ( sa , 0 , na , 0 , k ) ;
public static String fromUTF32 ( Integer [ ] sa ) throws IllegalArgumentException {
sb . append ( ( char ) s ) ;
RtfTemplate newTemplate ( String str , RtfAttributes attr ) throws IOException ;
public TTFSubSetFile ( boolean useKerning , boolean useAdvanced ) {
textUtil . addChar ( s . charAt ( i ) ) ;
textUtil . adjust ( dp [ i ] ) ;
adjust ( new int [ ] {
if ( ! IFUtil . isPAIdentity ( pa ) ) {
IFUtil . adjustPA ( dp [ idx - 1 ] , pa ) ;
trimAdjustments ( dp , text . length ( ) ) , text . toString ( ) ) ;
trimAdjustments ( dp , text . length ( ) ) , text . toString ( ) ) ;
private int [ ] [ ] trimAdjustments ( int [ ] [ ] dp , int textLength ) {
if ( ( pa ! = null ) & & ! IFUtil . isPAIdentity ( pa ) ) {
dp = IFUtil . copyDP ( dp , 0 , i ) ;
init ( ) ;
public static RtfColorTable getInstance ( ) {
instance = new RtfColorTable ( ) ;
getColorNumber ( 192 , 192 , 192 ) ;
public Integer getColorNumber ( String name ) {
addColor ( identifier ) ;
retVal = colorTable . size ( ) ;
retVal = ( ( Integer ) o ) . intValue ( ) + 1 ;
header . writeGroupMark ( true ) ;
header . write ( "str" ) ;
int len = colorTable . size ( ) ;
int identifier = ( ( Integer ) colorTable . get ( i ) ) . intValue ( ) ;
header . writeGroupMark ( false ) ;
private int determineIdentifier ( int red , int green , int blue ) {
private int determineColorLevel ( int identifier , int color ) {
public static int [ ] resolveLevels ( CharSequence cs , Direction defaultLevel ) {
public static int [ ] resolveLevels ( int [ ] chars , int [ ] classes , int defaultLevel , int [ ] levels , boolean useRuleL1 ) {
int [ ] wca = copySequence ( ica ) ;
resolveSeparators ( ica , wca , defaultLevel , levels ) ;
dump ( "str" + ( ( chars ! = null ) ? chars . length : - 1 ) + "str" , chars , classes , defaultLevel , levels ) ;
private static int [ ] copySequence ( int [ ] ta ) {
System . arraycopy ( ta , 0 , na , 0 , na . length ) ;
private static void resolveExplicit ( int [ ] wca , int defaultLevel , int [ ] ea ) {
wca [ i ] = directionOfLevel ( el ) ;
private static int directionOfLevel ( int level ) {
private static int levelOfEmbedding ( int embedding ) {
private static int [ ] levelsFromEmbeddings ( int [ ] ea , int [ ] la ) {
la [ i ] = levelOfEmbedding ( ea [ i ] ) ;
private static void resolveRuns ( int [ ] wca , int defaultLevel , int [ ] ea , int [ ] la ) {
throw new IllegalArgumentException ( "str" ) ;
throw new IllegalArgumentException ( "str" ) ;
int l = findNextNonRetainedFormattingLevel ( wca , ea , s , lPrev ) ;
lPrev = resolveRun ( wca , defaultLevel , ea , la , s , e , l , lPrev ) ;
private static int findNextNonRetainedFormattingLevel ( int [ ] wca , int [ ] ea , int start , int lPrev ) {
return levelOfEmbedding ( ea [ s ] ) ;
private static int getLevelRunLength ( int [ ] ea , int start ) {
int nc = getRetainedFormattingRunLength ( wca , start ) ;
private static int getRetainedFormattingRunLength ( int [ ] wca , int start ) {
private static int resolveRun ( int [ ] wca , int defaultLevel , int [ ] ea , int [ ] la , int start , int end , int level , int levelPrev ) {
int sor = directionOfLevel ( max ( levelPrev , level ) ) ;
le = max ( level , defaultLevel ) ;
le = max ( level , la [ i ] ) ;
le = max ( level , defaultLevel ) ;
int eor = directionOfLevel ( le ) ;
log . debug ( "str" + padLeft ( start , 3 ) + "str" + padLeft ( end , 3 ) + "str" + padLeft ( level , 2 ) + "str" + getClassName ( sor ) + "str" + getClassName ( eor ) + "str" ) ;
return isRetainedFormatting ( wca , start , end ) ? levelPrev : level ;
private static void resolveWeak ( int [ ] wca , int defaultLevel , int [ ] ea , int [ ] la , int start , int end , int level , int sor , int eor ) {
} else if ( isStrong ( bc ) ) {
resolveAdjacentBoundaryNeutrals ( wca , start , end , i , ON ) ;
private static void resolveNeutrals ( int [ ] wca , int defaultLevel , int [ ] ea , int [ ] la , int start , int end , int level , int sor , int eor ) {
if ( isNeutral ( bc ) ) {
} else if ( isNeutral ( bc ) ) {
} else if ( isRetainedFormatting ( bc ) ) {
resolveAdjacentBoundaryNeutrals ( wca , start , end , i , bcPrev ) ;
resolveAdjacentBoundaryNeutrals ( wca , start , end , i , bcEmbedding ) ;
private static void resolveAdjacentBoundaryNeutrals ( int [ ] wca , int start , int end , int index , int bcNew ) {
private static void resolveImplicit ( int [ ] wca , int defaultLevel , int [ ] ea , int [ ] la , int start , int end , int level , int sor , int eor ) {
private static void resolveSeparators ( int [ ] ica , int [ ] wca , int dl , int [ ] la ) {
if ( isRetainedFormatting ( pc ) ) {
if ( isRetainedFormatting ( ic ) ) {
if ( isRetainedFormatting ( ic ) ) {
private static boolean isStrong ( int bc ) {
private static boolean isNeutral ( int bc ) {
private static boolean isRetainedFormatting ( int bc ) {
private static boolean isRetainedFormatting ( int [ ] ca , int s , int e ) {
if ( ! isRetainedFormatting ( ca [ i ] ) ) {
private static int max ( int x , int y ) {
private static int [ ] getClasses ( int [ ] chars ) {
bc = BidiClass . getBidiClass ( chars [ i ] ) ;
private static boolean convertToScalar ( CharSequence cs , int [ ] chars ) throws IllegalArgumentException {
throw new IllegalArgumentException ( "str" ) ;
int chIn = cs . charAt ( i ) ;
chLo = cs . charAt ( i + 1 ) ;
chOut = convertToScalar ( chHi , chLo ) ;
throw new IllegalArgumentException ( "str" ) ;
throw new IllegalArgumentException ( "str" ) ;
throw new IllegalArgumentException ( "str" ) ;
if ( ! triggered & & triggersBidi ( chOut ) ) {
private static int convertToScalar ( int chHi , int chLo ) {
throw new IllegalArgumentException ( "str" ) ;
throw new IllegalArgumentException ( "str" ) ;
sb . append ( ( char ) ch ) ;
sb . append ( CharUtilities . charToNCRef ( ch ) ) ;
sb . append ( "str" ) ;
sb . append ( "str" ) ;
private static String getClassName ( int bc ) {
private static String padLeft ( String s , int width ) {
sb . append ( s ) ;
public static void main ( String [ ] args ) {
compile ( WF_FILE_SCRIPT , WF_FILE_LANGUAGE , spn ) ;
System . err . println ( e . getMessage ( ) ) ;
private static void compile ( String script , String language , String spn ) {
TTXFile tf = TTXFile . getFromCache ( ttxFontsDir + File . separator + tfn ) ;
private static List compile ( String script , String language , String spn , String tfn , TTXFile tf ) {
data . add ( new Object [ ] { script , language , spn , tfn } ) ;
fis = new FileInputStream ( spn ) ;
LineNumberReader lr = new LineNumberReader ( new InputStreamReader ( fis , Charset . forName ( "str" ) ) ) ;
if ( ! gpos . position ( ogs , script , language , 1000 , widths , paa ) ) {
data . add ( new Object [ ] { wf , getGlyphs ( igs ) , getGlyphs ( ogs ) , paa } ) ;
throw new RuntimeException ( e . getMessage ( ) , e ) ;
throw new RuntimeException ( e . getMessage ( ) , e ) ;
throw new RuntimeException ( e . getMessage ( ) , e ) ;
System . err . println ( "str" + ( data . size ( ) - 1 ) + "str" + tfn ) ;
private static int [ ] getGlyphs ( GlyphSequence gs ) {
gb . get ( ga ) ;
return s . substring ( 0 , i ) ;
private static void output ( String dpn , List < Object [ ] > data ) {
fos = new FileOutputStream ( dpn ) ;
throw new RuntimeException ( e . getMessage ( ) , e ) ;
throw new RuntimeException ( e . getMessage ( ) , e ) ;
throw new RuntimeException ( e . getMessage ( ) , e ) ;
boolean test ( String script , String language , String feature , GlyphSequence gs , int index , int flags ) ;
protected Stack collectDelimitedTextRanges ( Stack ranges , DelimitedTextRange currentRange ) {
ranges = header . collectDelimitedTextRanges ( ranges ) ;
ranges = footer . collectDelimitedTextRanges ( ranges ) ;
ranges = ( ( FONode ) it . next ( ) ) . collectDelimitedTextRanges ( ranges ) ;
public void assignWritingModeTraits ( WritingModeTraitsSetter wms ) {
public boolean isEmpty ( ) {
public boolean setChildren ( List list ) {
public static int getBidiClass ( int ch ) {
return getBidiClass ( ch , bcS1 , bcE1 , bcC1 ) ;
public static String encodePositionAdjustments ( int [ ] [ ] dp , int paCount ) {
sb . append ( na ) ;
encodeNextAdjustment ( sb , nz , a ) ;
encodeNextAdjustment ( sb , nz , 0 ) ;
public static String encodePositionAdjustments ( int [ ] [ ] dp ) {
return encodePositionAdjustments ( dp , dp . length ) ;
private static void encodeZeroes ( StringBuffer sb , int nz ) {
sb . append ( "str" ) ;
sb . append ( "str" ) ;
private static void encodeAdjustment ( StringBuffer sb , int a ) {
public static int [ ] [ ] decodePositionAdjustments ( String value ) {
String [ ] sa = value . split ( "str" ) ;
int na = Integer . parseInt ( sa [ 0 ] ) ;
int nz = Integer . parseInt ( s . substring ( 1 ) ) ;
dp [ k / 4 ] [ k % 4 ] = Integer . parseInt ( s ) ;
GlyphContextTester getTester ( String feature ) ;
public RtfHyperLink ( IRtfTextContainer parent , Writer writer , String str , RtfAttributes attr )
public RtfHyperLink ( RtfTextrun parent , Writer writer , RtfAttributes attr )
super ( ( RtfContainer ) parent , writer , attr ) ;
return ( RtfAttributes ) this . attrib . clone ( ) ;
private void closeCurrentText ( ) throws IOException {
mText . close ( ) ;
private void closeAll ( ) throws IOException {
public void setExternalURL ( String url ) {
public boolean isEmpty ( ) {
return GlyphPositioningTable . getLookupTypeName ( getType ( ) ) ;
public boolean isCompatible ( GlyphSubtable subtable ) {
public boolean position ( GlyphPositioningState ps ) {
public static final boolean position ( GlyphPositioningState ps , GlyphPositioningSubtable [ ] sta , int sequenceIndex ) {
applied = ps . apply ( sta [ i ] ) ;
applied = ps . apply ( sta [ i ] ) ;
public static final boolean position ( GlyphSequence gs , String script , String language , String feature , int fontSize , GlyphPositioningSubtable [ ] sta , int [ ] widths , int [ ] [ ] adjustments , ScriptContextTester sct ) {
return position ( state . reset ( gs , script , language , feature , fontSize , widths , adjustments , sct ) , sta , - 1 ) ;
writeChar ( ch , sb , useMultiByte ) ;
public void writeTd ( double x , double y ) {
public void writeTj ( char ch ) {
public synchronized boolean hasEventListeners ( ) {
LOG . debug ( debug . toString ( ) ) ;
key = key . replace ( "str" , "str" ) ;
indexed . add ( Integer . valueOf ( hival ) ) ;
return Integer . valueOf ( i ) ;
protected Map < String , PDFICCBasedColorSpace > iccColorSpaces = new LinkedHashMap < String , PDFICCBasedColorSpace > ( ) ;
this . iccColorSpaces . put ( desc , icc ) ;
PDFICCBasedColorSpace cs = this . iccColorSpaces . get ( desc ) ;
for ( PDFColorSpace colorSpace : colorSpaces . values ( ) ) {
invalidChildError ( locator , getParent ( ) . getName ( ) , FO_URI , getLocalName ( ) ,
invalidChildError ( locator , getParent ( ) . getName ( ) , FO_URI , getLocalName ( ) ,
"str" + positionAtBreak ) ;
return ( level = = rl . level )
protected boolean isNeutralItem ( String nsURI , String lName ) {
} else if ( pc = = BidiConstants . WS ) {
private interface Maker {
private interface Event {
private interface ElementHandler {
Map < String , Class < ? > > m = new java . util . HashMap < String , Class < ? > > ( ) ;
String msg = "str" + this . fontFileURI + "str" ;
addCharacterSet ( font , "str" , new TimesRoman ( ) ) ;
addCharacterSet ( font , "str" , new TimesItalic ( ) ) ;
addCharacterSet ( font , "str" , new TimesBold ( ) ) ;
addCharacterSet ( font , "str" , new TimesBoldItalic ( ) ) ;
parentTree . getNums ( ) . put ( structParent , parent ) ;
private AlignmentContext ( int altitude ,
CommonBorderPaddingBackground bpProps , boolean isNotFirst , boolean isNotLast ,
addBorderTrait ( area , bpProps , isNotFirst ,
addBorderTrait ( area , bpProps , isNotLast ,
boolean discard , int side , int mode ,
public static void addBorders ( Area area , CommonBorderPaddingBackground borderProps ,
BorderProps bps = getBorderProps ( borderProps , CommonBorderPaddingBackground . BEFORE ) ;
bps = getBorderProps ( borderProps , CommonBorderPaddingBackground . AFTER ) ;
bps = getBorderProps ( borderProps , CommonBorderPaddingBackground . START ) ;
bps = getBorderProps ( borderProps , CommonBorderPaddingBackground . END ) ;
addPadding ( area , borderProps , context ) ;
public static final Integer INTERNAL_LINK = 1 ;
public static final Integer EXTERNAL_LINK = 2 ;
public static final Integer FONT = 3 ;
public static final Integer FONT_SIZE = 4 ;
public static final Integer COLOR = 7 ;
public static final Integer PROD_ID = 8 ;
public static final Integer BACKGROUND = 9 ;
public static final Integer UNDERLINE = 10 ;
public static final Integer OVERLINE = 11 ;
public static final Integer LINETHROUGH = 12 ;
public static final Integer BORDER_START = 15 ;
public static final Integer BORDER_END = 16 ;
public static final Integer BORDER_BEFORE = 17 ;
public static final Integer BORDER_AFTER = 18 ;
public static final Integer PADDING_START = 19 ;
public static final Integer PADDING_END = 20 ;
public static final Integer PADDING_BEFORE = 21 ;
public static final Integer PADDING_AFTER = 22 ;
public static final Integer SPACE_START = 23 ;
public static final Integer SPACE_END = 24 ;
public static final Integer START_INDENT = 27 ;
public static final Integer END_INDENT = 28 ;
public static final Integer SPACE_BEFORE = 29 ;
public static final Integer SPACE_AFTER = 30 ;
public static final Integer IS_REFERENCE_AREA = 31 ;
public static final Integer IS_VIEWPORT_AREA = 32 ;
public static final Integer BLINK = 33 ;
public static final Integer UNDERLINE_COLOR = 34 ;
public static final Integer OVERLINE_COLOR = 35 ;
public static final Integer LINETHROUGH_COLOR = 36 ;
public static final Integer PTR = 37 ;
private Map < String , Region > regions ;
regions = new HashMap < String , Region > ( 5 ) ;
hasRegionBefore = true ;
return ( this = = PDFA_1A ) ;
sb . append ( doubleOut ( getNumber ( ) . doubleValue ( ) , 10 ) ) ;
addAreas ( alg , optimalPageCount , blockList , effectiveList ) ;
if ( "str" . equals ( encoding ) ) {
private byte colorModel = COLOR_MODEL_YCRCB ;
System . arraycopy ( width , 0 , arr , 0 , width . length ) ;
XMLUtil . addAttribute ( atts , "str" , "str" + state . getFontFamily ( ) + "str" ) ;
public synchronized int getMaxAscent ( String family , int style , int size ) {
public synchronized int getAscender ( String family , int style , int size ) {
public synchronized int getCapHeight ( String family , int style , int size ) {
public synchronized int getDescender ( String family , int style , int size ) {
public synchronized int getXHeight ( String family , int style , int size ) {
public synchronized int width ( int i , String family , int style , int size ) {
public synchronized int [ ] getWidths ( String family , int style , int size ) {
public synchronized java . awt . Font getFont ( String family , int style , int size ) {
public synchronized boolean hasChar ( String family , int style , int size , char c ) {
lineDataInfo . x2 = pageHeight - Math . round ( ( float ) at . getTranslateY ( ) - x - width ) ;
yOrigin = y - width ;
int component = Math . round ( comps [ i ] * 255 ) ;
if ( ( referencedFontsMatcher ! = null & & referencedFontsMatcher . matches ( triplet ) )
if ( log ! = null & & log . isInfoEnabled ( ) ) {
data [ pos + + ] = 0x0A ;
gen . showPage ( ) ;
private AFPExtensionAttachment returnedObject ;
return getCharacterSet ( size ) . getAscender ( ) * size ;
return getCharacterSet ( size ) . getCapHeight ( ) * size ;
return getCharacterSet ( size ) . getDescender ( ) * size ;
return getCharacterSet ( size ) . getXHeight ( ) * size ;
return getCharacterSet ( size ) . getWidth ( character ) * size ;
return charSet . getAscender ( ) * size ;
return charSet . getCapHeight ( ) * size ;
return charSet . getDescender ( ) * size ;
return charSet . getXHeight ( ) * size ;
return charSet . getWidth ( character ) * size ;
widths [ i ] = widths [ i ] * size ;
this . hasChanged = ( this . hasChanged | | ! nothingChanged ) ;
while ( ch > 0 ) {
returnList . add ( forcedBreakAfterLast ) ;
header . writeGroupMark ( true ) ;
if ( newWeight < = 400 ) {
public static synchronized FontTriplet createFontKey ( String family , String style ,
m . setDefault ( "str" ) ;
m . setDefault ( "str" ) ;
atts . addAttribute ( "str" , "str" , "str" , "str" , getInterfaceName ( ) ) ;
handler . startElement ( "str" , elName , elName , atts ) ;
handler . endElement ( "str" , elName , elName ) ;
Parameter param = new Parameter ( type , name ) ;
atts . addAttribute ( "str" , "str" , "str" , "str" , getExceptionClass ( ) ) ;
handler . startElement ( "str" , elName , elName , atts ) ;
handler . endElement ( "str" , elName , elName ) ;
handler . startElement ( "str" , elName , elName , atts ) ;
handler . endElement ( "str" , elName , elName ) ;
private boolean throwExceptions = true ;
} else if ( block . getTraitAsBoolean ( Trait . IS_REFERENCE_AREA ) ) {
String str = new String ( data , start , length ) ;
sb . append ( "str" ) . append ( ( ( Property ) getColumnWidth ( ) ) . getString ( ) ) ;
if ( actualWidth + allFootnotes < = getLineWidth ( activeNode . line ) ) {
getLineWidth ( activeNode . line ) - actualWidth , canDeferOldFootnotes ) ) > 0 ) {
int availableBPD = getLineWidth ( lastNode . line ) ;
availableBPD = getLineWidth ( node . line ) ;
private static final Log LOG = LogFactory . getLog ( AbstractBaseLayoutManager . class ) ;
LOG . error ( "str" + lengthBase ) ;
while ( lm ! = null & & fobjx ! = lm . getFObj ( ) ) {
return lm . getBaseLength ( lengthBase , fobjx ) ;
LOG . error ( "str" ) ;
LOG . error ( "str" ) ;
LOG . error ( "str" ) ;
LOG . error ( "str" ) ;
LOG . error ( "str" ) ;
LOG . error ( "str" ) ;
int paddingEnd = padding . getPaddingEnd ( false , this ) ;
sb . append ( "str" ) ;
dict . put ( "str" , array ) ;
dict . put ( "str" , array . get ( 0 ) ) ;
sb . append ( "str" ) ;
corr . setUseParent ( false ) ;
( byte ) afpFontAttributes . getFontReference ( ) ,
private String key ;
private String value ;
private int resolution = 240 ;
String EBCIDIC_ENCODING = "str" ;
private Throwable underlyingException ;
underlyingException = t ;
if ( underlyingException = = null ) {
+ underlyingException . getClass ( ) . getName ( ) ;
if ( underlyingException = = null ) {
underlyingException . printStackTrace ( ps ) ;
if ( underlyingException = = null ) {
underlyingException . printStackTrace ( pw ) ;
int cumulateLength = 0 ;
if ( HARDCODED_FONT_NAMES . contains ( f . getName ( ) ) ) {
String searchName = FontUtil . stripWhiteSpace ( f . getName ( ) ) . toLowerCase ( ) ;
addFontMetricsMapper ( fontInfo , f . getName ( ) , fontKey , graphics , style ) ;
addFontTriplet ( fontInfo , f . getName ( ) ,
if ( ! f . getName ( ) . equals ( f . getFamily ( ) ) ) {
private static final boolean DEBUG = false ;
InputStream in = openFontUrl ( resolver , effURI ) ;
private static InputStream openFontUrl ( FontResolver resolver , String uri )
totalLength = previousRowsLength + ElementListUtils . calcContentLength ( elementList ) ;
remainingLength = totalLength - previousRowsLength ;
if ( idx > - 1 ) {
if ( obj instanceof FixedLength ) {
int EN_100 = 169 ;
int EN_200 = 170 ;
int EN_300 = 171 ;
int EN_400 = 172 ;
int EN_500 = 173 ;
int EN_600 = 174 ;
int EN_700 = 175 ;
int EN_800 = 176 ;
int EN_900 = 177 ;
int EN_AVOID = 178 ;
int EN_PRE = 179 ;
int EN_CAPTION = 180 ;
int EN_ICON = 181 ;
int EN_MENU = 182 ;
int EN_MESSAGE_BOX = 183 ;
int EN_SMALL_CAPTION = 184 ;
int EN_STATUS_BAR = 185 ;
int ENUM_COUNT = 185 ;
clippingRect = new Rectangle ( saveIP , saveBP , bv . getIPD ( ) , bv . getBPD ( ) ) ;
if ( offset > fsize | | offset < 0 ) {
out . println ( "str" ) ;
package org . apache . fop . text . linebreak ;
if ( offset > = fsize | | offset < 0 ) {
if ( current > = fsize ) {
encoding = "str" ;
previousBreak = ElementListUtils . determinePreviousBreak ( bodyList , bodyFirstIndex ) ;
| | ( len . isAbsolute ( ) & & len . getValue ( ) < 0 ) ) {
uniBytes = new String ( a ) . getBytes ( "str" ) ;
Iterator providers = Service . providers ( ElementMapping . class , false ) ;
String mapping = ( String ) providers . next ( ) ;
UIManager . setLookAndFeel (
Position innerPosition = pos ;
if ( attributeNS = = null | | attributeNS . length ( ) = = 0 ) {
log . info ( "str" ) ;
log . error ( "str" + ex . getMessage ( ) , ex ) ;
return this . footerNetHeight ;
writeOneAttribute ( RtfText . LEFT_INDENT_FIRST , "str" ) ;
private static final int HEIGHT_OFFSET = 22 ;
lineArea . finalise ( ) ;
= userConfig . getChild ( "str" ) . getValueAsFloat ( DEFAULT_RESOLUTION ) ;
log . debug ( "str" ) ;
int rx = currentIPPosition + area . getBorderAndPaddingWidthStart ( ) ;
} else if ( ! ( ( ListElement ) contentList . getLast ( ) ) . isGlue ( ) ) {
writeControlWord ( "str" ) ;
m . getSubpropMaker ( CP_CONDITIONALITY ) . setDefault ( "str" ) ;
m . getSubpropMaker ( CP_CONDITIONALITY ) . setDefault ( "str" ) ;
lastBreakClass = Constants . EN_COLUMN ;
currentBPPosition = saveSpanBPPos + span . getHeight ( ) ;
log . debug ( "str" + breakClass ) ;
CTM tempctm = new CTM ( containingIPPosition , currentBPPosition ) ;
} else if ( prop_enum = = Constants . EN_UNDERLINE ) {
} else if ( prop_enum = = Constants . EN_NO_UNDERLINE ) {
} else if ( prop_enum = = Constants . EN_OVERLINE ) {
} else if ( prop_enum = = Constants . EN_NO_OVERLINE ) {
} else if ( prop_enum = = Constants . EN_LINE_THROUGH ) {
} else if ( prop_enum = = Constants . EN_NO_LINE_THROUGH ) {
} else if ( prop_enum = = Constants . EN_BLINK ) {
} else if ( prop_enum = = Constants . EN_NO_BLINK ) {
l . set ( i , prop_enum ) ;
public Color backcolor = Color . black ;
columnLMs . add ( new Column ( ( TableColumn ) iter . next ( ) ) ) ;
protected void renderBookmarkTree ( BookmarkData bookmarks ) {
renderBookmarkItem ( ext , null ) ;
closeText ( ) ;
pdf . append ( "str" + ( rx / 1000 f ) + "str" + ( bl / 1000 f ) + "str"
textOpen = true ;
closeText ( ) ;
pdf . append ( "str" + ( rx / 1000 f ) + "str" + ( bl / 1000 f ) + "str"
textOpen = true ;
if ( childNodes . size ( ) ! = 1 ) {
m . getSubpropMaker ( CP_CONDITIONALITY ) . setDefault ( "str" ) ;
m . getSubpropMaker ( CP_CONDITIONALITY ) . setDefault ( "str" ) ;
sub . addEnum ( "str" , makeEnumProperty ( FORCE , "str" ) ) ;
private Property makeEnumProperty ( int enumValue , String text ) {
enums = new Property [ ENUM_COUNT + 1 ] ;
enums [ enumValue ] = new EnumProperty ( enumValue , text ) ;
return makeEnumProperty ( START , "str" ) ;
return makeEnumProperty ( END , "str" ) ;
return makeEnumProperty ( START , "str" ) ;
return makeEnumProperty ( CENTER , "str" ) ;
m . addEnum ( "str" , makeEnumProperty ( NORMAL , "str" ) ) ;
m . addEnum ( "str" , makeEnumProperty ( NORMAL , "str" ) ) ;
public ListIterator getChildNodes ( FONode childNode ) {
textrun . addString ( new String ( data , start , length - start ) ) ;
this . explicitFirstNumber = ( pageStart > 0 ) ? pageStart : 1 ;
this . layoutMasterSet . addPageSequenceMaster ( masterName , this ) ;
+ "str" ) ;
while ( ( curLM = getCellLM ( cellcount ) ) ! = null ) {
while ( ( curLM = getCellLM ( cellcount ) ) ! = null ) {
protected int bpMarginOffset = 0 ;
protected int ipMarginOffset = 0 ;
ipMarginOffset + = spaceStart . intValue ( ) ;
ipMarginOffset + = paddingStart . intValue ( ) ;
Integer paddingBefore = ( Integer ) block . getTrait ( Trait . PADDING_BEFORE ) ;
bpMarginOffset + = paddingBefore . intValue ( ) ;
ipMarginOffset + = borderStartWidth . width ;
bpMarginOffset + = borderBeforeWidth . width ;
public void writeListPrefix ( RtfListItem item )
if ( p ! = null & & ( propId & Constants . COMPOUND_MASK ) ! = 0 ) {
return ( Property ) super . get ( propertyName ) ;
LayoutProcessor blm = new BidiLayoutManager ( ( InlineStackingLayoutManager ) lm ) ;
BidiLayoutManager ( InlineStackingLayoutManager cLM ) {
if ( ! pInfo . getPropertyList ( ) . getElement ( ) . equals ( "str" ) ) {
rtfAttr . set ( RtfText . ATTR_FONT_FAMILY ,
( int ) FoUnitsConverter . getInstance ( ) . convertToTwips ( sValue ) ) ;
log . warn ( "str" + fe . getMessage ( ) ) ;
log . warn ( "str" + fe . getMessage ( ) ) ;
log . warn ( "str" + fe . getMessage ( ) ) ;
if ( ( fopValue . getRed ( ) = = 0 )
if ( bp ! = prevBP & & ! prevBP . couldEndLine ( ) ) {
public void serveBasicLink ( final BasicLink node ) {
protected InlineParent createArea ( ) {
addNamedColor ( "str" , getColorNumber ( 128 , 128 , 128 ) . intValue ( ) ) ;
public Integer getColorNumber ( int red , int green , int blue ) {
return new Integer ( retVal + 1 ) ;
rtfColor = RtfColorTable . getInstance ( ) . getColorNumber ( "str" ) . intValue ( ) ;
greenComponent , blueComponent ) . intValue ( ) ;
return ( int ) ( floatValue * 255 ) ;
import org . apache . commons . io . IOUtil ;
IOUtil . copy ( in , bout ) ;
List sequence = ( List ) pageSequence . get ( seq - 1 ) ;
List sequence = ( List ) pageSequence . get ( seq - 1 ) ;
PSProcSets . writeFontDict ( gen , fontInfo ) ;
public void setColors ( int cols ) throws PDFFilterException {
colors = cols ;
public void setColumns ( int cols ) throws PDFFilterException {
columns = cols ;
this . black = ( tempDouble / PDFColor . blackFactor ) ;
this . black = 1.0 - ( tempDouble / PDFColor . blackFactor ) ;
page . savePage ( tempstream ) ;
if ( over ) {
if ( borderProps ! = null ) {
int iStartPos = 0 ;
if ( _renderer = = null ) throw new Error ( "str" ) ;
Iterator e = glyphs . keySet ( ) . iterator ( ) ;
Iterator e = glyphs . keySet ( ) . iterator ( ) ;
if ( over ) {
if ( over ) {
protected List blockBreaks = new ArrayList ( ) ;
iStartPos = lfp . getLeafPos ( ) + 1 ;
public void init ( ) {
int i = 0 ;
int [ ] bbox = epsImage . getBBox ( ) ;
getContentPane ( ) ,
+ e . getClass ( ) . getName ( ) + "str" + e . getMessage ( ) + "str" , translator . getString ( "str" ) ,
pdfg . addLink ( getBounds ( ) , transform , destination , type ) ;
+ "str" + length
import java . util . HashMap ;
location . set ( object . getNumber ( ) - 1 ,
this . location . set ( o . getNumber ( ) - 1 ,
private int flowIPD = 0 ;
import org . apache . fop . pdf . PDFDocument ;
import org . apache . fop . pdf . PDFPage ;
import org . apache . fop . area . CTM ;
currentStream . add ( "str" ) ;
protected Map dirTabs ;
private List unicodeMapping ;
getLogger ( ) . debug ( "str" + cmapPID
getLogger ( ) . debug ( "str" + numGlyphStrings
getLogger ( ) . debug ( k + "str" + i + "str" + mtxTab . length
if ( ! notice . equals ( "str" )
& & ! fontName . equals ( "str" )
package org . apache . fop . viewer ;
import java . util . ResourceBundle ;
this ( Locale . getDefault ( ) ) ;
if ( newClip | | newTransform ) {
this . pdfDoc . output ( outputStream ) ;
this . currentFontName = name ;
resourceContext . addGState ( gstate ) ;
if ( over ) {
if ( borderProps ! = null ) {
iStartPos = lfp . getLeafPos ( ) + 1 ;
"str" , "str" , "str" , "str" , "str" , "str" , "str" ,
"str" , "str" , "str" , "str" , "str" , "str" ,
"str" , "str" , "str" , "str" , "str" , "str" ,
"str" , "str" , "str" , "str" , "str" , "str" ,
"str" , "str" , "str" , "str" , "str" , "str" ,
getLogger ( ) . error ( "str" , t ) ;
if ( ! checkTTC ( in , name ) )
line . setAttributeNS ( null , "str" , "str" ) ;
userAgent . getLogger ( ) . error ( "str" , t ) ;
if ( child instanceof FObj & & ( ( FObj ) child ) . generatesInlineAreas ( ) ) {
log . warn ( "str" ) ;
"str" , "str" , "str" , "str" , "str" , "str" ,
if ( currentHeight + lineHeight > maxHeight ) {
if ( hyphProps . hyphenate = = Hyphenate . TRUE ) {
char ch = area . getFontState ( ) . mapChar ( s . charAt ( i ) ) ;
( new Integer ( ( int ) area . getFontState ( ) . mapChar ( s . charAt ( i + 1 ) ) ) ) ,
area . setMaxHeight ( area . getMaxHeight ( ) - footArea . getHeight ( ) + oldHeight ) ;
cmap_rangeOffsets [ i ] = in . readTTFUShort ( ) ;
addRect ( x1 - ( th / 2 ) , y1 , th , y2 - y1 + 1 , stroke , stroke ) ;
addRect ( x1 , y1 + ( th / 2 ) , x2 - x1 + 1 , th , stroke , stroke ) ;
addRect ( x1 - ( th / 2 ) , start , th , len , stroke , stroke ) ;
addRect ( x1 - ( th / 2 ) , y1 , th , y2 - y1 + 1 , stroke , stroke ) ;
addRect ( start , y1 + ( th / 2 ) , len , th , stroke , stroke ) ;
addRect ( x1 , y1 + ( th / 2 ) , x2 - x1 + 1 , th , stroke , stroke ) ;
AreaContainer ac = p . getBody ( ) . getCurrentColumnArea ( ) ;
entries . addElement ( new Entry ( start , metrics ) ) ;
entries . addElement ( new int [ ] { first , last , width } ) ;
entries . addElement ( new int [ ] { first , last , width , posX , posY } ) ;
_outlines . addElement ( obj ) ;
import org . apache . fop . layout . inline . InlineArea ;
for ( int i = start ; i < start + length ; i + + ) {
return new ListBlock . Maker ( ) ;
int areaWidth = area . getAllocationWidth ( ) - startIndent - endIndent ;
final static int [ ] [ ] vals = {
x = Double . valueOf ( st . nextToken ( ) ) . floatValue ( ) ;
y = Double . valueOf ( st . nextToken ( ) ) . floatValue ( ) ;
width = Double . valueOf ( st . nextToken ( ) ) . floatValue ( ) ;
height = Double . valueOf ( st . nextToken ( ) ) . floatValue ( ) ;
selectors . addElement ( current ) ;
rules . removeElementAt ( index ) ;
static protected Vector formats = null ;
Enumeration itr = formats . elements ( ) ;
private Vector files = new Vector ( ) ;
Enumeration iterator = files . elements ( ) ;
files . addElement ( source ) ;
MessageHandler . logln ( "str" + actMessId + "str" ) ;
MessageHandler . logln ( "str" + actMessId + "str" ) ;
default : title = "str" ;
MessageHandler . logln ( "str" ) ;
+ "str" ) ;
} else if ( area instanceof SVGPolylineElementImpl ) {
propertyTable = ( Hashtable ) elementTable . get ( elementName ) ;
public Vector elements = new Vector ( ) ;
public Vector elements = new Vector ( ) ;
public void removeChild ( Area area ) {
package org . apache . fop . dom . svg ;
package org . apache . fop . dom . svg ;
return new FObjMixed . Maker ( ) ;
super ( parent , propertyList ) ;
children . addElement ( new FOText ( data , start , length , this ) ) ;
r . setX ( r . getX ( ) + ac . getXPosition ( ) + area . getTableCellXOffset ( ) ) ;
this . currentYPosition - = h ;
assertEquals ( "str" , response . description ( ) ) ;
assertEquals ( "str" , response . description ( ) ) ;
assertEquals ( "str" , response . description ( ) ) ;
assertEquals ( "str" , response . description ( ) ) ;
assertEquals ( "str" , response . description ( ) ) ;
assertEquals ( "str" , response . description ( ) ) ;
assertEquals ( uploader . getRequestPayloadSize ( ) , 10 * 1024 * 1024 ) ;
private int requestPayloadSize = 10 * 1024 * 1024 ;
assertEquals ( uploader . getRequestPayloadSize ( ) , 1024 * 1024 * 1024 ) ;
private int requestPayloadSize = 1024 * 1024 * 1024 ;
private MockServerClient mockServer ;
TusUploader uploader = client . resumeUpload ( upload ) ;
public void set ( String fingerprint , URL url ) {
public void remove ( String fingerprint ) {
public void testResumeOrCreateUpload ( ) throws IOException , ProtocolException {
client . setUploadCreationURL ( mockServerURL ) ;
public static double expScale ( double cons , double val ) {
String operation = job . getConfiguration ( ) . get ( "str" , "str" ) ;
if ( operation . startsWith ( "str" ) ) {
initBuffers ( ) ;
public File getSceneFile ( String fileName ) {
if ( actorArray . getNumElement ( ) > 0 ) {
double t = ( scene . waterHeight - .125 - ray . o . y - scene . origin . y ) / ray . d . y ;
double t = ( scene . waterHeight - .125 - ray . o . y - scene . origin . y ) / ray . d . y ;
double theta = ( len < Ray . EPSILON ) ? 0 : Math . acos ( - z ) / ( Constants . TAU * len ) ;
double theta = ( len < Ray . EPSILON ) ? 0 : Math . acos ( - z ) / ( Constants . TAU * len ) ;
logger . warn ( "str" ) ;
new SignTexture ( "str" ) ,
fileDialog . setFile ( bufferedScene . name ( ) + "str" + bufferedScene . spp + "str" ) ;
value = Math . max ( 0 , value ) ;
public synchronized void set ( int y , int x , int z ) {
public synchronized int get ( int x , int z ) {
color = texture [ 0 ] . getColor ( 1 - ray . u , ray . v ) ;
color = texture [ 3 ] . getColor ( ray . u , ray . v ) ;
color = texture [ index [ 0 ] ] . getColor ( 1 - ray . u , ray . v ) ;
color = texture [ index [ 3 ] ] . getColor ( ray . u , ray . v ) ;
double t11 = m11 * o . m11 + m12 * o . m21 + m13 * o . m31 ;
double t21 = m21 * o . m11 + m22 * o . m21 + m23 * o . m31 ;
double t31 = m31 * o . m11 + m32 * o . m21 + m33 * o . m31 ;
sunAzimuth . set ( QuickMath . radToDeg ( renderMan . scene ( ) . sun ( ) . getAzimuth ( ) ) ) ;
sunAltitude . set ( QuickMath . radToDeg ( renderMan . scene ( ) . sun ( ) . getAltitude ( ) ) ) ;
textField . setText ( String . format ( "str" , value ) ) ;
renderManager . scene ( ) . setCloudHeight ( value ) ;
camera . setView ( - 3 * Math . PI / 4 , - 5 * Math . PI / 16 ) ;
} else if ( args [ i ] . equals ( "str" ) ) {
textures . add ( new IndexedTexture ( "str" , Texture . anvilTop , 0xE7 ) ) ;
clouds [ tilex ] [ tiley ] | = ( ( long ) ( v & 1 ) ) < < ( suby * 8 + subx ) ;
response . put ( "str" , FieldFactory . createForScm ( "str" , "str" , false , false , false , "str" ) ) ;
LOGGER . info ( String . format ( "str" , flyweightFolder ) ) ;
LOGGER . info ( String . format ( "str" , revision . getRevision ( ) ) ) ;
LOGGER . debug ( String . format ( "str" , gitConfig . getUrl ( ) ) ) ;
LOGGER . debug ( "str" ) ;
LOGGER . debug ( String . format ( "str" , oldBranchToRevisionMap , newBranchToRevisionMap ) ) ;
LOGGER . info ( String . format ( "str" , newerRevisions . size ( ) ) ) ;
LOGGER . info ( String . format ( "str" , destinationFolder , revision ) ) ;
public static final String REF_SPEC = "str" ;
. compose ( combineLatestPair ( changedUser ) )
protected @BindString ( R . string . discovery_sort_types_magic ) String magicString ;
this . magicString , this . popularString , this . newestString , this . endingSoonString , this . mostFundedString
view . switchMap ( v - > v . lifecycle ( ) . map ( e - > Pair . create ( v , e ) ) )
Observable < String > currentCommentBody ( ) ;
private final BehaviorSubject < String > currentCommentBody = BehaviorSubject . create ( ) ;
. subscribe ( currentCommentBody : : onNext ) ;
vm . outputs . currentCommentBody ( ) . subscribe ( showCommentBodyTest ) ;
. switchMap ( t - > RxTextView . textChanges ( t ) . skip ( 1 ) )
private final PublishSubject < Void > commentPosted = PublishSubject . create ( ) ;
public void onPageFinished ( final @NonNull WebView view , final @NonNull String url ) {
public WebResourceResponse shouldInterceptRequest ( final @NonNull WebView view , final @NonNull String url ) {
public void registerRequestHandlers ( final @NonNull List < RequestHandler > requestHandlers ) {
public void setFormContents ( final @NonNull FormContents formContents ) {
protected Request buildRequest ( final @NonNull String url ) {
protected InputStream insertWebViewJavascript ( final @NonNull Context context , final @NonNull InputStream originalBody )
protected boolean isInterceptable ( final @NonNull Uri uri ) {
private boolean startModalWebViewActivity ( final @NonNull Request request , final @NonNull WebView webView ) {
private boolean startProjectActivity ( final @NonNull Request request , final @NonNull WebView webView ) {
private boolean handleRequest ( final @NonNull Request request , final @NonNull WebView webView ) {
public MimeHeaders ( final @NonNull String contentType ) {
protected void onCreate ( final @Nullable Bundle savedInstanceState ) {
void onNameTextChanged ( final @NonNull CharSequence fullName ) {
void onEmailTextChanged ( final @NonNull CharSequence email ) {
void onPasswordTextChange ( final @NonNull CharSequence password ) {
public ApiException ( final @NonNull ErrorEnvelope errorEnvelope , final @NonNull retrofit . Response response ) {
public BindableAdapter ( final @NonNull Context context ) {
public abstract View newView ( final @NonNull LayoutInflater inflater , final int position , final @Nullable ViewGroup container ) ;
@Override public final View getDropDownView ( final int position , View view , final @Nullable ViewGroup container ) {
public View newDropDownView ( final @NonNull LayoutInflater inflater , final int position , final @Nullable ViewGroup container ) {
public void bindDropDownView ( final @NonNull T item , final int position , final @NonNull View view ) {
public abstract @Nullable String newerActivities ( ) ;
public SearchToolbar ( final @NonNull Context context ) {
public SearchToolbar ( final @NonNull Context context , final @Nullable AttributeSet attrs ) {
public SearchToolbar ( final @NonNull Context context , final @Nullable AttributeSet attrs , final int defStyleAttr ) {
public StringPreference ( final @NonNull SharedPreferences sharedPreferences , final @NonNull String key ) {
public void set ( final @NonNull String value ) {
public CombineLatestPairTransformer ( final @NonNull Observable < T > second ) {
@NonNull public Observable < Pair < S , T > > call ( final @NonNull Observable < S > first ) {
protected void onCreate ( final @Nullable Bundle savedInstanceState ) {
cancelButtonTextView . setOnClickListener ( ( final @NonNull View v ) - > dismissCommentDialog ( ) ) ;
postCommentButton . setOnClickListener ( ( final @NonNull View v ) - > {
public void projectContextClicked ( final @NonNull ProjectContextViewHolder viewHolder ) {
public void emptyCommentFeedLoginClicked ( final @NonNull EmptyCommentFeedViewHolder viewHolder ) {
protected void onActivityResult ( final int requestCode , final int resultCode , final @NonNull Intent intent ) {
public IconTextView ( final @NonNull Context context ) {
public IconTextView ( final @NonNull Context context , final @Nullable AttributeSet attrs ) {
public IconTextView ( final @NonNull Context context , final @Nullable AttributeSet attrs , final int defStyleAttr ) {
public IconTextView ( final @NonNull Context context , final @Nullable AttributeSet attrs , final int defStyleAttr ,
protected void initialize ( final @NonNull Context context , final @Nullable AttributeSet attrs , final int defStyleAttr ,
public TakePairWhenTransformer ( final @NonNull Observable < T > when ) {
public Observable < Pair < S , T > > call ( final @NonNull Observable < S > source ) {
ApiEndpoint ( final @NonNull String name , final @Nullable String url ) {
public static ApiEndpoint from ( final @NonNull String url ) {
public WebViewJavascriptInterface ( final @NonNull KSWebViewClient webViewClient ) {
public void email ( final @NonNull String s ) {
public void password ( final @NonNull String s ) {
protected void onCreate ( final @NonNull Context context , @Nullable Bundle savedInstanceState ) {
private static boolean isValid ( final @NonNull String email , final @NonNull String password ) {
private Observable < AccessTokenEnvelope > submit ( final @NonNull String email , final @NonNull String password ) {
private void success ( final @NonNull AccessTokenEnvelope envelope ) {
protected void onHandleIntent ( final @NonNull Intent intent ) {
public TakeWhenTransformer ( final @NonNull Observable < T > when ) {
public Observable < S > call ( final @NonNull Observable < S > source ) {
public EnumAdapter ( final @NonNull Context context , final @NonNull Class < T > enumType , final boolean showNull , final @LayoutRes int spinnerItemResource ) {
public View newView ( final @NonNull LayoutInflater inflater , final int position , final @Nullable ViewGroup container ) {
public final void bindView ( final @NonNull T item , final int position , final @NonNull View view ) {
public final View newDropDownView ( final @NonNull LayoutInflater inflater , final int position , final @Nullable ViewGroup container ) {
protected String getName ( final @NonNull T item ) {
public void initialProject ( final @NonNull Project project ) { initialProject . onNext ( project ) ; }
public void commentBody ( final @NonNull String string ) {
protected void onCreate ( final @NonNull Context context , final @Nullable Bundle savedInstanceState ) {
private Observable < Comment > postComment ( final @NonNull Project project , final @NonNull String body ) {
public void postClick ( final @NonNull String body ) {
protected void onCreate ( final @Nullable Bundle savedInstanceState ) {
public void codeEditTextOnTextChanged ( final @NonNull CharSequence code ) {
public abstract @Nullable DateTime completedAt ( ) ;
public abstract @Nullable Reward reward ( ) ;
public abstract @Nullable Project project ( ) ;
public abstract @Nullable Location location ( ) ;
public abstract @Nullable Long rewardId ( ) ;
public abstract @Nullable User backer ( ) ;
@NonNull public static Map < String , Object > discoveryParamsProperties ( final @NonNull DiscoveryParams params ) {
@NonNull public static Map < String , Object > discoveryParamsProperties ( final @NonNull DiscoveryParams params , @NonNull String prefix ) {
@NonNull public static Map < String , Object > categoryProperties ( final @NonNull Category category ) {
@NonNull public static Map < String , Object > categoryProperties ( final @NonNull Category category , final @NonNull String prefix ) {
@NonNull public static Map < String , Object > locationProperties ( final @NonNull Location location ) {
@NonNull public static Map < String , Object > locationProperties ( final @NonNull Location location , final @NonNull String prefix ) {
@NonNull public static Map < String , Object > userProperties ( final @NonNull User user ) {
@NonNull public static Map < String , Object > userProperties ( final @NonNull User user , final @NonNull String prefix ) {
@NonNull public static Map < String , Object > projectProperties ( final @NonNull Project project ) {
@NonNull public static Map < String , Object > projectProperties ( final @NonNull Project project , final @NonNull String prefix ) {
@NonNull public static Map < String , Object > projectProperties ( final @NonNull Project project , final @Nullable User loggedInUser , final @NonNull String prefix ) {
@NonNull public static Map < String , Object > activityProperties ( final @NonNull Activity activity ) {
@NonNull public static Map < String , Object > activityProperties ( final @NonNull Activity activity , final @NonNull String prefix ) {
@NonNull public static Map < String , Object > updateProperties ( final @NonNull Project project , final @NonNull Update update ) {
@NonNull public static Map < String , Object > updateProperties ( final @NonNull Project project , final @NonNull Update update , final @NonNull String prefix ) {
public void add ( final @NonNull PushNotificationEnvelope envelope ) {
protected NeverApiErrorTransformer ( final @Nullable Action1 < ErrorEnvelope > errorAction ) {
public @NonNull Observable < T > call ( final @NonNull Observable < T > source ) {
protected void onHandleIntent ( final @NonNull Intent intent ) {
private void sendTokenToApi ( final @NonNull String token ) {
private void subscribeToGlobalTopic ( final @NonNull String token ) throws IOException {
public Bitmap transform ( final @NonNull Bitmap source ) {
public LoginToolbar ( final @NonNull Context context ) {
public LoginToolbar ( final @NonNull Context context , final @Nullable AttributeSet attrs ) {
public LoginToolbar ( final @NonNull Context context , final @Nullable AttributeSet attrs , final int defStyleAttr ) {
@Override public @NonNull Bitmap transform ( final @NonNull Bitmap source ) {
public abstract @Nullable Activity activity ( ) ;
public abstract @Nullable Project project ( ) ;
public abstract @Nullable User user ( ) ;
public < T > TypeAdapter < T > create ( final @NonNull Gson gson , final @NonNull TypeToken < T > type ) {
public WaitUntilTransformer ( final @NonNull Observable < R > until ) {
public Observable < T > call ( final @NonNull Observable < T > source ) {
public ProjectCardViewHolder ( final @NonNull View view , final @NonNull Delegate delegate ) {
public void onClick ( final @NonNull View view ) {
protected void onCreate ( final @NonNull Context context , final @Nullable Bundle savedInstanceState ) {
public HtmlTextView ( final @NonNull Context context ) {
public HtmlTextView ( final @NonNull Context context , final @Nullable AttributeSet attrs ) {
protected void onCreate ( final @NonNull Context context , final @Nullable Bundle savedInstanceState ) {
public void emptyActivityFeedDiscoverProjectsClicked ( final @NonNull EmptyActivityFeedViewHolder viewHolder ) {
public void emptyActivityFeedLoginClicked ( final @NonNull EmptyActivityFeedViewHolder viewHolder ) {
public void friendBackingClicked ( final @NonNull FriendBackingViewHolder viewHolder , final @NonNull Activity activity ) {
public Logout ( final @NonNull CookieManager cookieManager , final @NonNull CurrentUser currentUser ) {
public WebClient ( final @NonNull WebService service ) {
public abstract @Nullable String code ( ) ;
public void email ( final @NonNull String s ) {
public void onCreate ( final @NonNull Context context , @Nullable Bundle savedInstanceState ) {
private Observable < User > submitEmail ( final @NonNull String email ) {
public KSToolbar ( final @NonNull Context context ) {
public KSToolbar ( final @NonNull Context context , final @Nullable AttributeSet attrs ) {
public KSToolbar ( final @NonNull Context context , final @Nullable AttributeSet attrs , final int defStyleAttr ) {
public void setTitle ( final @NonNull String title ) {
protected final void addSubscription ( final @NonNull Subscription subscription ) {
public void trackLoginRegisterTout ( final @Nullable String intent ) {
public BooleanPreference ( final @NonNull SharedPreferences sharedPreferences , final @NonNull String key ) {
public BooleanPreference ( final @NonNull SharedPreferences sharedPreferences , final @NonNull String key ,
public static @ColorInt int foregroundColor ( final int backgroundColor , final @NonNull Context context ) {
ApiEndpoint provideApiEndpoint ( @ApiEndpointPreference final @NonNull StringPreference apiEndpointPreference ) {
StringPreference provideApiEndpointPreference ( final @NonNull SharedPreferences sharedPreferences ) {
public static RefWatcher getRefWatcher ( final @NonNull Context context ) {
public void onMessageReceived ( final @NonNull String from , final @NonNull Bundle data ) {
public LoginPopupMenu ( final @NonNull Context context , final @NonNull View anchor ) {
protected SignupData ( final @NonNull String fullName , final @NonNull String email , final @NonNull String password ,
public KSViewHolder ( final @NonNull View view ) {
public void onClick ( final @NonNull View view ) {
public Font ( final @NonNull AssetManager assetManager ) {
public static @NonNull < T > ApiErrorOperator < T > apiError ( final @NonNull Gson gson ) {
protected void onCreate ( final @NonNull Context context , final @Nullable Bundle savedInstanceState ) {
protected void onResume ( final @NonNull ViewType view ) {
private void onTakeView ( final @NonNull ViewType view ) {
public final void addSubscription ( final @NonNull Subscription subscription ) {
protected void save ( final @NonNull Bundle state ) {
public IconButton ( final @NonNull Context context ) {
public IconButton ( final @NonNull Context context , final @Nullable AttributeSet attrs ) {
public IconButton ( final @NonNull Context context , final @Nullable AttributeSet attrs , final int defStyleAttr ) {
public static boolean isApiUri ( final @NonNull Uri uri , final @NonNull String webEndpoint ) {
public static boolean isCookiesUri ( final @NonNull Uri uri , final @NonNull String webEndpoint ) {
public static boolean isDiscoverCategoriesPath ( final @NonNull String path ) {
public static boolean isDiscoverScopePath ( final @NonNull String path , final @NonNull String scope ) {
public static boolean isDiscoverPlacesPath ( final @NonNull String path ) {
public static boolean isHelloUri ( final @NonNull Uri uri , final @NonNull String webEndpoint ) {
public static boolean isHivequeenUri ( final @NonNull Uri uri , final @NonNull String webEndpoint ) {
public static boolean isKickstarterUri ( final @NonNull Uri uri , final @NonNull String webEndpoint ) {
public static boolean isProjectUri ( final @NonNull Uri uri , final @NonNull String webEndpoint ) {
public static boolean isSignupUri ( final @NonNull Uri uri , final @NonNull String webEndpoint ) {
public static boolean isStagingUri ( final @NonNull Uri uri , final @NonNull String webEndpoint ) {
public static boolean isCheckoutThanksUri ( final @NonNull Uri uri , final @NonNull String webEndpoint ) {
public static boolean isModalUri ( final @NonNull Uri uri , final @NonNull String webEndpoint ) {
public static boolean isPrivacyUri ( final @NonNull Uri uri , final @NonNull String webEndpoint ) {
public static boolean isProjectNewPledgeUri ( final @NonNull Uri uri , final @NonNull String webEndpoint ) {
public static boolean isTermsOfUseUri ( final @NonNull Uri uri , final @NonNull String webEndpoint ) {
public static boolean isWebUri ( final @NonNull Uri uri , final @NonNull String webEndpoint ) {
public ResponseException ( final @NonNull retrofit . Response response ) {
public void login ( final @NonNull User newUser , final @NonNull String accessToken ) {
protected void onCreate ( final @Nullable Bundle savedInstanceState ) {
protected void onActivityResult ( final int requestCode , final int resultCode , final @NonNull Intent intent ) {
void onEmailTextChanged ( final @NonNull CharSequence email ) {
void onPasswordTextChanged ( final @NonNull CharSequence password ) {
public abstract @Nullable Integer likesCount ( ) ;
public abstract @Nullable DateTime publishedAt ( ) ;
public abstract @Nullable DateTime updatedAt ( ) ;
public abstract @Nullable Api api ( ) ;
public IntPreference ( final @NonNull SharedPreferences sharedPreferences , final @NonNull String key ) {
public IntPreference ( final @NonNull SharedPreferences sharedPreferences , final @NonNull String key ,
public abstract @Nullable Integer projectsCount ( ) ;
public int secondaryColor ( final @NonNull Context context ) {
public void onCreate ( final @Nullable Bundle savedInstanceState ) {
public KSRendererBuilder ( final @NonNull Context context , final @NonNull String videoLink ) {
public void buildRenderers ( final @NonNull KSVideoPlayer player ) {
public EmptyCommentFeedViewHolder ( final @NonNull View view , final @NonNull Delegate delegate ) {
protected @LayoutRes int layout ( final @NonNull SectionRow sectionRow ) {
protected @NonNull KSViewHolder viewHolder ( final @LayoutRes int layout , final @NonNull View view ) {
public KoalaTrackingClient ( @ForApplication final @NonNull Context context , final @NonNull CurrentUser currentUser ) {
public void track ( final @NonNull String eventName ) {
public void track ( final @NonNull String eventName , final @NonNull Map < String , Object > properties ) {
public static @ColorInt int primaryColor ( final @NonNull Context context , final @NonNull DiscoveryParams params ) {
public static @ColorInt int secondaryColor ( final @NonNull Context context , final @NonNull DiscoveryParams params ) {
public static boolean overlayShouldBeLight ( final @NonNull DiscoveryParams params ) {
public static @ColorInt int overlayTextColor ( final @NonNull Context context , final @NonNull DiscoveryParams params ) {
public static @ColorInt int overlayTextColor ( final @NonNull Context context , final boolean light ) {
public static boolean isAvailable ( final @NonNull Context context ) {
public ProjectToolbar ( final @NonNull Context context ) {
public ProjectToolbar ( final @NonNull Context context , final @Nullable AttributeSet attrs ) {
public ProjectToolbar ( final @NonNull Context context , final @Nullable AttributeSet attrs , final int defStyleAttr ) {
public abstract @Nullable Long commentId ( ) ;
@NonNull public static < T > Map < String , T > prefixKeys ( final @NonNull Map < String , T > source , final @NonNull String prefix ) {
@NonNull public static < S , T > Map < S , T > compact ( final @NonNull Map < S , T > source ) {
public static byte [ ] readFully ( final @NonNull InputStream inputStream ) throws IOException {
public abstract @Nullable UrlsEnvelope urls ( ) ;
public abstract @Nullable ApiEnvelope api ( ) ;
protected void onCreate ( final @NonNull Context context , final @Nullable Bundle savedInstanceState ) {
public void initialize ( final @NonNull Project project ) {
public Observable < Backing > fetchProjectBacking ( final @NonNull Project project , final @NonNull User user ) {
public static boolean isUserAuthor ( final @NonNull Comment comment , final @Nullable User user ) {
@NonNull public Observable < Void > call ( final @NonNull Observable < S > source ) {
public static < T > NeverErrorTransformer < T > pipeErrorsTo ( final @NonNull PublishSubject < Throwable > errorSubject ) {
public static < T > NeverErrorTransformer < T > pipeErrorsTo ( final @NonNull Action1 < Throwable > errorAction ) {
public static < T > NeverApiErrorTransformer < T > pipeApiErrorsTo ( final @NonNull PublishSubject < ErrorEnvelope > errorSubject ) {
public static < T > NeverApiErrorTransformer < T > pipeApiErrorsTo ( final @NonNull Action1 < ErrorEnvelope > errorAction ) {
public static < S , T > TakeWhenTransformer < S , T > takeWhen ( final @NonNull Observable < T > when ) {
public static < S , T > TakePairWhenTransformer < S , T > takePairWhen ( final @NonNull Observable < T > when ) {
public static < S , T > ZipPairTransformer < S , T > zipPair ( final @NonNull Observable < T > second ) {
public static < S , T > CombineLatestPairTransformer < S , T > combineLatestPair ( final @NonNull Observable < T > second ) {
@NonNull public static < T , R > WaitUntilTransformer < T , R > waitUntil ( final @NonNull Observable < R > until ) {
void bind ( final @NonNull DiscoveryViewModel viewModel , final @NonNull WebClient client ) ;
public void onClick ( final @NonNull View view ) {
public void destroy ( final @NonNull ViewModel viewModel ) {
public void save ( final @NonNull ViewModel viewModel , final @NonNull Bundle envelope ) {
private String fetchId ( final @Nullable Bundle savedInstanceState ) {
private String findIdForViewModel ( final @NonNull ViewModel viewModel ) {
public CommentFeedAdapter ( final @NonNull Delegate delegate ) {
protected @LayoutRes int layout ( final @NonNull SectionRow sectionRow ) {
protected @NonNull KSViewHolder viewHolder ( final @LayoutRes int layout , final @NonNull View view ) {
public abstract @Nullable Api api ( ) ;
public abstract @Nullable String projectShort ( ) ;
public abstract @Nullable String updates ( ) ;
public ApiErrorOperator ( final @NonNull Gson gson ) {
public Subscriber < ? super Response < T > > call ( final @NonNull Subscriber < ? super T > subscriber ) {
public void onError ( final @NonNull Throwable e ) {
public void onNext ( final @NonNull retrofit . Response < T > response ) {
} catch ( final @NonNull IOException e ) {
public RequestHandler ( final @NonNull RequestHandler . Matcher matcher , final @NonNull RequestHandler . Action action ) {
public boolean matches ( final @NonNull Uri uri , final @NonNull String webEndpoint ) {
public boolean action ( final @NonNull Request request , final @NonNull WebView webView ) {
boolean call ( final @NonNull Uri uri , final @NonNull String webEndpoint ) ;
boolean call ( final @NonNull Request request , final @NonNull WebView webView ) ;
public DebugPushNotificationsView ( final @NonNull Context context ) {
public DebugPushNotificationsView ( final @NonNull Context context , final @Nullable AttributeSet attrs ) {
public DebugPushNotificationsView ( final @NonNull Context context , final @Nullable AttributeSet attrs , final int defStyleAttr ) {
protected void onCreate ( final @Nullable Bundle savedInstanceState ) {
protected void onSaveInstanceState ( final @NonNull Bundle outState ) {
protected final void addSubscription ( final @NonNull Subscription subscription ) {
private void fetchViewModel ( final @Nullable Bundle viewModelEnvelope ) {
public static void hideKeyboard ( final @NonNull Context context , final @Nullable View view ) {
public ActivityFeedToolbar ( final @NonNull Context context ) {
protected void onCreate ( final @NonNull Context context , @Nullable Bundle savedInstanceState ) {
public Observable < AccessTokenEnvelope > createNewAccount ( final @NonNull String fbAccessToken , final boolean sendNewsletters ) {
private void registerWithFacebookSuccess ( final @NonNull AccessTokenEnvelope envelope ) {
public KSRequestInterceptor ( final @NonNull Release release ) {
public Response intercept ( final @NonNull Chain chain ) throws IOException {
private Request request ( final @NonNull Request initialRequest ) {
public void onCreate ( final @Nullable Bundle savedInstanceState ) {
public Response intercept ( final @NonNull Chain chain ) throws IOException {
private Request request ( final @NonNull Request initialRequest ) {
private HttpUrl url ( final @NonNull HttpUrl initialHttpUrl ) {
private boolean shouldIntercept ( final @NonNull Request request ) {
@NonNull public Observable < T > call ( final @NonNull Observable < T > source ) {
public CommentViewHolder ( final @NonNull View view ) {
protected void onCreate ( final @Nullable Bundle savedInstanceState ) {
void onEmailTextChanged ( final @NonNull CharSequence email ) {
private void submitBugReport ( final @Nullable User user ) {
public void onItemSelected ( final @NonNull AdapterView < ? > adapterView , final @NonNull View view ,
public void onNothingSelected ( final @NonNull AdapterView < ? > adapterView ) { }
private void showCustomEndpointDialog ( final int originalSelection , final @NonNull String defaultUrl ) {
private void setEndpointAndRelaunch ( final @NonNull String endpoint ) {
protected void onCreate ( final @NonNull Context context , final @Nullable Bundle savedInstanceState ) {
public void takeProject ( final @NonNull Project project ) {
public void categoryPromoClick ( final @NonNull CategoryPromoViewHolder viewHolder , final @NonNull Category category ) {
public void projectCardMiniClick ( final @NonNull ProjectCardMiniViewHolder viewHolder , final @NonNull Project project ) {
public KSVideoPlayer ( final @NonNull RendererBuilder rendererBuilder ) {
public void onPlayerError ( final @NonNull ExoPlaybackException error ) {
public void setListener ( final @NonNull Listener listener ) {
public void setSurface ( final @NonNull Surface surface ) {
public Release ( final @NonNull PackageInfo packageInfo ) {
public RewardViewHolder ( final @NonNull View view , final @NonNull Delegate delegate ) {
public void onClick ( final @NonNull View view ) {
public static Bundle maybeGetBundle ( final @Nullable Bundle state , final @NonNull String key ) {
protected void onCreate ( final @NonNull Context context , final @Nullable Bundle savedInstanceState ) {
protected abstract @NonNull KSViewHolder viewHolder ( final @LayoutRes int layout , final @NonNull View view ) ;
public final @NonNull KSViewHolder onCreateViewHolder ( final @NonNull ViewGroup viewGroup , final @LayoutRes int layout ) {
private @NonNull View inflateView ( final @NonNull ViewGroup viewGroup , final @LayoutRes int viewType ) {
protected void onCreate ( final @Nullable Bundle savedInstanceState ) {
protected void onRestoreInstanceState ( final @Nullable Bundle savedInstanceState ) {
protected void onSaveInstanceState ( final @NonNull Bundle outState ) {
private boolean handleCheckoutThanksUriRequest ( final @NonNull Request request , final @NonNull WebView webView ) {
private boolean handleSignupUriRequest ( final @NonNull Request request , final @NonNull WebView webView ) {
protected void onActivityResult ( final int requestCode , final int resultCode , final @NonNull Intent intent ) {
public ZipPairTransformer ( final @NonNull Observable < R > second ) {
public KSWebView ( final @NonNull Context context ) {
public KSWebView ( final @NonNull Context context , final @Nullable AttributeSet attrs ) {
public KSWebView ( final @NonNull Context context , final @Nullable AttributeSet attrs , final int defStyle ) {
public ApplicationModule ( final @NonNull Application application ) {
ApiClientType provideApiClientType ( final @NonNull ApiService apiService , final @NonNull Gson gson ) {
ApiService provideApiService ( @Named ( "str" ) final @NonNull Retrofit retrofit ) {
String provideClientId ( final @NonNull ApiEndpoint apiEndpoint ) {
@NonNull KSRequestInterceptor provideKSRequestInterceptor ( final @NonNull Release release ) {
@NonNull WebClient provideWebClient ( final @NonNull WebService webService ) {
WebService provideWebService ( @Named ( "str" ) final @NonNull Retrofit retrofit ) {
private @NonNull Retrofit createRetrofit ( @NonNull String baseUrl , final @NonNull Gson gson , final @NonNull OkHttpClient okHttpClient ) {
@NonNull StringPreference provideAccessTokenPreference ( final @NonNull SharedPreferences sharedPreferences ) {
@NonNull IntPreference provideActivitySamplePreference ( final @NonNull SharedPreferences sharedPreferences ) {
@NonNull BooleanPreference provideAppRatingPreference ( final @NonNull SharedPreferences sharedPreferences ) {
Koala provideKoala ( @ForApplication final @NonNull Context context , final @NonNull CurrentUser currentUser ) {
Release provideRelease ( final @NonNull PackageInfo packageInfo ) {
@NonNull String provideWebEndpoint ( final @NonNull ApiEndpoint apiEndpoint ) {
Font provideFont ( final @NonNull AssetManager assetManager ) {
KSWebViewClient provideKSWebViewClient ( final @NonNull OkHttpClient okHttpClient ,
Logout provideLogout ( final @NonNull CookieManager cookieManager , final @NonNull CurrentUser currentUser ) {
PackageInfo providePackageInfo ( final @NonNull Application application ) {
String providePackageName ( final @NonNull Application application ) {
Resources provideResources ( @ForApplication final @NonNull Context context ) {
StringPreference provideUserPreference ( final @NonNull SharedPreferences sharedPreferences ) {
public ApplicationLifecycleUtil ( final @NonNull KSApplication application ) {
public void onActivityCreated ( final @NonNull Activity activity , final @Nullable Bundle bundle ) {
public void onActivityStarted ( final @NonNull Activity activity ) {
public void onActivityResumed ( final @NonNull Activity activity ) {
public void onActivityPaused ( final @NonNull Activity activity ) {
public void onActivityStopped ( final @NonNull Activity activity ) {
public void onActivitySaveInstanceState ( final @NonNull Activity activity , final @Nullable Bundle bundle ) {
public void onActivityDestroyed ( final @NonNull Activity activity ) {
public void onConfigurationChanged ( final @NonNull Configuration configuration ) {
final @NonNull Intent intent ;
protected ActivityResultData ( final int requestCode , final int resultCode , final @NonNull Intent intent ) {
public void onSuccess ( final @NonNull LoginResult result ) {
public void onError ( final @NonNull FacebookException error ) {
protected void onCreate ( final @NonNull Context context , @Nullable Bundle savedInstanceState ) {
public void activityResult ( final int requestCode , final int resultCode , final @NonNull Intent intent ) {
public void clearFacebookSession ( final @NonNull FacebookException e ) {
public void facebookLoginClick ( final @NonNull LoginToutActivity activity , @NonNull List < String > facebookPermissions ) {
public void facebookLoginSuccess ( final @NonNull AccessTokenEnvelope envelope ) {
private Observable < AccessTokenEnvelope > loginWithFacebookAccessToken ( final @NonNull String fbAccessToken ) {
public void reason ( final @Nullable String r ) {
public abstract @Nullable List < String > errorMessages ( ) ;
public static @Nullable ErrorEnvelope fromThrowable ( final @NonNull Throwable t ) {
public abstract @Nullable String webm ( ) ;
public @NonNull String filterString ( final @NonNull Context context ) {
public ProjectViewHolder ( final @NonNull View view , final @NonNull Delegate delegate ) {
protected void onCreate ( final @Nullable Bundle savedInstanceState ) {
protected void onActivityResult ( final int requestCode , final int resultCode , final @NonNull Intent intent ) {
public void startFacebookConfirmationActivity ( final @NonNull ErrorEnvelope . FacebookUser facebookUser ) {
public DiscoveryToolbar ( final @NonNull Context context ) {
public DiscoveryToolbar ( final @NonNull Context context , final @Nullable AttributeSet attrs ) {
public DiscoveryToolbar ( final @NonNull Context context , final @Nullable AttributeSet attrs , final int defStyleAttr ) {
public void loadParams ( final @NonNull DiscoveryParams params ) {
public void searchButtonClick ( final @NonNull View view ) {
finish ( ) ;
mediaController . show ( ) ;
return currentUser . loggedInUser ( ) ;
protected @BindString ( R . string . signup_error_title ) String errorTitleString ;
successfullyFundedTextView . setText ( bannerSuccessfulString ) ;
public @Nullable String formattedCommentsCount ( ) {
public @Nullable String formattedStateChangedAt ( ) {
public @Nullable String formattedUpdatesCount ( ) {
. setLogLevel ( BuildConfig . DEBUG ? RestAdapter . LogLevel . HEADERS_AND_ARGS : RestAdapter . LogLevel . NONE )
. setLogLevel ( BuildConfig . DEBUG ? RestAdapter . LogLevel . HEADERS_AND_ARGS : RestAdapter . LogLevel . NONE )
cast . getLeftExpression ( ) . accept ( this ) ;
cast . getLeftExpression ( ) . accept ( this ) ;
protected StringBuilder buffer ;
protected StringBuilder buffer ;
protected StringBuilder buffer = new StringBuilder ( ) ;
protected StringBuilder buffer = new StringBuilder ( ) ;
protected StringBuilder buffer ;
protected StringBuilder buffer ;
protected StringBuilder buffer = new StringBuilder ( ) ;
protected StringBuilder buffer ;
protected StringBuilder buffer ;
protected StringBuilder buffer ;
protected StringBuilder buffer = new StringBuilder ( ) ;
protected StringBuilder buffer ;
protected StringBuilder buffer ;
protected StringBuilder buffer ;
protected StringBuilder buffer ;
protected StringBuilder buffer ;
protected StringBuilder buffer ;
protected final StringBuilder buffer ;
protected StringBuilder buffer ;
protected StringBuilder buffer ;
assertEquals ( "str" , ( ( JdbcNamedParameter ) rowCount ) . getName ( ) ) ;
assertEquals ( "str" , ( ( JdbcNamedParameter ) rowCount ) . getName ( ) ) ;
private StringBuilder buffer = new StringBuilder ( ) ;
assertTrue ( success > = 139 ) ;
assertTrue ( success > = 135 ) ;
private final StringBuilder buffer ;
return type + ( name ! = null ? "str" + name : "str" ) + "str" + PlainSelect . getStringList ( columnsNames , true , true ) ;
private final boolean isFixedClock ;
if ( isFixedClock ) {
InputStream buildInfoFile = RskContext . class . getClassLoader ( ) . getResourceAsStream ( "str" ) ;
this . valueRaw = transaction . get ( 4 ) . getRLPData ( ) ;
when ( block . getWrappedHash ( ) ) . thenReturn ( new ByteArrayWrapper ( HASH_1 ) ) ;
if ( oldFederation ! = null | | shouldSaveOldFederation ) {
if ( pendingFederation ! = null | | shouldSavePendingFederation ) {
Web3Impl web3 = new Web3Impl ( eth , RskSystemProperties . CONFIG , WalletFactory . createWallet ( ) , Mockito . mock ( MinerClient . class ) , Mockito . mock ( MinerServer . class ) ) ;
runtimeMode = new ClusterAccess ( getClusterConfiguration ( ) ) . resolveRuntimeMode ( runtimeMode , log ) ;
List < ImageConfiguration > configs = generator . customize ( new ArrayList < > ( ) , true ) ;
color { { d = "str" ; } } ;
@Parameter ( property = "str" )
private final String SPRING_BOOT_CONFIGMAP_BOOSTER_BOOSTERYAMLURL = "str" ;
RELEASED_VERSION_TAG = boosterYaml . getEnvironment ( ) . getProduction ( ) . getSource ( ) . getGitSource ( ) . getRef ( ) ;
private final String SPRING_BOOT_CRUD_BOOSTER_BOOSTERYAMLURL = "str" ;
RELEASED_VERSION_TAG = boosterYaml . getEnvironment ( ) . getProduction ( ) . getSource ( ) . getGitSource ( ) . getRef ( ) ;
private final String SPRING_BOOT_HTTP_BOOSTER_BOOSTERYAMLURL = "str" ;
RELEASED_VERSION_TAG = boosterYaml . getEnvironment ( ) . getProduction ( ) . getSource ( ) . getGitSource ( ) . getRef ( ) ;
containers . get ( nIndex ) . setImage ( "str" ) ;
| | MavenUtil . hasDependencyOnAnyArtifactOfGroup ( getProject ( ) , VERTX_GROUPID ) ;
String fullPath = "str" + resourcePath . getFileName ( ) . toString ( ) ;
container . withLivenessProbe ( probe ) ;
if ( answer ! = null & & answer . trim ( ) . isEmpty ( ) | | answer . trim ( ) . toUpperCase ( ) . startsWith ( "str" ) ) {
if ( answer ! = null & & answer . trim ( ) . isEmpty ( ) | | answer . trim ( ) . toUpperCase ( ) . startsWith ( "str" ) ) {
List < Integer > portNumbers = new ArrayList < > ( ) ;
private static final String ENRICHER_PROP_PREFIX = "str" ;
private static final String GENERATOR_PROP_PREFIX = "str" ;
public PasswordToken ( String appId , String password , String timestamp , String host , String tokenKey ) throws Exception {
String tokenKey = redisTemplate . opsForValue ( ) . get ( "str" + IpUtil . getIpFromRequest ( WebUtils . toHttp ( request ) ) . toUpperCase ( ) ) ;
redisTemplate . opsForValue ( ) . set ( "str" + IpUtil . getIpFromRequest ( WebUtils . toHttp ( request ) ) , tokenKey , 6 , TimeUnit . SECONDS ) ;
String host = IpUtil . getIpFromRequest ( WebUtils . toHttp ( request ) ) ;
return authAccountLogMapper . selectAccountLogList ( ) ;
List < AuthAccountLog > selectAccountLogList ( ) ;
WebUtils . toHttp ( servletRequest ) . getRequestURI ( ) , WebUtils . toHttp ( servletRequest ) . getMethod ( ) , ( short ) 1 , null ) ) ;
if ( ( partSet . length > 1 )
final int opDirection = oldRoom . getReverseDir ( nextDirection ) ;
meat . setDisplayText ( L ( "str" , parts [ partCode ] [ 0 ] . toString ( ) . toLowerCase ( ) , simpleTargetName ) ) ;
meat . setDisplayText ( L ( "str" , parts [ partCode ] [ 0 ] . toString ( ) . toLowerCase ( ) , simpleTargetName ) ) ;
info . append ( L ( "str" , target . name ( ) , "str" + ageYears ) ) ;
return new String [ ] { L ( "str" , I . name ( ) , bidWords ) , null } ;
return new String [ ] { L ( "str" , currencyName ) , null } ;
return new String [ ] { L ( "str" , currencyName ) , null } ;
if ( ( CMLib . dice ( ) . roll ( 1 , 100 + ( ( numKids - 1 ) * 100 ) - ( super . getXLEVELLevel ( mob ) * 10 ) , 0 ) = = 1 )
if ( ( CMLib . dice ( ) . roll ( 1 , 100 + ( numKids * 100 ) - ( super . getXLEVELLevel ( mob ) * 10 ) , 0 ) = = 1 )
desc = L ( "str" + sondat + "str" , mob . Name ( ) , otherParentName ) ;
final boolean alreadyHere = follower . location ( ) = = ( Room ) enterMsg . target ( ) ;
final List < Item > coll = new ArrayList < Item > ( ) ;
commands . add ( firstWord ) ;
commands . add ( firstWord ) ;
chosenOne . autoInvocation ( M , false ) ;
newMOB . setDisplayText ( L ( "str" ) ) ;
if ( ( levelsDown < 0 ) | | ( affectableStats . level ( ) < = 0 ) )
if ( H ! = null )
if ( H ! = null )
if ( ( value . length ( ) > 0 ) & & ( CMath . isNumber ( value ) ) )
final MOB M = ( MOB ) args [ 2 ] ;
+ "str" + ( ( viewedmob . getStartRoom ( ) = = null ) ? "str" : viewedmob . getStartRoom ( ) . roomID ( ) )
& & ( ! ( factionID . equalsIgnoreCase ( inclinID ) ) ) )
& & ( ! ( factionID . equalsIgnoreCase ( inclinID ) ) ) )
Log . errOut ( "str" + condition + "str" + e . getMessage ( ) ) ;
Log . errOut ( "str" + condition + "str" + e . getMessage ( ) ) ;
keyName = this . getShortID ( item ) ;
keyName = this . getShortID ( mob ) ;
private String lhs = null ;
private WhereComp lhs = null ;
R . capacityA . setMiscText ( "str" ) ;
R . capacityA . setMiscText ( "str" ) ;
R . capacityA . setMiscText ( "str" ) ;
R . capacityA . setMiscText ( "str" ) ;
final ShipQuarter R = ( ShipQuarter ) super . copyOf ( ) ;
R . capacityA . setMiscText ( "str" ) ;
final ShipQuarter R = ( ShipQuarter ) super . newInstance ( ) ;
R . capacityA . setMiscText ( "str" ) ;
if ( skipSwitchMap . containsKey ( "str" ) )
si = skipSwitchMap . get ( "str" ) . intValue ( ) ;
CMLib . ableMapper ( ) . addCharAbilityMapping ( ID ( ) , 1 , "str" , false , CMParms . parseSemicolons ( "str" , true ) ) ;
public class Familiarity_Sword extends Familiarity_Weapon
final BigDecimal areaOfTriangle = BigDecimal . valueOf ( CMath . abs ( CMath . sqrt ( semiPerimeter . multiply ( semiPerimeter . subtract ( currentDistance ) )
. multiply ( semiPerimeter . subtract ( prevDistance ) ) . doubleValue ( ) ) ) ) ;
if ( amount . trim ( ) . equals ( "str" ) | | ( amount . startsWith ( "str" ) ) )
( ( Container ) buildingI ) . setCapacity ( ( ( Container ) buildingI ) . basePhyStats ( ) . weight ( ) + 1 ) ;
( ( Container ) buildingI ) . setCapacity ( ( ( Container ) buildingI ) . basePhyStats ( ) . weight ( ) + 1 ) ;
( ( Container ) buildingI ) . setCapacity ( ( ( Container ) buildingI ) . basePhyStats ( ) . weight ( ) + 1 ) ;
( ( Container ) buildingI ) . setCapacity ( ( ( Container ) buildingI ) . basePhyStats ( ) . weight ( ) + 1 ) ;
( ( Container ) buildingI ) . setCapacity ( ( ( Container ) buildingI ) . basePhyStats ( ) . weight ( ) + 1 ) ;
commonTell ( mob , L ( "str" , ( commands . get ( 0 ) ) ) ) ;
protected int [ ] [ ] fetchFoundResourceData ( final MOB mob , int req1Required , String req1Desc , final Item first )
public int destroyResourcesAmt ( final MOB E , final int howMuch , final int finalMaterial , final String subType , final Container C )
return destroyResourcesAmt ( getAllItems ( E ) , howMuch , finalMaterial , subType , C ) ;
public int destroyResourcesAmt ( final Room E , final int howMuch , final int finalMaterial , final String subType , final Container C )
return destroyResourcesAmt ( getAllItems ( E ) , howMuch , finalMaterial , subType , C ) ;
public int destroyResourcesAmt ( final List < Item > V , final int howMuch , final int finalMaterial , final String subType , final Container C )
amount - = CMLib . materials ( ) . destroyResourcesAmt ( fuel , amount , ( ( RawMaterial ) I ) . material ( ) , ( ( RawMaterial ) I ) . getSubType ( ) , this ) ;
protected void generateRecipes ( )
Log . errOut ( "str" , "str" + nextRoomID + "str" + roomID ) ;
final StringBuilder str = new StringBuilder ( "str" ) ;
final StringBuilder str = new StringBuilder ( "str" ) ;
final StringBuilder str = new StringBuilder ( "str" ) ;
& & ( mob . location ( ) . getArea ( ) . getTimeObj ( ) ! = R . getArea ( ) . getTimeObj ( ) ) )
message = CMParms . getParmStr ( newText , "str" , L ( "str" ) ) ;
final CMMsg msg = CMClass . getMsg ( mob , target , this , verbalCastCode ( mob , target , auto ) , auto ? "str" : L ( "str" ) ) ;
backHere . bringMobHere ( M , true ) ;
climask = climask | ( ( int ) CMath . pow ( 2 , i - 1 ) ) ;
setMiscText ( CMParms . combineWith ( rooms , "str" ) ) ;
if ( targetWeight < ( mob . baseWeight ( ) / 3 ) )
target = getItem ( mobTarget ) ;
return Ability . ACODE_CHANT | Ability . DOMAIN_ANIMALAFFINITY ;
& & ( CMLib . dice ( ) . rollPercentage ( ) < = ( ( 2 * super . getXLEVELLevel ( msg . source ( ) ) ) + 25 ) )
if ( ( R ! = null ) & & ( R . numInhabitants ( ) > 0 ) & & ( R . numPCInhabitants ( ) > 0 ) )
buyPrice = ( buyPrice / 2 ) + ( ( buyPrice / 2 ) * ( ( sellerMinCha - buyerMinWis ) / denom ) ) ;
if ( ( o instanceof BoardableShip ) & & ( ! ( o instanceof Area ) ) )
if ( ! CMParms . contains ( getCurrentBattleCoveredDirections ( ) , dir ) )
if ( ( mob . isAttributeSet ( MOB . Attrib . NOBATTLESPAM ) & & ( parm . length ( ) = = 0 ) ) | | ( parm . equalsIgnoreCase ( "str" ) ) )
if ( ( ! mob . isAttributeSet ( MOB . Attrib . NOBATTLESPAM ) & & ( parm . length ( ) = = 0 ) ) | | ( parm . equalsIgnoreCase ( "str" ) ) )
return destroyed + "str" + myHost . ID ( ) + "str" + CMLib . map ( ) . getApproximateExtendedRoomID ( CMLib . map ( ) . roomLocation ( myHost ) ) + "str" ;
final int oldest = number > = counter ? 1 : ( counter - number + 1 ) ;
public class MasterFoodPrep extends FoodPrep
final double pctPenalty = CMath . div ( CMProps . getIntVar ( CMProps . Int . MANACOMPOUND_PCTPENALTY ) , 100.0 ) ;
if ( ( multiClassRule . equals ( "str" ) | | multiClassFirstRule . equals ( "str" ) | | multiClassSecondRule . equals ( "str" ) )
shipChkR = CMLib . map ( ) . roomLocation ( ( ( BoardableShip ) shipChkR . getArea ( ) ) . getShipItem ( ) ) ;
if ( ( C . getYear ( ) = = mob . playerStats ( ) . getBirthday ( ) [ PlayerStats . BIRTHDEX_LASTYEARCELEBRATED ] )
public class MasterFloristry extends Floristry
final String message = this . getRPProficiencyStr ( A2 . proficiency ( ) ) ;
promptStatStr ( mob , me . playerStats ( ) , PlayerStats . PlayerFlag . getListString ( ) , + + showNumber , showFlag , "str" , "str" , true ) ;
affectableStats . setSensesMask ( ( affectableStats . sensesMask ( ) | PhyStats . CAN_SEE_DARK ) & ( ~ PhyStats . CAN_NOT_SEE ) ) ;
for ( final CharClass lC : whoM . charStats ( ) . getCharClasses ( ) )
setDisplayText ( "str" ) ;
cat = "str" + subkey ;
CMLib . ableMapper ( ) . addCharAbilityMapping ( ID ( ) , 1 , "str" , false , CMParms . parseSemicolons ( "str" , true ) ) ;
for ( final Pair < Clan , Integer > cp : whoM . clans ( ) )
return beneficialWordsFizzle ( mob , target , L ( "str" ) ) ;
CMLib . commands ( ) . postSay ( target , L ( "str" , amtStr ) ) ;
final String line = this . input ;
return L ( "str" ) ;
CMLib . threads ( ) . startTickDown ( C , Tickable . TICKID_CLAN , 1 ) ;
CMLib . combat ( ) . postDamage ( srcM , targetM , this , damage , CMMsg . MASK_MALICIOUS | CMMsg . MASK_ALWAYS | CMMsg . TYP_CAST_SPELL , Weapon . TYPE_SLASHING , L ( "str" ) ) ;
locObj . put ( "str" , CMLib . map ( ) . getExtendedRoomID ( CMLib . map ( ) . roomLocation ( SKs . second ) ) ) ;
Log . errOut ( "str" , "str" + MOBID + "str" + roomID ) ;
return ( contents > 2 ) ? 0 : 2 - contents ;
this . description = "str" ;
if ( CMLib . flags ( ) . isGood ( from ) )
S . stdPrintln ( Message . toString ( ) ) ;
mob . tell ( L ( "str" , target . name ( mob ) ) ) ;
String arg1 = varify ( source , target , scripted , monster , primaryItem , secondaryItem , msg , tmp , tt [ t + 0 ] ) . toUpperCase ( ) ;
final String arg3 = varify ( source , target , scripted , monster , primaryItem , secondaryItem , msg , tmp , tt [ t + 2 ] ) ;
if ( ( arg1 . toUpperCase ( ) . startsWith ( "str" ) & & ( arg1 . substring ( 4 ) . trim ( ) . startsWith ( "str" ) ) ) )
IMBUCRAFT ( "str" , ExpertiseLibrary . Flag . X4 ) ,
final long t = t0 * CMProps . getMillisPerMudHour ( ) / MudHost . TIME_SAVETHREAD_SLEEP ;
if ( ! I2 . amDestroyed ( ) )
if ( ( R = = null ) | | ( legalBehavior = = null ) )
if ( ( R = = null ) | | ( legalBehavior = = null ) )
if ( mob . isMonster ( ) & & ( legalBehavior ! = null ) )
return L ( "str" ) ;
return L ( "str" ) ;
beneficialWordsFizzle ( mob , null , L ( "str" ) ) ;
str = auto ? "str" : L ( "str" ) ;
CMMsg msg = CMClass . getMsg ( mob , target , this , auto ? CMMsg . MSG_OK_VISUAL : ( CMMsg . MSG_THIEF_ACT | CMMsg . MASK_EYES ) , auto ? "str" : L ( "str" ) , CMMsg . MSG_LOOK , str , CMMsg . NO_EFFECT , null ) ;
msg = CMClass . getMsg ( mob , target , null , CMMsg . MSG_OK_VISUAL , auto ? "str" : L ( "str" ) , CMMsg . MSG_OK_VISUAL , str , ( str = = null ) ? CMMsg . NO_EFFECT : CMMsg . MSG_OK_VISUAL , str ) ;
return super . makeMobName ( "str" , age ) ;
public TickClient startTickDown ( final Tickable E , final int tickID , final long tickTimeMs , final int numTicks )
return startTickDown ( CMLib . map ( ) . getOwnedThreadGroup ( E ) , E , tickID , tickTimeMs , numTicks ) ;
public synchronized TickClient startTickDown ( ThreadGroup group , final Tickable E , final int tickID , final long tickTimeMs , final int numTicks )
& & ( almostTock . getTickInterval ( ) = = tickTimeMs )
tock = new StdTickGroup ( this , tickTimeMs , group . getName ( ) , isSolitary ) ;
CMLib . expertises ( ) . postTeach ( teacher , mobFor , teachableA ) ;
if ( maintained . size ( ) > = avgMonsters )
if ( maintained . size ( ) > = avgItems )
int attempts = 10000 ;
allKnownFields . addAll ( Arrays . asList ( new String [ ] { "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" , "str" } ) ) ;
CMLib . ableMapper ( ) . addCharAbilityMapping ( ID ( ) , 1 , "str" , false , CMParms . parseSemicolons ( "str" , true ) ) ;
CMLib . ableMapper ( ) . addCharAbilityMapping ( ID ( ) , 1 , "str" , false , CMParms . parseSemicolons ( "str" , true ) ) ;
return Ability . ACODE_SKILL | Ability . DOMAIN_RACIALABILITY ;
public int castingQuality ( final MOB mob , final Physical target )
public boolean invoke ( final MOB mob , final List < String > commands , final Physical givenTarget , final boolean auto , final int asLevel )
mob . tell ( L ( "str" ) ) ;
final Rideable R = ( Rideable ) mob ;
final Rider r = R . fetchRider ( i ) ;
final List < Rider > targets = new ArrayList < Rider > ( R . numRiders ( ) ) ;
for ( final Rider target : targets )
public void peaceAt ( final MOB mob )
public boolean invoke ( final MOB mob , final List < String > commands , final Physical givenTarget , final boolean auto , final int asLevel )
final MOB spirit = CMClass . getMOB ( "str" ) ;
if ( I2 . basePhyStats ( ) . weight ( ) < = amountToGo )
protected boolean doLearnRecipe ( final MOB mob , final List < String > commands , final Physical givenTarget , final boolean auto , final int asLevel )
public boolean supportsMending ( final Physical I )
protected boolean canMend ( final MOB mob , final Environmental E , final boolean quiet )
public boolean invoke ( final MOB mob , final List < String > commands , final Physical givenTarget , final boolean auto , final int asLevel )
| | ( ( myClasses . length = = 1 )
private static final DoubleFilterer < Item > [ ] emptyFiltererArray = new DoubleFilterer [ 0 ] ;
public void setAllBaseValues ( final int def )
public void setAllValues ( final int def )
public void copyInto ( final CharStats intoStats )
public void setArriveLeaveStr ( final String arriveStr , final String leaveStr )
public void setWearableRestrictionsBitmap ( final long bitmap )
public void setDisplayClassName ( final String newName )
public void setDisplayClassLevel ( final String newLevel )
public String displayClassLevel ( final MOB mob , final boolean shortForm )
public String displayClassLevelOnly ( final MOB mob )
public void setNonBaseStatsFromString ( final String str )
public void setRaceName ( final String newRaceName )
public CharClass getMyClass ( final int i )
public int getClassLevel ( final String aClass )
public int getClassLevel ( final CharClass aClass )
public void setClassLevel ( final CharClass aClass , final int level )
public boolean isLevelCapped ( final CharClass C )
public void setCurrentClassLevel ( final int level )
public void setCurrentClass ( final CharClass aClass )
throw new PostProcessException ( "str" + E2 . ID ( ) + "str" + R . roomID ( ) + "str" + V . var + "str" ) ;
public boolean execute ( final MOB mob , final List < String > commands , final int metaFlags )
for ( final MOB . Attrib a : MOB . Attrib . values ( ) )
public int compare ( final Attrib o1 , final Attrib o2 )
if ( a . isAutoReversed ( ) )
msg . append ( "str" ) ;
msg . append ( "str" ) ;
public boolean invoke ( final MOB mob , final List < String > commands , final Physical givenTarget , final boolean auto , final int asLevel )
skill = CMClass . getAbility ( "str" ) ;
final String container = ( ( thisItem . container ( ) ! = null ) ? ( "str" + getShortID ( thisItem . container ( ) ) ) : "str" ) ;
+ "str" + ( ( container ! = null ) ? ( "str" + getShortID ( container ) ) : "str" ) + "str"
final Environmental E = shop . getStock ( itemID , mob ) ;
final Environmental E = shop . getStock ( itemID , mob ) ;
protected void flunkRoomCmd ( final MOB mob )
protected void flunkAreaCmd ( final MOB mob )
public void rooms ( final MOB mob , final List < String > commands )
public void accounts ( final MOB mob , final List < String > commands )
public void areas ( final MOB mob , final List < String > commands )
for ( final Area A : alsoUpdateAreas )
public void quests ( final MOB mob , final List < String > commands )
public void updateChangedExit ( final MOB mob , final Room baseRoom , final Exit thisExit , final Exit prevExit )
public void exits ( final MOB mob , final List < String > commands )
public boolean races ( final MOB mob , final List < String > commands )
public void allQualify ( final MOB mob , final List < String > commands )
public boolean classes ( final MOB mob , final List < String > commands )
public boolean abilities ( final MOB mob , final List < String > commands )
public boolean languages ( final MOB mob , final List < String > commands )
public boolean craftSkills ( final MOB mob , final List < String > commands )
public void components ( final MOB mob , final List < String > commands )
public void socials ( final MOB mob , final List < String > commands )
public void players ( final MOB mob , final List < String > commands )
final MOB M = CMLib . players ( ) . getLoadPlayer ( mobID ) ;
public boolean achievements ( final MOB mob , final List < String > commands )
final AccountStats . Agent agent = ( AccountStats . Agent ) CMath . s_valueOf ( AccountStats . Agent . class , agentStr . toUpperCase ( ) . trim ( ) ) ;
public void manufacturer ( final MOB mob , final List < String > commands ) throws IOException
public void mobs ( final MOB mob , final List < String > commands )
public boolean errorOut ( final MOB mob )
public boolean execute ( final MOB mob , List < String > commands , final int metaFlags )
CMLib . genEd ( ) . genMiscText ( mob , thang , 1 , 1 ) ;
public Object executeInternal ( final MOB mob , final int metaFlags , final Object . . . args ) throws java . io . IOException
public boolean securityCheck ( final MOB mob )
final List < MOB > students = this . getApplicableStudents ( mob ) ;
& & ( students . size ( ) > = 3 ) )
for ( final MOB studentM : students )
public boolean invoke ( final MOB mob , final List < String > commands , final Physical givenTarget , final boolean auto , final int asLevel )
final TimeClock lastPubC = ( TimeClock ) CMClass . getCommon ( "str" ) ;
final Lecturing L = ( Lecturing ) beneficialAffect ( mob , mob , asLevel , duration ) ;
private DataBuffers handleEncodingRequest ( final HTTPRequest request , final File file , final DataBuffers buffers , final Map < HTTPHeader , String > headers ) throws HTTPException
if ( buffers . getLength ( ) = = 0 )
if ( deflatePreference = = 0.0 )
if ( gzipPreference = = 0.0 )
private long [ ] checkRangeRequest ( final long [ ] rangeAZ , final long limit ) throws HTTPException
private long [ ] setRangeRequests ( final HTTPRequest request , final DataBuffers buffers ) throws HTTPException
private ByteBuffer generateStandardHeaderResponse ( final HTTPRequest request , final HTTPStatus status , final Map < HTTPHeader , String > headers , final DataBuffers response ) throws HTTPException
num = str . charAt ( enDex + 2 ) - "str" ;
public Object eval ( final Object val , final Object [ ] choices , final boolean emptyOK ) throws CMException
public void promptStatInt ( final MOB mob , final Modifiable E , final int showNumber , final int showFlag , final String fieldDisplayStr , final String field ) throws IOException
public void promptStatInt ( final MOB mob , final Modifiable E , final String help , final int showNumber , final int showFlag , final String fieldDisplayStr , final String field ) throws IOException
public void promptStatBool ( final MOB mob , final Modifiable E , final int showNumber , final int showFlag , final String fieldDisplayStr , final String field ) throws IOException
public void promptStatBool ( final MOB mob , final Modifiable E , final String help , final int showNumber , final int showFlag , final String fieldDisplayStr , final String field ) throws IOException
public void promptStatStr ( final MOB mob , final Modifiable E , final int showNumber , final int showFlag , final String fieldDisplayStr , final String field ) throws IOException
public void promptStatStr ( final MOB mob , final Modifiable E , final String help , final int showNumber , final int showFlag , final String fieldDisplayStr , final String field , final boolean emptyOK ) throws IOException
public void promptRawStatStr ( final MOB mob , final Modifiable E , final String help , final int showNumber , final int showFlag , final String fieldDisplayStr , final String field , final boolean emptyOK ) throws IOException
public void promptStatStr ( final MOB mob , final Modifiable E , final String help , final int showNumber , final int showFlag , final String fieldDisplayStr , final String field , final int maxChars ) throws IOException
public void promptStatChoices ( final MOB mob , final Modifiable E , final String help , final int showNumber , final int showFlag , final String fieldDisplayStr , final String field , final Object [ ] choices ) throws IOException
public void promptStatCommaChoices ( final MOB mob , final Modifiable E , final String help , final int showNumber , final int showFlag , final String fieldDisplayStr , final String field , final Object [ ] choices ) throws IOException
public String prompt ( final MOB mob , final String oldVal , final int showNumber , final int showFlag , final String fieldDisplayStr ) throws IOException
public String prompt ( final MOB mob , final String oldVal , final int showNumber , final int showFlag , final String fieldDisplayStr , final String help ) throws IOException
public String prompt ( final MOB mob , final String oldVal , final int showNumber , final int showFlag , final String fieldDisplayStr , final boolean emptyOK ) throws IOException
public String prompt ( final MOB mob , final String oldVal , final int showNumber , final int showFlag , final String fieldDisplayStr , final boolean emptyOK , final String help ) throws IOException
public String prompt ( final MOB mob , final String oldVal , final int showNumber , final int showFlag , final String fieldDisplayStr , final boolean emptyOK , final boolean rawPrint ) throws IOException
public String prompt ( final MOB mob , final String oldVal , final int showNumber , final int showFlag , final String fieldDisplayStr , final boolean emptyOK , final boolean rawPrint , final String help ) throws IOException
public boolean prompt ( final MOB mob , final boolean oldVal , final int showNumber , final int showFlag , final String fieldDisplayStr ) throws IOException
public double prompt ( final MOB mob , final double oldVal , final int showNumber , final int showFlag , final String fieldDisplayStr ) throws IOException
public int prompt ( final MOB mob , final int oldVal , final int showNumber , final int showFlag , final String fieldDisplayStr ) throws IOException
public long prompt ( final MOB mob , final long oldVal , final int showNumber , final int showFlag , final String fieldDisplayStr ) throws IOException
public boolean promptToggle ( final MOB mob , final int showNumber , final int showFlag , final String fieldDisplayStr )
public String promptCommaList ( final MOB mob ,
final boolean mcp = sess . isAllowedMcp ( "str" , ( float ) 1.0 ) ;
public boolean prompt ( final MOB mob , final boolean oldVal , final int showNumber , final int showFlag , final String fieldDisplayStr , final String help )
public double prompt ( final MOB mob , final double oldVal , final int showNumber , final int showFlag , final String fieldDisplayStr , final String help )
public double prompt ( final MOB mob , final double oldVal , final int showNumber , final int showFlag , final String fieldDisplayStr , final String help , final double minValue , final double maxValue )
public int prompt ( final MOB mob , final int oldVal , final int showNumber , final int showFlag , final String fieldDisplayStr , final String help )
public long prompt ( final MOB mob , final long oldVal , final int showNumber , final int showFlag , final String fieldDisplayStr , final String help )
public int promptMulti ( final MOB mob , final int oldVal , final int showNumber , final int showFlag , final String fieldDisplayStr , final PairList < String , String > choices )
public String promptMultiOrExtra ( final MOB mob , final String oldVal , final int showNumber , final int showFlag , final String fieldDisplayStr , final PairList < String , String > choices )
public String promptMultiSelectList ( final MOB mob , final String oldVal , final String delimiter , final int showNumber , final int showFlag , final String fieldDisplayStr , final PairList < String , String > choices , final boolean nullOK )
for ( final String s : CMParms . parseAny ( oldVal , delimiter , ! nullOK ) )
final String newVal = CMParms . combineWith ( oldVals , "str" ) ;
public String prompt ( final MOB mob , final String oldVal , final int showNumber , final int showFlag , final String fieldDisplayStr , final PairList < String , String > choices )
public void genName ( final MOB mob , final Environmental E , final int showNumber , final int showFlag ) throws IOException
protected void catalogCheckUpdate ( final MOB mob , final Physical P )
protected void genImage ( final MOB mob , final Environmental E , final int showNumber , final int showFlag ) throws IOException
E . setImage ( prompt ( mob , E . rawImage ( ) , showNumber , showFlag , "str" , true , false ,
protected void genCorpseData ( final MOB mob , final DeadBody I , final int showNumber , final int showFlag )
protected void genAuthor ( final MOB mob , final Area A , final int showNumber , final int showFlag ) throws IOException
protected void genPanelType ( final MOB mob , final ElecPanel S , final int showNumber , final int showFlag )
protected void genCurrency ( final MOB mob , final Area A , final int showNumber , final int showFlag )
protected void genTimeClock ( final MOB mob , final Area A , final int showNumber , final int showFlag )
protected void genClan ( final MOB mob , final MOB M , final int showNumber , final int showFlag )
protected void genDeity ( final MOB mob , final MOB M , final int showNumber , final int showFlag )
public Room changeRoomType ( Room R , final Room newRoom )
protected Room genRoomType ( final MOB mob , Room R , final int showNumber , final int showFlag )
public void genDescription ( final MOB mob , final Environmental E , final int showNumber , final int showFlag ) throws IOException
protected void genNotes ( final MOB mob , final MOB M , final int showNumber , final int showFlag ) throws IOException
protected void genPassword ( final MOB mob , final MOB M , final int showNumber , final int showFlag )
protected void genEmail ( final MOB mob , final AccountStats A , final int showNumber , final int showFlag ) throws IOException
protected void genBirthday ( final MOB mob , final PlayerStats A , final int showNumber , final int showFlag ) throws IOException
public void genDisplayText ( final MOB mob , final Environmental E , final int showNumber , final int showFlag ) throws IOException
protected void genMountText ( final MOB mob , final Rideable E , final int showNumber , final int showFlag )
protected void genDoorName ( final MOB mob , final Exit E , final int showNumber , final int showFlag )
protected void genBurnout ( final MOB mob , final Light I , final int showNumber , final int showFlag )
protected void genOpenWord ( final MOB mob , final Exit E , final int showNumber , final int showFlag )
protected void genSubOps ( final MOB mob , final Area A , final int showNumber , final int showFlag )
protected void genParentAreas ( final MOB mob , final Area A , final int showNumber , final int showFlag , final Set < Area > alsoUpdateAreas )
protected void genChildAreas ( final MOB mob , final Area A , final int showNumber , final int showFlag , final Set < Area > alsoUpdateAreas )
protected void genCloseWord ( final MOB mob , final Exit E , final int showNumber , final int showFlag )
protected void genExitMisc ( final MOB mob , final Exit E , final int showNumber , final int showFlag )
protected void genReadable1 ( final MOB mob , final Item E , final int showNumber , final int showFlag )
protected void genReadable2 ( final MOB mob , final Item E , final int showNumber , final int showFlag )
protected void genRecipe ( final MOB mob , final Recipe E , final int showNumber , final int showFlag )
protected void genGettable ( final MOB mob , final Item I , final int showNumber , final int showFlag )
protected void toggleDispositionMask ( final PhyStats E , final int mask )
protected void genDisposition ( final MOB mob , final PhyStats E , final int showNumber , final int showFlag )
public boolean genGenericPrompt ( final MOB mob , String prompt , final boolean val )
protected void toggleSensesMask ( final PhyStats E , final int mask )
protected void toggleClimateMask ( final Places A , final int mask )
protected void genClimateType ( final MOB mob , final Places A , final int showNumber , final int showFlag )
protected void genCharStats ( final MOB mob , final CharStats E )
protected void genCommonBonus ( final MOB mob , final PlayerStats pStats , final int showNumber , final int showFlag )
protected void genCharState ( final MOB mob , final MOB E , final int showNumber , final int showFlag )
protected void genSensesMask ( final MOB mob , final PhyStats E , final int showNumber , final int showFlag )
protected void genDoorsNLocks ( final MOB mob , final CloseableLockable E , final String doorName , final int showNumber , final int showFlag )
public String makeContainerTypes ( final Container E )
protected void genContainerTypes ( final MOB mob , final Container E , final int showNumber , final int showFlag )
protected void genLevel ( final MOB mob , final Physical P , final int showNumber , final int showFlag ) throws IOException
protected void genRejuv ( final MOB mob , final Physical P , final int showNumber , final int showFlag )
protected void genUses ( final MOB mob , final Item I , final int showNumber , final int showFlag ) throws IOException
I . setUsesRemaining ( prompt ( mob , ( ( Ammunition ) I ) . ammunitionRemaining ( ) , showNumber , showFlag , "str" ) ) ;
I . setUsesRemaining ( prompt ( mob , I . usesRemaining ( ) , showNumber , showFlag , "str" ) ) ;
public void genMiscSet ( final MOB mob , final Environmental E , final int showFlag )
public void genMiscText ( final MOB mob , final Environmental E , final int showNumber , final int showFlag )
protected void genTitleRoom ( final MOB mob , final LandTitle L , final int showNumber , final int showFlag )
public void genAbility ( final MOB mob , final Physical P , final int showNumber , final int showFlag , final String prompt ) throws IOException
public void genAbility ( final MOB mob , final Physical P , final int showNumber , final int showFlag ) throws IOException
protected void genCoinStuff ( final MOB mob , final Coins I , final int showNumber , final int showFlag )
protected void genHitPoints ( final MOB mob , final MOB M , final int showNumber , final int showFlag ) throws IOException
protected void genClanItem ( final MOB mob , final ClanItem I , final int showNumber , final int showFlag )
final ClanItemType type = ClanItemType . getValueOf ( s ) ;
protected void genHeight ( final MOB mob , final Physical P , final int showNumber , final int showFlag ) throws IOException
protected void genSize ( final MOB mob , final Armor A , final int showNumber , final int showFlag ) throws IOException
public void wornLayer ( final MOB mob , final short [ ] layerAtt , final short [ ] clothingLayer , final int showNumber , final int showFlag )
public void genTPQ ( final MOB mob , final MOB me , final int showNumber , final int showFlag ) throws IOException
protected void genCapacity ( final MOB mob , final Container E , final int showNumber , final int showFlag ) throws IOException
protected void genAttack ( final MOB mob , final Physical P , final int showNumber , final int showFlag ) throws IOException
protected void genDamage ( final MOB mob , final Physical P , final int showNumber , final int showFlag ) throws IOException
protected void genBanker1 ( final MOB mob , final Banker M , final int showNumber , final int showFlag ) throws IOException
protected void genBanker2 ( final MOB mob , final Banker M , final int showNumber , final int showFlag ) throws IOException
protected void genBanker3 ( final MOB mob , final Banker M , final int showNumber , final int showFlag ) throws IOException
protected void genBanker4 ( final MOB mob , final Banker M , final int showNumber , final int showFlag ) throws IOException
protected void genSpeed ( final MOB mob , final Physical P , final int showNumber , final int showFlag ) throws IOException
protected void genArmor ( final MOB mob , final Physical P , final int showNumber , final int showFlag ) throws IOException
protected void genMoney ( final MOB mob , final MOB M , final int showNumber , final int showFlag ) throws IOException
protected void genWeaponAmmo ( final MOB mob , final Weapon W , final int showNumber , final int showFlag )
protected void genWeaponRanges ( final MOB mob , final Weapon W , final int showNumber , final int showFlag )
protected void genWeaponType ( final MOB mob , final Weapon W , final int showNumber , final int showFlag )
protected void getTheme ( final MOB mob , final Area A , final int showNumber , final int showFlag )
protected void genConsumedMaterials ( final MOB mob , final FuelConsumer E , final int showNumber , final int showFlag ) throws IOException
protected void genMessageTypes ( final MOB mob , final ShipWarComponent E , final int showNumber , final int showFlag ) throws IOException
protected void genMaterialCode ( final MOB mob , final Item E , final int showNumber , final int showFlag )
protected int genAnyMaterialCode ( final MOB mob , final String prompt , int currMat , final boolean inheritOk , final int showNumber , final int showFlag )
protected void genBreathes ( final MOB mob , final Race me , final int showNumber , final int showFlag ) throws IOException
protected void genInstrumentType ( final MOB mob , final MusicalInstrument E , final int showNumber , final int showFlag )
for ( final InstrumentType type : MusicalInstrument . InstrumentType . values ( ) )
for ( final InstrumentType type : MusicalInstrument . InstrumentType . values ( ) )
protected void genSpecialFaction ( final MOB mob , final MOB E , final int showNumber , final int showFlag , final Faction F )
protected void genFaction ( final MOB mob , final MOB E , final int showNumber , final int showFlag )
protected void genGender ( final MOB mob , final MOB E , final int showNumber , final int showFlag )
protected void genWeaponClassification ( final MOB mob , final Weapon E , final int showNumber , final int showFlag )
protected void genSecretIdentity ( final MOB mob , final Item E , final int showNumber , final int showFlag ) throws IOException
protected void genMaterialSubType ( final MOB mob , final RawMaterial E , final int showNumber , final int showFlag ) throws IOException
protected void genNourishment ( final MOB mob , final Food E , final int showNumber , final int showFlag ) throws IOException
protected void genBiteSize ( final MOB mob , final Food E , final int showNumber , final int showFlag ) throws IOException
protected void genRace ( final MOB mob , final MOB M , final int showNumber , final int showFlag )
protected void genCharClass ( final MOB mob , final MOB M , final int showNumber , final int showFlag )
protected void genTattoos ( final MOB mob , final Tattooable M , final int showNumber , final int showFlag )
protected void genTitles ( final MOB mob , final MOB M , final int showNumber , final int showFlag )
protected void genExpertises ( final MOB mob , final MOB M , final int showNumber , final int showFlag )
protected void genSecurity ( final MOB mob , final MOB M , final int showNumber , final int showFlag )
public void genBehaviors ( final MOB mob , final PhysicalAgent P , final int showNumber , final int showFlag )
public String stringify ( final Object o )
& & ( o instanceof Behavior )
if ( s2 ! = null )
public void genAffects ( final MOB mob , final Physical P , final int showNumber , final int showFlag )
public String stringify ( final Object o )
if ( s2 ! = null )
protected void genRideable1 ( final MOB mob , final Rideable R , final int showNumber , final int showFlag )
protected void genRideable2 ( final MOB mob , final Rideable E , final int showNumber , final int showFlag ) throws IOException
protected void genShopkeeper1 ( final MOB mob , final ShopKeeper M , final int showNumber , final int showFlag )
protected void genShopkeeper2 ( final MOB mob , final ShopKeeper M , final int showNumber , final int showFlag )
protected void genEconomics1 ( final MOB mob , final Economics E , final int showNumber , final int showFlag ) throws IOException
protected void genEconomics2 ( final MOB mob , final Economics E , final int showNumber , final int showFlag )
protected void genAreaBlurbs ( final MOB mob , final Area A , final int showNumber , final int showFlag )
protected void genEconomics3 ( final MOB mob , final Economics E , final int showNumber , final int showFlag ) throws IOException
protected void genEconomics4 ( final MOB mob , final Economics E , final int showNumber , final int showFlag ) throws IOException
protected void genEconomics5 ( final MOB mob , final Economics E , final int showNumber , final int showFlag ) throws IOException
protected void genEconomics6 ( final MOB mob , final Economics E , final int showNumber , final int showFlag ) throws IOException
protected void genAbilities ( final MOB mob , final MOB M , final int showNumber , final int showFlag )
public void spells ( final MOB mob , final List < Ability > V , final int showNumber , final int showFlag , final boolean inParms ) throws IOException
if ( s2 ! = null )
public void spellsOrBehaviors ( final MOB mob , final List < CMObject > V , final int showNumber , final int showFlag , final boolean inParms ) throws IOException
protected void genClanMembers ( final MOB mob , final Clan C , final int showNumber , final int showFlag ) throws IOException
protected void genDeity1 ( final MOB mob , final Deity E , final int showNumber , final int showFlag ) throws IOException
protected void genDeity2 ( final MOB mob , final Deity E , final int showNumber , final int showFlag ) throws IOException
protected void genDeity3 ( final MOB mob , final Deity E , final int showNumber , final int showFlag ) throws IOException
protected void genDeity4 ( final MOB mob , final Deity E , final int showNumber , final int showFlag ) throws IOException
protected void genDeity5 ( final MOB mob , final Deity E , final int showNumber , final int showFlag ) throws IOException
protected void genDeity6 ( final MOB mob , final Deity E , final int showNumber , final int showFlag )
protected void genDeity7 ( final MOB mob , final Deity E , final int showNumber , final int showFlag )
A . setPlayerLevel ( prompt ( mob , A . getPlayerLevel ( ) , showNumber , showFlag , "str" ) ) ;
protected void genLocationCoords ( final MOB mob , final LocationRoom E , final int showNumber , final int showFlag ) throws IOException
public void genSpaceStuff ( final MOB mob , final SpaceObject E , final int showNumber , final int showFlag ) throws IOException
final String val = mob . session ( ) . prompt ( L ( "str" , "str" + showNumber , ( CMLib . english ( ) . sizeDescShort ( E . radius ( ) ) ) ) ) ;
final Long newValue = CMLib . english ( ) . parseSpaceDistance ( val ) ;
final List < String > utokens = CMParms . parseSpaces ( val . toUpperCase ( ) , true ) ;
final List < String > degreeStr = CMParms . parseCommas ( CMParms . combine ( tokens , y + 1 ) , true ) ;
final double [ ] degreesDbl = CMParms . toDoubleArray ( degreeStr ) ;
final Long [ ] valL = new Long [ 3 ] ;
final Long newValue = CMLib . english ( ) . parseSpaceDistance ( valsL . get ( i ) ) ;
final Long newValue = CMLib . english ( ) . parseSpaceDistance ( val ) ;
final int x = val . indexOf ( "str" ) ;
public void wornLocation ( final MOB mob , final long [ ] oldWornLocation , final boolean [ ] logicalAnd , final int showNumber , final int showFlag )
protected void genWornLocation ( final MOB mob , final Item E , final int showNumber , final int showFlag )
protected void genThirstQuenched ( final MOB mob , final Drink E , final int showNumber , final int showFlag ) throws IOException
protected void genDrinkHeld ( final MOB mob , final Drink E , final int showNumber , final int showFlag ) throws IOException
protected void genAttackAttribute ( final MOB mob , final CharClass E , final int showNumber , final int showFlag , final String fieldDisplayStr , final String field )
protected void genArmorCode ( final MOB mob , final CharClass E , final int showNumber , final int showFlag , final String fieldDisplayStr , final String field )
protected void genQualifications ( final MOB mob , final CharClass E , final int showNumber , final int showFlag , final String fieldDisplayStr , final String field )
protected void genClanAccept ( final MOB mob , final Clan E , final int showNumber , final int showFlag ) throws IOException
protected void genWeaponRestr ( final MOB mob , final CharClass E , final int showNumber , final int showFlag , final String fieldDisplayStr , final String FieldNum , final String field )
protected void genWeaponMaterials ( final MOB mob , final CharClass E , final int showNumber , final int showFlag , final String fieldDisplayStr , final String FieldNum , final String field )
protected void genDisableFlags ( final MOB mob , final Race E , final int showNumber , final int showFlag )
protected void genRaceWearFlags ( final MOB mob , final Race E , final int showNumber , final int showFlag )
protected void genRaceAvailability ( final MOB mob , final Race E , final int showNumber , final int showFlag )
protected void genClassAvailability ( final MOB mob , final CharClass E , final int showNumber , final int showFlag )
protected void genCat ( final MOB mob , final Race E , final int showNumber , final int showFlag )
protected void genRaceBuddy ( final MOB mob , final Race E , final int showNumber , final int showFlag , final String prompt , final String flag )
protected void genClassBuddy ( final MOB mob , final CharClass E , final int showNumber , final int showFlag , final String prompt , final String flag )
protected void genClassRaceQuals ( final MOB mob , final CharClass E , final int showNumber , final int showFlag , final String prompt , final String flag )
protected void genBodyParts ( final MOB mob , final Race E , final int showNumber , final int showFlag )
final Integer partNum = Race . BODYPARTHASH . get ( newName . toUpperCase ( ) . trim ( ) ) ;
protected void genPStats ( final MOB mob , final Race R , final int showNumber , final int showFlag )
protected void genAStats ( final MOB mob , final Race R , final String field , final String FieldName , final int showNumber , final int showFlag )
protected void genPStats ( final MOB mob , final CharClass R , final int showNumber , final int showFlag )
protected void genPStats ( final MOB mob , final CharClass R , final int showNumber , final int showFlag , final boolean skipRejuv )
protected void genAStats ( final MOB mob , final CharClass R , final String field , final String FieldName , final int showNumber , final int showFlag )
protected void genResources ( final MOB mob , final Race E , final int showNumber , final int showFlag )
protected void genOutfit ( final MOB mob , final Race E , final int showNumber , final int showFlag )
protected void genOutfit ( final MOB mob , final CharClass E , final int showNumber , final int showFlag )
protected void genMinimumStatQualifications ( final MOB mob , final CharClass E , final int showNumber , final int showFlag )
protected void genWeapon ( final MOB mob , final Race E , final int showNumber , final int showFlag )
protected void modifyDField ( final DVector fields , final String fieldName , final String value )
protected void genAgingChart ( final MOB mob , final Race E , final int showNumber , final int showFlag )
protected void genClassFlags ( final MOB mob , final CharClass E , final int showNumber , final int showFlag )
protected void genDynamicAbilities ( final MOB mob , final Modifiable E , final String typeName , final String levelName , final int showNumber , final int showFlag )
for ( final String roleId : roleIdsList )
final ClanPosition P = ( ( ClanGovernment ) E ) . findPositionRole ( roleId ) ;
final boolean repeat = true ;
final ClanPosition P = ( ( ClanGovernment ) E ) . findPositionRole ( nr ) ;
protected void genDynamicEffects ( final MOB mob , final Modifiable E , final String typeName , final String levelName , final int showNumber , final int showFlag )
final StringBuilder roles = new StringBuilder ( "str" ) ;
for ( final String roleId : roleIdsList )
final ClanPosition P = ( ( ClanGovernment ) E ) . findPositionRole ( roleId ) ;
if ( ( showFlag ! = showNumber ) & & ( showFlag > - 999 ) )
final boolean repeat = true ;
final ClanPosition P = ( ( ClanGovernment ) E ) . findPositionRole ( nr ) ;
protected void genDynamicImmunitiess ( final MOB mob , final Modifiable E , final String typeName , final int showNumber , final int showFlag )
if ( ( showFlag ! = showNumber ) & & ( showFlag > - 999 ) )
protected DVector genClassAbleMod ( final MOB mob , final DVector sets , final String ableID , final int origLevelIndex , int origAbleIndex )
protected void genClassAbilities ( final MOB mob , final CharClass E , final int showNumber , final int showFlag )
protected void genCulturalAbilities ( final MOB mob , final Race E , final int showNumber , final int showFlag )
public void modifyGenClass ( final MOB mob , final CharClass me , int showFlag )
public void modifyClanPosition ( final MOB mob , final ClanPosition me , int showFlag ) throws IOException
public void clanGovernmentPositions ( final MOB mob , final ClanGovernment me , final int showNumber , final int showFlag ) throws IOException
public void modifyGovernment ( final MOB mob , final ClanGovernment me , int showFlag ) throws IOException
public void modifyGenAbility ( final MOB mob , final Ability me , int showFlag ) throws IOException
public void modifyGenLanguage ( final MOB mob , final Language me , int showFlag ) throws IOException
public void modifyGenCraftSkill ( final MOB mob , final Ability me , int showFlag ) throws IOException
protected boolean genText ( final MOB mob , final PairList < String , String > set , final String [ ] choices , final String help , final int showNumber , final int showFlag , final String fieldDisplayStr , final String field )
protected boolean genText ( final MOB mob , final Map < String , String > map , final String [ ] choices , final String help , final int showNumber , final int showFlag , final String fieldDisplayStr , final String field )
protected boolean modifyComponent ( final MOB mob , final AbilityComponent comp , int showFlag )
public void modifyComponents ( final MOB mob , final String componentID , int showFlag ) throws IOException
public void modifyGenRace ( final MOB mob , final Race me , int showFlag ) throws IOException
protected void modifyGenItem ( final MOB mob , final Item me , int showFlag )
final SpaceObject spaceArea = ( SpaceObject ) me ;
protected void modifyGenFood ( final MOB mob , final Food me , int showFlag )
protected void genScripts ( final MOB mob , final MOB E , final int showNumber , final int showFlag )
protected void modifyGenDrink ( final MOB mob , final Drink me , int showFlag )
protected void modifyGenWallpaper ( final MOB mob , final Item me , int showFlag )
protected void modifyGenMap ( final MOB mob , final com . planet_ink . coffee_mud . Items . interfaces . RoomMap me , int showFlag )
protected void modifyGenContainer ( final MOB mob , final Container me , int showFlag )
protected void modifyGenWeapon ( final MOB mob , final Weapon me , int showFlag )
protected void modifyGenArmor ( final MOB mob , final Armor me , int showFlag )
if ( me instanceof Light )
protected void modifyGenInstrument ( final MOB mob , final MusicalInstrument me , int showFlag )
public void modifyGenExit ( final MOB mob , final Exit me , int showFlag )
protected void modifyGenMOB ( final MOB mob , final MOB me , int showFlag )
public void modifyPlayer ( final MOB mob , final MOB me , int showFlag ) throws IOException
protected void genClanStatus ( final MOB mob , final Clan C , final int showNumber , final int showFlag )
protected void genClanGovt ( final MOB mob , final Clan C , final int showNumber , final int showFlag )
protected double genAuctionPrompt ( final MOB mob , final double oldVal , final int showNumber , final int showFlag , final String msg , final boolean pct )
protected int genAuctionPrompt ( final MOB mob , final int oldVal , final int showNumber , final int showFlag , final String msg )
protected void genClanRole ( final MOB mob , final Clan C , final int showNumber , final int showFlag )
protected void genClanClass ( final MOB mob , final Clan C , final int showNumber , final int showFlag )
protected String genClanRoom ( final MOB mob , final Clan C , final String oldRoomID , final String promptCode , final int showNumber , final int showFlag )
public void modifyClan ( final MOB mob , final Clan C , int showFlag )
protected void modifyGenShopkeeper ( final MOB mob , final ShopKeeper me , int showFlag )
public Room modifyRoom ( final MOB mob , Room R , int showFlag ) throws IOException
protected void genAccountExpiration ( final MOB mob , final AccountStats A , final int showNumber , final int showFlag ) throws IOException
public void modifyAccount ( final MOB mob , final PlayerAccount A , int showFlag ) throws IOException
public void modifyStdMob ( final MOB mob , final MOB E , int showFlag ) throws IOException
public void modifyStdItem ( final MOB mob , final Item E , int showFlag ) throws IOException
public void modifyArea ( final MOB mob , final Area myArea , final Set < Area > alsoUpdateAreas , int showFlag ) throws IOException
final SpaceObject spaceArea = ( SpaceObject ) myArea ;
public AbilityMapper . AbilityMapping modifyAllQualifyEntry ( final MOB mob , final String eachOrAll , final Ability me , int showFlag ) throws IOException
public void modifyManufacturer ( final MOB mob , final Manufacturer me , int showFlag ) throws IOException
newMatches . add ( matches . get ( selNum - 1 ) ) ;
public boolean handleUnknownCommand ( final MOB mob , final List < String > command )
public boolean postCommandFail ( final MOB mob , final Environmental target , final Environmental tools , final List < String > command , final String msgStr )
public boolean postCommandRejection ( final MOB mob , final Environmental target , final Environmental tools , final List < String > command )
public Object unforcedInternalCommand ( final MOB mob , final String command , final Object . . . parms )
public Object forceInternalCommand ( final MOB mob , final String command , final Object . . . parms )
public boolean forceStandardCommand ( final MOB mob , final String command , final List < String > parms )
public void monitorGlobalMessage ( final Room room , final CMMsg msg )
for ( final WeakReference < MsgMonitor > W : globalMonitors )
public void addGlobalMonitor ( final MsgMonitor M )
for ( final WeakReference < MsgMonitor > W : globalMonitors )
public void delGlobalMonitor ( final MsgMonitor M )
for ( final WeakReference < MsgMonitor > W : globalMonitors )
public StringBuilder getScore ( final MOB mob )
public StringBuilder getEquipment ( final MOB viewer , final MOB mob )
public StringBuilder getInventory ( final MOB viewer , final MOB mob )
public void postChannel ( final MOB mob , final String channelName , final String message , final boolean systemMsg )
public void postChannel ( final String channelName , final Iterable < Pair < Clan , Integer > > clanList , final String message , final boolean systemMsg )
public boolean postDrop ( final MOB mob , final Environmental dropThis , final boolean quiet , final boolean optimized , final boolean intermediate )
public boolean postGive ( final MOB mob , final MOB targetM , final Item giveThis , final boolean quiet )
public boolean postOpen ( final MOB mob , final Environmental openThis , final boolean quiet )
public boolean postGet ( final MOB mob , final Item container , final Item getThis , final boolean quiet )
public boolean postPut ( final MOB mob , final Item container , final Item getThis , final boolean quiet )
public boolean postRemove ( final MOB mob , final Item item , final boolean quiet )
public boolean postWear ( final MOB mob , final Item item , final boolean quiet )
public void postLook ( final MOB mob , final boolean quiet )
public void postRead ( final MOB mob , final Physical target , final String readOff , final boolean quiet )
public void postFlee ( final MOB mob , final String whereTo )
public void postSheath ( final MOB mob , final boolean ifPossible )
public void postDraw ( final MOB mob , final boolean doHold , final boolean ifNecessary )
public void postStand ( final MOB mob , final boolean ifNecessary , final boolean quietly )
public void postSleep ( final MOB mob )
public void postFollow ( final MOB follower , final MOB leader , final boolean quiet )
public void postSay ( final MOB mob , final MOB target , final String text )
public void postSay ( final MOB mob , final String text )
public void postSay ( final MOB mob , final MOB target , String text , final boolean isPrivate , final boolean tellFlag )
protected void gmcpSaySend ( final String sayName , final MOB mob , final MOB target , final CMMsg msg )
public void handleBeingSniffed ( final CMMsg msg )
public void handleBeingMobSniffed ( final CMMsg msg )
public void handleObserveComesToLife ( final MOB observer , final MOB lifer , final CMMsg msg )
public void handleComeToLife ( final MOB mob , final CMMsg msg )
public void handleSit ( final CMMsg msg )
public void handleSleep ( final CMMsg msg )
public void handleStand ( final CMMsg msg )
public void handleRecall ( final CMMsg msg )
public int tickManaConsumption ( final MOB mob , int manaConsumeCounter )
protected String relativeCharStatTest ( final CharStats C , final MOB mob , final String weakword , final String strongword , final int stat )
public void handleBeingLookedAt ( final CMMsg msg )
public String makeContainerTypes ( final Container E )
final ArrayList < String > list = new ArrayList < String > ( ) ;
public String getExamineItemString ( final MOB mob , final Item item )
protected String dispossessionTimeLeftString ( final Item item )
protected void handleBeingItemLookedAt ( final CMMsg msg )
final StringBuilder spells = new StringBuilder ( "str" ) ;
protected void handleBeingItemSniffed ( final CMMsg msg )
public void handleBeingSpokenTo ( final MOB speaker , final MOB me , final String msg )
protected void handleBeingRoomSniffed ( final CMMsg msg )
protected void handleBeingRoomLookedAt ( final CMMsg msg )
public boolean execute ( final MOB mob , final List < String > commands , final int metaFlags )
public int compare ( final Area arg0 , final Area arg1 )
public int compare ( final Area arg0 , final Area arg1 )
public int compare ( final Area arg0 , final Area arg1 )
public int compare ( final Area arg0 , final Area arg1 )
public double getItemWeightMultiplier ( final boolean bundling )
public boolean supportsMending ( final Physical item )
protected boolean canMend ( final MOB mob , final Environmental E , final boolean quiet )
public boolean invoke ( final MOB mob , final List < String > commands , final Physical givenTarget , final boolean auto , final int asLevel )
final int x = wood . lastIndexOf ( "str" , cols [ 2 ] ) ;
buildingI . basePhyStats ( ) . setWeight ( getStandardWeight ( compData [ CF_AMOUNT ] , bundling ) ) ;
public double getItemWeightMultiplier ( final boolean bundling )
public boolean supportsMending ( final Physical item )
protected boolean canMend ( final MOB mob , final Environmental E , final boolean quiet )
public boolean invoke ( final MOB mob , final List < String > commands , final Physical givenTarget , final boolean auto , final int asLevel )
final int x = wood . lastIndexOf ( "str" , cols [ 2 ] ) ;
buildingI . basePhyStats ( ) . setWeight ( getStandardWeight ( compData [ CF_AMOUNT ] , bundling ) ) ;
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
public void setDockableItem ( final Item dockableItem )
public void setShipArea ( final String xml )
public void setMiscText ( final String newText )
protected Room getDestinationRoom ( final Room fromRoom )
public void setExpirationDate ( final long time )
if ( owner . length ( ) = = 0 )
if ( C ! = null )
public void renameShip ( final String newName )
final String oldName = area . Name ( ) ;
protected Room findNearestDocks ( final Room R )
public String putString ( final Rider R )
public String mountString ( final int commandType , final Rider R )
public String dismountString ( final Rider R )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
protected Set < Integer > disallowedWeaponClasses ( final MOB mob )
CMLib . ableMapper ( ) . addCharAbilityMapping ( ID ( ) , 1 , "str" , false , CMParms . parseSemicolons ( "str" , true ) ) ;
public List < Item > outfit ( final MOB myChar )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
public void setClimateObj ( final Climate obj )
public void setAuthorID ( final String authorID )
public void setDockableItem ( final Item dockableItem )
public void setTimeObj ( final TimeClock obj )
public void setCurrency ( final String newCurrency )
public void setExpirationDate ( final long time )
public void setAtmosphere ( final int resourceCode )
? shipItemRoom . getAtmosphere ( )
public void setSavable ( final boolean truefalse )
? shipItemRoom . getClimateTypeCode ( )
? shipItemRoom . getClimateType ( )
public void setClimateType ( final int newClimateType )
public void setName ( final String newName )
public void renameShip ( final String newName )
public void setShipArea ( final String xml )
public void setBasePhyStats ( final PhyStats newStats )
? shipItemArea . getTheme ( )
public void setTheme ( final int level )
public void setImage ( final String newImage )
public void setArchivePath ( final String pathFile )
public void setAreaState ( final State newState )
public boolean amISubOp ( final String username )
public void setSubOpList ( final String list )
public void addSubOp ( final String username )
public void delSubOp ( final String username )
public void setDisplayText ( final String newDisplayText )
public String displayText ( final MOB viewerMob )
public String name ( final MOB viewerMob )
public void setMiscText ( final String newMiscText )
public void setDescription ( final String newDescription )
public String description ( final MOB viewerMob )
public String getBlurbFlag ( final String flag )
public void affectCharState ( final MOB affectedMob , final CharState affectableMaxState )
public void addNonUninvokableEffect ( final Ability to )
public void addEffect ( final Ability to )
public void delEffect ( final Ability to )
public void delAllEffects ( final boolean unInvoke )
public Ability fetchEffect ( final int index )
public Ability fetchEffect ( final String ID )
public boolean inMyMetroArea ( final Area A )
public void fillInAreaRoom ( final Room R )
public void dockHere ( final Room roomR )
public Room unDock ( final boolean moveToOutside )
public String getNewRoomID ( final Room startRoom , final int direction )
public void addBehavior ( final Behavior to )
public void delBehavior ( final Behavior to )
if ( didSomething )
public void setPlayerLevel ( final int level )
public Behavior fetchBehavior ( final int index )
public Behavior fetchBehavior ( final String ID )
public void addScript ( final ScriptingEngine S )
public void delScript ( final ScriptingEngine S )
public ScriptingEngine fetchScript ( final int x )
public void addProperRoom ( final Room R )
public void delProperRoom ( final Room R )
public void addProperRoomnumber ( final String roomID )
public void delProperRoomnumber ( final String roomID )
public boolean isRoom ( final Room R )
public Room getRoom ( final String roomID )
public void setProperRoomnumbers ( final RoomnumberSet set )
public void addMetroRoomnumber ( final String roomID )
public void delMetroRoomnumber ( final String roomID )
public void addMetroRoom ( final Room R )
public void delMetroRoom ( final Room R )
public Area getChild ( final String named )
public boolean isChild ( final Area named )
public boolean isChild ( final String named )
public void addChild ( final Area area )
public void removeChild ( final Area area )
public boolean canChild ( final Area area )
public SLinkedList < Area > loadAreas ( final Collection < String > loadableSet )
public Area getParent ( final String named )
public boolean isParent ( final Area area )
public boolean isParent ( final String named )
public void addParent ( final Area area )
public void removeParent ( final Area area )
public boolean canParent ( final Area area )
public void setPrejudiceFactors ( final String factors )
public void setItemPricingAdjustments ( final String [ ] factors )
public void setIgnoreMask ( final String factors )
public void setBudget ( final String factors )
public void setDevalueRate ( final String factors )
public void setInvResetRate ( final int ticks )
public String getStat ( final String code )
public void setStat ( final String code , final String val )
public int getPrice ( )
public void setPrice ( final int price )
public String getOwnerName ( )
public void setOwnerName ( final String owner )
public CMObject getOwnerObject ( )
public String getTitleID ( )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
public void setPrejudiceFactors ( final String factors )
public void setIgnoreMask ( final String factors )
public void setMiscText ( final String newText )
private final static String [ ] MYCODES = { "str" , "str" , "str" , "str" ,
public String getStat ( final String code )
public void setStat ( final String code , final String val )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
protected boolean doLearnRecipe ( final MOB mob , final List < String > commands , final Physical givenTarget , final boolean auto , final int asLevel )
public boolean supportsMending ( final Physical I )
protected boolean canMend ( final MOB mob , final Environmental E , final boolean quiet )
public boolean invoke ( final MOB mob , final List < String > commands , final Physical givenTarget , final boolean auto , final int asLevel )
protected boolean autoGenInvoke ( final MOB mob , final List < String > commands , final Physical givenTarget , final boolean auto , final int asLevel , final int autoGenerate , final boolean forceLevels , final List < Item > crafted )
if ( ( componentsFoundList . size ( ) > 0 ) | | ( autoGenerate > 0 ) )
buildingI = getTargetItemFavorMOB ( mob , mob . location ( ) , givenTarget , commands , Wearable . FILTER_UNWORNONLY ) ;
final int recovery = ( int ) Math . round ( CMath . mul ( ( msg . value ( ) ) , 1.3 + CMath . mul ( super . getXLEVELLevel ( mob ) , 0.05 ) ) ) ;
final int recovery = ( int ) Math . round ( CMath . mul ( ( msg . value ( ) ) , 1.3 + CMath . mul ( super . getXLEVELLevel ( mob ) , 0.05 ) ) ) ;
final int recovery = ( int ) Math . round ( CMath . mul ( ( msg . value ( ) ) , 1.3 + CMath . mul ( super . getXLEVELLevel ( mob ) , 0.05 ) ) ) ;
newMOB . baseCharStats ( ) . setStat ( CharStats . STAT_GENDER , mobGender ) ;
lines . append ( "str" + CMStrings . padRight ( mob2 . Name ( ) , firstColWidth ) + "str" ) ;
lines . append ( "str" ) ;
lines . append ( "str" ) ;
final List < Environmental > set = disBundle ( I , 1 , howMuch , C ) ;
totals [ CoffeeTableRow . STAT_TICKSONLINE ] = minsOnline ;
itemDesc = amt + "str" + subType ;
affectableStats . addAmbiance ( "str" ) ;
if ( ( msg . targetMinor ( ) = = CMMsg . TYP_LEAVE )
if ( ( level > = 10 ) & & ( stats . get ( CombatStat . NUM_SECONDS_TOTAL ) [ 0 ] > ( CMProps . getMillisPerMudHour ( ) / 1000 ) ) )
if ( ( level > = 10 ) & & ( stats . get ( CombatStat . NUM_SECONDS_TOTAL ) [ 0 ] > ( CMProps . getMillisPerMudHour ( ) / 1000 ) ) )
final String wood = getComponentDescription ( mob , V , RCP_WOOD ) . toLowerCase ( ) ;
mat = otherAmtRequired + "str" + otherRequired . toLowerCase ( ) ;
final String wood = getComponentDescription ( mob , V , RCP_WOOD ) . toLowerCase ( ) ;
mat = otherAmtRequired + "str" + otherRequired . toLowerCase ( ) ;
mob . curState ( ) . adjMovement ( proficiency ( ) , mob . maxState ( ) ) ;
newItem . setDisplayText ( L ( "str" ) ) ;
mob . tell ( L ( "str" ) ) ;
return Ability . ACODE_PROPERTY | Ability . DOMAIN_RACIALABILITY ;
return Ability . ACODE_PROPERTY | Ability . DOMAIN_RACIALABILITY ;
private final static String localizedName = CMLib . lang ( ) . L ( "str" ) ;
return Ability . ACODE_PROPERTY | Ability . DOMAIN_RACIALABILITY ;
private final static String localizedName = CMLib . lang ( ) . L ( "str" ) ;
private final static String localizedName = CMLib . lang ( ) . L ( "str" ) ;
return Ability . ACODE_PROPERTY | Ability . DOMAIN_RACIALABILITY ;
final List < List < Item > > rivals = new ArrayList < List < Item > > ( mob . numItems ( ) ) ;
( ( Ammunition ) neww ) . setAmmunitionType ( ammunitionType ) ;
L ( "str" ) ) ;
name = "str" + ( seenM . Name ( ) . equals ( seenM . name ( ) ) ? seenM . titledName ( ) : seenM . name ( ) ) + "str" ;
name = ( ( seenM . Name ( ) . equals ( seenM . name ( ) ) ? seenM . titledName ( ) : seenM . name ( ) ) ) + "str" ;
name = name + ( "str" + CMLib . time ( ) . date2BestShortEllapsedTime ( seenM . session ( ) . getIdleMillis ( ) ) + "str" ) ;
name = "str" + seenM . Name ( ) + "str" ;
name = seenM . Name ( ) + "str" ;
name + = ( "str" + CMLib . time ( ) . date2BestShortEllapsedTime ( seenM . session ( ) . getIdleMillis ( ) ) + "str" ) ;
( L ( "str" , name ( ) . toLowerCase ( ) ) , RawMaterial . RESOURCE_FISH ) ) ;
target . tell ( mob , target , null , L ( "str" ) ) ;
& & ( msg . tool ( ) . ID ( ) . equals ( "str" ) ) )
& & ( msg . tool ( ) . ID ( ) . equals ( "str" ) ) )
if ( ( ( ( ShopKeeper ) M ) . isSold ( ShopKeeper . DEAL_BOOKS ) ) )
levelDiff = - ( levelDiff * ( ( ! CMLib . flags ( ) . canBeSeenBy ( mob , target ) ) ? 5 : 15 ) ) ;
levelDiff = - ( levelDiff * ( ( CMLib . flags ( ) . canBeSeenBy ( mob , target ) ) ? 1 : 2 ) ) ;
levelDiff = - ( levelDiff * ( ( ! CMLib . flags ( ) . canBeSeenBy ( mob , target ) ) ? 5 : 15 ) ) ;
levelDiff = - ( levelDiff * ( ( CMLib . flags ( ) . canBeSeenBy ( mob , target ) ) ? 1 : 2 ) ) ;
levelDiff = - ( levelDiff * ( ( ! CMLib . flags ( ) . canBeSeenBy ( mob , target ) ) ? 5 : 15 ) ) ;
levelDiff = - ( levelDiff * ( ( CMLib . flags ( ) . canBeSeenBy ( mob , target ) ) ? 1 : 2 ) ) ;
levelDiff = - ( levelDiff * ( ( ! CMLib . flags ( ) . canBeSeenBy ( mob , target ) ) ? 5 : 15 ) ) ;
levelDiff = - ( levelDiff * ( ( CMLib . flags ( ) . canBeSeenBy ( mob , target ) ) ? 1 : 2 ) ) ;
levelDiff = - ( levelDiff * ( ( ! CMLib . flags ( ) . canBeSeenBy ( mob , target ) ) ? 5 : 15 ) ) ;
levelDiff = - ( levelDiff * ( ( CMLib . flags ( ) . canBeSeenBy ( mob , target ) ) ? 1 : 2 ) ) ;
return maliciousFizzle ( mob , target , L ( "str" , gone ) ) ;
levelDiff = - ( levelDiff * ( ( CMLib . flags ( ) . canBeSeenBy ( mob , target ) ) ? 5 : 15 ) ) ;
levelDiff = - ( levelDiff * ( ( CMLib . flags ( ) . canBeSeenBy ( mob , target ) ) ? 5 : 15 ) ) ;
levelDiff = - ( levelDiff * ( ( CMLib . flags ( ) . canBeSeenBy ( mob , target ) ) ? 5 : 15 ) ) ;
levelDiff = - ( levelDiff * ( ( CMLib . flags ( ) . canBeSeenBy ( mob , target ) ) ? 5 : 15 ) ) ;
levelDiff = - ( levelDiff * ( ( CMLib . flags ( ) . canBeSeenBy ( mob , target ) ) ? 5 : 15 ) ) ;
student . tell ( L ( "str" , qLevel + "str" ) ) ;
commonTell ( mob , L ( "str"
CMProps . setUpLowVar ( CMProps . Str . MUDSTATUS , "str" ) ;
session . promptPrint ( L ( "str" ) ) ;
session . promptPrint ( L ( "str" ) ) ;
session . promptPrint ( L ( "str" ) ) ;
& & ( ( I2 instanceof Food ) | | ( I2 . name ( ) . endsWith ( "str" ) ) )
final Ability A2 = ( Ability ) capacityA . copyOf ( ) ;
final CraftorAbility rA = ( CraftorAbility ) CMClass . getAbility ( rAstr ) ;
if ( ( A ! = null ) & & ( targetE . fetchEffect ( A . ID ( ) ) = = null ) & & ( ! CMSecurity . isAbilityDisabled ( A . ID ( ) ) ) )
final Area newCloneArea = CMLib . map ( ) . getArea ( areaName . substring ( x + 1 ) ) ;
foundShortName = L ( "str" , RawMaterial . CODES . NAME ( resourceType ) . toLowerCase ( ) ) ;
naturalWeapon . setName ( L ( "str" ) ) ;
naturalWeapon . setName ( L ( "str" ) ) ;
R . show ( mob , target , CMMsg . MSG_OK_ACTION , L ( "str" ) ) ;
private final static String localizedName = CMLib . lang ( ) . L ( "str" ) ;
if ( ( R = = null ) | | ( A = = null ) | | ( R . amDestroyed ( ) ) | | ( A . amDestroyed ( ) ) )
final String form = forms . get ( A . myRaceCode ) . form ;
final String shape = forms . get ( A . myRaceCode ) . shapes [ i1 ] ;
final String shape = forms . get ( A . myRaceCode ) . shapes [ i1 ] ;
if ( questState . vars . containsKey ( code ) & & ( ! questState . isStat ( code ) ) )
final CMMsg msg = CMClass . getMsg ( fighter , fighter . getVictim ( ) , CMMsg . MSG_ADVANCE , L ( "str" ) ) ;
msg . modify ( msg . source ( ) , affected , gemI , CMMsg . MSG_GET , CMLib . lang ( ) . L ( "str" ) ) ;
if ( msg . source ( ) . location ( ) . show ( ( MOB ) msg . target ( ) , msg . source ( ) , null , CMMsg . MSG_QUIETMOVEMENT , L ( "str" , msg . tool ( ) . name ( ) ) ) )
R . show ( mob , null , CMMsg . MSG_NOISE , L ( "str" , lectureName , randM . name ( ) ) ) ;
puffPhrase = L ( "str" ) ;
R . show ( mob , null , CMMsg . MSG_NOISE , L ( "str" , lectureName ) ) ;
changeAllSays ( msg , "str" ) ;
return maliciousFizzle ( mob , null , L ( "str" ) ) ;
return beneficialVisualFizzle ( mob , null , L ( "str" ) ) ;
final CMMsg msg = CMClass . getMsg ( mob , target , this , verbalCastCode ( mob , target , auto ) , L ( auto ? "str" : "str" ) + CMLib . protocol ( ) . msp ( "str" , 40 ) ) ;
R . show ( mob , null , CMMsg . MSG_NOISE , L ( "str" , lectureName , randM . name ( ) ) ) ;
R . show ( mob , null , CMMsg . MSG_NOISE , L ( "str" , lectureName , randM . name ( ) ) ) ;
LOGINS ( "str" ) ,
follower . phyStats ( ) . setDisposition ( follower . phyStats ( ) . disposition ( ) & ( ~ dispmask ) ) ;
fixDataForComponents ( data , woodRequiredStr , ( autoGenerate > 0 ) & & ( woodRequired = = 0 ) , componentsFoundList ) ;
fixDataForComponents ( data , woodRequiredStr , ( autoGenerate > 0 ) & & ( woodRequired = = 0 ) , componentsFoundList ) ;
fixDataForComponents ( data , woodRequiredStr , ( autoGenerate > 0 ) & & ( woodRequired = = 0 ) , componentsFoundList ) ;
fixDataForComponents ( data , woodRequiredStr , ( autoGenerate > 0 ) & & ( woodRequired = = 0 ) , componentsFoundList ) ;
fixDataForComponents ( data , woodRequiredStr , ( autoGenerate > 0 ) & & ( woodRequired = = 0 ) , componentsFoundList ) ;
fixDataForComponents ( data , woodRequiredStr , ( autoGenerate > 0 ) & & ( woodRequired = = 0 ) , componentsFoundList ) ;
fixDataForComponents ( data , woodRequiredStr , ( autoGenerate > 0 ) & & ( woodRequired = = 0 ) , componentsFoundList ) ;
fixDataForComponents ( data , woodRequiredStr , ( autoGenerate > 0 ) & & ( woodRequired = = 0 ) , componentsFoundList ) ;
fixDataForComponents ( data , woodRequiredStr , ( autoGenerate > 0 ) & & ( woodRequired = = 0 ) , componentsFoundList ) ;
fixDataForComponents ( data , woodRequiredStr , ( autoGenerate > 0 ) & & ( woodRequired = = 0 ) , componentsFoundList ) ;
fixDataForComponents ( data , woodRequiredStr , ( autoGenerate > 0 ) & & ( woodRequired = = 0 ) , componentsFoundList ) ;
fixDataForComponents ( data , woodRequiredStr , ( autoGenerate > 0 ) & & ( woodRequired = = 0 ) , componentsFoundList ) ;
fixDataForComponents ( data , woodRequiredStr , ( autoGenerate > 0 ) & & ( woodRequired = = 0 ) , componentsFoundList ) ;
fixDataForComponents ( data , woodRequiredStr , ( autoGenerate > 0 ) & & ( woodRequired = = 0 ) , componentsFoundList ) ;
fixDataForComponents ( data , woodRequiredStr , ( autoGenerate > 0 ) & & ( woodRequired = = 0 ) , componentsFoundList ) ;
mob . tell ( "str" + V . get ( i ) + "str" ) ;
addAll ( T ) ;
add ( T . nextElement ( ) ) ;
add ( T . next ( ) ) ;
add ( o ) ;
add ( T . nextElement ( ) ) ;
add ( e ) ;
add ( T . next ( ) ) ;
remove ( T . nextElement ( ) ) ;
remove ( T . next ( ) ) ;
remove ( o ) ;
return size ( ) ;
toArray ( anArray ) ;
return get ( index ) ;
final Iterator < T > i = iterator ( ) ;
return ( size ( ) = = 0 ) ? null : get ( 0 ) ;
return ( size ( ) = = 0 ) ? null : get ( size ( ) - 1 ) ;
set ( index , obj ) ;
clear ( ) ;
add ( obj ) ;
add ( index , obj ) ;
clear ( ) ;
mob . tell ( L ( "str" + listOfThings ( ) + "str" ) ) ;
R . setStat ( "str" , "str" + ( int ) Math . round ( 100.0 * CMath . s_pct ( ( old = = null ) ? "str" : old ) ) ) ;
mob . tell ( L ( "str" , cmd ) ) ;
String [ ] newRecipeLines = Arrays . copyOf ( this . recipeLines , this . recipeLines . length + recipes . size ( ) ) ;
if ( mob . numAbilities ( ) ! = numSkills )
pStats . getTitles ( ) . remove ( degree [ DEG_TITLE ] ) ;
final double anglesDelta = pitchDelta + yawDelta ;
final List < JournalEntry > items = CMLib . database ( ) . DBReadJournalMsgsNewerThan ( CMJ . JOURNAL_NAME ( ) , mob . Name ( ) , - 1 ) ;
journalItem . setName ( CMJ . JOURNAL_NAME ( ) ) ;
realName = CMJ . JOURNAL_NAME ( ) ;
if ( session . confirm ( L ( "str" , CMJ . NAME ( ) ) , "str" , 5000 ) )
state = MsgMkrState . EDITPROMPT ;
target . location ( ) . show ( target , null , CMMsg . MSG_OK_ACTION , L ( "str" ) ) ;
target . location ( ) . show ( target , null , CMMsg . MSG_OK_ACTION , L ( "str" ) ) ;
C . execute ( mob , new XVector < String > ( "str" , "str" ) , MUDCmdProcessor . METAFLAG_FORCED ) ;
mob . tell ( L ( "str" , revealI . name ( mob ) ) ) ;
if ( ( level > = 10 ) & & ( stats . get ( CombatStat . NUM_SECONDS_TOTAL ) [ 0 ] > 0 ) )
if ( ( level > = 10 ) & & ( stats . get ( CombatStat . NUM_SECONDS_TOTAL ) [ 0 ] > 0 ) )
if ( ( level > = 6 ) & & ( stats . get ( CombatStat . NUM_SECONDS_TOTAL ) [ 0 ] > 0 ) )
if ( ( level > = 6 ) & & ( stats . get ( CombatStat . NUM_SECONDS_TOTAL ) [ 0 ] > 0 ) )
if ( ( level > = 6 ) & & ( stats . get ( CombatStat . NUM_SECONDS_TOTAL ) [ 0 ] > 0 ) )
if ( ( level > = 7 ) & & ( stats . get ( CombatStat . NUM_SECONDS_TOTAL ) [ 0 ] > 0 ) )
if ( ( level > = 7 ) & & ( stats . get ( CombatStat . NUM_SECONDS_TOTAL ) [ 0 ] > 0 ) )
if ( ( ! A . isSavable ( ) ) & & ( ( ( MOB ) P ) . isMine ( A ) ) )
if ( success & & ( ( ( Food ) target ) . nourishment ( ) > 0 ) )
if ( ( level > = 5 ) & & ( stats . get ( CombatStat . NUM_COMBATS ) [ 0 ] > 0 ) )
if ( ( level > = 2 ) & & ( stats . get ( CombatStat . NUM_COMBATS ) [ 0 ] > 0 ) )
if ( ( level > = 2 ) & & ( stats . get ( CombatStat . NUM_COMBATS ) [ 0 ] > 0 ) )
if ( ( level > = 2 ) & & ( stats . get ( CombatStat . NUM_COMBATS ) [ 0 ] > 0 ) )
if ( ( level > = 3 ) & & ( stats . get ( CombatStat . NUM_COMBATS ) [ 0 ] > 0 ) )
if ( ( level > = 3 ) & & ( stats . get ( CombatStat . NUM_COMBATS ) [ 0 ] > 0 ) )
doc . append ( "str" ) . append ( CMath . round ( 100.0 * mob . playerStats ( ) . getHygiene ( ) / PlayerStats . HYGIENE_DELIMIT ) ) . append ( "str" ) ;
doc . append ( "str" ) . append ( mob . phyStats ( ) . level ( ) ) . append ( "str" ) ;
CMLib . commands ( ) . postSay ( M , null , L ( "str" ) ) ;
private final String [ ] culturalAbilityNames = { "str" , "str" } ;
x2 = L ( "str" ) ;
x2 = L ( "str" ) ;
x2 = L ( "str" ) ;
x2 = L ( "str" ) ;
if ( removedAbles . size ( ) > 0 )
mob . tell ( target , null , null , L ( "str" ) ) ;
final Map < String , int [ ] > spam = observerM . playerStats ( ) . getCombatSpams ( ) ;
if ( givenTarget = = target )
tsess . prompt ( new InputCallback ( InputCallback . Type . CONFIRM , "str" , 30000L ) {
me . invoke ( mob , oldCommands , target , false , asLevel ) ;
final CMMsg msg = CMClass . getMsg ( mob , target , this , verbalCastCode ( mob , null , auto ) , auto ? L ( "str" + canSpeakWithWhat ( ) + "str" ) : L ( "str" + canSpeakWithWhatNoun ( ) + "str" ) ) ;
str . append ( M . fetchFaction ( F . factionID ( ) ) ) . append ( "str" ) ;
str . append ( M . fetchFaction ( F . factionID ( ) ) ) . append ( "str" ) ;
CMLib . combat ( ) . postDamage ( invoker , invoker , null , dmg / 2 , CMMsg . MASK_ALWAYS | CMMsg . TYP_UNDEAD , Weapon . TYPE_SLASHING , L ( "str" ) ) ;
return beneficialVisualFizzle ( mob , null , L ( "str" ) ) ;
return beneficialVisualFizzle ( mob , null , L ( "str" ) ) ;
return beneficialVisualFizzle ( mob , null , L ( "str" ) ) ;
int chartPointIndex = CMath . s_int ( parm ) ;
final Item I = ( ( BoardableShip ) R . getArea ( ) ) . getShipItem ( ) ;
public final static int RESOURCE_FUNGUS = MATERIAL_VEGETATION | 206 ;
L ( "str" , RawMaterial . CODES . NAME ( atmo ) . toLowerCase ( ) ) + CMLib . protocol ( ) . msp ( "str" , 10 ) ) ;
msgStr = L ( "str" ) + CMLib . protocol ( ) . msp ( "str" , 10 ) ;
msgStr = L ( "str" , RawMaterial . CODES . NAME ( atmo ) . toLowerCase ( ) ) ;
otherDirectionPhrase = L ( "str" + ( ( Directions . getOpDirectionCode ( directionCode ) = = Directions . GATE ) & & ( exit ! = null ) ? exit . name ( ) : fromDir ) ) ;
final String enterStr = L ( "str" , mob . riding ( ) . name ( ) , otherDirectionPhrase ) ;
name + = "str" + pStats . getAccount ( ) . getAccountName ( ) + "str" ;
CMLib . ableMapper ( ) . addCharAbilityMapping ( ID ( ) , - 1 , "str" , 0 , "str" , false , true ) ;
CMLib . ableMapper ( ) . addCharAbilityMapping ( ID ( ) , - 1 , "str" , 0 , "str" , false , true ) ;
CMLib . ableMapper ( ) . addCharAbilityMapping ( ID ( ) , - 1 , "str" , 0 , "str" , false , true ) ;
CMLib . ableMapper ( ) . addCharAbilityMapping ( ID ( ) , - 1 , "str" , 0 , "str" , false , true ) ;
if ( ( R = = null ) | | ( mob . location ( ) = = null ) )
private int num = - 1 ;
return ( num > = 0 ) & & ( getCount ( mob ) > = num ) ;
private int num = - 1 ;
return ( num > = 0 ) & & getCount ( mob ) > = num ;
private int num = - 1 ;
return ( num > = 0 ) & & ( getCount ( mob ) > num ) ;
private int num = - 1 ;
return ( num > = 0 ) & & ( getCount ( mob ) > = num ) ;
private int num = - 1 ;
return ( num > = 0 ) & & ( getCount ( mob ) > = num ) ;
if ( ( levelsDown < 0 ) | | ( affectableStats . level ( ) < = 0 ) )
AchievementLibrary . Tracker T = stat . getAchievementTracker ( A , whoM ) ;
AchievementLibrary . Tracker T = stat . getAchievementTracker ( A , whoM ) ;
AchievementLibrary . Tracker T = stat . getAchievementTracker ( A , whoM ) ;
& & ( CMLib . law ( ) . doesOwnThisProperty ( this . getOwnerName ( ) , R ) ) )
if ( ! CMLib . law ( ) . doesOwnThisProperty ( C . clanID ( ) , clanHomeRoom ) )
if ( ! CMLib . law ( ) . doesOwnThisProperty ( C . clanID ( ) , R ) )
if ( ! CMLib . law ( ) . doesOwnThisProperty ( C . clanID ( ) , R ) )
| | ( ! CMLib . law ( ) . doesOwnThisProperty ( C . clanID ( ) , newRoom ) ) )
if ( ! CMLib . law ( ) . doesOwnThisProperty ( C . clanID ( ) , R ) )
msg = CMClass . getMsg ( mob , null , null , CMMsg . MSG_SPEAK , "str" + CMStrings . removeColors ( mob . name ( ) ) + "str" + L ( "str" ) + theWordSuffix + "str" + combinedCommands + "str" ) ;
msg = CMClass . getMsg ( mob , null , null , CMMsg . MSG_SPEAK , "str" + CMStrings . removeColors ( mob . name ( ) ) + "str" + theWord . toLowerCase ( ) + theWordSuffix + "str" + combinedCommands + "str" ) ;
CMMsg . MASK_CHANNEL | CMMsg . MASK_ALWAYS | CMMsg . MSG_SPEAK , channelColor + "str" + channelName + "str" + L ( "str" ) + "str" + channelName + "str" + message + "str" ,
CMMsg . MASK_CHANNEL | ( CMMsg . TYP_CHANNEL + channelInt ) , channelColor + "str" + channelName + "str" + CMLib . english ( ) . makePlural ( channelName ) + "str" + message + "str" ) ;
if ( ( R ! = null ) & & ( ! ( ( MOB ) P ) . amDead ( ) ) )
if ( ( R ! = null ) & & ( ! ( ( MOB ) P ) . amDead ( ) ) )
if ( ( R ! = null ) & & ( ! ( ( MOB ) P ) . amDead ( ) ) )
if ( ( R ! = null ) & & ( ! ( ( MOB ) P ) . amDead ( ) ) )
if ( ( R ! = null ) & & ( ! ( ( MOB ) P ) . amDead ( ) ) )
if ( ( R ! = null ) & & ( ! ( ( MOB ) P ) . amDead ( ) ) )
if ( ( R ! = null ) & & ( ! ( ( MOB ) P ) . amDead ( ) ) )
if ( ( R ! = null ) & & ( ! ( ( MOB ) P ) . amDead ( ) ) )
if ( ( R ! = null ) & & ( ! ( ( MOB ) P ) . amDead ( ) ) )
if ( ( R ! = null ) & & ( ! ( ( MOB ) P ) . amDead ( ) ) )
public static final String POMVERSION = "str" ;
doc . append ( "str" ) . append ( Math . round ( ( double ) vicM . maxState ( ) . getHitPoints ( ) / ( double ) vicM . curState ( ) . getHitPoints ( ) * 100.0 ) ) ;
setDisplayText ( "str" ) ;
Log . errOut ( "str" + CharStats . CODES . NAME ( UNDEAD_SAVE_STATS [ statDex ] ) + "str" + oldStat + "str" + affectedMOB . baseCharStats ( ) . getStat ( UNDEAD_SAVE_STATS [ statDex ] ) ) ;
loop = oldLoop - 1 ;
private static final float HOST_VERSION_MINOR = ( float ) 0.7 ;
areas . add ( A2 ) ;
if ( I . isGeneric ( ) | | I . ID ( ) . equalsIgnoreCase ( "str" ) )
if ( ! added . contains ( A . getTattoo ( ) . toUpperCase ( ) . trim ( ) ) )
maps [ agent . ordinal ( ) ] . put ( A . getTattoo ( ) . toUpperCase ( ) . trim ( ) , A ) ;
if ( maps [ currentAgent . ordinal ( ) ] . containsKey ( tatt . toUpperCase ( ) . trim ( ) ) )
added . add ( tatt . toUpperCase ( ) . trim ( ) ) ;
str . append ( CMStrings . replaceAll ( CMStrings . deEscape ( help ) , "str" , "str" ) ) ;
value + = CMStrings . deEscape ( A . getRawParmVal ( otherParmName ) ) + "str" ;
parmTree . put ( s , CMStrings . deEscape ( A . getRawParmVal ( s ) ) ) ;
if ( ! mob . isAttributeSet ( MOB . Attrib . AUTOFORWARD ) )
mob . setAttribute ( MOB . Attrib . AUTOFORWARD , false ) ;
mob . setAttribute ( MOB . Attrib . AUTOFORWARD , true ) ;
if ( CMLib . flags ( ) . isUnattackable ( mob ) & & ( ! mob . isInCombat ( ) ) )
if ( CMLib . flags ( ) . isUnattackable ( mob ) & & ( mob . getVictim ( ) ! = this ) )
awardMessage . append ( L ( "str" , CMStrings . replaceAll ( aaward . getTitle ( ) , "str" , mob . Name ( ) ) ) ) ;
s = p . nextElement ( ) ;
final Room R = newRooms . elementAt ( r ) ;
Quest lowQ = V . firstElement ( ) ;
final Quest Q = sortedV . elementAt ( q ) ;
oldValue = oldValues . elementAt ( i ) ;
oldValue = oldValues . elementAt ( i ) ;
s = p . nextElement ( ) ;
thisAffect = eff . elementAt ( x ) ;
final Room R = commonRoomSet . elementAt ( v ) ;
final Room R = commonRoomSet . elementAt ( v ) ;
final Room R = commonRoomSet . elementAt ( v ) ;
final Room R = commonRoomSet . elementAt ( v ) ;
int len = ( wrap > 0 ) ? wrap : ( Integer . MAX_VALUE / 3 ) ;
int len = ( wrap > 0 ) ? wrap : ( Integer . MAX_VALUE / 3 ) ;
return L ( "str" , mob . name ( viewer ) ) ;
case 23 : say = "str" ; break ;
mob . tell ( L ( "str" , P . Name ( ) ) ) ;
"str" + CMLib . lang ( ) . L ( "str" ) + "str" +
naturalWeapon . setName ( L ( "str" ) ) ;
beneficialVisualFizzle ( mob , target , L ( "str" ) ) ;
mob . tell ( L ( "str" , modItem . name ( ) ) ) ;
mob . tell ( L ( "str" , modMOB . name ( ) ) ) ;
mob . tell ( L ( "str" ) ) ;
mob . tell ( L ( "str" , lookingFor , Directions . getInDirectionName ( nextDirection ) ) ) ;
for ( int r = foundAt - 1 ; r > = 0 ; r - - )
TrackingLibrary . TrackingFlags flags = new TrackingLibrary . TrackingFlags ( ) . add ( TrackingLibrary . TrackingFlag . NOEMPTYGRIDS ) ;
int xlvl = 2 + ( int ) Math . round ( CMath . div ( adjustedLevel ( invoker ( ) , 0 ) , 1.5 ) ) ;
public String otherBonuses ( ) { return "str" ; }
public String otherBonuses ( ) { return "str" ; }
tilesSpatial . put ( t , new ArrayList < Spatial > ( ) ) ;
if ( Double . isNaN ( minScale ) ) {
des . setName ( dr . getReportName ( ) ! = null ? dr . getReportName ( ) : "str" ) ;
if ( var . getInitialValueExpression ( ) ! = null ) {
JRDesignExpression initialValueExpression = ExpressionUtils . createAndRegisterExpression ( getDjd ( ) , initialValueExpressionParamName , var . getInitialValueExpression ( ) ) ;
private CustomExpression initialValueExpression ;
var . setInitialValueExpression ( initialValueExpression ) ;
if ( row . isShowTotals ( ) )
AbstractColumn col = var . getColumnToApplyOperation ( ) ;
for ( Package pkg : getMetaInfo ( roleGroup ) . getApplication ( ) . getPackages ( ) ) {
localizeConfigFiles ( launcher , roleName , roleGroup , getMetaInfo ( roleGroup ) ,
public synchronized NodeInformation getNodeInformation ( String hostname ,
public synchronized List < AbstractRMOperation > escalateOutstandingRequests ( ) {
public synchronized boolean isEscalated ( ) {
public synchronized void resetFailedRecently ( ) {
public synchronized AggregateConf getInstanceDefinitionSnapshot ( ) {
if ( status . getHostname ( ) ! = null & & ! status . getHostname ( ) . isEmpty ( ) ) {
MapOperations amConfiguration = resolvedInstance
log . debug ( "str" , authUser ) ;
import java . lang . reflect . Method ;
LoggerFactory . getLogger ( SliderIPCService . class ) ;
new StreamConsumer ( process . getErrorStream ( ) , true ) ;
: aggregateConf . getAppConf ( ) ;
int DEFAULT_TEST_TIMEOUT_SECONDS = 30 * 60 ;
String DEFAULT_YARN_QUEUE = null ;
tokens . put ( "str" , appConf . get ( OptionKeys . ZOOKEEPER_PATH ) ) ;
throw new BadCommandArgumentsException ( "str" ) ;
throw new BadCommandArgumentsException ( "str" ) ;
"str" , key ) ;
ResourceKeys . CONTAINER_FAILURE_THRESHOLD ,
public List < String > listRegisteredSliderInstances ( ) throws
private static final GameJob JOB_DEFAULT = GameJob . TerasologyStable ;
return gameThread ! = null & & gameThread . isAlive ( ) ;
return installationPath ! = null & & gameJar ! = null ;
} while ( ! Thread . currentThread ( ) . isInterrupted ( ) & & line ! = null ) ;
final boolean notSuccessful = gameVersion . getSuccessful ( ) = = null | | ! gameVersion . getSuccessful ( ) ;
if ( TerasologyGameVersion . BUILD_VERSION_LATEST ! = buildVersion & & buildVersion > = job . getMinBuildNumber ( ) ) {
if ( TerasologyGameVersion . BUILD_VERSION_LATEST ! = lastBuildVersion & & lastBuildVersion > = job . getMinBuildNumber ( ) ) {
if ( lastSuccessfulBuildNumber ! = null & & lastSuccessfulBuildNumber > = job . getMinBuildNumber ( ) ) {
for ( int buildNumber = lastSuccessfulBuildNumber - 1 ; ( buildNumbers . size ( ) < = job . getPrevBuildNumbers ( ) & & buildNumber > job . getMinBuildNumber ( ) ) ;
successful = jobResult ! = null & & ( ( jobResult = = JobResult . SUCCESS ) | | ( jobResult = = JobResult . UNSTABLE ) ) ;
int previousLogs = gameVersion . getJob ( ) . isStable ( ) ? 1 : 10 ;
return buildVersionMap . containsKey ( job ) ? buildVersionMap . get ( job ) : settings . getBuildVersion ( job ) ;
return lastBuildNumberMap . containsKey ( job ) ? lastBuildNumberMap . get ( job ) : settings . getLastBuildNumber ( job ) ;
private static final LogLevel LOG_LEVEL_DEFAULT = LogLevel . DEFAULT ;
Terasology ( "str" , "str" , 1355 , 20 , false , false , "str" , "str" , "str" ) ;
TerasologyStable ( "str" , "str" , 49 , 5 , true , false , "str" , "str" , "str" ) ,
Terasology ( "str" , "str" , 1355 , 40 , false , false , "str" , "str" , "str" ) ;
public static final String TERASOLOGY_LAUNCHER_DEVELOP_JOB_NAME = "str" ;
this . jobName = DownloadUtils . TERASOLOGY_LAUNCHER_DEVELOP_JOB_NAME ;
& & ( gameVersionInfo . getGitBranch ( ) . endsWith ( installedJob . getGitBranch ( ) ) ) & & ( installedJob . getMinBuildNumber ( ) < = installedBuildNumber ) ) {
logger . trace ( "str" , launcherLocation ) ;
logger . trace ( "str" , launcherDirectory ) ;
logger . trace ( "str" , updateURL ) ;
logger . trace ( "str" , downloadedZipFile ) ;
csvColumns , true , true , new LegacyReceiptFilter ( mPreferenceManager ) ) ;
final long customOrderId = ReceiptsOrderer . getCustomOrderId ( newReceipt , existingReceipts ) ;
viewPager . setOffscreenPageLimit ( 3 ) ;
Logger . info ( this , "str" , receipt ) ;
Logger . warn ( this , "str" , receipt ) ;
TestTimezoneToggler . setDefaultTimeZone ( TimeZone . getTimeZone ( "str" ) ) ;
TestTimezoneToggler . setDefaultTimeZone ( TimeZone . getTimeZone ( "str" ) ) ;
TestTimezoneToggler . setDefaultTimeZone ( TimeZone . getTimeZone ( "str" ) ) ;
TestTimezoneToggler . setDefaultTimeZone ( TimeZone . getTimeZone ( "str" ) ) ;
TestTimezoneToggler . setDefaultTimeZone ( TimeZone . getTimeZone ( "str" ) ) ;
TestTimezoneToggler . setDefaultTimeZone ( TimeZone . getTimeZone ( "str" ) ) ;
public static void setDefaultTimeZone ( @NonNull TimeZone timeZone ) {
"str" + mTimeZone . getID ( ) +
private final OperationFamilyType operationFamilyType ;
this . operationFamilyType = Preconditions . checkNotNull ( operationFamilyType ) ;
return operationFamilyType = = that . operationFamilyType ;
tripForeignKeyTableEventsListener . onGetSuccess ( foreignKeyGetResult . get ( ) , foreignKeyGetResult . getTrip ( ) ) ;
tripForeignKeyTableEventsListener . onGetFailure ( foreignKeyGetResult . getThrowable ( ) , foreignKeyGetResult . getTrip ( ) ) ;
priceBox . setText ( ModelUtils . getDecimalFormattedValue ( preTaxPrice ) ) ;
return string . replaceAll ( "str" , "str" ) . replace ( "str" , "str" ) . replace ( "str" , "str" ) ;
paymentMethods . add ( ImmutablePaymentMethodImpl . NONE ) ;
this . exchangeRateContainer = ( ViewGroup ) flex . getSubView ( getActivity ( ) , rootView , R . id . exchange_rate_container ) ;
import org . robolectric . android . controller . ActivityController ;
backupReminderTooltipStorage . getReceiptsCountWithoutBackup ( ) > = receiptsLimit ) {
return daysSinceLastManualBackup > = daysLimit ? Maybe . just ( daysSinceLastManualBackup ) : Maybe . empty ( ) ;
if ( regionChecker . isInWesternEurope ( ) & & shouldShowMarketsAd ( ) ) {
columns . add ( getColumn ( ActualDefinition . PRICE_EXCHANGED ) ) ;
columns . add ( getColumn ( ActualDefinition . PRICE_EXCHANGED ) ) ;
Toast . makeText ( context , R . string . purchase_unavailable , Toast . LENGTH_SHORT ) . show ( ) ;
} , throwable - > Toast . makeText ( context , R . string . purchase_unavailable , Toast . LENGTH_SHORT ) . show ( ) ) ) ;
private final AppRating mAppRating ;
mAppRating = appRating ;
final List < Distance > distances = new ArrayList < > ( mDB . getDistanceTable ( ) . getBlocking ( trip , false ) ) ;
receiptsTableList . addAll ( new DistanceToReceiptsConverter ( getContext ( ) , getPreferences ( ) ) . convert ( getDatabase ( ) . getDistanceTable ( ) . getBlocking ( trip , false ) ) ) ;
if ( idx > = 0 ) {
Toast . makeText ( getActivity ( ) , getFlexString ( R . string . DIALOG_TRIPMENU_TOAST_MISSING_FIELD ) , Toast . LENGTH_LONG ) . show ( ) ;
Toast . makeText ( getActivity ( ) , getFlexString ( R . string . CALENDAR_TAB_ERROR ) , Toast . LENGTH_LONG ) . show ( ) ;
Toast . makeText ( getActivity ( ) , getFlexString ( R . string . DURATION_ERROR ) , Toast . LENGTH_LONG ) . show ( ) ;
Toast . makeText ( getActivity ( ) , getFlexString ( R . string . SPACE_ERROR ) , Toast . LENGTH_LONG ) . show ( ) ;
Toast . makeText ( getActivity ( ) , getFlexString ( R . string . ILLEGAL_CHAR_ERROR ) , Toast . LENGTH_LONG ) . show ( ) ;
Toast . makeText ( getActivity ( ) , R . string . toast_error_trip_exists , Toast . LENGTH_LONG ) . show ( ) ;
Toast . makeText ( getActivity ( ) , getFlexString ( R . string . DB_ERROR ) , Toast . LENGTH_LONG ) . show ( ) ;
Toast . makeText ( getActivity ( ) , getFlexString ( R . string . DB_ERROR ) , Toast . LENGTH_LONG ) . show ( ) ;
Toast . makeText ( getActivity ( ) , getFlexString ( R . string . DB_ERROR ) , Toast . LENGTH_LONG ) . show ( ) ;
if ( mPreferences . getPrintDistanceTable ( ) & & ! distances . isEmpty ( ) ) {
final BigDecimal price = getDecimal ( c , priceIndex ) ;
final BigDecimal tax = getDecimal ( c , taxIndex ) ;
values . put ( ReceiptsTable . COLUMN_PRICE , price . doubleValue ( ) ) ;
values . put ( ReceiptsTable . COLUMN_TAX , tax . doubleValue ( ) ) ;
if ( ( _nonFilteredApps . get ( i ) . getComponentName ( ) ) . equals ( hidItemRaw ) ) {
return getString ( R . string . pref_key__theme , "str" ) ;
. withOnLongClickListener ( DragHandler . getLongClick ( Item . newAppItem ( app ) , DragAction . Action . DRAWER , null ) ) ) ;
Tool . startIntent ( _homeActivity , calendar ) ;
final ArrayList < LauncherAction . ActionDisplayItem > minibarArrangement = AppSettings . get ( ) . getMinibarArrangement ( ) ;
_adapter . add ( new Item ( item , minibarArrangement . contains ( item ) ) ) ;
View itemView = ItemViewFactory . getItemView ( getContext ( ) , this , item , Setup . appSettings ( ) . getDockIconSize ( ) , Setup . appSettings ( ) . isDockShowLabel ( ) ) ;
View itemView = ItemViewFactory . getItemView ( getContext ( ) , this , item , Setup . appSettings ( ) . getDockIconSize ( ) , Setup . appSettings ( ) . isDockShowLabel ( ) ) ;
View itemView = ItemViewFactory . getItemView ( getContext ( ) , this , item , Setup . appSettings ( ) . getDockIconSize ( ) , Setup . appSettings ( ) . isDockShowLabel ( ) ) ;
_adapter . add ( new Item ( item . _id , item , minibarArrangement . contains ( Integer . toString ( item . _id ) ) ) ) ;
void updateState ( Item item , Definitions . ItemState state ) ;
Home . db . updateState ( dragOutItem , Definitions . ItemState . Visible ) ;
Home . db . updateState ( item , Definitions . ItemState . Visible ) ;
home . db . updateState ( dropItem , Definitions . ItemState . Hidden ) ;
public void updateState ( Item item , Definitions . ItemState state ) {
int size = Tool . dp2px ( 18 , context ) ;
DialogHelper . selectActionDialog ( context , R . string . pref_title__desktop_swipe_up , ( ( DatabaseHelper ) Home . launcher . db ) . getGesture ( 1 ) , 1 , new DialogHelper . OnActionSelectedListener ( ) {
DialogHelper . selectActionDialog ( context , R . string . pref_title__desktop_swipe_down , ( ( DatabaseHelper ) Home . launcher . db ) . getGesture ( 2 ) , 2 , new DialogHelper . OnActionSelectedListener ( ) {
DialogHelper . selectActionDialog ( context , R . string . pref_title__desktop_pinch , ( ( DatabaseHelper ) Home . launcher . db ) . getGesture ( 3 ) , 3 , new DialogHelper . OnActionSelectedListener ( ) {
DialogHelper . selectActionDialog ( context , R . string . pref_title__desktop_unpinch , ( ( DatabaseHelper ) Home . launcher . db ) . getGesture ( 4 ) , 4 , new DialogHelper . OnActionSelectedListener ( ) {
minibarBackground . setBackgroundColor ( appSettings . getMinibarBackgroundColor ( ) ) ;
Tool . goneViews ( clockFrame , searchBar ) ;
if ( x > = cells . length | | y > = cells [ 0 ] . length ) continue ;
launcher . initMinibar ( ) ;
launcher . initMinibar ( ) ;
LauncherAction . RunAction ( LauncherAction . actionItems [ getResources ( ) . getIntArray ( R . array . gestureValues ) [ LauncherSettings . getInstance ( getContext ( ) ) . generalSettings . swipeUp ] - 1 ] . label , desktop . getContext ( ) ) ;
LauncherAction . RunAction ( LauncherAction . actionItems [ getResources ( ) . getIntArray ( R . array . gestureValues ) [ LauncherSettings . getInstance ( getContext ( ) ) . generalSettings . swipeDown ] - 1 ] . label , desktop . getContext ( ) ) ;
LauncherAction . RunAction ( LauncherAction . actionItems [ getResources ( ) . getIntArray ( R . array . gestureValues ) [ LauncherSettings . getInstance ( getContext ( ) ) . generalSettings . pinch ] - 1 ] . label , desktop . getContext ( ) ) ;
LauncherAction . RunAction ( LauncherAction . actionItems [ getResources ( ) . getIntArray ( R . array . gestureValues ) [ LauncherSettings . getInstance ( getContext ( ) ) . generalSettings . unPinch ] - 1 ] . label , desktop . getContext ( ) ) ;
LauncherAction . RunAction ( LauncherAction . actionItems [ getResources ( ) . getIntArray ( R . array . gestureValues ) [ LauncherSettings . getInstance ( getContext ( ) ) . generalSettings . doubleClick ] - 1 ] . label , desktop . getContext ( ) ) ;
LauncherAction . RunAction ( LauncherAction . actionItems [ getResources ( ) . getIntArray ( R . array . gestureValues ) [ LauncherSettings . getInstance ( getContext ( ) ) . generalSettings . singleClick ] - 1 ] . label , desktop . getContext ( ) ) ;
fragment = MaterialPrefFragment . newInstance ( new MaterialPrefFragment . Builder ( this , Color . DKGRAY , ContextCompat . getColor ( this , R . color . Light_TextColor ) , ContextCompat . getColor ( this , R . color . Light_Background ) , ContextCompat . getColor ( this , R . color . colorAccent ) , true )
fragment = MaterialPrefFragment . newInstance ( new MaterialPrefFragment . Builder ( this , Color . DKGRAY , ContextCompat . getColor ( this , R . color . Light_TextColor ) , ContextCompat . getColor ( this , R . color . Light_Background ) , ContextCompat . getColor ( this , R . color . colorAccent ) , true )
fragment = MaterialPrefFragment . newInstance ( new MaterialPrefFragment . Builder ( this , Color . DKGRAY , ContextCompat . getColor ( this , R . color . Light_TextColor ) , ContextCompat . getColor ( this , R . color . Light_Background ) , ContextCompat . getColor ( this , R . color . colorAccent ) , true )
fragment = MaterialPrefFragment . newInstance ( new MaterialPrefFragment . Builder ( this , Color . DKGRAY , ContextCompat . getColor ( this , R . color . Light_TextColor ) , ContextCompat . getColor ( this , R . color . Light_Background ) , ContextCompat . getColor ( this , R . color . colorAccent ) , true )
fragment = MaterialPrefFragment . newInstance ( new MaterialPrefFragment . Builder ( this , Color . DKGRAY , ContextCompat . getColor ( this , R . color . Light_TextColor ) , ContextCompat . getColor ( this , R . color . Light_Background ) , ContextCompat . getColor ( this , R . color . colorAccent ) , true )
fragment = MaterialPrefFragment . newInstance ( new MaterialPrefFragment . Builder ( this , Color . DKGRAY , ContextCompat . getColor ( this , R . color . Light_TextColor ) , ContextCompat . getColor ( this , R . color . Light_Background ) , ContextCompat . getColor ( this , R . color . colorAccent ) , true )
fragment = MaterialPrefFragment . newInstance ( new MaterialPrefFragment . Builder ( this , Color . DKGRAY , ContextCompat . getColor ( this , R . color . Light_TextColor ) , ContextCompat . getColor ( this , R . color . Light_Background ) , ContextCompat . getColor ( this , R . color . colorAccent ) , true )
Intent intent = new Intent ( Intent . ACTION_MAIN ) ;
Intent intent = new Intent ( Intent . ACTION_MAIN ) ;
boolean alertOnce = intent . getBooleanExtra ( "str" , false ) ;
Uri uriToShare = Uri . parse ( "str" + fileToShare . getAbsolutePath ( ) ) ;
int streamToUseInt = AudioManager . STREAM_MUSIC ;
params . putInt ( Engine . KEY_PARAM_STREAM , AudioManager . STREAM_ALARM ) ;
public TermlistRequest ( String [ ] indices ) {
if ( from < = i & & i < from + size ) {
if ( from < = i & & i < from + size ) {
if ( from < = i & & i < from + size ) {
if ( from < = i & & i < from + size ) {